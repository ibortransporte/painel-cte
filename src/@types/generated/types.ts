import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  _int4: { input: unknown; output: unknown; }
  _text: { input: unknown; output: unknown; }
  bigint: { input: unknown; output: unknown; }
  bpchar: { input: unknown; output: unknown; }
  date: { input: Date | string; output: string; }
  datetime: { input: Date | string; output: string; }
  datetimeoffset: { input: Date | string; output: string; }
  float8: { input: number; output: number; }
  geography: { input: unknown; output: unknown; }
  geometry: { input: unknown; output: unknown; }
  hstore: { input: unknown; output: unknown; }
  int4range: { input: unknown; output: unknown; }
  interval: { input: string; output: string; }
  json: { input: unknown; output: unknown; }
  jsonb: { input: unknown; output: unknown; }
  numeric: { input: number; output: number; }
  smallint: { input: number; output: number; }
  timestamptz: { input: Date | string; output: string; }
  tracker_device_model: { input: unknown; output: unknown; }
  uuid: { input: string; output: string; }
};

export type AdminSignInOutput = {
  __typename?: 'AdminSignInOutput';
  admin_uuid: Scalars['uuid']['output'];
  refresh_token: Scalars['String']['output'];
  token: Scalars['String']['output'];
};

export type AppSigninOutput = {
  __typename?: 'AppSigninOutput';
  admin: Maybe<Admin>;
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  refresh_token: Scalars['String']['output'];
  token: Scalars['String']['output'];
  user: Maybe<User>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type ChangeAdminPasswordOutput = {
  __typename?: 'ChangeAdminPasswordOutput';
  admin: Maybe<Admin>;
  admin_uuid: Maybe<Scalars['uuid']['output']>;
};

export type ChangeDriverPasswordOutput = {
  __typename?: 'ChangeDriverPasswordOutput';
  user: Maybe<User>;
  user_uuid: Scalars['String']['output'];
};

/** columns and relationships of "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle = {
  __typename?: 'CurrentTiresByVehicle';
  inspection_tire: Maybe<Last_Inspection_Tire_By_Vehicle>;
  start_at: Maybe<Scalars['datetime']['output']>;
  tire: Maybe<Tire>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  vehicle: Maybe<Vehicle>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle_Aggregate = {
  __typename?: 'CurrentTiresByVehicle_aggregate';
  aggregate: Maybe<CurrentTiresByVehicle_Aggregate_Fields>;
  nodes: Array<CurrentTiresByVehicle>;
};

/** aggregate fields of "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle_Aggregate_Fields = {
  __typename?: 'CurrentTiresByVehicle_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<CurrentTiresByVehicle_Max_Fields>;
  min: Maybe<CurrentTiresByVehicle_Min_Fields>;
};


/** aggregate fields of "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<CurrentTiresByVehicle_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "CurrentTiresByVehicle". All fields are combined with a logical 'AND'. */
export type CurrentTiresByVehicle_Bool_Exp = {
  _and?: InputMaybe<Array<CurrentTiresByVehicle_Bool_Exp>>;
  _not?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
  _or?: InputMaybe<Array<CurrentTiresByVehicle_Bool_Exp>>;
  start_at?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  tire_id?: InputMaybe<String_Mssql_Comparison_Exp>;
  tire_identifier?: InputMaybe<String_Mssql_Comparison_Exp>;
  vehicle_plate?: InputMaybe<String_Mssql_Comparison_Exp>;
};

/** upsert condition type for table "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle_If_Matched = {
  match_columns?: Array<CurrentTiresByVehicle_Insert_Match_Column>;
  update_columns?: Array<CurrentTiresByVehicle_Update_Column>;
  where?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
};

/** input type for inserting data into table "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle_Insert_Input = {
  start_at?: InputMaybe<Scalars['datetime']['input']>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** select match_columns of table "CurrentTiresByVehicle" */
export enum CurrentTiresByVehicle_Insert_Match_Column {
  /** column name */
  StartAt = 'start_at',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

/** aggregate max on columns */
export type CurrentTiresByVehicle_Max_Fields = {
  __typename?: 'CurrentTiresByVehicle_max_fields';
  start_at: Maybe<Scalars['datetime']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type CurrentTiresByVehicle_Min_Fields = {
  __typename?: 'CurrentTiresByVehicle_min_fields';
  start_at: Maybe<Scalars['datetime']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle_Mutation_Response = {
  __typename?: 'CurrentTiresByVehicle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTiresByVehicle>;
};

/** Ordering options when selecting data from "CurrentTiresByVehicle". */
export type CurrentTiresByVehicle_Order_By = {
  start_at?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** select columns of table "CurrentTiresByVehicle" */
export enum CurrentTiresByVehicle_Select_Column {
  /** column name */
  StartAt = 'start_at',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

/** input type for updating data in table "CurrentTiresByVehicle" */
export type CurrentTiresByVehicle_Set_Input = {
  start_at?: InputMaybe<Scalars['datetime']['input']>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "CurrentTiresByVehicle" */
export enum CurrentTiresByVehicle_Update_Column {
  /** column name */
  StartAt = 'start_at',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

export type EdiApiNFeOutput = {
  __typename?: 'EdiApiNFeOutput';
  message: Scalars['String']['output'];
};

/** Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'. */
export type Float_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Float']['input']>;
  _gt?: InputMaybe<Scalars['Float']['input']>;
  _gte?: InputMaybe<Scalars['Float']['input']>;
  _in?: InputMaybe<Array<Scalars['Float']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Float']['input']>;
  _lte?: InputMaybe<Scalars['Float']['input']>;
  _neq?: InputMaybe<Scalars['Float']['input']>;
  _nin?: InputMaybe<Array<Scalars['Float']['input']>>;
};

/** Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'. */
export type Float_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Float']['input']>;
  _gt?: InputMaybe<Scalars['Float']['input']>;
  _gte?: InputMaybe<Scalars['Float']['input']>;
  _in?: InputMaybe<Array<Scalars['Float']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Float']['input']>;
  _lte?: InputMaybe<Scalars['Float']['input']>;
  _neq?: InputMaybe<Scalars['Float']['input']>;
  _nin?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FuelAnalysisByAllDriversResult = {
  __typename?: 'FuelAnalysisByAllDriversResult';
  Km: Maybe<Scalars['Float']['output']>;
  KmComPeso: Maybe<Scalars['Float']['output']>;
  KmSemPeso: Maybe<Scalars['Float']['output']>;
  Peso: Maybe<Scalars['Float']['output']>;
  Previsto: Maybe<Scalars['Float']['output']>;
  Realizado: Maybe<Scalars['Float']['output']>;
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  month: Scalars['String']['output'];
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

export type FuelAnalysisByDriversResult = {
  __typename?: 'FuelAnalysisByDriversResult';
  codmoto: Scalars['String']['output'];
  months: Array<FuelAnalysisByDriversResultMonth>;
};

export type FuelAnalysisByDriversResultMonth = {
  __typename?: 'FuelAnalysisByDriversResultMonth';
  data: Array<FuelAnalysisByDriversResultMonthData>;
  month: Scalars['String']['output'];
  note: Maybe<User_Score_ActionType>;
};

export type FuelAnalysisByDriversResultMonthData = {
  __typename?: 'FuelAnalysisByDriversResultMonthData';
  Km: Maybe<Scalars['Float']['output']>;
  Kml: Maybe<Scalars['Float']['output']>;
  Peso: Maybe<Scalars['Float']['output']>;
  Previsto: Maybe<Scalars['Float']['output']>;
  Realizado: Maybe<Scalars['Float']['output']>;
};

export type InspectionProblem = {
  __typename?: 'InspectionProblem';
  vehicle_inspections: Scalars['json']['output'];
};


export type InspectionProblemVehicle_InspectionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** Boolean expression to filter rows from the logical model for "InspectionProblem". All fields are combined with a logical 'AND'. */
export type InspectionProblem_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<InspectionProblem_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<InspectionProblem_Bool_Exp_Bool_Exp>>;
  vehicle_inspections?: InputMaybe<Json_Comparison_Exp>;
};

export enum InspectionProblem_Enum_Name {
  /** column name */
  VehicleInspections = 'vehicle_inspections'
}

/** Ordering options when selecting data from "InspectionProblem". */
export type InspectionProblem_Order_By = {
  vehicle_inspections?: InputMaybe<Order_By>;
};

export type InspectionsExport = {
  __typename?: 'InspectionsExport';
  inspections: Scalars['json']['output'];
};


export type InspectionsExportInspectionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** Boolean expression to filter rows from the logical model for "InspectionsExport". All fields are combined with a logical 'AND'. */
export type InspectionsExport_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<InspectionsExport_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<InspectionsExport_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<InspectionsExport_Bool_Exp_Bool_Exp>>;
  inspections?: InputMaybe<Json_Comparison_Exp>;
};

export enum InspectionsExport_Enum_Name {
  /** column name */
  Inspections = 'inspections'
}

/** Ordering options when selecting data from "InspectionsExport". */
export type InspectionsExport_Order_By = {
  inspections?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NfPendingCte = {
  __typename?: 'NfPendingCte';
  chave_nf: Scalars['String']['output'];
  cnpj_destinatario: Scalars['String']['output'];
  cnpj_remetente: Scalars['String']['output'];
  data_nf: Scalars['timestamptz']['output'];
  endereco_destino: Scalars['String']['output'];
  numero_nf: Scalars['Int']['output'];
  observacao: Maybe<Scalars['String']['output']>;
  peso: Scalars['Float']['output'];
  serie_nf: Scalars['Int']['output'];
  valor_nf: Scalars['Float']['output'];
};

/** columns and relationships of "ParametroAlertaConducao" */
export type ParametroAlertaConducao = {
  __typename?: 'ParametroAlertaConducao';
  CalcularValorSql: Scalars['String']['output'];
  CondicaoValorSql: Scalars['String']['output'];
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Descricao: Scalars['String']['output'];
  FatorExponencial: Scalars['Float']['output'];
  FormatarValorSql: Scalars['String']['output'];
  Habilitado: Scalars['Boolean']['output'];
  Id: Scalars['Int']['output'];
  IntensidadeRisco: Scalars['Float']['output'];
  Nome: Maybe<Scalars['String']['output']>;
  NomeCategoria: Maybe<Scalars['String']['output']>;
  Threshold: Scalars['Float']['output'];
  UpdatedAt: Maybe<Scalars['datetime']['output']>;
  ValorEscalar: Scalars['Float']['output'];
};

/** aggregated selection of "ParametroAlertaConducao" */
export type ParametroAlertaConducao_Aggregate = {
  __typename?: 'ParametroAlertaConducao_aggregate';
  aggregate: Maybe<ParametroAlertaConducao_Aggregate_Fields>;
  nodes: Array<ParametroAlertaConducao>;
};

/** aggregate fields of "ParametroAlertaConducao" */
export type ParametroAlertaConducao_Aggregate_Fields = {
  __typename?: 'ParametroAlertaConducao_aggregate_fields';
  avg: Maybe<ParametroAlertaConducao_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<ParametroAlertaConducao_Max_Fields>;
  min: Maybe<ParametroAlertaConducao_Min_Fields>;
  stddev: Maybe<ParametroAlertaConducao_Stddev_Fields>;
  stddev_pop: Maybe<ParametroAlertaConducao_Stddev_Pop_Fields>;
  stddev_samp: Maybe<ParametroAlertaConducao_Stddev_Samp_Fields>;
  sum: Maybe<ParametroAlertaConducao_Sum_Fields>;
  var_pop: Maybe<ParametroAlertaConducao_Var_Pop_Fields>;
  var_samp: Maybe<ParametroAlertaConducao_Var_Samp_Fields>;
  variance: Maybe<ParametroAlertaConducao_Variance_Fields>;
};


/** aggregate fields of "ParametroAlertaConducao" */
export type ParametroAlertaConducao_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<ParametroAlertaConducao_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ParametroAlertaConducao_Avg_Fields = {
  __typename?: 'ParametroAlertaConducao_avg_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "ParametroAlertaConducao". All fields are combined with a logical 'AND'. */
export type ParametroAlertaConducao_Bool_Exp = {
  CalcularValorSql?: InputMaybe<String_Mssql_Comparison_Exp>;
  CondicaoValorSql?: InputMaybe<String_Mssql_Comparison_Exp>;
  CreatedAt?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  Descricao?: InputMaybe<String_Mssql_Comparison_Exp>;
  FatorExponencial?: InputMaybe<Float_Mssql_Comparison_Exp>;
  FormatarValorSql?: InputMaybe<String_Mssql_Comparison_Exp>;
  Habilitado?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IntensidadeRisco?: InputMaybe<Float_Mssql_Comparison_Exp>;
  Nome?: InputMaybe<String_Mssql_Comparison_Exp>;
  NomeCategoria?: InputMaybe<String_Mssql_Comparison_Exp>;
  Threshold?: InputMaybe<Float_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  ValorEscalar?: InputMaybe<Float_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<ParametroAlertaConducao_Bool_Exp>>;
  _not?: InputMaybe<ParametroAlertaConducao_Bool_Exp>;
  _or?: InputMaybe<Array<ParametroAlertaConducao_Bool_Exp>>;
};

/** upsert condition type for table "ParametroAlertaConducao" */
export type ParametroAlertaConducao_If_Matched = {
  match_columns?: Array<ParametroAlertaConducao_Insert_Match_Column>;
  update_columns?: Array<ParametroAlertaConducao_Update_Column>;
  where?: InputMaybe<ParametroAlertaConducao_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "ParametroAlertaConducao" */
export type ParametroAlertaConducao_Inc_Input = {
  FatorExponencial?: InputMaybe<Scalars['Float']['input']>;
  IntensidadeRisco?: InputMaybe<Scalars['Float']['input']>;
  Threshold?: InputMaybe<Scalars['Float']['input']>;
  ValorEscalar?: InputMaybe<Scalars['Float']['input']>;
};

/** input type for inserting data into table "ParametroAlertaConducao" */
export type ParametroAlertaConducao_Insert_Input = {
  CalcularValorSql?: InputMaybe<Scalars['String']['input']>;
  CondicaoValorSql?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  Descricao?: InputMaybe<Scalars['String']['input']>;
  FatorExponencial?: InputMaybe<Scalars['Float']['input']>;
  FormatarValorSql?: InputMaybe<Scalars['String']['input']>;
  Habilitado?: InputMaybe<Scalars['Boolean']['input']>;
  IntensidadeRisco?: InputMaybe<Scalars['Float']['input']>;
  Nome?: InputMaybe<Scalars['String']['input']>;
  NomeCategoria?: InputMaybe<Scalars['String']['input']>;
  Threshold?: InputMaybe<Scalars['Float']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetime']['input']>;
  ValorEscalar?: InputMaybe<Scalars['Float']['input']>;
};

/** select match_columns of table "ParametroAlertaConducao" */
export enum ParametroAlertaConducao_Insert_Match_Column {
  /** column name */
  CalcularValorSql = 'CalcularValorSql',
  /** column name */
  CondicaoValorSql = 'CondicaoValorSql',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Descricao = 'Descricao',
  /** column name */
  FatorExponencial = 'FatorExponencial',
  /** column name */
  FormatarValorSql = 'FormatarValorSql',
  /** column name */
  Habilitado = 'Habilitado',
  /** column name */
  Id = 'Id',
  /** column name */
  IntensidadeRisco = 'IntensidadeRisco',
  /** column name */
  Nome = 'Nome',
  /** column name */
  NomeCategoria = 'NomeCategoria',
  /** column name */
  Threshold = 'Threshold',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  ValorEscalar = 'ValorEscalar'
}

/** aggregate max on columns */
export type ParametroAlertaConducao_Max_Fields = {
  __typename?: 'ParametroAlertaConducao_max_fields';
  CalcularValorSql: Maybe<Scalars['String']['output']>;
  CondicaoValorSql: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Descricao: Maybe<Scalars['String']['output']>;
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  FormatarValorSql: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Nome: Maybe<Scalars['String']['output']>;
  NomeCategoria: Maybe<Scalars['String']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  UpdatedAt: Maybe<Scalars['datetime']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** aggregate min on columns */
export type ParametroAlertaConducao_Min_Fields = {
  __typename?: 'ParametroAlertaConducao_min_fields';
  CalcularValorSql: Maybe<Scalars['String']['output']>;
  CondicaoValorSql: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Descricao: Maybe<Scalars['String']['output']>;
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  FormatarValorSql: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Nome: Maybe<Scalars['String']['output']>;
  NomeCategoria: Maybe<Scalars['String']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  UpdatedAt: Maybe<Scalars['datetime']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** response of any mutation on the table "ParametroAlertaConducao" */
export type ParametroAlertaConducao_Mutation_Response = {
  __typename?: 'ParametroAlertaConducao_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ParametroAlertaConducao>;
};

/** Ordering options when selecting data from "ParametroAlertaConducao". */
export type ParametroAlertaConducao_Order_By = {
  CalcularValorSql?: InputMaybe<Order_By>;
  CondicaoValorSql?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  Descricao?: InputMaybe<Order_By>;
  FatorExponencial?: InputMaybe<Order_By>;
  FormatarValorSql?: InputMaybe<Order_By>;
  Habilitado?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IntensidadeRisco?: InputMaybe<Order_By>;
  Nome?: InputMaybe<Order_By>;
  NomeCategoria?: InputMaybe<Order_By>;
  Threshold?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  ValorEscalar?: InputMaybe<Order_By>;
};

/** primary key columns input for table: ParametroAlertaConducao */
export type ParametroAlertaConducao_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "ParametroAlertaConducao" */
export enum ParametroAlertaConducao_Select_Column {
  /** column name */
  CalcularValorSql = 'CalcularValorSql',
  /** column name */
  CondicaoValorSql = 'CondicaoValorSql',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Descricao = 'Descricao',
  /** column name */
  FatorExponencial = 'FatorExponencial',
  /** column name */
  FormatarValorSql = 'FormatarValorSql',
  /** column name */
  Habilitado = 'Habilitado',
  /** column name */
  Id = 'Id',
  /** column name */
  IntensidadeRisco = 'IntensidadeRisco',
  /** column name */
  Nome = 'Nome',
  /** column name */
  NomeCategoria = 'NomeCategoria',
  /** column name */
  Threshold = 'Threshold',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  ValorEscalar = 'ValorEscalar'
}

/** input type for updating data in table "ParametroAlertaConducao" */
export type ParametroAlertaConducao_Set_Input = {
  CalcularValorSql?: InputMaybe<Scalars['String']['input']>;
  CondicaoValorSql?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  Descricao?: InputMaybe<Scalars['String']['input']>;
  FatorExponencial?: InputMaybe<Scalars['Float']['input']>;
  FormatarValorSql?: InputMaybe<Scalars['String']['input']>;
  Habilitado?: InputMaybe<Scalars['Boolean']['input']>;
  IntensidadeRisco?: InputMaybe<Scalars['Float']['input']>;
  Nome?: InputMaybe<Scalars['String']['input']>;
  NomeCategoria?: InputMaybe<Scalars['String']['input']>;
  Threshold?: InputMaybe<Scalars['Float']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetime']['input']>;
  ValorEscalar?: InputMaybe<Scalars['Float']['input']>;
};

/** aggregate stddev on columns */
export type ParametroAlertaConducao_Stddev_Fields = {
  __typename?: 'ParametroAlertaConducao_stddev_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ParametroAlertaConducao_Stddev_Pop_Fields = {
  __typename?: 'ParametroAlertaConducao_stddev_pop_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ParametroAlertaConducao_Stddev_Samp_Fields = {
  __typename?: 'ParametroAlertaConducao_stddev_samp_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type ParametroAlertaConducao_Sum_Fields = {
  __typename?: 'ParametroAlertaConducao_sum_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** update columns of table "ParametroAlertaConducao" */
export enum ParametroAlertaConducao_Update_Column {
  /** column name */
  CalcularValorSql = 'CalcularValorSql',
  /** column name */
  CondicaoValorSql = 'CondicaoValorSql',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Descricao = 'Descricao',
  /** column name */
  FatorExponencial = 'FatorExponencial',
  /** column name */
  FormatarValorSql = 'FormatarValorSql',
  /** column name */
  Habilitado = 'Habilitado',
  /** column name */
  IntensidadeRisco = 'IntensidadeRisco',
  /** column name */
  Nome = 'Nome',
  /** column name */
  NomeCategoria = 'NomeCategoria',
  /** column name */
  Threshold = 'Threshold',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  ValorEscalar = 'ValorEscalar'
}

/** aggregate var_pop on columns */
export type ParametroAlertaConducao_Var_Pop_Fields = {
  __typename?: 'ParametroAlertaConducao_var_pop_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ParametroAlertaConducao_Var_Samp_Fields = {
  __typename?: 'ParametroAlertaConducao_var_samp_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ParametroAlertaConducao_Variance_Fields = {
  __typename?: 'ParametroAlertaConducao_variance_fields';
  FatorExponencial: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IntensidadeRisco: Maybe<Scalars['Float']['output']>;
  Threshold: Maybe<Scalars['Float']['output']>;
  ValorEscalar: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "PerformanceParameter" */
export type PerformanceParameter = {
  __typename?: 'PerformanceParameter';
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Scalars['Int']['output'];
  IsForOverallScore: Maybe<Scalars['Boolean']['output']>;
  IsForVolvoVehicles: Scalars['Int']['output'];
  Name: Scalars['String']['output'];
  RealName: Scalars['String']['output'];
  /** An array relationship */
  ScoreParameters: Array<ScoreParameter>;
  /** An aggregate relationship */
  ScoreParameters_aggregate: ScoreParameter_Aggregate;
  Type: Scalars['String']['output'];
};


/** columns and relationships of "PerformanceParameter" */
export type PerformanceParameterScoreParametersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};


/** columns and relationships of "PerformanceParameter" */
export type PerformanceParameterScoreParameters_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};

/** aggregated selection of "PerformanceParameter" */
export type PerformanceParameter_Aggregate = {
  __typename?: 'PerformanceParameter_aggregate';
  aggregate: Maybe<PerformanceParameter_Aggregate_Fields>;
  nodes: Array<PerformanceParameter>;
};

/** aggregate fields of "PerformanceParameter" */
export type PerformanceParameter_Aggregate_Fields = {
  __typename?: 'PerformanceParameter_aggregate_fields';
  avg: Maybe<PerformanceParameter_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<PerformanceParameter_Max_Fields>;
  min: Maybe<PerformanceParameter_Min_Fields>;
  stddev: Maybe<PerformanceParameter_Stddev_Fields>;
  stddev_pop: Maybe<PerformanceParameter_Stddev_Pop_Fields>;
  stddev_samp: Maybe<PerformanceParameter_Stddev_Samp_Fields>;
  sum: Maybe<PerformanceParameter_Sum_Fields>;
  var_pop: Maybe<PerformanceParameter_Var_Pop_Fields>;
  var_samp: Maybe<PerformanceParameter_Var_Samp_Fields>;
  variance: Maybe<PerformanceParameter_Variance_Fields>;
};


/** aggregate fields of "PerformanceParameter" */
export type PerformanceParameter_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<PerformanceParameter_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PerformanceParameter_Avg_Fields = {
  __typename?: 'PerformanceParameter_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "PerformanceParameter". All fields are combined with a logical 'AND'. */
export type PerformanceParameter_Bool_Exp = {
  CreatedAt?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  Description?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IsForOverallScore?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  IsForVolvoVehicles?: InputMaybe<Int_Mssql_Comparison_Exp>;
  Name?: InputMaybe<String_Mssql_Comparison_Exp>;
  RealName?: InputMaybe<String_Mssql_Comparison_Exp>;
  ScoreParameters?: InputMaybe<ScoreParameter_Bool_Exp>;
  Type?: InputMaybe<String_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<PerformanceParameter_Bool_Exp>>;
  _not?: InputMaybe<PerformanceParameter_Bool_Exp>;
  _or?: InputMaybe<Array<PerformanceParameter_Bool_Exp>>;
};

/** upsert condition type for table "PerformanceParameter" */
export type PerformanceParameter_If_Matched = {
  match_columns?: Array<PerformanceParameter_Insert_Match_Column>;
  update_columns?: Array<PerformanceParameter_Update_Column>;
  where?: InputMaybe<PerformanceParameter_Bool_Exp>;
};

/** input type for inserting data into table "PerformanceParameter" */
export type PerformanceParameter_Insert_Input = {
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  IsForOverallScore?: InputMaybe<Scalars['Boolean']['input']>;
  Name?: InputMaybe<Scalars['String']['input']>;
  RealName?: InputMaybe<Scalars['String']['input']>;
  Type?: InputMaybe<Scalars['String']['input']>;
};

/** select match_columns of table "PerformanceParameter" */
export enum PerformanceParameter_Insert_Match_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  IsForOverallScore = 'IsForOverallScore',
  /** column name */
  IsForVolvoVehicles = 'IsForVolvoVehicles',
  /** column name */
  Name = 'Name',
  /** column name */
  RealName = 'RealName',
  /** column name */
  Type = 'Type'
}

/** aggregate max on columns */
export type PerformanceParameter_Max_Fields = {
  __typename?: 'PerformanceParameter_max_fields';
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Int']['output']>;
  Name: Maybe<Scalars['String']['output']>;
  RealName: Maybe<Scalars['String']['output']>;
  Type: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type PerformanceParameter_Min_Fields = {
  __typename?: 'PerformanceParameter_min_fields';
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Int']['output']>;
  Name: Maybe<Scalars['String']['output']>;
  RealName: Maybe<Scalars['String']['output']>;
  Type: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "PerformanceParameter" */
export type PerformanceParameter_Mutation_Response = {
  __typename?: 'PerformanceParameter_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PerformanceParameter>;
};

/** Ordering options when selecting data from "PerformanceParameter". */
export type PerformanceParameter_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsForOverallScore?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  Name?: InputMaybe<Order_By>;
  RealName?: InputMaybe<Order_By>;
  ScoreParameters_aggregate?: InputMaybe<ScoreParameter_Aggregate_Order_By>;
  Type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: PerformanceParameter */
export type PerformanceParameter_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "PerformanceParameter" */
export enum PerformanceParameter_Select_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  IsForOverallScore = 'IsForOverallScore',
  /** column name */
  IsForVolvoVehicles = 'IsForVolvoVehicles',
  /** column name */
  Name = 'Name',
  /** column name */
  RealName = 'RealName',
  /** column name */
  Type = 'Type'
}

/** input type for updating data in table "PerformanceParameter" */
export type PerformanceParameter_Set_Input = {
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  IsForOverallScore?: InputMaybe<Scalars['Boolean']['input']>;
  Name?: InputMaybe<Scalars['String']['input']>;
  RealName?: InputMaybe<Scalars['String']['input']>;
  Type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type PerformanceParameter_Stddev_Fields = {
  __typename?: 'PerformanceParameter_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type PerformanceParameter_Stddev_Pop_Fields = {
  __typename?: 'PerformanceParameter_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type PerformanceParameter_Stddev_Samp_Fields = {
  __typename?: 'PerformanceParameter_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type PerformanceParameter_Sum_Fields = {
  __typename?: 'PerformanceParameter_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "PerformanceParameter" */
export enum PerformanceParameter_Update_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  IsForOverallScore = 'IsForOverallScore',
  /** column name */
  Name = 'Name',
  /** column name */
  RealName = 'RealName',
  /** column name */
  Type = 'Type'
}

/** aggregate var_pop on columns */
export type PerformanceParameter_Var_Pop_Fields = {
  __typename?: 'PerformanceParameter_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type PerformanceParameter_Var_Samp_Fields = {
  __typename?: 'PerformanceParameter_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PerformanceParameter_Variance_Fields = {
  __typename?: 'PerformanceParameter_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "PontosRastro" */
export type PontosRastro = {
  __typename?: 'PontosRastro';
  AreaCirculoGeography: Maybe<Scalars['geography']['output']>;
  PontoGeography: Maybe<Scalars['geography']['output']>;
  PontoRastroId: Scalars['Int']['output'];
  critico: Scalars['Boolean']['output'];
  idPessoaJuridica: Maybe<Scalars['Int']['output']>;
  idRastroGeocode: Maybe<Scalars['Int']['output']>;
  lat: Scalars['Float']['output'];
  lng: Scalars['Float']['output'];
  metrosArea: Scalars['Int']['output'];
  pontoRastreado: Maybe<Scalars['String']['output']>;
  tipoPonto: Maybe<Scalars['String']['output']>;
  velocidadeMaxima: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "PontosRastro" */
export type PontosRastro_Aggregate = {
  __typename?: 'PontosRastro_aggregate';
  aggregate: Maybe<PontosRastro_Aggregate_Fields>;
  nodes: Array<PontosRastro>;
};

/** aggregate fields of "PontosRastro" */
export type PontosRastro_Aggregate_Fields = {
  __typename?: 'PontosRastro_aggregate_fields';
  avg: Maybe<PontosRastro_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<PontosRastro_Max_Fields>;
  min: Maybe<PontosRastro_Min_Fields>;
  stddev: Maybe<PontosRastro_Stddev_Fields>;
  stddev_pop: Maybe<PontosRastro_Stddev_Pop_Fields>;
  stddev_samp: Maybe<PontosRastro_Stddev_Samp_Fields>;
  sum: Maybe<PontosRastro_Sum_Fields>;
  var_pop: Maybe<PontosRastro_Var_Pop_Fields>;
  var_samp: Maybe<PontosRastro_Var_Samp_Fields>;
  variance: Maybe<PontosRastro_Variance_Fields>;
};


/** aggregate fields of "PontosRastro" */
export type PontosRastro_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<PontosRastro_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PontosRastro_Avg_Fields = {
  __typename?: 'PontosRastro_avg_fields';
  PontoRastroId: Maybe<Scalars['Float']['output']>;
  idPessoaJuridica: Maybe<Scalars['Float']['output']>;
  idRastroGeocode: Maybe<Scalars['Float']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Float']['output']>;
  velocidadeMaxima: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "PontosRastro". All fields are combined with a logical 'AND'. */
export type PontosRastro_Bool_Exp = {
  AreaCirculoGeography?: InputMaybe<Geography_Mssql_Comparison_Exp>;
  PontoGeography?: InputMaybe<Geography_Mssql_Comparison_Exp>;
  PontoRastroId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<PontosRastro_Bool_Exp>>;
  _not?: InputMaybe<PontosRastro_Bool_Exp>;
  _or?: InputMaybe<Array<PontosRastro_Bool_Exp>>;
  critico?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  idPessoaJuridica?: InputMaybe<Int_Mssql_Comparison_Exp>;
  idRastroGeocode?: InputMaybe<Int_Mssql_Comparison_Exp>;
  lat?: InputMaybe<Float_Mssql_Comparison_Exp>;
  lng?: InputMaybe<Float_Mssql_Comparison_Exp>;
  metrosArea?: InputMaybe<Int_Mssql_Comparison_Exp>;
  pontoRastreado?: InputMaybe<String_Mssql_Comparison_Exp>;
  tipoPonto?: InputMaybe<String_Mssql_Comparison_Exp>;
  velocidadeMaxima?: InputMaybe<Int_Mssql_Comparison_Exp>;
};

/** upsert condition type for table "PontosRastro" */
export type PontosRastro_If_Matched = {
  match_columns?: Array<PontosRastro_Insert_Match_Column>;
  update_columns?: Array<PontosRastro_Update_Column>;
  where?: InputMaybe<PontosRastro_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "PontosRastro" */
export type PontosRastro_Inc_Input = {
  idPessoaJuridica?: InputMaybe<Scalars['Int']['input']>;
  idRastroGeocode?: InputMaybe<Scalars['Int']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  metrosArea?: InputMaybe<Scalars['Int']['input']>;
  velocidadeMaxima?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "PontosRastro" */
export type PontosRastro_Insert_Input = {
  AreaCirculoGeography?: InputMaybe<Scalars['geography']['input']>;
  critico?: InputMaybe<Scalars['Boolean']['input']>;
  idPessoaJuridica?: InputMaybe<Scalars['Int']['input']>;
  idRastroGeocode?: InputMaybe<Scalars['Int']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  metrosArea?: InputMaybe<Scalars['Int']['input']>;
  pontoRastreado?: InputMaybe<Scalars['String']['input']>;
  tipoPonto?: InputMaybe<Scalars['String']['input']>;
  velocidadeMaxima?: InputMaybe<Scalars['Int']['input']>;
};

/** select match_columns of table "PontosRastro" */
export enum PontosRastro_Insert_Match_Column {
  /** column name */
  AreaCirculoGeography = 'AreaCirculoGeography',
  /** column name */
  PontoGeography = 'PontoGeography',
  /** column name */
  PontoRastroId = 'PontoRastroId',
  /** column name */
  Critico = 'critico',
  /** column name */
  IdPessoaJuridica = 'idPessoaJuridica',
  /** column name */
  IdRastroGeocode = 'idRastroGeocode',
  /** column name */
  Lat = 'lat',
  /** column name */
  Lng = 'lng',
  /** column name */
  MetrosArea = 'metrosArea',
  /** column name */
  PontoRastreado = 'pontoRastreado',
  /** column name */
  TipoPonto = 'tipoPonto',
  /** column name */
  VelocidadeMaxima = 'velocidadeMaxima'
}

/** aggregate max on columns */
export type PontosRastro_Max_Fields = {
  __typename?: 'PontosRastro_max_fields';
  AreaCirculoGeography: Maybe<Scalars['geography']['output']>;
  PontoGeography: Maybe<Scalars['geography']['output']>;
  PontoRastroId: Maybe<Scalars['Int']['output']>;
  idPessoaJuridica: Maybe<Scalars['Int']['output']>;
  idRastroGeocode: Maybe<Scalars['Int']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Int']['output']>;
  pontoRastreado: Maybe<Scalars['String']['output']>;
  tipoPonto: Maybe<Scalars['String']['output']>;
  velocidadeMaxima: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type PontosRastro_Min_Fields = {
  __typename?: 'PontosRastro_min_fields';
  AreaCirculoGeography: Maybe<Scalars['geography']['output']>;
  PontoGeography: Maybe<Scalars['geography']['output']>;
  PontoRastroId: Maybe<Scalars['Int']['output']>;
  idPessoaJuridica: Maybe<Scalars['Int']['output']>;
  idRastroGeocode: Maybe<Scalars['Int']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Int']['output']>;
  pontoRastreado: Maybe<Scalars['String']['output']>;
  tipoPonto: Maybe<Scalars['String']['output']>;
  velocidadeMaxima: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "PontosRastro" */
export type PontosRastro_Mutation_Response = {
  __typename?: 'PontosRastro_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PontosRastro>;
};

/** Ordering options when selecting data from "PontosRastro". */
export type PontosRastro_Order_By = {
  AreaCirculoGeography?: InputMaybe<Order_By>;
  PontoGeography?: InputMaybe<Order_By>;
  PontoRastroId?: InputMaybe<Order_By>;
  critico?: InputMaybe<Order_By>;
  idPessoaJuridica?: InputMaybe<Order_By>;
  idRastroGeocode?: InputMaybe<Order_By>;
  lat?: InputMaybe<Order_By>;
  lng?: InputMaybe<Order_By>;
  metrosArea?: InputMaybe<Order_By>;
  pontoRastreado?: InputMaybe<Order_By>;
  tipoPonto?: InputMaybe<Order_By>;
  velocidadeMaxima?: InputMaybe<Order_By>;
};

/** primary key columns input for table: PontosRastro */
export type PontosRastro_Pk_Columns_Input = {
  PontoRastroId: Scalars['Int']['input'];
};

/** select columns of table "PontosRastro" */
export enum PontosRastro_Select_Column {
  /** column name */
  AreaCirculoGeography = 'AreaCirculoGeography',
  /** column name */
  PontoGeography = 'PontoGeography',
  /** column name */
  PontoRastroId = 'PontoRastroId',
  /** column name */
  Critico = 'critico',
  /** column name */
  IdPessoaJuridica = 'idPessoaJuridica',
  /** column name */
  IdRastroGeocode = 'idRastroGeocode',
  /** column name */
  Lat = 'lat',
  /** column name */
  Lng = 'lng',
  /** column name */
  MetrosArea = 'metrosArea',
  /** column name */
  PontoRastreado = 'pontoRastreado',
  /** column name */
  TipoPonto = 'tipoPonto',
  /** column name */
  VelocidadeMaxima = 'velocidadeMaxima'
}

/** input type for updating data in table "PontosRastro" */
export type PontosRastro_Set_Input = {
  AreaCirculoGeography?: InputMaybe<Scalars['geography']['input']>;
  critico?: InputMaybe<Scalars['Boolean']['input']>;
  idPessoaJuridica?: InputMaybe<Scalars['Int']['input']>;
  idRastroGeocode?: InputMaybe<Scalars['Int']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  metrosArea?: InputMaybe<Scalars['Int']['input']>;
  pontoRastreado?: InputMaybe<Scalars['String']['input']>;
  tipoPonto?: InputMaybe<Scalars['String']['input']>;
  velocidadeMaxima?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type PontosRastro_Stddev_Fields = {
  __typename?: 'PontosRastro_stddev_fields';
  PontoRastroId: Maybe<Scalars['Float']['output']>;
  idPessoaJuridica: Maybe<Scalars['Float']['output']>;
  idRastroGeocode: Maybe<Scalars['Float']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Float']['output']>;
  velocidadeMaxima: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type PontosRastro_Stddev_Pop_Fields = {
  __typename?: 'PontosRastro_stddev_pop_fields';
  PontoRastroId: Maybe<Scalars['Float']['output']>;
  idPessoaJuridica: Maybe<Scalars['Float']['output']>;
  idRastroGeocode: Maybe<Scalars['Float']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Float']['output']>;
  velocidadeMaxima: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type PontosRastro_Stddev_Samp_Fields = {
  __typename?: 'PontosRastro_stddev_samp_fields';
  PontoRastroId: Maybe<Scalars['Float']['output']>;
  idPessoaJuridica: Maybe<Scalars['Float']['output']>;
  idRastroGeocode: Maybe<Scalars['Float']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Float']['output']>;
  velocidadeMaxima: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type PontosRastro_Sum_Fields = {
  __typename?: 'PontosRastro_sum_fields';
  PontoRastroId: Maybe<Scalars['Int']['output']>;
  idPessoaJuridica: Maybe<Scalars['Int']['output']>;
  idRastroGeocode: Maybe<Scalars['Int']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Int']['output']>;
  velocidadeMaxima: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "PontosRastro" */
export enum PontosRastro_Update_Column {
  /** column name */
  AreaCirculoGeography = 'AreaCirculoGeography',
  /** column name */
  Critico = 'critico',
  /** column name */
  IdPessoaJuridica = 'idPessoaJuridica',
  /** column name */
  IdRastroGeocode = 'idRastroGeocode',
  /** column name */
  Lat = 'lat',
  /** column name */
  Lng = 'lng',
  /** column name */
  MetrosArea = 'metrosArea',
  /** column name */
  PontoRastreado = 'pontoRastreado',
  /** column name */
  TipoPonto = 'tipoPonto',
  /** column name */
  VelocidadeMaxima = 'velocidadeMaxima'
}

/** aggregate var_pop on columns */
export type PontosRastro_Var_Pop_Fields = {
  __typename?: 'PontosRastro_var_pop_fields';
  PontoRastroId: Maybe<Scalars['Float']['output']>;
  idPessoaJuridica: Maybe<Scalars['Float']['output']>;
  idRastroGeocode: Maybe<Scalars['Float']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Float']['output']>;
  velocidadeMaxima: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type PontosRastro_Var_Samp_Fields = {
  __typename?: 'PontosRastro_var_samp_fields';
  PontoRastroId: Maybe<Scalars['Float']['output']>;
  idPessoaJuridica: Maybe<Scalars['Float']['output']>;
  idRastroGeocode: Maybe<Scalars['Float']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Float']['output']>;
  velocidadeMaxima: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PontosRastro_Variance_Fields = {
  __typename?: 'PontosRastro_variance_fields';
  PontoRastroId: Maybe<Scalars['Float']['output']>;
  idPessoaJuridica: Maybe<Scalars['Float']['output']>;
  idRastroGeocode: Maybe<Scalars['Float']['output']>;
  lat: Maybe<Scalars['Float']['output']>;
  lng: Maybe<Scalars['Float']['output']>;
  metrosArea: Maybe<Scalars['Float']['output']>;
  velocidadeMaxima: Maybe<Scalars['Float']['output']>;
};

export type RefreshTokenOutput = {
  __typename?: 'RefreshTokenOutput';
  token: Scalars['String']['output'];
};

export type RegisterAdminOutput = {
  __typename?: 'RegisterAdminOutput';
  avatar_url: Scalars['String']['output'];
  cpf: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  email: Scalars['String']['output'];
  enabled: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};

/** columns and relationships of "ScoreParameter" */
export type ScoreParameter = {
  __typename?: 'ScoreParameter';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  CreatedAt: Scalars['datetime']['output'];
  DeletedAt: Maybe<Scalars['datetime']['output']>;
  DeletedAtDate: Maybe<Scalars['date']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  ExponentFactor: Scalars['Float']['output'];
  Id: Scalars['Int']['output'];
  IsDeleted: Scalars['Int']['output'];
  IsForSpecificVehicleModel: Scalars['Int']['output'];
  IsForVolvoVehicles: Scalars['Int']['output'];
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  ParameterName: Scalars['String']['output'];
  /** An object relationship */
  PerformanceParameter: Maybe<PerformanceParameter>;
  PerformanceParameterId: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  ScoreType: ScoreType;
  ScoreTypeId: Scalars['Int']['output'];
  Type: Scalars['String']['output'];
  VehicleModel: Maybe<Scalars['String']['output']>;
  Weight: Scalars['Float']['output'];
  WeightedBy: Scalars['String']['output'];
};

/** aggregated selection of "ScoreParameter" */
export type ScoreParameter_Aggregate = {
  __typename?: 'ScoreParameter_aggregate';
  aggregate: Maybe<ScoreParameter_Aggregate_Fields>;
  nodes: Array<ScoreParameter>;
};

/** aggregate fields of "ScoreParameter" */
export type ScoreParameter_Aggregate_Fields = {
  __typename?: 'ScoreParameter_aggregate_fields';
  avg: Maybe<ScoreParameter_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<ScoreParameter_Max_Fields>;
  min: Maybe<ScoreParameter_Min_Fields>;
  stddev: Maybe<ScoreParameter_Stddev_Fields>;
  stddev_pop: Maybe<ScoreParameter_Stddev_Pop_Fields>;
  stddev_samp: Maybe<ScoreParameter_Stddev_Samp_Fields>;
  sum: Maybe<ScoreParameter_Sum_Fields>;
  var_pop: Maybe<ScoreParameter_Var_Pop_Fields>;
  var_samp: Maybe<ScoreParameter_Var_Samp_Fields>;
  variance: Maybe<ScoreParameter_Variance_Fields>;
};


/** aggregate fields of "ScoreParameter" */
export type ScoreParameter_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<ScoreParameter_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "ScoreParameter" */
export type ScoreParameter_Aggregate_Order_By = {
  avg?: InputMaybe<ScoreParameter_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ScoreParameter_Max_Order_By>;
  min?: InputMaybe<ScoreParameter_Min_Order_By>;
  stddev?: InputMaybe<ScoreParameter_Stddev_Order_By>;
  stddev_pop?: InputMaybe<ScoreParameter_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<ScoreParameter_Stddev_Samp_Order_By>;
  sum?: InputMaybe<ScoreParameter_Sum_Order_By>;
  var_pop?: InputMaybe<ScoreParameter_Var_Pop_Order_By>;
  var_samp?: InputMaybe<ScoreParameter_Var_Samp_Order_By>;
  variance?: InputMaybe<ScoreParameter_Variance_Order_By>;
};

/** aggregate avg on columns */
export type ScoreParameter_Avg_Fields = {
  __typename?: 'ScoreParameter_avg_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsDeleted: Maybe<Scalars['Float']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Float']['output']>;
  ScoreTypeId: Maybe<Scalars['Float']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "ScoreParameter" */
export type ScoreParameter_Avg_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ScoreParameter". All fields are combined with a logical 'AND'. */
export type ScoreParameter_Bool_Exp = {
  AboveRangeReplacementValue?: InputMaybe<Float_Mssql_Comparison_Exp>;
  BelowRangeReplacementValue?: InputMaybe<Float_Mssql_Comparison_Exp>;
  CreatedAt?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  DeletedAt?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  DeletedAtDate?: InputMaybe<Date_Mssql_Comparison_Exp>;
  Description?: InputMaybe<String_Mssql_Comparison_Exp>;
  ExponentFactor?: InputMaybe<Float_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IsDeleted?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IsForSpecificVehicleModel?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IsForVolvoVehicles?: InputMaybe<Int_Mssql_Comparison_Exp>;
  MaxValue?: InputMaybe<Float_Mssql_Comparison_Exp>;
  MaxValueToApplyParameter?: InputMaybe<Float_Mssql_Comparison_Exp>;
  MinValue?: InputMaybe<Float_Mssql_Comparison_Exp>;
  MinValueToApplyParameter?: InputMaybe<Float_Mssql_Comparison_Exp>;
  ParameterName?: InputMaybe<String_Mssql_Comparison_Exp>;
  PerformanceParameter?: InputMaybe<PerformanceParameter_Bool_Exp>;
  PerformanceParameterId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  ScoreType?: InputMaybe<ScoreType_Bool_Exp>;
  ScoreTypeId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  Type?: InputMaybe<String_Mssql_Comparison_Exp>;
  VehicleModel?: InputMaybe<String_Mssql_Comparison_Exp>;
  Weight?: InputMaybe<Float_Mssql_Comparison_Exp>;
  WeightedBy?: InputMaybe<String_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<ScoreParameter_Bool_Exp>>;
  _not?: InputMaybe<ScoreParameter_Bool_Exp>;
  _or?: InputMaybe<Array<ScoreParameter_Bool_Exp>>;
};

/** upsert condition type for table "ScoreParameter" */
export type ScoreParameter_If_Matched = {
  match_columns?: Array<ScoreParameter_Insert_Match_Column>;
  update_columns?: Array<ScoreParameter_Update_Column>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "ScoreParameter" */
export type ScoreParameter_Inc_Input = {
  AboveRangeReplacementValue?: InputMaybe<Scalars['Float']['input']>;
  BelowRangeReplacementValue?: InputMaybe<Scalars['Float']['input']>;
  ExponentFactor?: InputMaybe<Scalars['Float']['input']>;
  MaxValue?: InputMaybe<Scalars['Float']['input']>;
  MaxValueToApplyParameter?: InputMaybe<Scalars['Float']['input']>;
  MinValue?: InputMaybe<Scalars['Float']['input']>;
  MinValueToApplyParameter?: InputMaybe<Scalars['Float']['input']>;
  PerformanceParameterId?: InputMaybe<Scalars['Int']['input']>;
  ScoreTypeId?: InputMaybe<Scalars['Int']['input']>;
  Weight?: InputMaybe<Scalars['Float']['input']>;
};

/** input type for inserting data into table "ScoreParameter" */
export type ScoreParameter_Insert_Input = {
  AboveRangeReplacementValue?: InputMaybe<Scalars['Float']['input']>;
  BelowRangeReplacementValue?: InputMaybe<Scalars['Float']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  DeletedAt?: InputMaybe<Scalars['datetime']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  ExponentFactor?: InputMaybe<Scalars['Float']['input']>;
  MaxValue?: InputMaybe<Scalars['Float']['input']>;
  MaxValueToApplyParameter?: InputMaybe<Scalars['Float']['input']>;
  MinValue?: InputMaybe<Scalars['Float']['input']>;
  MinValueToApplyParameter?: InputMaybe<Scalars['Float']['input']>;
  ParameterName?: InputMaybe<Scalars['String']['input']>;
  PerformanceParameterId?: InputMaybe<Scalars['Int']['input']>;
  ScoreTypeId?: InputMaybe<Scalars['Int']['input']>;
  Type?: InputMaybe<Scalars['String']['input']>;
  VehicleModel?: InputMaybe<Scalars['String']['input']>;
  Weight?: InputMaybe<Scalars['Float']['input']>;
  WeightedBy?: InputMaybe<Scalars['String']['input']>;
};

/** select match_columns of table "ScoreParameter" */
export enum ScoreParameter_Insert_Match_Column {
  /** column name */
  AboveRangeReplacementValue = 'AboveRangeReplacementValue',
  /** column name */
  BelowRangeReplacementValue = 'BelowRangeReplacementValue',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  DeletedAt = 'DeletedAt',
  /** column name */
  DeletedAtDate = 'DeletedAtDate',
  /** column name */
  Description = 'Description',
  /** column name */
  ExponentFactor = 'ExponentFactor',
  /** column name */
  Id = 'Id',
  /** column name */
  IsDeleted = 'IsDeleted',
  /** column name */
  IsForSpecificVehicleModel = 'IsForSpecificVehicleModel',
  /** column name */
  IsForVolvoVehicles = 'IsForVolvoVehicles',
  /** column name */
  MaxValue = 'MaxValue',
  /** column name */
  MaxValueToApplyParameter = 'MaxValueToApplyParameter',
  /** column name */
  MinValue = 'MinValue',
  /** column name */
  MinValueToApplyParameter = 'MinValueToApplyParameter',
  /** column name */
  ParameterName = 'ParameterName',
  /** column name */
  PerformanceParameterId = 'PerformanceParameterId',
  /** column name */
  ScoreTypeId = 'ScoreTypeId',
  /** column name */
  Type = 'Type',
  /** column name */
  VehicleModel = 'VehicleModel',
  /** column name */
  Weight = 'Weight',
  /** column name */
  WeightedBy = 'WeightedBy'
}

/** aggregate max on columns */
export type ScoreParameter_Max_Fields = {
  __typename?: 'ScoreParameter_max_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  DeletedAt: Maybe<Scalars['datetime']['output']>;
  DeletedAtDate: Maybe<Scalars['date']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsDeleted: Maybe<Scalars['Int']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Int']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Int']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  ParameterName: Maybe<Scalars['String']['output']>;
  PerformanceParameterId: Maybe<Scalars['Int']['output']>;
  ScoreTypeId: Maybe<Scalars['Int']['output']>;
  Type: Maybe<Scalars['String']['output']>;
  VehicleModel: Maybe<Scalars['String']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
  WeightedBy: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "ScoreParameter" */
export type ScoreParameter_Max_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  DeletedAt?: InputMaybe<Order_By>;
  DeletedAtDate?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  ParameterName?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Type?: InputMaybe<Order_By>;
  VehicleModel?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
  WeightedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ScoreParameter_Min_Fields = {
  __typename?: 'ScoreParameter_min_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  DeletedAt: Maybe<Scalars['datetime']['output']>;
  DeletedAtDate: Maybe<Scalars['date']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsDeleted: Maybe<Scalars['Int']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Int']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Int']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  ParameterName: Maybe<Scalars['String']['output']>;
  PerformanceParameterId: Maybe<Scalars['Int']['output']>;
  ScoreTypeId: Maybe<Scalars['Int']['output']>;
  Type: Maybe<Scalars['String']['output']>;
  VehicleModel: Maybe<Scalars['String']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
  WeightedBy: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "ScoreParameter" */
export type ScoreParameter_Min_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  DeletedAt?: InputMaybe<Order_By>;
  DeletedAtDate?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  ParameterName?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Type?: InputMaybe<Order_By>;
  VehicleModel?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
  WeightedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "ScoreParameter" */
export type ScoreParameter_Mutation_Response = {
  __typename?: 'ScoreParameter_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ScoreParameter>;
};

/** Ordering options when selecting data from "ScoreParameter". */
export type ScoreParameter_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  DeletedAt?: InputMaybe<Order_By>;
  DeletedAtDate?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  ParameterName?: InputMaybe<Order_By>;
  PerformanceParameter?: InputMaybe<PerformanceParameter_Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreType?: InputMaybe<ScoreType_Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Type?: InputMaybe<Order_By>;
  VehicleModel?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
  WeightedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: ScoreParameter */
export type ScoreParameter_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "ScoreParameter" */
export enum ScoreParameter_Select_Column {
  /** column name */
  AboveRangeReplacementValue = 'AboveRangeReplacementValue',
  /** column name */
  BelowRangeReplacementValue = 'BelowRangeReplacementValue',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  DeletedAt = 'DeletedAt',
  /** column name */
  DeletedAtDate = 'DeletedAtDate',
  /** column name */
  Description = 'Description',
  /** column name */
  ExponentFactor = 'ExponentFactor',
  /** column name */
  Id = 'Id',
  /** column name */
  IsDeleted = 'IsDeleted',
  /** column name */
  IsForSpecificVehicleModel = 'IsForSpecificVehicleModel',
  /** column name */
  IsForVolvoVehicles = 'IsForVolvoVehicles',
  /** column name */
  MaxValue = 'MaxValue',
  /** column name */
  MaxValueToApplyParameter = 'MaxValueToApplyParameter',
  /** column name */
  MinValue = 'MinValue',
  /** column name */
  MinValueToApplyParameter = 'MinValueToApplyParameter',
  /** column name */
  ParameterName = 'ParameterName',
  /** column name */
  PerformanceParameterId = 'PerformanceParameterId',
  /** column name */
  ScoreTypeId = 'ScoreTypeId',
  /** column name */
  Type = 'Type',
  /** column name */
  VehicleModel = 'VehicleModel',
  /** column name */
  Weight = 'Weight',
  /** column name */
  WeightedBy = 'WeightedBy'
}

/** input type for updating data in table "ScoreParameter" */
export type ScoreParameter_Set_Input = {
  AboveRangeReplacementValue?: InputMaybe<Scalars['Float']['input']>;
  BelowRangeReplacementValue?: InputMaybe<Scalars['Float']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  DeletedAt?: InputMaybe<Scalars['datetime']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  ExponentFactor?: InputMaybe<Scalars['Float']['input']>;
  MaxValue?: InputMaybe<Scalars['Float']['input']>;
  MaxValueToApplyParameter?: InputMaybe<Scalars['Float']['input']>;
  MinValue?: InputMaybe<Scalars['Float']['input']>;
  MinValueToApplyParameter?: InputMaybe<Scalars['Float']['input']>;
  ParameterName?: InputMaybe<Scalars['String']['input']>;
  PerformanceParameterId?: InputMaybe<Scalars['Int']['input']>;
  ScoreTypeId?: InputMaybe<Scalars['Int']['input']>;
  Type?: InputMaybe<Scalars['String']['input']>;
  VehicleModel?: InputMaybe<Scalars['String']['input']>;
  Weight?: InputMaybe<Scalars['Float']['input']>;
  WeightedBy?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type ScoreParameter_Stddev_Fields = {
  __typename?: 'ScoreParameter_stddev_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsDeleted: Maybe<Scalars['Float']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Float']['output']>;
  ScoreTypeId: Maybe<Scalars['Float']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "ScoreParameter" */
export type ScoreParameter_Stddev_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ScoreParameter_Stddev_Pop_Fields = {
  __typename?: 'ScoreParameter_stddev_pop_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsDeleted: Maybe<Scalars['Float']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Float']['output']>;
  ScoreTypeId: Maybe<Scalars['Float']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "ScoreParameter" */
export type ScoreParameter_Stddev_Pop_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ScoreParameter_Stddev_Samp_Fields = {
  __typename?: 'ScoreParameter_stddev_samp_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsDeleted: Maybe<Scalars['Float']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Float']['output']>;
  ScoreTypeId: Maybe<Scalars['Float']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "ScoreParameter" */
export type ScoreParameter_Stddev_Samp_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type ScoreParameter_Sum_Fields = {
  __typename?: 'ScoreParameter_sum_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsDeleted: Maybe<Scalars['Int']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Int']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Int']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Int']['output']>;
  ScoreTypeId: Maybe<Scalars['Int']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by sum() on columns of table "ScoreParameter" */
export type ScoreParameter_Sum_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** update columns of table "ScoreParameter" */
export enum ScoreParameter_Update_Column {
  /** column name */
  AboveRangeReplacementValue = 'AboveRangeReplacementValue',
  /** column name */
  BelowRangeReplacementValue = 'BelowRangeReplacementValue',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  DeletedAt = 'DeletedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  ExponentFactor = 'ExponentFactor',
  /** column name */
  MaxValue = 'MaxValue',
  /** column name */
  MaxValueToApplyParameter = 'MaxValueToApplyParameter',
  /** column name */
  MinValue = 'MinValue',
  /** column name */
  MinValueToApplyParameter = 'MinValueToApplyParameter',
  /** column name */
  ParameterName = 'ParameterName',
  /** column name */
  PerformanceParameterId = 'PerformanceParameterId',
  /** column name */
  ScoreTypeId = 'ScoreTypeId',
  /** column name */
  Type = 'Type',
  /** column name */
  VehicleModel = 'VehicleModel',
  /** column name */
  Weight = 'Weight',
  /** column name */
  WeightedBy = 'WeightedBy'
}

/** aggregate var_pop on columns */
export type ScoreParameter_Var_Pop_Fields = {
  __typename?: 'ScoreParameter_var_pop_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsDeleted: Maybe<Scalars['Float']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Float']['output']>;
  ScoreTypeId: Maybe<Scalars['Float']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "ScoreParameter" */
export type ScoreParameter_Var_Pop_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ScoreParameter_Var_Samp_Fields = {
  __typename?: 'ScoreParameter_var_samp_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsDeleted: Maybe<Scalars['Float']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Float']['output']>;
  ScoreTypeId: Maybe<Scalars['Float']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "ScoreParameter" */
export type ScoreParameter_Var_Samp_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type ScoreParameter_Variance_Fields = {
  __typename?: 'ScoreParameter_variance_fields';
  AboveRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  BelowRangeReplacementValue: Maybe<Scalars['Float']['output']>;
  ExponentFactor: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsDeleted: Maybe<Scalars['Float']['output']>;
  IsForSpecificVehicleModel: Maybe<Scalars['Float']['output']>;
  IsForVolvoVehicles: Maybe<Scalars['Float']['output']>;
  MaxValue: Maybe<Scalars['Float']['output']>;
  MaxValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  MinValue: Maybe<Scalars['Float']['output']>;
  MinValueToApplyParameter: Maybe<Scalars['Float']['output']>;
  PerformanceParameterId: Maybe<Scalars['Float']['output']>;
  ScoreTypeId: Maybe<Scalars['Float']['output']>;
  Weight: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "ScoreParameter" */
export type ScoreParameter_Variance_Order_By = {
  AboveRangeReplacementValue?: InputMaybe<Order_By>;
  BelowRangeReplacementValue?: InputMaybe<Order_By>;
  ExponentFactor?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsDeleted?: InputMaybe<Order_By>;
  IsForSpecificVehicleModel?: InputMaybe<Order_By>;
  IsForVolvoVehicles?: InputMaybe<Order_By>;
  MaxValue?: InputMaybe<Order_By>;
  MaxValueToApplyParameter?: InputMaybe<Order_By>;
  MinValue?: InputMaybe<Order_By>;
  MinValueToApplyParameter?: InputMaybe<Order_By>;
  PerformanceParameterId?: InputMaybe<Order_By>;
  ScoreTypeId?: InputMaybe<Order_By>;
  Weight?: InputMaybe<Order_By>;
};

/** columns and relationships of "ScoreType" */
export type ScoreType = {
  __typename?: 'ScoreType';
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Scalars['Int']['output'];
  Name: Scalars['String']['output'];
  /** An array relationship */
  ScoreParameters: Array<ScoreParameter>;
  /** An aggregate relationship */
  ScoreParameters_aggregate: ScoreParameter_Aggregate;
};


/** columns and relationships of "ScoreType" */
export type ScoreTypeScoreParametersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};


/** columns and relationships of "ScoreType" */
export type ScoreTypeScoreParameters_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};

/** aggregated selection of "ScoreType" */
export type ScoreType_Aggregate = {
  __typename?: 'ScoreType_aggregate';
  aggregate: Maybe<ScoreType_Aggregate_Fields>;
  nodes: Array<ScoreType>;
};

/** aggregate fields of "ScoreType" */
export type ScoreType_Aggregate_Fields = {
  __typename?: 'ScoreType_aggregate_fields';
  avg: Maybe<ScoreType_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<ScoreType_Max_Fields>;
  min: Maybe<ScoreType_Min_Fields>;
  stddev: Maybe<ScoreType_Stddev_Fields>;
  stddev_pop: Maybe<ScoreType_Stddev_Pop_Fields>;
  stddev_samp: Maybe<ScoreType_Stddev_Samp_Fields>;
  sum: Maybe<ScoreType_Sum_Fields>;
  var_pop: Maybe<ScoreType_Var_Pop_Fields>;
  var_samp: Maybe<ScoreType_Var_Samp_Fields>;
  variance: Maybe<ScoreType_Variance_Fields>;
};


/** aggregate fields of "ScoreType" */
export type ScoreType_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<ScoreType_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ScoreType_Avg_Fields = {
  __typename?: 'ScoreType_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "ScoreType". All fields are combined with a logical 'AND'. */
export type ScoreType_Bool_Exp = {
  CreatedAt?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  Description?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  Name?: InputMaybe<String_Mssql_Comparison_Exp>;
  ScoreParameters?: InputMaybe<ScoreParameter_Bool_Exp>;
  _and?: InputMaybe<Array<ScoreType_Bool_Exp>>;
  _not?: InputMaybe<ScoreType_Bool_Exp>;
  _or?: InputMaybe<Array<ScoreType_Bool_Exp>>;
};

/** upsert condition type for table "ScoreType" */
export type ScoreType_If_Matched = {
  match_columns?: Array<ScoreType_Insert_Match_Column>;
  update_columns?: Array<ScoreType_Update_Column>;
  where?: InputMaybe<ScoreType_Bool_Exp>;
};

/** input type for inserting data into table "ScoreType" */
export type ScoreType_Insert_Input = {
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  Name?: InputMaybe<Scalars['String']['input']>;
};

/** select match_columns of table "ScoreType" */
export enum ScoreType_Insert_Match_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  Name = 'Name'
}

/** aggregate max on columns */
export type ScoreType_Max_Fields = {
  __typename?: 'ScoreType_max_fields';
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  Name: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type ScoreType_Min_Fields = {
  __typename?: 'ScoreType_min_fields';
  CreatedAt: Maybe<Scalars['datetime']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  Name: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "ScoreType" */
export type ScoreType_Mutation_Response = {
  __typename?: 'ScoreType_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ScoreType>;
};

/** Ordering options when selecting data from "ScoreType". */
export type ScoreType_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  Name?: InputMaybe<Order_By>;
  ScoreParameters_aggregate?: InputMaybe<ScoreParameter_Aggregate_Order_By>;
};

/** primary key columns input for table: ScoreType */
export type ScoreType_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "ScoreType" */
export enum ScoreType_Select_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  Name = 'Name'
}

/** input type for updating data in table "ScoreType" */
export type ScoreType_Set_Input = {
  CreatedAt?: InputMaybe<Scalars['datetime']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  Name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type ScoreType_Stddev_Fields = {
  __typename?: 'ScoreType_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ScoreType_Stddev_Pop_Fields = {
  __typename?: 'ScoreType_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ScoreType_Stddev_Samp_Fields = {
  __typename?: 'ScoreType_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type ScoreType_Sum_Fields = {
  __typename?: 'ScoreType_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "ScoreType" */
export enum ScoreType_Update_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Name = 'Name'
}

/** aggregate var_pop on columns */
export type ScoreType_Var_Pop_Fields = {
  __typename?: 'ScoreType_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ScoreType_Var_Samp_Fields = {
  __typename?: 'ScoreType_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ScoreType_Variance_Fields = {
  __typename?: 'ScoreType_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

export type SigninOutput = {
  __typename?: 'SigninOutput';
  refresh_token: Scalars['String']['output'];
  token: Scalars['String']['output'];
  user: Maybe<User>;
  user_uuid: Scalars['uuid']['output'];
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "SuntechEquipamento" */
export type SuntechEquipamento = {
  __typename?: 'SuntechEquipamento';
  Obs: Maybe<Scalars['String']['output']>;
  PLACA_PROTHEUS: Maybe<Scalars['String']['output']>;
  SerialCompleto: Maybe<Scalars['String']['output']>;
  arquivoAcaoEmbarcada: Maybe<Scalars['String']['output']>;
  chip_ddd: Maybe<Scalars['String']['output']>;
  chip_numero: Maybe<Scalars['String']['output']>;
  chip_operadora: Maybe<Scalars['String']['output']>;
  chip_pin: Maybe<Scalars['String']['output']>;
  chip_pin2: Maybe<Scalars['String']['output']>;
  chip_puk1: Maybe<Scalars['String']['output']>;
  chip_puk2: Maybe<Scalars['String']['output']>;
  codbarras: Maybe<Scalars['String']['output']>;
  codseguranca: Maybe<Scalars['String']['output']>;
  dadoLivreAtivo: Maybe<Scalars['Boolean']['output']>;
  dtUltimoPacoteSetup: Maybe<Scalars['datetime']['output']>;
  esn: Maybe<Scalars['String']['output']>;
  firmware: Maybe<Scalars['String']['output']>;
  gatewayIP1: Maybe<Scalars['String']['output']>;
  gatewayIP2: Maybe<Scalars['String']['output']>;
  gatewayIP3: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  idCliente: Maybe<Scalars['String']['output']>;
  modelo: Maybe<Scalars['String']['output']>;
  placa: Maybe<Scalars['String']['output']>;
  protocol: Scalars['String']['output'];
  segurancaSaidas: Maybe<Scalars['String']['output']>;
  serial: Scalars['String']['output'];
  situacao: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "SuntechEquipamento" */
export type SuntechEquipamento_Aggregate = {
  __typename?: 'SuntechEquipamento_aggregate';
  aggregate: Maybe<SuntechEquipamento_Aggregate_Fields>;
  nodes: Array<SuntechEquipamento>;
};

/** aggregate fields of "SuntechEquipamento" */
export type SuntechEquipamento_Aggregate_Fields = {
  __typename?: 'SuntechEquipamento_aggregate_fields';
  avg: Maybe<SuntechEquipamento_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<SuntechEquipamento_Max_Fields>;
  min: Maybe<SuntechEquipamento_Min_Fields>;
  stddev: Maybe<SuntechEquipamento_Stddev_Fields>;
  stddev_pop: Maybe<SuntechEquipamento_Stddev_Pop_Fields>;
  stddev_samp: Maybe<SuntechEquipamento_Stddev_Samp_Fields>;
  sum: Maybe<SuntechEquipamento_Sum_Fields>;
  var_pop: Maybe<SuntechEquipamento_Var_Pop_Fields>;
  var_samp: Maybe<SuntechEquipamento_Var_Samp_Fields>;
  variance: Maybe<SuntechEquipamento_Variance_Fields>;
};


/** aggregate fields of "SuntechEquipamento" */
export type SuntechEquipamento_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<SuntechEquipamento_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type SuntechEquipamento_Avg_Fields = {
  __typename?: 'SuntechEquipamento_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "SuntechEquipamento". All fields are combined with a logical 'AND'. */
export type SuntechEquipamento_Bool_Exp = {
  Obs?: InputMaybe<String_Mssql_Comparison_Exp>;
  PLACA_PROTHEUS?: InputMaybe<String_Mssql_Comparison_Exp>;
  SerialCompleto?: InputMaybe<String_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<SuntechEquipamento_Bool_Exp>>;
  _not?: InputMaybe<SuntechEquipamento_Bool_Exp>;
  _or?: InputMaybe<Array<SuntechEquipamento_Bool_Exp>>;
  arquivoAcaoEmbarcada?: InputMaybe<String_Mssql_Comparison_Exp>;
  chip_ddd?: InputMaybe<String_Mssql_Comparison_Exp>;
  chip_numero?: InputMaybe<String_Mssql_Comparison_Exp>;
  chip_operadora?: InputMaybe<String_Mssql_Comparison_Exp>;
  chip_pin?: InputMaybe<String_Mssql_Comparison_Exp>;
  chip_pin2?: InputMaybe<String_Mssql_Comparison_Exp>;
  chip_puk1?: InputMaybe<String_Mssql_Comparison_Exp>;
  chip_puk2?: InputMaybe<String_Mssql_Comparison_Exp>;
  codbarras?: InputMaybe<String_Mssql_Comparison_Exp>;
  codseguranca?: InputMaybe<String_Mssql_Comparison_Exp>;
  dadoLivreAtivo?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  dtUltimoPacoteSetup?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  esn?: InputMaybe<String_Mssql_Comparison_Exp>;
  firmware?: InputMaybe<String_Mssql_Comparison_Exp>;
  gatewayIP1?: InputMaybe<String_Mssql_Comparison_Exp>;
  gatewayIP2?: InputMaybe<String_Mssql_Comparison_Exp>;
  gatewayIP3?: InputMaybe<String_Mssql_Comparison_Exp>;
  id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  idCliente?: InputMaybe<String_Mssql_Comparison_Exp>;
  modelo?: InputMaybe<String_Mssql_Comparison_Exp>;
  placa?: InputMaybe<String_Mssql_Comparison_Exp>;
  protocol?: InputMaybe<String_Mssql_Comparison_Exp>;
  segurancaSaidas?: InputMaybe<String_Mssql_Comparison_Exp>;
  serial?: InputMaybe<String_Mssql_Comparison_Exp>;
  situacao?: InputMaybe<String_Mssql_Comparison_Exp>;
};

/** upsert condition type for table "SuntechEquipamento" */
export type SuntechEquipamento_If_Matched = {
  match_columns?: Array<SuntechEquipamento_Insert_Match_Column>;
  update_columns?: Array<SuntechEquipamento_Update_Column>;
  where?: InputMaybe<SuntechEquipamento_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "SuntechEquipamento" */
export type SuntechEquipamento_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "SuntechEquipamento" */
export type SuntechEquipamento_Insert_Input = {
  Obs?: InputMaybe<Scalars['String']['input']>;
  PLACA_PROTHEUS?: InputMaybe<Scalars['String']['input']>;
  SerialCompleto?: InputMaybe<Scalars['String']['input']>;
  arquivoAcaoEmbarcada?: InputMaybe<Scalars['String']['input']>;
  chip_ddd?: InputMaybe<Scalars['String']['input']>;
  chip_numero?: InputMaybe<Scalars['String']['input']>;
  chip_operadora?: InputMaybe<Scalars['String']['input']>;
  chip_pin?: InputMaybe<Scalars['String']['input']>;
  chip_pin2?: InputMaybe<Scalars['String']['input']>;
  chip_puk1?: InputMaybe<Scalars['String']['input']>;
  chip_puk2?: InputMaybe<Scalars['String']['input']>;
  codbarras?: InputMaybe<Scalars['String']['input']>;
  codseguranca?: InputMaybe<Scalars['String']['input']>;
  dadoLivreAtivo?: InputMaybe<Scalars['Boolean']['input']>;
  dtUltimoPacoteSetup?: InputMaybe<Scalars['datetime']['input']>;
  esn?: InputMaybe<Scalars['String']['input']>;
  firmware?: InputMaybe<Scalars['String']['input']>;
  gatewayIP1?: InputMaybe<Scalars['String']['input']>;
  gatewayIP2?: InputMaybe<Scalars['String']['input']>;
  gatewayIP3?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  idCliente?: InputMaybe<Scalars['String']['input']>;
  modelo?: InputMaybe<Scalars['String']['input']>;
  placa?: InputMaybe<Scalars['String']['input']>;
  protocol?: InputMaybe<Scalars['String']['input']>;
  segurancaSaidas?: InputMaybe<Scalars['String']['input']>;
  serial?: InputMaybe<Scalars['String']['input']>;
  situacao?: InputMaybe<Scalars['String']['input']>;
};

/** select match_columns of table "SuntechEquipamento" */
export enum SuntechEquipamento_Insert_Match_Column {
  /** column name */
  Obs = 'Obs',
  /** column name */
  PlacaProtheus = 'PLACA_PROTHEUS',
  /** column name */
  SerialCompleto = 'SerialCompleto',
  /** column name */
  ArquivoAcaoEmbarcada = 'arquivoAcaoEmbarcada',
  /** column name */
  ChipDdd = 'chip_ddd',
  /** column name */
  ChipNumero = 'chip_numero',
  /** column name */
  ChipOperadora = 'chip_operadora',
  /** column name */
  ChipPin = 'chip_pin',
  /** column name */
  ChipPin2 = 'chip_pin2',
  /** column name */
  ChipPuk1 = 'chip_puk1',
  /** column name */
  ChipPuk2 = 'chip_puk2',
  /** column name */
  Codbarras = 'codbarras',
  /** column name */
  Codseguranca = 'codseguranca',
  /** column name */
  DadoLivreAtivo = 'dadoLivreAtivo',
  /** column name */
  DtUltimoPacoteSetup = 'dtUltimoPacoteSetup',
  /** column name */
  Esn = 'esn',
  /** column name */
  Firmware = 'firmware',
  /** column name */
  GatewayIp1 = 'gatewayIP1',
  /** column name */
  GatewayIp2 = 'gatewayIP2',
  /** column name */
  GatewayIp3 = 'gatewayIP3',
  /** column name */
  Id = 'id',
  /** column name */
  IdCliente = 'idCliente',
  /** column name */
  Modelo = 'modelo',
  /** column name */
  Placa = 'placa',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  SegurancaSaidas = 'segurancaSaidas',
  /** column name */
  Serial = 'serial',
  /** column name */
  Situacao = 'situacao'
}

/** aggregate max on columns */
export type SuntechEquipamento_Max_Fields = {
  __typename?: 'SuntechEquipamento_max_fields';
  Obs: Maybe<Scalars['String']['output']>;
  PLACA_PROTHEUS: Maybe<Scalars['String']['output']>;
  SerialCompleto: Maybe<Scalars['String']['output']>;
  arquivoAcaoEmbarcada: Maybe<Scalars['String']['output']>;
  chip_ddd: Maybe<Scalars['String']['output']>;
  chip_numero: Maybe<Scalars['String']['output']>;
  chip_operadora: Maybe<Scalars['String']['output']>;
  chip_pin: Maybe<Scalars['String']['output']>;
  chip_pin2: Maybe<Scalars['String']['output']>;
  chip_puk1: Maybe<Scalars['String']['output']>;
  chip_puk2: Maybe<Scalars['String']['output']>;
  codbarras: Maybe<Scalars['String']['output']>;
  codseguranca: Maybe<Scalars['String']['output']>;
  dtUltimoPacoteSetup: Maybe<Scalars['datetime']['output']>;
  esn: Maybe<Scalars['String']['output']>;
  firmware: Maybe<Scalars['String']['output']>;
  gatewayIP1: Maybe<Scalars['String']['output']>;
  gatewayIP2: Maybe<Scalars['String']['output']>;
  gatewayIP3: Maybe<Scalars['String']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  idCliente: Maybe<Scalars['String']['output']>;
  modelo: Maybe<Scalars['String']['output']>;
  placa: Maybe<Scalars['String']['output']>;
  protocol: Maybe<Scalars['String']['output']>;
  segurancaSaidas: Maybe<Scalars['String']['output']>;
  serial: Maybe<Scalars['String']['output']>;
  situacao: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type SuntechEquipamento_Min_Fields = {
  __typename?: 'SuntechEquipamento_min_fields';
  Obs: Maybe<Scalars['String']['output']>;
  PLACA_PROTHEUS: Maybe<Scalars['String']['output']>;
  SerialCompleto: Maybe<Scalars['String']['output']>;
  arquivoAcaoEmbarcada: Maybe<Scalars['String']['output']>;
  chip_ddd: Maybe<Scalars['String']['output']>;
  chip_numero: Maybe<Scalars['String']['output']>;
  chip_operadora: Maybe<Scalars['String']['output']>;
  chip_pin: Maybe<Scalars['String']['output']>;
  chip_pin2: Maybe<Scalars['String']['output']>;
  chip_puk1: Maybe<Scalars['String']['output']>;
  chip_puk2: Maybe<Scalars['String']['output']>;
  codbarras: Maybe<Scalars['String']['output']>;
  codseguranca: Maybe<Scalars['String']['output']>;
  dtUltimoPacoteSetup: Maybe<Scalars['datetime']['output']>;
  esn: Maybe<Scalars['String']['output']>;
  firmware: Maybe<Scalars['String']['output']>;
  gatewayIP1: Maybe<Scalars['String']['output']>;
  gatewayIP2: Maybe<Scalars['String']['output']>;
  gatewayIP3: Maybe<Scalars['String']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  idCliente: Maybe<Scalars['String']['output']>;
  modelo: Maybe<Scalars['String']['output']>;
  placa: Maybe<Scalars['String']['output']>;
  protocol: Maybe<Scalars['String']['output']>;
  segurancaSaidas: Maybe<Scalars['String']['output']>;
  serial: Maybe<Scalars['String']['output']>;
  situacao: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "SuntechEquipamento" */
export type SuntechEquipamento_Mutation_Response = {
  __typename?: 'SuntechEquipamento_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SuntechEquipamento>;
};

/** Ordering options when selecting data from "SuntechEquipamento". */
export type SuntechEquipamento_Order_By = {
  Obs?: InputMaybe<Order_By>;
  PLACA_PROTHEUS?: InputMaybe<Order_By>;
  SerialCompleto?: InputMaybe<Order_By>;
  arquivoAcaoEmbarcada?: InputMaybe<Order_By>;
  chip_ddd?: InputMaybe<Order_By>;
  chip_numero?: InputMaybe<Order_By>;
  chip_operadora?: InputMaybe<Order_By>;
  chip_pin?: InputMaybe<Order_By>;
  chip_pin2?: InputMaybe<Order_By>;
  chip_puk1?: InputMaybe<Order_By>;
  chip_puk2?: InputMaybe<Order_By>;
  codbarras?: InputMaybe<Order_By>;
  codseguranca?: InputMaybe<Order_By>;
  dadoLivreAtivo?: InputMaybe<Order_By>;
  dtUltimoPacoteSetup?: InputMaybe<Order_By>;
  esn?: InputMaybe<Order_By>;
  firmware?: InputMaybe<Order_By>;
  gatewayIP1?: InputMaybe<Order_By>;
  gatewayIP2?: InputMaybe<Order_By>;
  gatewayIP3?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  idCliente?: InputMaybe<Order_By>;
  modelo?: InputMaybe<Order_By>;
  placa?: InputMaybe<Order_By>;
  protocol?: InputMaybe<Order_By>;
  segurancaSaidas?: InputMaybe<Order_By>;
  serial?: InputMaybe<Order_By>;
  situacao?: InputMaybe<Order_By>;
};

/** select columns of table "SuntechEquipamento" */
export enum SuntechEquipamento_Select_Column {
  /** column name */
  Obs = 'Obs',
  /** column name */
  PlacaProtheus = 'PLACA_PROTHEUS',
  /** column name */
  SerialCompleto = 'SerialCompleto',
  /** column name */
  ArquivoAcaoEmbarcada = 'arquivoAcaoEmbarcada',
  /** column name */
  ChipDdd = 'chip_ddd',
  /** column name */
  ChipNumero = 'chip_numero',
  /** column name */
  ChipOperadora = 'chip_operadora',
  /** column name */
  ChipPin = 'chip_pin',
  /** column name */
  ChipPin2 = 'chip_pin2',
  /** column name */
  ChipPuk1 = 'chip_puk1',
  /** column name */
  ChipPuk2 = 'chip_puk2',
  /** column name */
  Codbarras = 'codbarras',
  /** column name */
  Codseguranca = 'codseguranca',
  /** column name */
  DadoLivreAtivo = 'dadoLivreAtivo',
  /** column name */
  DtUltimoPacoteSetup = 'dtUltimoPacoteSetup',
  /** column name */
  Esn = 'esn',
  /** column name */
  Firmware = 'firmware',
  /** column name */
  GatewayIp1 = 'gatewayIP1',
  /** column name */
  GatewayIp2 = 'gatewayIP2',
  /** column name */
  GatewayIp3 = 'gatewayIP3',
  /** column name */
  Id = 'id',
  /** column name */
  IdCliente = 'idCliente',
  /** column name */
  Modelo = 'modelo',
  /** column name */
  Placa = 'placa',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  SegurancaSaidas = 'segurancaSaidas',
  /** column name */
  Serial = 'serial',
  /** column name */
  Situacao = 'situacao'
}

/** input type for updating data in table "SuntechEquipamento" */
export type SuntechEquipamento_Set_Input = {
  Obs?: InputMaybe<Scalars['String']['input']>;
  PLACA_PROTHEUS?: InputMaybe<Scalars['String']['input']>;
  SerialCompleto?: InputMaybe<Scalars['String']['input']>;
  arquivoAcaoEmbarcada?: InputMaybe<Scalars['String']['input']>;
  chip_ddd?: InputMaybe<Scalars['String']['input']>;
  chip_numero?: InputMaybe<Scalars['String']['input']>;
  chip_operadora?: InputMaybe<Scalars['String']['input']>;
  chip_pin?: InputMaybe<Scalars['String']['input']>;
  chip_pin2?: InputMaybe<Scalars['String']['input']>;
  chip_puk1?: InputMaybe<Scalars['String']['input']>;
  chip_puk2?: InputMaybe<Scalars['String']['input']>;
  codbarras?: InputMaybe<Scalars['String']['input']>;
  codseguranca?: InputMaybe<Scalars['String']['input']>;
  dadoLivreAtivo?: InputMaybe<Scalars['Boolean']['input']>;
  dtUltimoPacoteSetup?: InputMaybe<Scalars['datetime']['input']>;
  esn?: InputMaybe<Scalars['String']['input']>;
  firmware?: InputMaybe<Scalars['String']['input']>;
  gatewayIP1?: InputMaybe<Scalars['String']['input']>;
  gatewayIP2?: InputMaybe<Scalars['String']['input']>;
  gatewayIP3?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  idCliente?: InputMaybe<Scalars['String']['input']>;
  modelo?: InputMaybe<Scalars['String']['input']>;
  placa?: InputMaybe<Scalars['String']['input']>;
  protocol?: InputMaybe<Scalars['String']['input']>;
  segurancaSaidas?: InputMaybe<Scalars['String']['input']>;
  serial?: InputMaybe<Scalars['String']['input']>;
  situacao?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type SuntechEquipamento_Stddev_Fields = {
  __typename?: 'SuntechEquipamento_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type SuntechEquipamento_Stddev_Pop_Fields = {
  __typename?: 'SuntechEquipamento_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type SuntechEquipamento_Stddev_Samp_Fields = {
  __typename?: 'SuntechEquipamento_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type SuntechEquipamento_Sum_Fields = {
  __typename?: 'SuntechEquipamento_sum_fields';
  id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "SuntechEquipamento" */
export enum SuntechEquipamento_Update_Column {
  /** column name */
  Obs = 'Obs',
  /** column name */
  PlacaProtheus = 'PLACA_PROTHEUS',
  /** column name */
  SerialCompleto = 'SerialCompleto',
  /** column name */
  ArquivoAcaoEmbarcada = 'arquivoAcaoEmbarcada',
  /** column name */
  ChipDdd = 'chip_ddd',
  /** column name */
  ChipNumero = 'chip_numero',
  /** column name */
  ChipOperadora = 'chip_operadora',
  /** column name */
  ChipPin = 'chip_pin',
  /** column name */
  ChipPin2 = 'chip_pin2',
  /** column name */
  ChipPuk1 = 'chip_puk1',
  /** column name */
  ChipPuk2 = 'chip_puk2',
  /** column name */
  Codbarras = 'codbarras',
  /** column name */
  Codseguranca = 'codseguranca',
  /** column name */
  DadoLivreAtivo = 'dadoLivreAtivo',
  /** column name */
  DtUltimoPacoteSetup = 'dtUltimoPacoteSetup',
  /** column name */
  Esn = 'esn',
  /** column name */
  Firmware = 'firmware',
  /** column name */
  GatewayIp1 = 'gatewayIP1',
  /** column name */
  GatewayIp2 = 'gatewayIP2',
  /** column name */
  GatewayIp3 = 'gatewayIP3',
  /** column name */
  Id = 'id',
  /** column name */
  IdCliente = 'idCliente',
  /** column name */
  Modelo = 'modelo',
  /** column name */
  Placa = 'placa',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  SegurancaSaidas = 'segurancaSaidas',
  /** column name */
  Serial = 'serial',
  /** column name */
  Situacao = 'situacao'
}

/** aggregate var_pop on columns */
export type SuntechEquipamento_Var_Pop_Fields = {
  __typename?: 'SuntechEquipamento_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type SuntechEquipamento_Var_Samp_Fields = {
  __typename?: 'SuntechEquipamento_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SuntechEquipamento_Variance_Fields = {
  __typename?: 'SuntechEquipamento_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand = {
  __typename?: 'SuntechTrackerBatchCommand';
  CreatedAt: Scalars['datetimeoffset']['output'];
  Description: Scalars['String']['output'];
  FileContent: Scalars['String']['output'];
  Filename: Scalars['String']['output'];
  Id: Scalars['Int']['output'];
  /** An array relationship */
  SuntechTrackerBatchCommandDevices: Array<SuntechTrackerBatchCommandDevice>;
  /** An aggregate relationship */
  SuntechTrackerBatchCommandDevices_aggregate: SuntechTrackerBatchCommandDevice_Aggregate;
  UpdatedAt: Scalars['datetimeoffset']['output'];
};


/** columns and relationships of "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommandSuntechTrackerBatchCommandDevicesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
};


/** columns and relationships of "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommandSuntechTrackerBatchCommandDevices_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
};

/** columns and relationships of "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice = {
  __typename?: 'SuntechTrackerBatchCommandDevice';
  CreatedAt: Scalars['datetimeoffset']['output'];
  Id: Scalars['Int']['output'];
  IdEquipment: Scalars['Int']['output'];
  /** An object relationship */
  SuntechTrackerBatchCommand: SuntechTrackerBatchCommand;
  SuntechTrackerBatchCommandId: Scalars['Int']['output'];
  /** An array relationship */
  SuntechTrackerCommands: Array<SuntechTrackerCommand>;
  /** An aggregate relationship */
  SuntechTrackerCommands_aggregate: SuntechTrackerCommand_Aggregate;
  TrackerSerialNumber: Scalars['String']['output'];
  UpdatedAt: Scalars['datetimeoffset']['output'];
};


/** columns and relationships of "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDeviceSuntechTrackerCommandsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
};


/** columns and relationships of "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDeviceSuntechTrackerCommands_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
};

/** aggregated selection of "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Aggregate = {
  __typename?: 'SuntechTrackerBatchCommandDevice_aggregate';
  aggregate: Maybe<SuntechTrackerBatchCommandDevice_Aggregate_Fields>;
  nodes: Array<SuntechTrackerBatchCommandDevice>;
};

/** aggregate fields of "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Aggregate_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_aggregate_fields';
  avg: Maybe<SuntechTrackerBatchCommandDevice_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<SuntechTrackerBatchCommandDevice_Max_Fields>;
  min: Maybe<SuntechTrackerBatchCommandDevice_Min_Fields>;
  stddev: Maybe<SuntechTrackerBatchCommandDevice_Stddev_Fields>;
  stddev_pop: Maybe<SuntechTrackerBatchCommandDevice_Stddev_Pop_Fields>;
  stddev_samp: Maybe<SuntechTrackerBatchCommandDevice_Stddev_Samp_Fields>;
  sum: Maybe<SuntechTrackerBatchCommandDevice_Sum_Fields>;
  var_pop: Maybe<SuntechTrackerBatchCommandDevice_Var_Pop_Fields>;
  var_samp: Maybe<SuntechTrackerBatchCommandDevice_Var_Samp_Fields>;
  variance: Maybe<SuntechTrackerBatchCommandDevice_Variance_Fields>;
};


/** aggregate fields of "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<SuntechTrackerBatchCommandDevice_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Aggregate_Order_By = {
  avg?: InputMaybe<SuntechTrackerBatchCommandDevice_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SuntechTrackerBatchCommandDevice_Max_Order_By>;
  min?: InputMaybe<SuntechTrackerBatchCommandDevice_Min_Order_By>;
  stddev?: InputMaybe<SuntechTrackerBatchCommandDevice_Stddev_Order_By>;
  stddev_pop?: InputMaybe<SuntechTrackerBatchCommandDevice_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<SuntechTrackerBatchCommandDevice_Stddev_Samp_Order_By>;
  sum?: InputMaybe<SuntechTrackerBatchCommandDevice_Sum_Order_By>;
  var_pop?: InputMaybe<SuntechTrackerBatchCommandDevice_Var_Pop_Order_By>;
  var_samp?: InputMaybe<SuntechTrackerBatchCommandDevice_Var_Samp_Order_By>;
  variance?: InputMaybe<SuntechTrackerBatchCommandDevice_Variance_Order_By>;
};

/** aggregate avg on columns */
export type SuntechTrackerBatchCommandDevice_Avg_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Avg_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "SuntechTrackerBatchCommandDevice". All fields are combined with a logical 'AND'. */
export type SuntechTrackerBatchCommandDevice_Bool_Exp = {
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IdEquipment?: InputMaybe<Int_Mssql_Comparison_Exp>;
  SuntechTrackerBatchCommand?: InputMaybe<SuntechTrackerBatchCommand_Bool_Exp>;
  SuntechTrackerBatchCommandId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  SuntechTrackerCommands?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
  TrackerSerialNumber?: InputMaybe<String_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Bool_Exp>>;
  _not?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
  _or?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Bool_Exp>>;
};

/** upsert condition type for table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_If_Matched = {
  match_columns?: Array<SuntechTrackerBatchCommandDevice_Insert_Match_Column>;
  update_columns?: Array<SuntechTrackerBatchCommandDevice_Update_Column>;
  where?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Inc_Input = {
  IdEquipment?: InputMaybe<Scalars['Int']['input']>;
  SuntechTrackerBatchCommandId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Insert_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  IdEquipment?: InputMaybe<Scalars['Int']['input']>;
  SuntechTrackerBatchCommandId?: InputMaybe<Scalars['Int']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** select match_columns of table "SuntechTrackerBatchCommandDevice" */
export enum SuntechTrackerBatchCommandDevice_Insert_Match_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Id = 'Id',
  /** column name */
  IdEquipment = 'IdEquipment',
  /** column name */
  SuntechTrackerBatchCommandId = 'SuntechTrackerBatchCommandId',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate max on columns */
export type SuntechTrackerBatchCommandDevice_Max_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_max_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IdEquipment: Maybe<Scalars['Int']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Int']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** order by max() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Max_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SuntechTrackerBatchCommandDevice_Min_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_min_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IdEquipment: Maybe<Scalars['Int']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Int']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** order by min() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Min_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Mutation_Response = {
  __typename?: 'SuntechTrackerBatchCommandDevice_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SuntechTrackerBatchCommandDevice>;
};

/** Ordering options when selecting data from "SuntechTrackerBatchCommandDevice". */
export type SuntechTrackerBatchCommandDevice_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommand?: InputMaybe<SuntechTrackerBatchCommand_Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
  SuntechTrackerCommands_aggregate?: InputMaybe<SuntechTrackerCommand_Aggregate_Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: SuntechTrackerBatchCommandDevice */
export type SuntechTrackerBatchCommandDevice_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "SuntechTrackerBatchCommandDevice" */
export enum SuntechTrackerBatchCommandDevice_Select_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Id = 'Id',
  /** column name */
  IdEquipment = 'IdEquipment',
  /** column name */
  SuntechTrackerBatchCommandId = 'SuntechTrackerBatchCommandId',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** input type for updating data in table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Set_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  IdEquipment?: InputMaybe<Scalars['Int']['input']>;
  SuntechTrackerBatchCommandId?: InputMaybe<Scalars['Int']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** aggregate stddev on columns */
export type SuntechTrackerBatchCommandDevice_Stddev_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Stddev_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type SuntechTrackerBatchCommandDevice_Stddev_Pop_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Stddev_Pop_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type SuntechTrackerBatchCommandDevice_Stddev_Samp_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Stddev_Samp_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type SuntechTrackerBatchCommandDevice_Sum_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
  IdEquipment: Maybe<Scalars['Int']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Sum_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** update columns of table "SuntechTrackerBatchCommandDevice" */
export enum SuntechTrackerBatchCommandDevice_Update_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  IdEquipment = 'IdEquipment',
  /** column name */
  SuntechTrackerBatchCommandId = 'SuntechTrackerBatchCommandId',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate var_pop on columns */
export type SuntechTrackerBatchCommandDevice_Var_Pop_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Var_Pop_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type SuntechTrackerBatchCommandDevice_Var_Samp_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Var_Samp_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type SuntechTrackerBatchCommandDevice_Variance_Fields = {
  __typename?: 'SuntechTrackerBatchCommandDevice_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "SuntechTrackerBatchCommandDevice" */
export type SuntechTrackerBatchCommandDevice_Variance_Order_By = {
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** columns and relationships of "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset = {
  __typename?: 'SuntechTrackerBatchCommandPreset';
  Content: Scalars['String']['output'];
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Scalars['String']['output'];
  Id: Scalars['Int']['output'];
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** aggregated selection of "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset_Aggregate = {
  __typename?: 'SuntechTrackerBatchCommandPreset_aggregate';
  aggregate: Maybe<SuntechTrackerBatchCommandPreset_Aggregate_Fields>;
  nodes: Array<SuntechTrackerBatchCommandPreset>;
};

/** aggregate fields of "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset_Aggregate_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_aggregate_fields';
  avg: Maybe<SuntechTrackerBatchCommandPreset_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<SuntechTrackerBatchCommandPreset_Max_Fields>;
  min: Maybe<SuntechTrackerBatchCommandPreset_Min_Fields>;
  stddev: Maybe<SuntechTrackerBatchCommandPreset_Stddev_Fields>;
  stddev_pop: Maybe<SuntechTrackerBatchCommandPreset_Stddev_Pop_Fields>;
  stddev_samp: Maybe<SuntechTrackerBatchCommandPreset_Stddev_Samp_Fields>;
  sum: Maybe<SuntechTrackerBatchCommandPreset_Sum_Fields>;
  var_pop: Maybe<SuntechTrackerBatchCommandPreset_Var_Pop_Fields>;
  var_samp: Maybe<SuntechTrackerBatchCommandPreset_Var_Samp_Fields>;
  variance: Maybe<SuntechTrackerBatchCommandPreset_Variance_Fields>;
};


/** aggregate fields of "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<SuntechTrackerBatchCommandPreset_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type SuntechTrackerBatchCommandPreset_Avg_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "SuntechTrackerBatchCommandPreset". All fields are combined with a logical 'AND'. */
export type SuntechTrackerBatchCommandPreset_Bool_Exp = {
  Content?: InputMaybe<String_Mssql_Comparison_Exp>;
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Description?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<SuntechTrackerBatchCommandPreset_Bool_Exp>>;
  _not?: InputMaybe<SuntechTrackerBatchCommandPreset_Bool_Exp>;
  _or?: InputMaybe<Array<SuntechTrackerBatchCommandPreset_Bool_Exp>>;
};

/** upsert condition type for table "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset_If_Matched = {
  match_columns?: Array<SuntechTrackerBatchCommandPreset_Insert_Match_Column>;
  update_columns?: Array<SuntechTrackerBatchCommandPreset_Update_Column>;
  where?: InputMaybe<SuntechTrackerBatchCommandPreset_Bool_Exp>;
};

/** input type for inserting data into table "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset_Insert_Input = {
  Content?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** select match_columns of table "SuntechTrackerBatchCommandPreset" */
export enum SuntechTrackerBatchCommandPreset_Insert_Match_Column {
  /** column name */
  Content = 'Content',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate max on columns */
export type SuntechTrackerBatchCommandPreset_Max_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_max_fields';
  Content: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** aggregate min on columns */
export type SuntechTrackerBatchCommandPreset_Min_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_min_fields';
  Content: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** response of any mutation on the table "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset_Mutation_Response = {
  __typename?: 'SuntechTrackerBatchCommandPreset_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SuntechTrackerBatchCommandPreset>;
};

/** Ordering options when selecting data from "SuntechTrackerBatchCommandPreset". */
export type SuntechTrackerBatchCommandPreset_Order_By = {
  Content?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: SuntechTrackerBatchCommandPreset */
export type SuntechTrackerBatchCommandPreset_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "SuntechTrackerBatchCommandPreset" */
export enum SuntechTrackerBatchCommandPreset_Select_Column {
  /** column name */
  Content = 'Content',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** input type for updating data in table "SuntechTrackerBatchCommandPreset" */
export type SuntechTrackerBatchCommandPreset_Set_Input = {
  Content?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** aggregate stddev on columns */
export type SuntechTrackerBatchCommandPreset_Stddev_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type SuntechTrackerBatchCommandPreset_Stddev_Pop_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type SuntechTrackerBatchCommandPreset_Stddev_Samp_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type SuntechTrackerBatchCommandPreset_Sum_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "SuntechTrackerBatchCommandPreset" */
export enum SuntechTrackerBatchCommandPreset_Update_Column {
  /** column name */
  Content = 'Content',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate var_pop on columns */
export type SuntechTrackerBatchCommandPreset_Var_Pop_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type SuntechTrackerBatchCommandPreset_Var_Samp_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SuntechTrackerBatchCommandPreset_Variance_Fields = {
  __typename?: 'SuntechTrackerBatchCommandPreset_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregated selection of "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand_Aggregate = {
  __typename?: 'SuntechTrackerBatchCommand_aggregate';
  aggregate: Maybe<SuntechTrackerBatchCommand_Aggregate_Fields>;
  nodes: Array<SuntechTrackerBatchCommand>;
};

/** aggregate fields of "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand_Aggregate_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_aggregate_fields';
  avg: Maybe<SuntechTrackerBatchCommand_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<SuntechTrackerBatchCommand_Max_Fields>;
  min: Maybe<SuntechTrackerBatchCommand_Min_Fields>;
  stddev: Maybe<SuntechTrackerBatchCommand_Stddev_Fields>;
  stddev_pop: Maybe<SuntechTrackerBatchCommand_Stddev_Pop_Fields>;
  stddev_samp: Maybe<SuntechTrackerBatchCommand_Stddev_Samp_Fields>;
  sum: Maybe<SuntechTrackerBatchCommand_Sum_Fields>;
  var_pop: Maybe<SuntechTrackerBatchCommand_Var_Pop_Fields>;
  var_samp: Maybe<SuntechTrackerBatchCommand_Var_Samp_Fields>;
  variance: Maybe<SuntechTrackerBatchCommand_Variance_Fields>;
};


/** aggregate fields of "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<SuntechTrackerBatchCommand_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type SuntechTrackerBatchCommand_Avg_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "SuntechTrackerBatchCommand". All fields are combined with a logical 'AND'. */
export type SuntechTrackerBatchCommand_Bool_Exp = {
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Description?: InputMaybe<String_Mssql_Comparison_Exp>;
  FileContent?: InputMaybe<String_Mssql_Comparison_Exp>;
  Filename?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  SuntechTrackerBatchCommandDevices?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<SuntechTrackerBatchCommand_Bool_Exp>>;
  _not?: InputMaybe<SuntechTrackerBatchCommand_Bool_Exp>;
  _or?: InputMaybe<Array<SuntechTrackerBatchCommand_Bool_Exp>>;
};

/** upsert condition type for table "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand_If_Matched = {
  match_columns?: Array<SuntechTrackerBatchCommand_Insert_Match_Column>;
  update_columns?: Array<SuntechTrackerBatchCommand_Update_Column>;
  where?: InputMaybe<SuntechTrackerBatchCommand_Bool_Exp>;
};

/** input type for inserting data into table "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand_Insert_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  FileContent?: InputMaybe<Scalars['String']['input']>;
  Filename?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** select match_columns of table "SuntechTrackerBatchCommand" */
export enum SuntechTrackerBatchCommand_Insert_Match_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  FileContent = 'FileContent',
  /** column name */
  Filename = 'Filename',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate max on columns */
export type SuntechTrackerBatchCommand_Max_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_max_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  FileContent: Maybe<Scalars['String']['output']>;
  Filename: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** aggregate min on columns */
export type SuntechTrackerBatchCommand_Min_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_min_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  FileContent: Maybe<Scalars['String']['output']>;
  Filename: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** response of any mutation on the table "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand_Mutation_Response = {
  __typename?: 'SuntechTrackerBatchCommand_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SuntechTrackerBatchCommand>;
};

/** Ordering options when selecting data from "SuntechTrackerBatchCommand". */
export type SuntechTrackerBatchCommand_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  FileContent?: InputMaybe<Order_By>;
  Filename?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDevices_aggregate?: InputMaybe<SuntechTrackerBatchCommandDevice_Aggregate_Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: SuntechTrackerBatchCommand */
export type SuntechTrackerBatchCommand_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "SuntechTrackerBatchCommand" */
export enum SuntechTrackerBatchCommand_Select_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  FileContent = 'FileContent',
  /** column name */
  Filename = 'Filename',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** input type for updating data in table "SuntechTrackerBatchCommand" */
export type SuntechTrackerBatchCommand_Set_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  FileContent?: InputMaybe<Scalars['String']['input']>;
  Filename?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** aggregate stddev on columns */
export type SuntechTrackerBatchCommand_Stddev_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type SuntechTrackerBatchCommand_Stddev_Pop_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type SuntechTrackerBatchCommand_Stddev_Samp_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type SuntechTrackerBatchCommand_Sum_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "SuntechTrackerBatchCommand" */
export enum SuntechTrackerBatchCommand_Update_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  FileContent = 'FileContent',
  /** column name */
  Filename = 'Filename',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate var_pop on columns */
export type SuntechTrackerBatchCommand_Var_Pop_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type SuntechTrackerBatchCommand_Var_Samp_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SuntechTrackerBatchCommand_Variance_Fields = {
  __typename?: 'SuntechTrackerBatchCommand_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "SuntechTrackerCommand" */
export type SuntechTrackerCommand = {
  __typename?: 'SuntechTrackerCommand';
  AckAt: Maybe<Scalars['datetimeoffset']['output']>;
  AttemptCount: Scalars['Int']['output'];
  CanceledAt: Maybe<Scalars['datetimeoffset']['output']>;
  CommandString: Scalars['String']['output'];
  CreatedAt: Scalars['datetimeoffset']['output'];
  ExternalId: Maybe<Scalars['String']['output']>;
  Id: Scalars['Int']['output'];
  IdEquipment: Scalars['Int']['output'];
  IsCanceled: Scalars['Int']['output'];
  LastAttemptAt: Maybe<Scalars['datetimeoffset']['output']>;
  MaxRetryAttempts: Scalars['Int']['output'];
  ResponseString: Maybe<Scalars['String']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  SentAt: Maybe<Scalars['datetimeoffset']['output']>;
  Status: Scalars['String']['output'];
  /** An object relationship */
  SuntechTrackerBatchCommandDevice: Maybe<SuntechTrackerBatchCommandDevice>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
  TimeoutAt: Maybe<Scalars['datetimeoffset']['output']>;
  TrackerSerialNumber: Scalars['String']['output'];
  UpdatedAt: Scalars['datetimeoffset']['output'];
};

/** aggregated selection of "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Aggregate = {
  __typename?: 'SuntechTrackerCommand_aggregate';
  aggregate: Maybe<SuntechTrackerCommand_Aggregate_Fields>;
  nodes: Array<SuntechTrackerCommand>;
};

/** aggregate fields of "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Aggregate_Fields = {
  __typename?: 'SuntechTrackerCommand_aggregate_fields';
  avg: Maybe<SuntechTrackerCommand_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<SuntechTrackerCommand_Max_Fields>;
  min: Maybe<SuntechTrackerCommand_Min_Fields>;
  stddev: Maybe<SuntechTrackerCommand_Stddev_Fields>;
  stddev_pop: Maybe<SuntechTrackerCommand_Stddev_Pop_Fields>;
  stddev_samp: Maybe<SuntechTrackerCommand_Stddev_Samp_Fields>;
  sum: Maybe<SuntechTrackerCommand_Sum_Fields>;
  var_pop: Maybe<SuntechTrackerCommand_Var_Pop_Fields>;
  var_samp: Maybe<SuntechTrackerCommand_Var_Samp_Fields>;
  variance: Maybe<SuntechTrackerCommand_Variance_Fields>;
};


/** aggregate fields of "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<SuntechTrackerCommand_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Aggregate_Order_By = {
  avg?: InputMaybe<SuntechTrackerCommand_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SuntechTrackerCommand_Max_Order_By>;
  min?: InputMaybe<SuntechTrackerCommand_Min_Order_By>;
  stddev?: InputMaybe<SuntechTrackerCommand_Stddev_Order_By>;
  stddev_pop?: InputMaybe<SuntechTrackerCommand_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<SuntechTrackerCommand_Stddev_Samp_Order_By>;
  sum?: InputMaybe<SuntechTrackerCommand_Sum_Order_By>;
  var_pop?: InputMaybe<SuntechTrackerCommand_Var_Pop_Order_By>;
  var_samp?: InputMaybe<SuntechTrackerCommand_Var_Samp_Order_By>;
  variance?: InputMaybe<SuntechTrackerCommand_Variance_Order_By>;
};

/** aggregate avg on columns */
export type SuntechTrackerCommand_Avg_Fields = {
  __typename?: 'SuntechTrackerCommand_avg_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Avg_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "SuntechTrackerCommand". All fields are combined with a logical 'AND'. */
export type SuntechTrackerCommand_Bool_Exp = {
  AckAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  AttemptCount?: InputMaybe<Int_Mssql_Comparison_Exp>;
  CanceledAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  CommandString?: InputMaybe<String_Mssql_Comparison_Exp>;
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  ExternalId?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IdEquipment?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IsCanceled?: InputMaybe<Int_Mssql_Comparison_Exp>;
  LastAttemptAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  MaxRetryAttempts?: InputMaybe<Int_Mssql_Comparison_Exp>;
  ResponseString?: InputMaybe<String_Mssql_Comparison_Exp>;
  RetryIntervalSeconds?: InputMaybe<Int_Mssql_Comparison_Exp>;
  SentAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Status?: InputMaybe<String_Mssql_Comparison_Exp>;
  SuntechTrackerBatchCommandDevice?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  TimeoutAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  TrackerSerialNumber?: InputMaybe<String_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<SuntechTrackerCommand_Bool_Exp>>;
  _not?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
  _or?: InputMaybe<Array<SuntechTrackerCommand_Bool_Exp>>;
};

/** upsert condition type for table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_If_Matched = {
  match_columns?: Array<SuntechTrackerCommand_Insert_Match_Column>;
  update_columns?: Array<SuntechTrackerCommand_Update_Column>;
  where?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Inc_Input = {
  AttemptCount?: InputMaybe<Scalars['Int']['input']>;
  IdEquipment?: InputMaybe<Scalars['Int']['input']>;
  MaxRetryAttempts?: InputMaybe<Scalars['Int']['input']>;
  RetryIntervalSeconds?: InputMaybe<Scalars['Int']['input']>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Insert_Input = {
  AckAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  AttemptCount?: InputMaybe<Scalars['Int']['input']>;
  CanceledAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  CommandString?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  ExternalId?: InputMaybe<Scalars['String']['input']>;
  IdEquipment?: InputMaybe<Scalars['Int']['input']>;
  LastAttemptAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  MaxRetryAttempts?: InputMaybe<Scalars['Int']['input']>;
  ResponseString?: InputMaybe<Scalars['String']['input']>;
  RetryIntervalSeconds?: InputMaybe<Scalars['Int']['input']>;
  SentAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Scalars['Int']['input']>;
  TimeoutAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** select match_columns of table "SuntechTrackerCommand" */
export enum SuntechTrackerCommand_Insert_Match_Column {
  /** column name */
  AckAt = 'AckAt',
  /** column name */
  AttemptCount = 'AttemptCount',
  /** column name */
  CanceledAt = 'CanceledAt',
  /** column name */
  CommandString = 'CommandString',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  ExternalId = 'ExternalId',
  /** column name */
  Id = 'Id',
  /** column name */
  IdEquipment = 'IdEquipment',
  /** column name */
  IsCanceled = 'IsCanceled',
  /** column name */
  LastAttemptAt = 'LastAttemptAt',
  /** column name */
  MaxRetryAttempts = 'MaxRetryAttempts',
  /** column name */
  ResponseString = 'ResponseString',
  /** column name */
  RetryIntervalSeconds = 'RetryIntervalSeconds',
  /** column name */
  SentAt = 'SentAt',
  /** column name */
  Status = 'Status',
  /** column name */
  SuntechTrackerBatchCommandDeviceId = 'SuntechTrackerBatchCommandDeviceId',
  /** column name */
  TimeoutAt = 'TimeoutAt',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate max on columns */
export type SuntechTrackerCommand_Max_Fields = {
  __typename?: 'SuntechTrackerCommand_max_fields';
  AckAt: Maybe<Scalars['datetimeoffset']['output']>;
  AttemptCount: Maybe<Scalars['Int']['output']>;
  CanceledAt: Maybe<Scalars['datetimeoffset']['output']>;
  CommandString: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  ExternalId: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IdEquipment: Maybe<Scalars['Int']['output']>;
  IsCanceled: Maybe<Scalars['Int']['output']>;
  LastAttemptAt: Maybe<Scalars['datetimeoffset']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Int']['output']>;
  ResponseString: Maybe<Scalars['String']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  SentAt: Maybe<Scalars['datetimeoffset']['output']>;
  Status: Maybe<Scalars['String']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
  TimeoutAt: Maybe<Scalars['datetimeoffset']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** order by max() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Max_Order_By = {
  AckAt?: InputMaybe<Order_By>;
  AttemptCount?: InputMaybe<Order_By>;
  CanceledAt?: InputMaybe<Order_By>;
  CommandString?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  ExternalId?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  LastAttemptAt?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  ResponseString?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SentAt?: InputMaybe<Order_By>;
  Status?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
  TimeoutAt?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SuntechTrackerCommand_Min_Fields = {
  __typename?: 'SuntechTrackerCommand_min_fields';
  AckAt: Maybe<Scalars['datetimeoffset']['output']>;
  AttemptCount: Maybe<Scalars['Int']['output']>;
  CanceledAt: Maybe<Scalars['datetimeoffset']['output']>;
  CommandString: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  ExternalId: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IdEquipment: Maybe<Scalars['Int']['output']>;
  IsCanceled: Maybe<Scalars['Int']['output']>;
  LastAttemptAt: Maybe<Scalars['datetimeoffset']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Int']['output']>;
  ResponseString: Maybe<Scalars['String']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  SentAt: Maybe<Scalars['datetimeoffset']['output']>;
  Status: Maybe<Scalars['String']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
  TimeoutAt: Maybe<Scalars['datetimeoffset']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** order by min() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Min_Order_By = {
  AckAt?: InputMaybe<Order_By>;
  AttemptCount?: InputMaybe<Order_By>;
  CanceledAt?: InputMaybe<Order_By>;
  CommandString?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  ExternalId?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  LastAttemptAt?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  ResponseString?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SentAt?: InputMaybe<Order_By>;
  Status?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
  TimeoutAt?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Mutation_Response = {
  __typename?: 'SuntechTrackerCommand_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SuntechTrackerCommand>;
};

/** Ordering options when selecting data from "SuntechTrackerCommand". */
export type SuntechTrackerCommand_Order_By = {
  AckAt?: InputMaybe<Order_By>;
  AttemptCount?: InputMaybe<Order_By>;
  CanceledAt?: InputMaybe<Order_By>;
  CommandString?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  ExternalId?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  LastAttemptAt?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  ResponseString?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SentAt?: InputMaybe<Order_By>;
  Status?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDevice?: InputMaybe<SuntechTrackerBatchCommandDevice_Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
  TimeoutAt?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: SuntechTrackerCommand */
export type SuntechTrackerCommand_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "SuntechTrackerCommand" */
export enum SuntechTrackerCommand_Select_Column {
  /** column name */
  AckAt = 'AckAt',
  /** column name */
  AttemptCount = 'AttemptCount',
  /** column name */
  CanceledAt = 'CanceledAt',
  /** column name */
  CommandString = 'CommandString',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  ExternalId = 'ExternalId',
  /** column name */
  Id = 'Id',
  /** column name */
  IdEquipment = 'IdEquipment',
  /** column name */
  IsCanceled = 'IsCanceled',
  /** column name */
  LastAttemptAt = 'LastAttemptAt',
  /** column name */
  MaxRetryAttempts = 'MaxRetryAttempts',
  /** column name */
  ResponseString = 'ResponseString',
  /** column name */
  RetryIntervalSeconds = 'RetryIntervalSeconds',
  /** column name */
  SentAt = 'SentAt',
  /** column name */
  Status = 'Status',
  /** column name */
  SuntechTrackerBatchCommandDeviceId = 'SuntechTrackerBatchCommandDeviceId',
  /** column name */
  TimeoutAt = 'TimeoutAt',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** input type for updating data in table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Set_Input = {
  AckAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  AttemptCount?: InputMaybe<Scalars['Int']['input']>;
  CanceledAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  CommandString?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  ExternalId?: InputMaybe<Scalars['String']['input']>;
  IdEquipment?: InputMaybe<Scalars['Int']['input']>;
  LastAttemptAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  MaxRetryAttempts?: InputMaybe<Scalars['Int']['input']>;
  ResponseString?: InputMaybe<Scalars['String']['input']>;
  RetryIntervalSeconds?: InputMaybe<Scalars['Int']['input']>;
  SentAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Scalars['Int']['input']>;
  TimeoutAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** aggregate stddev on columns */
export type SuntechTrackerCommand_Stddev_Fields = {
  __typename?: 'SuntechTrackerCommand_stddev_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Stddev_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type SuntechTrackerCommand_Stddev_Pop_Fields = {
  __typename?: 'SuntechTrackerCommand_stddev_pop_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Stddev_Pop_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type SuntechTrackerCommand_Stddev_Samp_Fields = {
  __typename?: 'SuntechTrackerCommand_stddev_samp_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Stddev_Samp_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type SuntechTrackerCommand_Sum_Fields = {
  __typename?: 'SuntechTrackerCommand_sum_fields';
  AttemptCount: Maybe<Scalars['Int']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IdEquipment: Maybe<Scalars['Int']['output']>;
  IsCanceled: Maybe<Scalars['Int']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Int']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Sum_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** update columns of table "SuntechTrackerCommand" */
export enum SuntechTrackerCommand_Update_Column {
  /** column name */
  AckAt = 'AckAt',
  /** column name */
  AttemptCount = 'AttemptCount',
  /** column name */
  CanceledAt = 'CanceledAt',
  /** column name */
  CommandString = 'CommandString',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  ExternalId = 'ExternalId',
  /** column name */
  IdEquipment = 'IdEquipment',
  /** column name */
  LastAttemptAt = 'LastAttemptAt',
  /** column name */
  MaxRetryAttempts = 'MaxRetryAttempts',
  /** column name */
  ResponseString = 'ResponseString',
  /** column name */
  RetryIntervalSeconds = 'RetryIntervalSeconds',
  /** column name */
  SentAt = 'SentAt',
  /** column name */
  SuntechTrackerBatchCommandDeviceId = 'SuntechTrackerBatchCommandDeviceId',
  /** column name */
  TimeoutAt = 'TimeoutAt',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate var_pop on columns */
export type SuntechTrackerCommand_Var_Pop_Fields = {
  __typename?: 'SuntechTrackerCommand_var_pop_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Var_Pop_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type SuntechTrackerCommand_Var_Samp_Fields = {
  __typename?: 'SuntechTrackerCommand_var_samp_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Var_Samp_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type SuntechTrackerCommand_Variance_Fields = {
  __typename?: 'SuntechTrackerCommand_variance_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IdEquipment: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  SuntechTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "SuntechTrackerCommand" */
export type SuntechTrackerCommand_Variance_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IdEquipment?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SuntechTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

export type TireAnalysisReport = {
  __typename?: 'TireAnalysisReport';
  correct_pressure_count: Scalars['bigint']['output'];
  correct_pressure_tolerance_parameter: Scalars['float8']['output'];
  distinct_vehicle_inspectioned_count: Scalars['bigint']['output'];
  end_at: Scalars['timestamptz']['output'];
  excessive_high_pressure_count: Scalars['bigint']['output'];
  excessive_high_pressure_tolerance_parameter: Scalars['float8']['output'];
  excessive_low_pressure_count: Scalars['bigint']['output'];
  excessive_low_pressure_tolerance_parameter: Scalars['float8']['output'];
  high_pressure_count: Scalars['bigint']['output'];
  high_pressure_tolerance_parameter: Scalars['float8']['output'];
  inspection_by_distinct_tire_count: Scalars['bigint']['output'];
  inspection_count: Scalars['bigint']['output'];
  low_pressure_count: Scalars['bigint']['output'];
  low_pressure_tolerance_parameter: Scalars['float8']['output'];
  low_tire_depth_count: Scalars['bigint']['output'];
  low_tire_depth_parameter: Scalars['float8']['output'];
  new_tire_count: Scalars['bigint']['output'];
  open_service_count: Scalars['bigint']['output'];
  reformed_tire_count: Scalars['bigint']['output'];
  start_at: Scalars['timestamptz']['output'];
  tire_inspection_count: Scalars['bigint']['output'];
  twin_tires_high_depth_difference_count: Scalars['bigint']['output'];
  twin_tires_minimum_depth_difference_tolerance_parameter: Scalars['float8']['output'];
  wear_irregular_count: Scalars['bigint']['output'];
  wear_irregular_parameter: Scalars['float8']['output'];
  wear_severe_cavalo_mecanico_count: Scalars['bigint']['output'];
  wear_severe_cavalo_mecanico_parameter: Scalars['float8']['output'];
  wear_severe_count: Scalars['bigint']['output'];
  wear_severe_parameter: Scalars['float8']['output'];
  wear_severe_semi_reboque_count: Scalars['bigint']['output'];
  wear_severe_semi_reboque_parameter: Scalars['float8']['output'];
};

/** TireAnalysisReportNative Query Arguments */
export type TireAnalysisReport_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** Boolean expression to filter rows from the logical model for "TireAnalysisReport". All fields are combined with a logical 'AND'. */
export type TireAnalysisReport_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<TireAnalysisReport_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<TireAnalysisReport_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<TireAnalysisReport_Bool_Exp_Bool_Exp>>;
  correct_pressure_count?: InputMaybe<Bigint_Comparison_Exp>;
  correct_pressure_tolerance_parameter?: InputMaybe<Float8_Comparison_Exp>;
  distinct_vehicle_inspectioned_count?: InputMaybe<Bigint_Comparison_Exp>;
  end_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  excessive_high_pressure_count?: InputMaybe<Bigint_Comparison_Exp>;
  excessive_high_pressure_tolerance_parameter?: InputMaybe<Float8_Comparison_Exp>;
  excessive_low_pressure_count?: InputMaybe<Bigint_Comparison_Exp>;
  excessive_low_pressure_tolerance_parameter?: InputMaybe<Float8_Comparison_Exp>;
  high_pressure_count?: InputMaybe<Bigint_Comparison_Exp>;
  high_pressure_tolerance_parameter?: InputMaybe<Float8_Comparison_Exp>;
  inspection_by_distinct_tire_count?: InputMaybe<Bigint_Comparison_Exp>;
  inspection_count?: InputMaybe<Bigint_Comparison_Exp>;
  low_pressure_count?: InputMaybe<Bigint_Comparison_Exp>;
  low_pressure_tolerance_parameter?: InputMaybe<Float8_Comparison_Exp>;
  low_tire_depth_count?: InputMaybe<Bigint_Comparison_Exp>;
  low_tire_depth_parameter?: InputMaybe<Float8_Comparison_Exp>;
  new_tire_count?: InputMaybe<Bigint_Comparison_Exp>;
  open_service_count?: InputMaybe<Bigint_Comparison_Exp>;
  reformed_tire_count?: InputMaybe<Bigint_Comparison_Exp>;
  start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  tire_inspection_count?: InputMaybe<Bigint_Comparison_Exp>;
  twin_tires_high_depth_difference_count?: InputMaybe<Bigint_Comparison_Exp>;
  twin_tires_minimum_depth_difference_tolerance_parameter?: InputMaybe<Float8_Comparison_Exp>;
  wear_irregular_count?: InputMaybe<Bigint_Comparison_Exp>;
  wear_irregular_parameter?: InputMaybe<Float8_Comparison_Exp>;
  wear_severe_cavalo_mecanico_count?: InputMaybe<Bigint_Comparison_Exp>;
  wear_severe_cavalo_mecanico_parameter?: InputMaybe<Float8_Comparison_Exp>;
  wear_severe_count?: InputMaybe<Bigint_Comparison_Exp>;
  wear_severe_parameter?: InputMaybe<Float8_Comparison_Exp>;
  wear_severe_semi_reboque_count?: InputMaybe<Bigint_Comparison_Exp>;
  wear_severe_semi_reboque_parameter?: InputMaybe<Float8_Comparison_Exp>;
};

export enum TireAnalysisReport_Enum_Name {
  /** column name */
  CorrectPressureCount = 'correct_pressure_count',
  /** column name */
  CorrectPressureToleranceParameter = 'correct_pressure_tolerance_parameter',
  /** column name */
  DistinctVehicleInspectionedCount = 'distinct_vehicle_inspectioned_count',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  ExcessiveHighPressureCount = 'excessive_high_pressure_count',
  /** column name */
  ExcessiveHighPressureToleranceParameter = 'excessive_high_pressure_tolerance_parameter',
  /** column name */
  ExcessiveLowPressureCount = 'excessive_low_pressure_count',
  /** column name */
  ExcessiveLowPressureToleranceParameter = 'excessive_low_pressure_tolerance_parameter',
  /** column name */
  HighPressureCount = 'high_pressure_count',
  /** column name */
  HighPressureToleranceParameter = 'high_pressure_tolerance_parameter',
  /** column name */
  InspectionByDistinctTireCount = 'inspection_by_distinct_tire_count',
  /** column name */
  InspectionCount = 'inspection_count',
  /** column name */
  LowPressureCount = 'low_pressure_count',
  /** column name */
  LowPressureToleranceParameter = 'low_pressure_tolerance_parameter',
  /** column name */
  LowTireDepthCount = 'low_tire_depth_count',
  /** column name */
  LowTireDepthParameter = 'low_tire_depth_parameter',
  /** column name */
  NewTireCount = 'new_tire_count',
  /** column name */
  OpenServiceCount = 'open_service_count',
  /** column name */
  ReformedTireCount = 'reformed_tire_count',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  TireInspectionCount = 'tire_inspection_count',
  /** column name */
  TwinTiresHighDepthDifferenceCount = 'twin_tires_high_depth_difference_count',
  /** column name */
  TwinTiresMinimumDepthDifferenceToleranceParameter = 'twin_tires_minimum_depth_difference_tolerance_parameter',
  /** column name */
  WearIrregularCount = 'wear_irregular_count',
  /** column name */
  WearIrregularParameter = 'wear_irregular_parameter',
  /** column name */
  WearSevereCavaloMecanicoCount = 'wear_severe_cavalo_mecanico_count',
  /** column name */
  WearSevereCavaloMecanicoParameter = 'wear_severe_cavalo_mecanico_parameter',
  /** column name */
  WearSevereCount = 'wear_severe_count',
  /** column name */
  WearSevereParameter = 'wear_severe_parameter',
  /** column name */
  WearSevereSemiReboqueCount = 'wear_severe_semi_reboque_count',
  /** column name */
  WearSevereSemiReboqueParameter = 'wear_severe_semi_reboque_parameter'
}

/** Ordering options when selecting data from "TireAnalysisReport". */
export type TireAnalysisReport_Order_By = {
  correct_pressure_count?: InputMaybe<Order_By>;
  correct_pressure_tolerance_parameter?: InputMaybe<Order_By>;
  distinct_vehicle_inspectioned_count?: InputMaybe<Order_By>;
  end_at?: InputMaybe<Order_By>;
  excessive_high_pressure_count?: InputMaybe<Order_By>;
  excessive_high_pressure_tolerance_parameter?: InputMaybe<Order_By>;
  excessive_low_pressure_count?: InputMaybe<Order_By>;
  excessive_low_pressure_tolerance_parameter?: InputMaybe<Order_By>;
  high_pressure_count?: InputMaybe<Order_By>;
  high_pressure_tolerance_parameter?: InputMaybe<Order_By>;
  inspection_by_distinct_tire_count?: InputMaybe<Order_By>;
  inspection_count?: InputMaybe<Order_By>;
  low_pressure_count?: InputMaybe<Order_By>;
  low_pressure_tolerance_parameter?: InputMaybe<Order_By>;
  low_tire_depth_count?: InputMaybe<Order_By>;
  low_tire_depth_parameter?: InputMaybe<Order_By>;
  new_tire_count?: InputMaybe<Order_By>;
  open_service_count?: InputMaybe<Order_By>;
  reformed_tire_count?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
  tire_inspection_count?: InputMaybe<Order_By>;
  twin_tires_high_depth_difference_count?: InputMaybe<Order_By>;
  twin_tires_minimum_depth_difference_tolerance_parameter?: InputMaybe<Order_By>;
  wear_irregular_count?: InputMaybe<Order_By>;
  wear_irregular_parameter?: InputMaybe<Order_By>;
  wear_severe_cavalo_mecanico_count?: InputMaybe<Order_By>;
  wear_severe_cavalo_mecanico_parameter?: InputMaybe<Order_By>;
  wear_severe_count?: InputMaybe<Order_By>;
  wear_severe_parameter?: InputMaybe<Order_By>;
  wear_severe_semi_reboque_count?: InputMaybe<Order_By>;
  wear_severe_semi_reboque_parameter?: InputMaybe<Order_By>;
};

export type TrackerTracesOutput = {
  __typename?: 'TrackerTracesOutput';
  traces: Array<Scalars['json']['output']>;
};

export type TripAnalysisWithAllDriversByMonthInput = {
  month: Scalars['date']['input'];
};

export type TripAnalysisWithAllDriversByMonthSingleOutput = {
  __typename?: 'TripAnalysisWithAllDriversByMonthSingleOutput';
  brake_use: Scalars['Float']['output'];
  charged_empty: Scalars['Float']['output'];
  charged_filled: Scalars['Float']['output'];
  consumed_fuel: Scalars['Float']['output'];
  economic_range: Scalars['Float']['output'];
  engine_load: Scalars['Float']['output'];
  inertia: Scalars['Float']['output'];
  motorista_code: Scalars['String']['output'];
  note: Scalars['Float']['output'];
  predicted_empty: Scalars['Float']['output'];
  predicted_filled: Scalars['Float']['output'];
  slow_running: Scalars['Float']['output'];
  speed_control: Scalars['Float']['output'];
  total_km: Scalars['Float']['output'];
  total_trips_empty: Scalars['Float']['output'];
  total_trips_filled: Scalars['Float']['output'];
  user: Maybe<User>;
};

export type TripAnalysisWithAllMonthsByDriverSingleOutput = {
  __typename?: 'TripAnalysisWithAllMonthsByDriverSingleOutput';
  brake_use: Scalars['Float']['output'];
  charged_empty: Scalars['Float']['output'];
  charged_filled: Scalars['Float']['output'];
  consumed_fuel: Scalars['Float']['output'];
  economic_range: Scalars['Float']['output'];
  engine_load: Scalars['Float']['output'];
  inertia: Scalars['Float']['output'];
  month: Scalars['date']['output'];
  motorista_code: Scalars['String']['output'];
  note: Scalars['Float']['output'];
  predicted_empty: Scalars['Float']['output'];
  predicted_filled: Scalars['Float']['output'];
  slow_running: Scalars['Float']['output'];
  speed_control: Scalars['Float']['output'];
  total_km: Scalars['Float']['output'];
  total_trips_empty: Scalars['Float']['output'];
  total_trips_filled: Scalars['Float']['output'];
  user: Maybe<User>;
};

export type TripHeadersOutput = {
  __typename?: 'TripHeadersOutput';
  analysisEndedAt: Scalars['timestamptz']['output'];
  analysisStartedAt: Scalars['timestamptz']['output'];
  codmoto: Scalars['String']['output'];
  firstLocation: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isVolvoConnect: Scalars['Boolean']['output'];
  lastLocation: Maybe<Scalars['String']['output']>;
  licensePlate: Scalars['String']['output'];
  truckBrand: Maybe<Scalars['String']['output']>;
  truckModel: Maybe<Scalars['String']['output']>;
  truckYear: Maybe<Scalars['Int']['output']>;
};

export type TripsReportsByTripIdsOutput = {
  __typename?: 'TripsReportsByTripIdsOutput';
  anoVeiculo: Maybe<Scalars['Int']['output']>;
  brakeUse: Maybe<Scalars['Float']['output']>;
  codmoto: Maybe<Scalars['String']['output']>;
  consumoEmMarchaLenta: Maybe<Scalars['Float']['output']>;
  consumoEmMovimento: Maybe<Scalars['Float']['output']>;
  consumoFinal: Maybe<Scalars['Float']['output']>;
  consumoInicial: Maybe<Scalars['Float']['output']>;
  consumoMedio: Maybe<Scalars['Float']['output']>;
  consumoTotal: Maybe<Scalars['Float']['output']>;
  consumoTotalEmViagem: Maybe<Scalars['Float']['output']>;
  contagemDeDesligamentosDaIgnicao: Maybe<Scalars['Int']['output']>;
  dataFinal: Maybe<Scalars['timestamptz']['output']>;
  dataInicial: Maybe<Scalars['timestamptz']['output']>;
  distanciaAcimaDoLimiteDeVelocidade: Maybe<Scalars['Float']['output']>;
  distanciaCargaNoMotor: Maybe<Scalars['Float']['output']>;
  distanciaComFreioDeCarreta: Maybe<Scalars['Float']['output']>;
  distanciaComFreioDeServico: Maybe<Scalars['Float']['output']>;
  distanciaDeRolagem: Maybe<Scalars['Float']['output']>;
  distanciaDeUtilizacaoDosFreiosAuxiliares: Maybe<Scalars['Float']['output']>;
  distanciaEmAcliveComConducaoEconomica: Maybe<Scalars['Float']['output']>;
  distanciaEmAcliveTotal: Maybe<Scalars['Float']['output']>;
  distanciaEmConducaoEconomica: Maybe<Scalars['Float']['output']>;
  distanciaForaDaFaixaEconomica: Maybe<Scalars['Float']['output']>;
  distanciaMovimentoEngrenadoSemAceleracao: Maybe<Scalars['Float']['output']>;
  distanciaNaFaixaEconomica: Maybe<Scalars['Float']['output']>;
  distanciaPercorridaAcimaDe80Kmh: Maybe<Scalars['Float']['output']>;
  distanciaPercorridaAcimaDe83: Maybe<Scalars['Float']['output']>;
  distanciaPercorridaEmInercia: Maybe<Scalars['Float']['output']>;
  distanciaPercorridaEmPilotoAutomatico: Maybe<Scalars['Float']['output']>;
  distanciaPercorridaNaTrip: Maybe<Scalars['Float']['output']>;
  distanciaTotal: Maybe<Scalars['Float']['output']>;
  economicRange: Maybe<Scalars['Float']['output']>;
  engineLoad: Maybe<Scalars['Float']['output']>;
  fuelConsumeByWeightRangeJson: Maybe<Scalars['String']['output']>;
  horaMotorTotal: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  marcaVeiculo: Maybe<Scalars['String']['output']>;
  modeloVeiculo: Maybe<Scalars['String']['output']>;
  nomeMotorista: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  numeroDesaceleracaoBruscas: Maybe<Scalars['Int']['output']>;
  numeroKickDowns: Maybe<Scalars['Int']['output']>;
  odometroFinal: Maybe<Scalars['Float']['output']>;
  odometroInicial: Maybe<Scalars['Float']['output']>;
  placa: Maybe<Scalars['String']['output']>;
  pontoDeChegada: Maybe<Scalars['String']['output']>;
  pontoDePartida: Maybe<Scalars['String']['output']>;
  porcentagemDistanciaGiroMotor1600a1800SemAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemDistanciaGiroMotor1800a2000SemAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemDistanciaGiroMotor2000a2200SemAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemDistanciaGiroMotor2200a2400SemAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemDistanciaGiroMotorAcima2400SemAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemGiro0a400: Maybe<Scalars['Float']['output']>;
  porcentagemGiro400a800: Maybe<Scalars['Float']['output']>;
  porcentagemGiro800a1200: Maybe<Scalars['Float']['output']>;
  porcentagemGiro1200a1600: Maybe<Scalars['Float']['output']>;
  porcentagemGiro1600a2000: Maybe<Scalars['Float']['output']>;
  porcentagemGiro2000a2400: Maybe<Scalars['Float']['output']>;
  porcentagemGiro2400a2800: Maybe<Scalars['Float']['output']>;
  porcentagemGiro2800a3200: Maybe<Scalars['Float']['output']>;
  porcentagemGiro3200a3600: Maybe<Scalars['Float']['output']>;
  porcentagemGiroMaior3600: Maybe<Scalars['Float']['output']>;
  porcentagemPercorridaPressaoTurbo70a140: Maybe<Scalars['Float']['output']>;
  porcentagemPercorridaPressaoTurbo140a210: Maybe<Scalars['Float']['output']>;
  porcentagemPercorridaPressaoTurbo210a280: Maybe<Scalars['Float']['output']>;
  porcentagemPercorridaPressaoTurbo280a350: Maybe<Scalars['Float']['output']>;
  porcentagemPercorridaPressaoTurbo350a420: Maybe<Scalars['Float']['output']>;
  porcentagemPercorridaPressaoTurbo420a500: Maybe<Scalars['Float']['output']>;
  porcentagemPercorridaPressaoTurboMenor70: Maybe<Scalars['Float']['output']>;
  porcentagemPesoTotal0a15000: Maybe<Scalars['Float']['output']>;
  porcentagemPesoTotal15000a30000: Maybe<Scalars['Float']['output']>;
  porcentagemPesoTotal30000a45000: Maybe<Scalars['Float']['output']>;
  porcentagemPesoTotal45000a60000: Maybe<Scalars['Float']['output']>;
  porcentagemPesoTotal60000a75000: Maybe<Scalars['Float']['output']>;
  porcentagemPesoTotal75000a90000: Maybe<Scalars['Float']['output']>;
  porcentagemPesoTotalMaior90000: Maybe<Scalars['Float']['output']>;
  porcentagemRetarder0a20: Maybe<Scalars['Float']['output']>;
  porcentagemRetarder20a40: Maybe<Scalars['Float']['output']>;
  porcentagemRetarder40a60: Maybe<Scalars['Float']['output']>;
  porcentagemRetarder60a80: Maybe<Scalars['Float']['output']>;
  porcentagemRetarder80a100: Maybe<Scalars['Float']['output']>;
  porcentagemTemperaturaEmGraus60a80: Maybe<Scalars['Float']['output']>;
  porcentagemTemperaturaEmGraus80a90: Maybe<Scalars['Float']['output']>;
  porcentagemTemperaturaEmGraus90a97: Maybe<Scalars['Float']['output']>;
  porcentagemTemperaturaEmGraus97a104: Maybe<Scalars['Float']['output']>;
  porcentagemTemperaturaEmGraus104a108: Maybe<Scalars['Float']['output']>;
  porcentagemTemperaturaEmGrausMaior108: Maybe<Scalars['Float']['output']>;
  porcentagemTemperaturaEmGrausMenor60: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro900a1100ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro1100a1200ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro1200a1300ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro1300a1400ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro1400a1500ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro1500a1600ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro1600a1800ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro1800a2000ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiro2000a2200ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiroMaior2200ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoGiroMenor900ComAceleracao: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio0a5: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio5a10: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio10a15: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio15a25: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio25a40: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio40a70: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio70a80: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio80a90: Maybe<Scalars['Float']['output']>;
  porcentagemTempoPercorridoPedalFreio90a100: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador0a10: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador0a20: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador10a20: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador20a30: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador20a40: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador30a40: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador40a50: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador40a60: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador50a60: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador60a70: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador60a80: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador70a80: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador80a90: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador80a100: Maybe<Scalars['Float']['output']>;
  porcentagemUsoAcelerador90a100: Maybe<Scalars['Float']['output']>;
  porcentagemVelocidade53a63: Maybe<Scalars['Float']['output']>;
  porcentagemVelocidade63a73: Maybe<Scalars['Float']['output']>;
  porcentagemVelocidade73a83: Maybe<Scalars['Float']['output']>;
  porcentagemVelocidade83a93: Maybe<Scalars['Float']['output']>;
  porcentagemVelocidadeAcima93: Maybe<Scalars['Float']['output']>;
  porcentagemVelocidadeMenor53: Maybe<Scalars['Float']['output']>;
  quantidadeDeUsoDeFreioEmMovimento: Maybe<Scalars['Int']['output']>;
  slowRunning: Maybe<Scalars['Float']['output']>;
  speedControl: Maybe<Scalars['Float']['output']>;
  temperaturaMaxima: Maybe<Scalars['Float']['output']>;
  tempoAcimaDoLimiteDeVelocidade: Maybe<Scalars['Float']['output']>;
  tempoEmTransmissaoAutomatica: Maybe<Scalars['Float']['output']>;
  tempoEmTransmissaoManual: Maybe<Scalars['Float']['output']>;
  tempoEmTransmissaoPower: Maybe<Scalars['Float']['output']>;
  tempoEmbreagemSemiAcoplada: Maybe<Scalars['Float']['output']>;
  tempoEmpreagemSemRe: Maybe<Scalars['Float']['output']>;
  tempoForaDaFaixaEconomica: Maybe<Scalars['Float']['output']>;
  tempoFuncionamentoMotorFinal: Maybe<Scalars['Float']['output']>;
  tempoFuncionamentoMotorInicial: Maybe<Scalars['Float']['output']>;
  tempoMarchaLentaEmHoras: Maybe<Scalars['Float']['output']>;
  tempoNaFaixaEconomica: Maybe<Scalars['Float']['output']>;
  tempoPercorridoAcimaDe80Kmh: Maybe<Scalars['Float']['output']>;
  tempoPercorridoAcimaDe83Kmh: Maybe<Scalars['Float']['output']>;
  tempoPercorridoNaTripEmHoras: Maybe<Scalars['Float']['output']>;
  tempoRetarder: Maybe<Scalars['Float']['output']>;
  tempoTotalTransmissao: Maybe<Scalars['Float']['output']>;
  tempoUtilizacaoFreioServico: Maybe<Scalars['Float']['output']>;
  type: Maybe<Scalars['String']['output']>;
  weightAndfuelLevelAndConsumeByOdometerJson: Maybe<Scalars['String']['output']>;
};

/** columns and relationships of "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand = {
  __typename?: 'VirlocTrackerBatchCommand';
  CreatedAt: Scalars['datetimeoffset']['output'];
  Description: Scalars['String']['output'];
  FileContent: Scalars['String']['output'];
  Filename: Scalars['String']['output'];
  Id: Scalars['Int']['output'];
  UpdatedAt: Scalars['datetimeoffset']['output'];
  /** An array relationship */
  VirlocTrackerBatchCommandDevices: Array<VirlocTrackerBatchCommandDevice>;
  /** An aggregate relationship */
  VirlocTrackerBatchCommandDevices_aggregate: VirlocTrackerBatchCommandDevice_Aggregate;
};


/** columns and relationships of "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommandVirlocTrackerBatchCommandDevicesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
};


/** columns and relationships of "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommandVirlocTrackerBatchCommandDevices_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
};

/** columns and relationships of "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice = {
  __typename?: 'VirlocTrackerBatchCommandDevice';
  CreatedAt: Scalars['datetimeoffset']['output'];
  Id: Scalars['Int']['output'];
  TrackerDeviceID: Scalars['String']['output'];
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Scalars['datetimeoffset']['output'];
  /** An object relationship */
  VirlocTrackerBatchCommand: VirlocTrackerBatchCommand;
  VirlocTrackerBatchCommandId: Scalars['Int']['output'];
  /** An array relationship */
  VirlocTrackerCommands: Array<VirlocTrackerCommand>;
  /** An aggregate relationship */
  VirlocTrackerCommands_aggregate: VirlocTrackerCommand_Aggregate;
};


/** columns and relationships of "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDeviceVirlocTrackerCommandsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
};


/** columns and relationships of "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDeviceVirlocTrackerCommands_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
};

/** aggregated selection of "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Aggregate = {
  __typename?: 'VirlocTrackerBatchCommandDevice_aggregate';
  aggregate: Maybe<VirlocTrackerBatchCommandDevice_Aggregate_Fields>;
  nodes: Array<VirlocTrackerBatchCommandDevice>;
};

/** aggregate fields of "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Aggregate_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_aggregate_fields';
  avg: Maybe<VirlocTrackerBatchCommandDevice_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<VirlocTrackerBatchCommandDevice_Max_Fields>;
  min: Maybe<VirlocTrackerBatchCommandDevice_Min_Fields>;
  stddev: Maybe<VirlocTrackerBatchCommandDevice_Stddev_Fields>;
  stddev_pop: Maybe<VirlocTrackerBatchCommandDevice_Stddev_Pop_Fields>;
  stddev_samp: Maybe<VirlocTrackerBatchCommandDevice_Stddev_Samp_Fields>;
  sum: Maybe<VirlocTrackerBatchCommandDevice_Sum_Fields>;
  var_pop: Maybe<VirlocTrackerBatchCommandDevice_Var_Pop_Fields>;
  var_samp: Maybe<VirlocTrackerBatchCommandDevice_Var_Samp_Fields>;
  variance: Maybe<VirlocTrackerBatchCommandDevice_Variance_Fields>;
};


/** aggregate fields of "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<VirlocTrackerBatchCommandDevice_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Aggregate_Order_By = {
  avg?: InputMaybe<VirlocTrackerBatchCommandDevice_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<VirlocTrackerBatchCommandDevice_Max_Order_By>;
  min?: InputMaybe<VirlocTrackerBatchCommandDevice_Min_Order_By>;
  stddev?: InputMaybe<VirlocTrackerBatchCommandDevice_Stddev_Order_By>;
  stddev_pop?: InputMaybe<VirlocTrackerBatchCommandDevice_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<VirlocTrackerBatchCommandDevice_Stddev_Samp_Order_By>;
  sum?: InputMaybe<VirlocTrackerBatchCommandDevice_Sum_Order_By>;
  var_pop?: InputMaybe<VirlocTrackerBatchCommandDevice_Var_Pop_Order_By>;
  var_samp?: InputMaybe<VirlocTrackerBatchCommandDevice_Var_Samp_Order_By>;
  variance?: InputMaybe<VirlocTrackerBatchCommandDevice_Variance_Order_By>;
};

/** aggregate avg on columns */
export type VirlocTrackerBatchCommandDevice_Avg_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Avg_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "VirlocTrackerBatchCommandDevice". All fields are combined with a logical 'AND'. */
export type VirlocTrackerBatchCommandDevice_Bool_Exp = {
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  TrackerDeviceID?: InputMaybe<String_Mssql_Comparison_Exp>;
  TrackerSerialNumber?: InputMaybe<String_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  VirlocTrackerBatchCommand?: InputMaybe<VirlocTrackerBatchCommand_Bool_Exp>;
  VirlocTrackerBatchCommandId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  VirlocTrackerCommands?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
  _and?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Bool_Exp>>;
  _not?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
  _or?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Bool_Exp>>;
};

/** upsert condition type for table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_If_Matched = {
  match_columns?: Array<VirlocTrackerBatchCommandDevice_Insert_Match_Column>;
  update_columns?: Array<VirlocTrackerBatchCommandDevice_Update_Column>;
  where?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Inc_Input = {
  VirlocTrackerBatchCommandId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Insert_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TrackerDeviceID?: InputMaybe<Scalars['String']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  VirlocTrackerBatchCommandId?: InputMaybe<Scalars['Int']['input']>;
};

/** select match_columns of table "VirlocTrackerBatchCommandDevice" */
export enum VirlocTrackerBatchCommandDevice_Insert_Match_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Id = 'Id',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceID',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  VirlocTrackerBatchCommandId = 'VirlocTrackerBatchCommandId'
}

/** aggregate max on columns */
export type VirlocTrackerBatchCommandDevice_Max_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_max_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  TrackerDeviceID: Maybe<Scalars['String']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Max_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  TrackerDeviceID?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type VirlocTrackerBatchCommandDevice_Min_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_min_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  TrackerDeviceID: Maybe<Scalars['String']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Min_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  TrackerDeviceID?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Mutation_Response = {
  __typename?: 'VirlocTrackerBatchCommandDevice_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VirlocTrackerBatchCommandDevice>;
};

/** Ordering options when selecting data from "VirlocTrackerBatchCommandDevice". */
export type VirlocTrackerBatchCommandDevice_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  TrackerDeviceID?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommand?: InputMaybe<VirlocTrackerBatchCommand_Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
  VirlocTrackerCommands_aggregate?: InputMaybe<VirlocTrackerCommand_Aggregate_Order_By>;
};

/** primary key columns input for table: VirlocTrackerBatchCommandDevice */
export type VirlocTrackerBatchCommandDevice_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "VirlocTrackerBatchCommandDevice" */
export enum VirlocTrackerBatchCommandDevice_Select_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Id = 'Id',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceID',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  VirlocTrackerBatchCommandId = 'VirlocTrackerBatchCommandId'
}

/** input type for updating data in table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Set_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TrackerDeviceID?: InputMaybe<Scalars['String']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  VirlocTrackerBatchCommandId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type VirlocTrackerBatchCommandDevice_Stddev_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Stddev_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type VirlocTrackerBatchCommandDevice_Stddev_Pop_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Stddev_Pop_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type VirlocTrackerBatchCommandDevice_Stddev_Samp_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Stddev_Samp_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type VirlocTrackerBatchCommandDevice_Sum_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Sum_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** update columns of table "VirlocTrackerBatchCommandDevice" */
export enum VirlocTrackerBatchCommandDevice_Update_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceID',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  VirlocTrackerBatchCommandId = 'VirlocTrackerBatchCommandId'
}

/** aggregate var_pop on columns */
export type VirlocTrackerBatchCommandDevice_Var_Pop_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Var_Pop_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type VirlocTrackerBatchCommandDevice_Var_Samp_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Var_Samp_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type VirlocTrackerBatchCommandDevice_Variance_Fields = {
  __typename?: 'VirlocTrackerBatchCommandDevice_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandId: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "VirlocTrackerBatchCommandDevice" */
export type VirlocTrackerBatchCommandDevice_Variance_Order_By = {
  Id?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandId?: InputMaybe<Order_By>;
};

/** columns and relationships of "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset = {
  __typename?: 'VirlocTrackerBatchCommandPreset';
  Content: Scalars['String']['output'];
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Scalars['String']['output'];
  Id: Scalars['Int']['output'];
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** aggregated selection of "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset_Aggregate = {
  __typename?: 'VirlocTrackerBatchCommandPreset_aggregate';
  aggregate: Maybe<VirlocTrackerBatchCommandPreset_Aggregate_Fields>;
  nodes: Array<VirlocTrackerBatchCommandPreset>;
};

/** aggregate fields of "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset_Aggregate_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_aggregate_fields';
  avg: Maybe<VirlocTrackerBatchCommandPreset_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<VirlocTrackerBatchCommandPreset_Max_Fields>;
  min: Maybe<VirlocTrackerBatchCommandPreset_Min_Fields>;
  stddev: Maybe<VirlocTrackerBatchCommandPreset_Stddev_Fields>;
  stddev_pop: Maybe<VirlocTrackerBatchCommandPreset_Stddev_Pop_Fields>;
  stddev_samp: Maybe<VirlocTrackerBatchCommandPreset_Stddev_Samp_Fields>;
  sum: Maybe<VirlocTrackerBatchCommandPreset_Sum_Fields>;
  var_pop: Maybe<VirlocTrackerBatchCommandPreset_Var_Pop_Fields>;
  var_samp: Maybe<VirlocTrackerBatchCommandPreset_Var_Samp_Fields>;
  variance: Maybe<VirlocTrackerBatchCommandPreset_Variance_Fields>;
};


/** aggregate fields of "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<VirlocTrackerBatchCommandPreset_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type VirlocTrackerBatchCommandPreset_Avg_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "VirlocTrackerBatchCommandPreset". All fields are combined with a logical 'AND'. */
export type VirlocTrackerBatchCommandPreset_Bool_Exp = {
  Content?: InputMaybe<String_Mssql_Comparison_Exp>;
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Description?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<VirlocTrackerBatchCommandPreset_Bool_Exp>>;
  _not?: InputMaybe<VirlocTrackerBatchCommandPreset_Bool_Exp>;
  _or?: InputMaybe<Array<VirlocTrackerBatchCommandPreset_Bool_Exp>>;
};

/** upsert condition type for table "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset_If_Matched = {
  match_columns?: Array<VirlocTrackerBatchCommandPreset_Insert_Match_Column>;
  update_columns?: Array<VirlocTrackerBatchCommandPreset_Update_Column>;
  where?: InputMaybe<VirlocTrackerBatchCommandPreset_Bool_Exp>;
};

/** input type for inserting data into table "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset_Insert_Input = {
  Content?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** select match_columns of table "VirlocTrackerBatchCommandPreset" */
export enum VirlocTrackerBatchCommandPreset_Insert_Match_Column {
  /** column name */
  Content = 'Content',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate max on columns */
export type VirlocTrackerBatchCommandPreset_Max_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_max_fields';
  Content: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** aggregate min on columns */
export type VirlocTrackerBatchCommandPreset_Min_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_min_fields';
  Content: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** response of any mutation on the table "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset_Mutation_Response = {
  __typename?: 'VirlocTrackerBatchCommandPreset_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VirlocTrackerBatchCommandPreset>;
};

/** Ordering options when selecting data from "VirlocTrackerBatchCommandPreset". */
export type VirlocTrackerBatchCommandPreset_Order_By = {
  Content?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: VirlocTrackerBatchCommandPreset */
export type VirlocTrackerBatchCommandPreset_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "VirlocTrackerBatchCommandPreset" */
export enum VirlocTrackerBatchCommandPreset_Select_Column {
  /** column name */
  Content = 'Content',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** input type for updating data in table "VirlocTrackerBatchCommandPreset" */
export type VirlocTrackerBatchCommandPreset_Set_Input = {
  Content?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** aggregate stddev on columns */
export type VirlocTrackerBatchCommandPreset_Stddev_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type VirlocTrackerBatchCommandPreset_Stddev_Pop_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type VirlocTrackerBatchCommandPreset_Stddev_Samp_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type VirlocTrackerBatchCommandPreset_Sum_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "VirlocTrackerBatchCommandPreset" */
export enum VirlocTrackerBatchCommandPreset_Update_Column {
  /** column name */
  Content = 'Content',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate var_pop on columns */
export type VirlocTrackerBatchCommandPreset_Var_Pop_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type VirlocTrackerBatchCommandPreset_Var_Samp_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type VirlocTrackerBatchCommandPreset_Variance_Fields = {
  __typename?: 'VirlocTrackerBatchCommandPreset_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregated selection of "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand_Aggregate = {
  __typename?: 'VirlocTrackerBatchCommand_aggregate';
  aggregate: Maybe<VirlocTrackerBatchCommand_Aggregate_Fields>;
  nodes: Array<VirlocTrackerBatchCommand>;
};

/** aggregate fields of "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand_Aggregate_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_aggregate_fields';
  avg: Maybe<VirlocTrackerBatchCommand_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<VirlocTrackerBatchCommand_Max_Fields>;
  min: Maybe<VirlocTrackerBatchCommand_Min_Fields>;
  stddev: Maybe<VirlocTrackerBatchCommand_Stddev_Fields>;
  stddev_pop: Maybe<VirlocTrackerBatchCommand_Stddev_Pop_Fields>;
  stddev_samp: Maybe<VirlocTrackerBatchCommand_Stddev_Samp_Fields>;
  sum: Maybe<VirlocTrackerBatchCommand_Sum_Fields>;
  var_pop: Maybe<VirlocTrackerBatchCommand_Var_Pop_Fields>;
  var_samp: Maybe<VirlocTrackerBatchCommand_Var_Samp_Fields>;
  variance: Maybe<VirlocTrackerBatchCommand_Variance_Fields>;
};


/** aggregate fields of "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<VirlocTrackerBatchCommand_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type VirlocTrackerBatchCommand_Avg_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_avg_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "VirlocTrackerBatchCommand". All fields are combined with a logical 'AND'. */
export type VirlocTrackerBatchCommand_Bool_Exp = {
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Description?: InputMaybe<String_Mssql_Comparison_Exp>;
  FileContent?: InputMaybe<String_Mssql_Comparison_Exp>;
  Filename?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  VirlocTrackerBatchCommandDevices?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
  _and?: InputMaybe<Array<VirlocTrackerBatchCommand_Bool_Exp>>;
  _not?: InputMaybe<VirlocTrackerBatchCommand_Bool_Exp>;
  _or?: InputMaybe<Array<VirlocTrackerBatchCommand_Bool_Exp>>;
};

/** upsert condition type for table "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand_If_Matched = {
  match_columns?: Array<VirlocTrackerBatchCommand_Insert_Match_Column>;
  update_columns?: Array<VirlocTrackerBatchCommand_Update_Column>;
  where?: InputMaybe<VirlocTrackerBatchCommand_Bool_Exp>;
};

/** input type for inserting data into table "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand_Insert_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  FileContent?: InputMaybe<Scalars['String']['input']>;
  Filename?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** select match_columns of table "VirlocTrackerBatchCommand" */
export enum VirlocTrackerBatchCommand_Insert_Match_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  FileContent = 'FileContent',
  /** column name */
  Filename = 'Filename',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate max on columns */
export type VirlocTrackerBatchCommand_Max_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_max_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  FileContent: Maybe<Scalars['String']['output']>;
  Filename: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** aggregate min on columns */
export type VirlocTrackerBatchCommand_Min_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_min_fields';
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Description: Maybe<Scalars['String']['output']>;
  FileContent: Maybe<Scalars['String']['output']>;
  Filename: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
};

/** response of any mutation on the table "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand_Mutation_Response = {
  __typename?: 'VirlocTrackerBatchCommand_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VirlocTrackerBatchCommand>;
};

/** Ordering options when selecting data from "VirlocTrackerBatchCommand". */
export type VirlocTrackerBatchCommand_Order_By = {
  CreatedAt?: InputMaybe<Order_By>;
  Description?: InputMaybe<Order_By>;
  FileContent?: InputMaybe<Order_By>;
  Filename?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDevices_aggregate?: InputMaybe<VirlocTrackerBatchCommandDevice_Aggregate_Order_By>;
};

/** primary key columns input for table: VirlocTrackerBatchCommand */
export type VirlocTrackerBatchCommand_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "VirlocTrackerBatchCommand" */
export enum VirlocTrackerBatchCommand_Select_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  FileContent = 'FileContent',
  /** column name */
  Filename = 'Filename',
  /** column name */
  Id = 'Id',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** input type for updating data in table "VirlocTrackerBatchCommand" */
export type VirlocTrackerBatchCommand_Set_Input = {
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  Description?: InputMaybe<Scalars['String']['input']>;
  FileContent?: InputMaybe<Scalars['String']['input']>;
  Filename?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
};

/** aggregate stddev on columns */
export type VirlocTrackerBatchCommand_Stddev_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_stddev_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type VirlocTrackerBatchCommand_Stddev_Pop_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_stddev_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type VirlocTrackerBatchCommand_Stddev_Samp_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_stddev_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type VirlocTrackerBatchCommand_Sum_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_sum_fields';
  Id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "VirlocTrackerBatchCommand" */
export enum VirlocTrackerBatchCommand_Update_Column {
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Description = 'Description',
  /** column name */
  FileContent = 'FileContent',
  /** column name */
  Filename = 'Filename',
  /** column name */
  UpdatedAt = 'UpdatedAt'
}

/** aggregate var_pop on columns */
export type VirlocTrackerBatchCommand_Var_Pop_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_var_pop_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type VirlocTrackerBatchCommand_Var_Samp_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_var_samp_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type VirlocTrackerBatchCommand_Variance_Fields = {
  __typename?: 'VirlocTrackerBatchCommand_variance_fields';
  Id: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "VirlocTrackerCommand" */
export type VirlocTrackerCommand = {
  __typename?: 'VirlocTrackerCommand';
  AckAt: Maybe<Scalars['datetimeoffset']['output']>;
  AttemptCount: Scalars['Int']['output'];
  CanceledAt: Maybe<Scalars['datetimeoffset']['output']>;
  CommandMessageId: Scalars['String']['output'];
  CommandString: Scalars['String']['output'];
  CreatedAt: Scalars['datetimeoffset']['output'];
  Id: Scalars['Int']['output'];
  IsCanceled: Scalars['Int']['output'];
  LastAttemptAt: Maybe<Scalars['datetimeoffset']['output']>;
  MaxRetryAttempts: Scalars['Int']['output'];
  ResponseString: Maybe<Scalars['String']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  SentAt: Maybe<Scalars['datetimeoffset']['output']>;
  Status: Scalars['String']['output'];
  TimeoutAt: Maybe<Scalars['datetimeoffset']['output']>;
  TrackerDeviceId: Scalars['String']['output'];
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Scalars['datetimeoffset']['output'];
  /** An object relationship */
  VirlocTrackerBatchCommandDevice: Maybe<VirlocTrackerBatchCommandDevice>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Aggregate = {
  __typename?: 'VirlocTrackerCommand_aggregate';
  aggregate: Maybe<VirlocTrackerCommand_Aggregate_Fields>;
  nodes: Array<VirlocTrackerCommand>;
};

/** aggregate fields of "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Aggregate_Fields = {
  __typename?: 'VirlocTrackerCommand_aggregate_fields';
  avg: Maybe<VirlocTrackerCommand_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<VirlocTrackerCommand_Max_Fields>;
  min: Maybe<VirlocTrackerCommand_Min_Fields>;
  stddev: Maybe<VirlocTrackerCommand_Stddev_Fields>;
  stddev_pop: Maybe<VirlocTrackerCommand_Stddev_Pop_Fields>;
  stddev_samp: Maybe<VirlocTrackerCommand_Stddev_Samp_Fields>;
  sum: Maybe<VirlocTrackerCommand_Sum_Fields>;
  var_pop: Maybe<VirlocTrackerCommand_Var_Pop_Fields>;
  var_samp: Maybe<VirlocTrackerCommand_Var_Samp_Fields>;
  variance: Maybe<VirlocTrackerCommand_Variance_Fields>;
};


/** aggregate fields of "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<VirlocTrackerCommand_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Aggregate_Order_By = {
  avg?: InputMaybe<VirlocTrackerCommand_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<VirlocTrackerCommand_Max_Order_By>;
  min?: InputMaybe<VirlocTrackerCommand_Min_Order_By>;
  stddev?: InputMaybe<VirlocTrackerCommand_Stddev_Order_By>;
  stddev_pop?: InputMaybe<VirlocTrackerCommand_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<VirlocTrackerCommand_Stddev_Samp_Order_By>;
  sum?: InputMaybe<VirlocTrackerCommand_Sum_Order_By>;
  var_pop?: InputMaybe<VirlocTrackerCommand_Var_Pop_Order_By>;
  var_samp?: InputMaybe<VirlocTrackerCommand_Var_Samp_Order_By>;
  variance?: InputMaybe<VirlocTrackerCommand_Variance_Order_By>;
};

/** aggregate avg on columns */
export type VirlocTrackerCommand_Avg_Fields = {
  __typename?: 'VirlocTrackerCommand_avg_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Avg_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "VirlocTrackerCommand". All fields are combined with a logical 'AND'. */
export type VirlocTrackerCommand_Bool_Exp = {
  AckAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  AttemptCount?: InputMaybe<Int_Mssql_Comparison_Exp>;
  CanceledAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  CommandMessageId?: InputMaybe<String_Mssql_Comparison_Exp>;
  CommandString?: InputMaybe<String_Mssql_Comparison_Exp>;
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  IsCanceled?: InputMaybe<Int_Mssql_Comparison_Exp>;
  LastAttemptAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  MaxRetryAttempts?: InputMaybe<Int_Mssql_Comparison_Exp>;
  ResponseString?: InputMaybe<String_Mssql_Comparison_Exp>;
  RetryIntervalSeconds?: InputMaybe<Int_Mssql_Comparison_Exp>;
  SentAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  Status?: InputMaybe<String_Mssql_Comparison_Exp>;
  TimeoutAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  TrackerDeviceId?: InputMaybe<String_Mssql_Comparison_Exp>;
  TrackerSerialNumber?: InputMaybe<String_Mssql_Comparison_Exp>;
  UpdatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  VirlocTrackerBatchCommandDevice?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<VirlocTrackerCommand_Bool_Exp>>;
  _not?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
  _or?: InputMaybe<Array<VirlocTrackerCommand_Bool_Exp>>;
};

/** upsert condition type for table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_If_Matched = {
  match_columns?: Array<VirlocTrackerCommand_Insert_Match_Column>;
  update_columns?: Array<VirlocTrackerCommand_Update_Column>;
  where?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Inc_Input = {
  AttemptCount?: InputMaybe<Scalars['Int']['input']>;
  MaxRetryAttempts?: InputMaybe<Scalars['Int']['input']>;
  RetryIntervalSeconds?: InputMaybe<Scalars['Int']['input']>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Insert_Input = {
  AckAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  AttemptCount?: InputMaybe<Scalars['Int']['input']>;
  CanceledAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  CommandMessageId?: InputMaybe<Scalars['String']['input']>;
  CommandString?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  LastAttemptAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  MaxRetryAttempts?: InputMaybe<Scalars['Int']['input']>;
  ResponseString?: InputMaybe<Scalars['String']['input']>;
  RetryIntervalSeconds?: InputMaybe<Scalars['Int']['input']>;
  SentAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TimeoutAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TrackerDeviceId?: InputMaybe<Scalars['String']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Scalars['Int']['input']>;
};

/** select match_columns of table "VirlocTrackerCommand" */
export enum VirlocTrackerCommand_Insert_Match_Column {
  /** column name */
  AckAt = 'AckAt',
  /** column name */
  AttemptCount = 'AttemptCount',
  /** column name */
  CanceledAt = 'CanceledAt',
  /** column name */
  CommandMessageId = 'CommandMessageId',
  /** column name */
  CommandString = 'CommandString',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Id = 'Id',
  /** column name */
  IsCanceled = 'IsCanceled',
  /** column name */
  LastAttemptAt = 'LastAttemptAt',
  /** column name */
  MaxRetryAttempts = 'MaxRetryAttempts',
  /** column name */
  ResponseString = 'ResponseString',
  /** column name */
  RetryIntervalSeconds = 'RetryIntervalSeconds',
  /** column name */
  SentAt = 'SentAt',
  /** column name */
  Status = 'Status',
  /** column name */
  TimeoutAt = 'TimeoutAt',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceId',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  VirlocTrackerBatchCommandDeviceId = 'VirlocTrackerBatchCommandDeviceId'
}

/** aggregate max on columns */
export type VirlocTrackerCommand_Max_Fields = {
  __typename?: 'VirlocTrackerCommand_max_fields';
  AckAt: Maybe<Scalars['datetimeoffset']['output']>;
  AttemptCount: Maybe<Scalars['Int']['output']>;
  CanceledAt: Maybe<Scalars['datetimeoffset']['output']>;
  CommandMessageId: Maybe<Scalars['String']['output']>;
  CommandString: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsCanceled: Maybe<Scalars['Int']['output']>;
  LastAttemptAt: Maybe<Scalars['datetimeoffset']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Int']['output']>;
  ResponseString: Maybe<Scalars['String']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  SentAt: Maybe<Scalars['datetimeoffset']['output']>;
  Status: Maybe<Scalars['String']['output']>;
  TimeoutAt: Maybe<Scalars['datetimeoffset']['output']>;
  TrackerDeviceId: Maybe<Scalars['String']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Max_Order_By = {
  AckAt?: InputMaybe<Order_By>;
  AttemptCount?: InputMaybe<Order_By>;
  CanceledAt?: InputMaybe<Order_By>;
  CommandMessageId?: InputMaybe<Order_By>;
  CommandString?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  LastAttemptAt?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  ResponseString?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SentAt?: InputMaybe<Order_By>;
  Status?: InputMaybe<Order_By>;
  TimeoutAt?: InputMaybe<Order_By>;
  TrackerDeviceId?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type VirlocTrackerCommand_Min_Fields = {
  __typename?: 'VirlocTrackerCommand_min_fields';
  AckAt: Maybe<Scalars['datetimeoffset']['output']>;
  AttemptCount: Maybe<Scalars['Int']['output']>;
  CanceledAt: Maybe<Scalars['datetimeoffset']['output']>;
  CommandMessageId: Maybe<Scalars['String']['output']>;
  CommandString: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsCanceled: Maybe<Scalars['Int']['output']>;
  LastAttemptAt: Maybe<Scalars['datetimeoffset']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Int']['output']>;
  ResponseString: Maybe<Scalars['String']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  SentAt: Maybe<Scalars['datetimeoffset']['output']>;
  Status: Maybe<Scalars['String']['output']>;
  TimeoutAt: Maybe<Scalars['datetimeoffset']['output']>;
  TrackerDeviceId: Maybe<Scalars['String']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
  UpdatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Min_Order_By = {
  AckAt?: InputMaybe<Order_By>;
  AttemptCount?: InputMaybe<Order_By>;
  CanceledAt?: InputMaybe<Order_By>;
  CommandMessageId?: InputMaybe<Order_By>;
  CommandString?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  LastAttemptAt?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  ResponseString?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SentAt?: InputMaybe<Order_By>;
  Status?: InputMaybe<Order_By>;
  TimeoutAt?: InputMaybe<Order_By>;
  TrackerDeviceId?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Mutation_Response = {
  __typename?: 'VirlocTrackerCommand_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VirlocTrackerCommand>;
};

/** Ordering options when selecting data from "VirlocTrackerCommand". */
export type VirlocTrackerCommand_Order_By = {
  AckAt?: InputMaybe<Order_By>;
  AttemptCount?: InputMaybe<Order_By>;
  CanceledAt?: InputMaybe<Order_By>;
  CommandMessageId?: InputMaybe<Order_By>;
  CommandString?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  LastAttemptAt?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  ResponseString?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  SentAt?: InputMaybe<Order_By>;
  Status?: InputMaybe<Order_By>;
  TimeoutAt?: InputMaybe<Order_By>;
  TrackerDeviceId?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
  UpdatedAt?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDevice?: InputMaybe<VirlocTrackerBatchCommandDevice_Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: VirlocTrackerCommand */
export type VirlocTrackerCommand_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "VirlocTrackerCommand" */
export enum VirlocTrackerCommand_Select_Column {
  /** column name */
  AckAt = 'AckAt',
  /** column name */
  AttemptCount = 'AttemptCount',
  /** column name */
  CanceledAt = 'CanceledAt',
  /** column name */
  CommandMessageId = 'CommandMessageId',
  /** column name */
  CommandString = 'CommandString',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  Id = 'Id',
  /** column name */
  IsCanceled = 'IsCanceled',
  /** column name */
  LastAttemptAt = 'LastAttemptAt',
  /** column name */
  MaxRetryAttempts = 'MaxRetryAttempts',
  /** column name */
  ResponseString = 'ResponseString',
  /** column name */
  RetryIntervalSeconds = 'RetryIntervalSeconds',
  /** column name */
  SentAt = 'SentAt',
  /** column name */
  Status = 'Status',
  /** column name */
  TimeoutAt = 'TimeoutAt',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceId',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  VirlocTrackerBatchCommandDeviceId = 'VirlocTrackerBatchCommandDeviceId'
}

/** input type for updating data in table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Set_Input = {
  AckAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  AttemptCount?: InputMaybe<Scalars['Int']['input']>;
  CanceledAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  CommandMessageId?: InputMaybe<Scalars['String']['input']>;
  CommandString?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  LastAttemptAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  MaxRetryAttempts?: InputMaybe<Scalars['Int']['input']>;
  ResponseString?: InputMaybe<Scalars['String']['input']>;
  RetryIntervalSeconds?: InputMaybe<Scalars['Int']['input']>;
  SentAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TimeoutAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  TrackerDeviceId?: InputMaybe<Scalars['String']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
  UpdatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type VirlocTrackerCommand_Stddev_Fields = {
  __typename?: 'VirlocTrackerCommand_stddev_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Stddev_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type VirlocTrackerCommand_Stddev_Pop_Fields = {
  __typename?: 'VirlocTrackerCommand_stddev_pop_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Stddev_Pop_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type VirlocTrackerCommand_Stddev_Samp_Fields = {
  __typename?: 'VirlocTrackerCommand_stddev_samp_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Stddev_Samp_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type VirlocTrackerCommand_Sum_Fields = {
  __typename?: 'VirlocTrackerCommand_sum_fields';
  AttemptCount: Maybe<Scalars['Int']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  IsCanceled: Maybe<Scalars['Int']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Int']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Int']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Sum_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** update columns of table "VirlocTrackerCommand" */
export enum VirlocTrackerCommand_Update_Column {
  /** column name */
  AckAt = 'AckAt',
  /** column name */
  AttemptCount = 'AttemptCount',
  /** column name */
  CanceledAt = 'CanceledAt',
  /** column name */
  CommandMessageId = 'CommandMessageId',
  /** column name */
  CommandString = 'CommandString',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  LastAttemptAt = 'LastAttemptAt',
  /** column name */
  MaxRetryAttempts = 'MaxRetryAttempts',
  /** column name */
  ResponseString = 'ResponseString',
  /** column name */
  RetryIntervalSeconds = 'RetryIntervalSeconds',
  /** column name */
  SentAt = 'SentAt',
  /** column name */
  TimeoutAt = 'TimeoutAt',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceId',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber',
  /** column name */
  UpdatedAt = 'UpdatedAt',
  /** column name */
  VirlocTrackerBatchCommandDeviceId = 'VirlocTrackerBatchCommandDeviceId'
}

/** aggregate var_pop on columns */
export type VirlocTrackerCommand_Var_Pop_Fields = {
  __typename?: 'VirlocTrackerCommand_var_pop_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Var_Pop_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type VirlocTrackerCommand_Var_Samp_Fields = {
  __typename?: 'VirlocTrackerCommand_var_samp_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Var_Samp_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type VirlocTrackerCommand_Variance_Fields = {
  __typename?: 'VirlocTrackerCommand_variance_fields';
  AttemptCount: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
  IsCanceled: Maybe<Scalars['Float']['output']>;
  MaxRetryAttempts: Maybe<Scalars['Float']['output']>;
  RetryIntervalSeconds: Maybe<Scalars['Float']['output']>;
  VirlocTrackerBatchCommandDeviceId: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "VirlocTrackerCommand" */
export type VirlocTrackerCommand_Variance_Order_By = {
  AttemptCount?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  IsCanceled?: InputMaybe<Order_By>;
  MaxRetryAttempts?: InputMaybe<Order_By>;
  RetryIntervalSeconds?: InputMaybe<Order_By>;
  VirlocTrackerBatchCommandDeviceId?: InputMaybe<Order_By>;
};

/** columns and relationships of "VirlocTrackerDevice" */
export type VirlocTrackerDevice = {
  __typename?: 'VirlocTrackerDevice';
  BoardVersion: Maybe<Scalars['String']['output']>;
  CANLibraryVersion: Maybe<Scalars['String']['output']>;
  CreatedAt: Scalars['datetimeoffset']['output'];
  EquipmentId: Maybe<Scalars['Int']['output']>;
  EquipmentSerial: Maybe<Scalars['String']['output']>;
  FirmwareVersion: Maybe<Scalars['String']['output']>;
  ICCID: Maybe<Scalars['String']['output']>;
  Id: Scalars['Int']['output'];
  ProtocolVersion: Maybe<Scalars['String']['output']>;
  ScriptVersion: Maybe<Scalars['String']['output']>;
  TrackerDeviceId: Scalars['String']['output'];
  TrackerModel: Maybe<Scalars['String']['output']>;
  TrackerSerialNumber: Scalars['String']['output'];
};

/** aggregated selection of "VirlocTrackerDevice" */
export type VirlocTrackerDevice_Aggregate = {
  __typename?: 'VirlocTrackerDevice_aggregate';
  aggregate: Maybe<VirlocTrackerDevice_Aggregate_Fields>;
  nodes: Array<VirlocTrackerDevice>;
};

/** aggregate fields of "VirlocTrackerDevice" */
export type VirlocTrackerDevice_Aggregate_Fields = {
  __typename?: 'VirlocTrackerDevice_aggregate_fields';
  avg: Maybe<VirlocTrackerDevice_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<VirlocTrackerDevice_Max_Fields>;
  min: Maybe<VirlocTrackerDevice_Min_Fields>;
  stddev: Maybe<VirlocTrackerDevice_Stddev_Fields>;
  stddev_pop: Maybe<VirlocTrackerDevice_Stddev_Pop_Fields>;
  stddev_samp: Maybe<VirlocTrackerDevice_Stddev_Samp_Fields>;
  sum: Maybe<VirlocTrackerDevice_Sum_Fields>;
  var_pop: Maybe<VirlocTrackerDevice_Var_Pop_Fields>;
  var_samp: Maybe<VirlocTrackerDevice_Var_Samp_Fields>;
  variance: Maybe<VirlocTrackerDevice_Variance_Fields>;
};


/** aggregate fields of "VirlocTrackerDevice" */
export type VirlocTrackerDevice_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<VirlocTrackerDevice_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type VirlocTrackerDevice_Avg_Fields = {
  __typename?: 'VirlocTrackerDevice_avg_fields';
  EquipmentId: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "VirlocTrackerDevice". All fields are combined with a logical 'AND'. */
export type VirlocTrackerDevice_Bool_Exp = {
  BoardVersion?: InputMaybe<String_Mssql_Comparison_Exp>;
  CANLibraryVersion?: InputMaybe<String_Mssql_Comparison_Exp>;
  CreatedAt?: InputMaybe<Datetimeoffset_Mssql_Comparison_Exp>;
  EquipmentId?: InputMaybe<Int_Mssql_Comparison_Exp>;
  EquipmentSerial?: InputMaybe<String_Mssql_Comparison_Exp>;
  FirmwareVersion?: InputMaybe<String_Mssql_Comparison_Exp>;
  ICCID?: InputMaybe<String_Mssql_Comparison_Exp>;
  Id?: InputMaybe<Int_Mssql_Comparison_Exp>;
  ProtocolVersion?: InputMaybe<String_Mssql_Comparison_Exp>;
  ScriptVersion?: InputMaybe<String_Mssql_Comparison_Exp>;
  TrackerDeviceId?: InputMaybe<String_Mssql_Comparison_Exp>;
  TrackerModel?: InputMaybe<String_Mssql_Comparison_Exp>;
  TrackerSerialNumber?: InputMaybe<String_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<VirlocTrackerDevice_Bool_Exp>>;
  _not?: InputMaybe<VirlocTrackerDevice_Bool_Exp>;
  _or?: InputMaybe<Array<VirlocTrackerDevice_Bool_Exp>>;
};

/** upsert condition type for table "VirlocTrackerDevice" */
export type VirlocTrackerDevice_If_Matched = {
  match_columns?: Array<VirlocTrackerDevice_Insert_Match_Column>;
  update_columns?: Array<VirlocTrackerDevice_Update_Column>;
  where?: InputMaybe<VirlocTrackerDevice_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "VirlocTrackerDevice" */
export type VirlocTrackerDevice_Inc_Input = {
  EquipmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "VirlocTrackerDevice" */
export type VirlocTrackerDevice_Insert_Input = {
  BoardVersion?: InputMaybe<Scalars['String']['input']>;
  CANLibraryVersion?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  EquipmentId?: InputMaybe<Scalars['Int']['input']>;
  EquipmentSerial?: InputMaybe<Scalars['String']['input']>;
  FirmwareVersion?: InputMaybe<Scalars['String']['input']>;
  ICCID?: InputMaybe<Scalars['String']['input']>;
  ProtocolVersion?: InputMaybe<Scalars['String']['input']>;
  ScriptVersion?: InputMaybe<Scalars['String']['input']>;
  TrackerDeviceId?: InputMaybe<Scalars['String']['input']>;
  TrackerModel?: InputMaybe<Scalars['String']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** select match_columns of table "VirlocTrackerDevice" */
export enum VirlocTrackerDevice_Insert_Match_Column {
  /** column name */
  BoardVersion = 'BoardVersion',
  /** column name */
  CanLibraryVersion = 'CANLibraryVersion',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  EquipmentId = 'EquipmentId',
  /** column name */
  EquipmentSerial = 'EquipmentSerial',
  /** column name */
  FirmwareVersion = 'FirmwareVersion',
  /** column name */
  Iccid = 'ICCID',
  /** column name */
  Id = 'Id',
  /** column name */
  ProtocolVersion = 'ProtocolVersion',
  /** column name */
  ScriptVersion = 'ScriptVersion',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceId',
  /** column name */
  TrackerModel = 'TrackerModel',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber'
}

/** aggregate max on columns */
export type VirlocTrackerDevice_Max_Fields = {
  __typename?: 'VirlocTrackerDevice_max_fields';
  BoardVersion: Maybe<Scalars['String']['output']>;
  CANLibraryVersion: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  EquipmentId: Maybe<Scalars['Int']['output']>;
  EquipmentSerial: Maybe<Scalars['String']['output']>;
  FirmwareVersion: Maybe<Scalars['String']['output']>;
  ICCID: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  ProtocolVersion: Maybe<Scalars['String']['output']>;
  ScriptVersion: Maybe<Scalars['String']['output']>;
  TrackerDeviceId: Maybe<Scalars['String']['output']>;
  TrackerModel: Maybe<Scalars['String']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type VirlocTrackerDevice_Min_Fields = {
  __typename?: 'VirlocTrackerDevice_min_fields';
  BoardVersion: Maybe<Scalars['String']['output']>;
  CANLibraryVersion: Maybe<Scalars['String']['output']>;
  CreatedAt: Maybe<Scalars['datetimeoffset']['output']>;
  EquipmentId: Maybe<Scalars['Int']['output']>;
  EquipmentSerial: Maybe<Scalars['String']['output']>;
  FirmwareVersion: Maybe<Scalars['String']['output']>;
  ICCID: Maybe<Scalars['String']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
  ProtocolVersion: Maybe<Scalars['String']['output']>;
  ScriptVersion: Maybe<Scalars['String']['output']>;
  TrackerDeviceId: Maybe<Scalars['String']['output']>;
  TrackerModel: Maybe<Scalars['String']['output']>;
  TrackerSerialNumber: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "VirlocTrackerDevice" */
export type VirlocTrackerDevice_Mutation_Response = {
  __typename?: 'VirlocTrackerDevice_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VirlocTrackerDevice>;
};

/** Ordering options when selecting data from "VirlocTrackerDevice". */
export type VirlocTrackerDevice_Order_By = {
  BoardVersion?: InputMaybe<Order_By>;
  CANLibraryVersion?: InputMaybe<Order_By>;
  CreatedAt?: InputMaybe<Order_By>;
  EquipmentId?: InputMaybe<Order_By>;
  EquipmentSerial?: InputMaybe<Order_By>;
  FirmwareVersion?: InputMaybe<Order_By>;
  ICCID?: InputMaybe<Order_By>;
  Id?: InputMaybe<Order_By>;
  ProtocolVersion?: InputMaybe<Order_By>;
  ScriptVersion?: InputMaybe<Order_By>;
  TrackerDeviceId?: InputMaybe<Order_By>;
  TrackerModel?: InputMaybe<Order_By>;
  TrackerSerialNumber?: InputMaybe<Order_By>;
};

/** primary key columns input for table: VirlocTrackerDevice */
export type VirlocTrackerDevice_Pk_Columns_Input = {
  Id: Scalars['Int']['input'];
};

/** select columns of table "VirlocTrackerDevice" */
export enum VirlocTrackerDevice_Select_Column {
  /** column name */
  BoardVersion = 'BoardVersion',
  /** column name */
  CanLibraryVersion = 'CANLibraryVersion',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  EquipmentId = 'EquipmentId',
  /** column name */
  EquipmentSerial = 'EquipmentSerial',
  /** column name */
  FirmwareVersion = 'FirmwareVersion',
  /** column name */
  Iccid = 'ICCID',
  /** column name */
  Id = 'Id',
  /** column name */
  ProtocolVersion = 'ProtocolVersion',
  /** column name */
  ScriptVersion = 'ScriptVersion',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceId',
  /** column name */
  TrackerModel = 'TrackerModel',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber'
}

/** input type for updating data in table "VirlocTrackerDevice" */
export type VirlocTrackerDevice_Set_Input = {
  BoardVersion?: InputMaybe<Scalars['String']['input']>;
  CANLibraryVersion?: InputMaybe<Scalars['String']['input']>;
  CreatedAt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  EquipmentId?: InputMaybe<Scalars['Int']['input']>;
  EquipmentSerial?: InputMaybe<Scalars['String']['input']>;
  FirmwareVersion?: InputMaybe<Scalars['String']['input']>;
  ICCID?: InputMaybe<Scalars['String']['input']>;
  ProtocolVersion?: InputMaybe<Scalars['String']['input']>;
  ScriptVersion?: InputMaybe<Scalars['String']['input']>;
  TrackerDeviceId?: InputMaybe<Scalars['String']['input']>;
  TrackerModel?: InputMaybe<Scalars['String']['input']>;
  TrackerSerialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type VirlocTrackerDevice_Stddev_Fields = {
  __typename?: 'VirlocTrackerDevice_stddev_fields';
  EquipmentId: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type VirlocTrackerDevice_Stddev_Pop_Fields = {
  __typename?: 'VirlocTrackerDevice_stddev_pop_fields';
  EquipmentId: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type VirlocTrackerDevice_Stddev_Samp_Fields = {
  __typename?: 'VirlocTrackerDevice_stddev_samp_fields';
  EquipmentId: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type VirlocTrackerDevice_Sum_Fields = {
  __typename?: 'VirlocTrackerDevice_sum_fields';
  EquipmentId: Maybe<Scalars['Int']['output']>;
  Id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "VirlocTrackerDevice" */
export enum VirlocTrackerDevice_Update_Column {
  /** column name */
  BoardVersion = 'BoardVersion',
  /** column name */
  CanLibraryVersion = 'CANLibraryVersion',
  /** column name */
  CreatedAt = 'CreatedAt',
  /** column name */
  EquipmentId = 'EquipmentId',
  /** column name */
  EquipmentSerial = 'EquipmentSerial',
  /** column name */
  FirmwareVersion = 'FirmwareVersion',
  /** column name */
  Iccid = 'ICCID',
  /** column name */
  ProtocolVersion = 'ProtocolVersion',
  /** column name */
  ScriptVersion = 'ScriptVersion',
  /** column name */
  TrackerDeviceId = 'TrackerDeviceId',
  /** column name */
  TrackerModel = 'TrackerModel',
  /** column name */
  TrackerSerialNumber = 'TrackerSerialNumber'
}

/** aggregate var_pop on columns */
export type VirlocTrackerDevice_Var_Pop_Fields = {
  __typename?: 'VirlocTrackerDevice_var_pop_fields';
  EquipmentId: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type VirlocTrackerDevice_Var_Samp_Fields = {
  __typename?: 'VirlocTrackerDevice_var_samp_fields';
  EquipmentId: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type VirlocTrackerDevice_Variance_Fields = {
  __typename?: 'VirlocTrackerDevice_variance_fields';
  EquipmentId: Maybe<Scalars['Float']['output']>;
  Id: Maybe<Scalars['Float']['output']>;
};

export type WrongDataTrips = {
  __typename?: 'WrongDataTrips';
  CodMotorista: Maybe<Scalars['String']['output']>;
  FimViagem: Maybe<Scalars['timestamptz']['output']>;
  InicioViagem: Maybe<Scalars['timestamptz']['output']>;
  LitrosCobranca: Maybe<Scalars['Float']['output']>;
  LitrosPrevistos: Maybe<Scalars['Float']['output']>;
  PesoTotal: Maybe<Scalars['Int']['output']>;
  ViagemId: Maybe<Scalars['Int']['output']>;
  dias_de_viagem: Maybe<Scalars['Int']['output']>;
  km: Maybe<Scalars['Float']['output']>;
  km_por_dia_aproximado: Maybe<Scalars['Int']['output']>;
  placa: Maybe<Scalars['String']['output']>;
};

/** columns and relationships of "achievement" */
export type Achievement = {
  __typename?: 'achievement';
  created_at: Scalars['timestamptz']['output'];
  description: Scalars['String']['output'];
  image_url: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload: Scalars['jsonb']['output'];
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Int']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Int']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  scoreTypeByScoreType: Maybe<Score_Type>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  user_fk_achievements: Array<User_Fk_Achievement>;
  /** An aggregate relationship */
  user_fk_achievements_aggregate: User_Fk_Achievement_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "achievement" */
export type AchievementNotification_Template_PayloadArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "achievement" */
export type AchievementUser_Fk_AchievementsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


/** columns and relationships of "achievement" */
export type AchievementUser_Fk_Achievements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};

/** aggregated selection of "achievement" */
export type Achievement_Aggregate = {
  __typename?: 'achievement_aggregate';
  aggregate: Maybe<Achievement_Aggregate_Fields>;
  nodes: Array<Achievement>;
};

export type Achievement_Aggregate_Bool_Exp = {
  count?: InputMaybe<Achievement_Aggregate_Bool_Exp_Count>;
};

export type Achievement_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Achievement_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "achievement" */
export type Achievement_Aggregate_Fields = {
  __typename?: 'achievement_aggregate_fields';
  avg: Maybe<Achievement_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Achievement_Max_Fields>;
  min: Maybe<Achievement_Min_Fields>;
  stddev: Maybe<Achievement_Stddev_Fields>;
  stddev_pop: Maybe<Achievement_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Achievement_Stddev_Samp_Fields>;
  sum: Maybe<Achievement_Sum_Fields>;
  var_pop: Maybe<Achievement_Var_Pop_Fields>;
  var_samp: Maybe<Achievement_Var_Samp_Fields>;
  variance: Maybe<Achievement_Variance_Fields>;
};


/** aggregate fields of "achievement" */
export type Achievement_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "achievement" */
export type Achievement_Aggregate_Order_By = {
  avg?: InputMaybe<Achievement_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Achievement_Max_Order_By>;
  min?: InputMaybe<Achievement_Min_Order_By>;
  stddev?: InputMaybe<Achievement_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Achievement_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Achievement_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Achievement_Sum_Order_By>;
  var_pop?: InputMaybe<Achievement_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Achievement_Var_Samp_Order_By>;
  variance?: InputMaybe<Achievement_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Achievement_Append_Input = {
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "achievement" */
export type Achievement_Arr_Rel_Insert_Input = {
  data: Array<Achievement_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Achievement_On_Conflict>;
};

/** aggregate avg on columns */
export type Achievement_Avg_Fields = {
  __typename?: 'achievement_avg_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Float']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Float']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "achievement" */
export type Achievement_Avg_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "achievement". All fields are combined with a logical 'AND'. */
export type Achievement_Bool_Exp = {
  _and?: InputMaybe<Array<Achievement_Bool_Exp>>;
  _not?: InputMaybe<Achievement_Bool_Exp>;
  _or?: InputMaybe<Array<Achievement_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  image_url?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notification_template_payload?: InputMaybe<Jsonb_Comparison_Exp>;
  ranking_min_position?: InputMaybe<Int_Comparison_Exp>;
  ranking_min_score?: InputMaybe<Int_Comparison_Exp>;
  ranking_position?: InputMaybe<Int_Comparison_Exp>;
  scoreTypeByScoreType?: InputMaybe<Score_Type_Bool_Exp>;
  score_type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_fk_achievements?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
  user_fk_achievements_aggregate?: InputMaybe<User_Fk_Achievement_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "achievement" */
export enum Achievement_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  AchievementPkey = 'achievement_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Achievement_Delete_At_Path_Input = {
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Achievement_Delete_Elem_Input = {
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Achievement_Delete_Key_Input = {
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "achievement" */
export type Achievement_Inc_Input = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Scalars['Int']['input']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Scalars['Int']['input']>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "achievement" */
export type Achievement_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Scalars['jsonb']['input']>;
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Scalars['Int']['input']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Scalars['Int']['input']>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Scalars['Int']['input']>;
  scoreTypeByScoreType?: InputMaybe<Score_Type_Obj_Rel_Insert_Input>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_fk_achievements?: InputMaybe<User_Fk_Achievement_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Achievement_Max_Fields = {
  __typename?: 'achievement_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  image_url: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Int']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Int']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Int']['output']>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "achievement" */
export type Achievement_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  image_url?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Achievement_Min_Fields = {
  __typename?: 'achievement_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  image_url: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Int']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Int']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Int']['output']>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "achievement" */
export type Achievement_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  image_url?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "achievement" */
export type Achievement_Mutation_Response = {
  __typename?: 'achievement_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Achievement>;
};

/** input type for inserting object relation for remote table "achievement" */
export type Achievement_Obj_Rel_Insert_Input = {
  data: Achievement_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Achievement_On_Conflict>;
};

/** on_conflict condition type for table "achievement" */
export type Achievement_On_Conflict = {
  constraint: Achievement_Constraint;
  update_columns?: Array<Achievement_Update_Column>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};

/** Ordering options when selecting data from "achievement". */
export type Achievement_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  image_url?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notification_template_payload?: InputMaybe<Order_By>;
  ranking_min_position?: InputMaybe<Order_By>;
  ranking_min_score?: InputMaybe<Order_By>;
  ranking_position?: InputMaybe<Order_By>;
  scoreTypeByScoreType?: InputMaybe<Score_Type_Order_By>;
  score_type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_fk_achievements_aggregate?: InputMaybe<User_Fk_Achievement_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: achievement */
export type Achievement_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Achievement_Prepend_Input = {
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "achievement" */
export enum Achievement_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  NotificationTemplatePayload = 'notification_template_payload',
  /** column name */
  RankingMinPosition = 'ranking_min_position',
  /** column name */
  RankingMinScore = 'ranking_min_score',
  /** column name */
  RankingPosition = 'ranking_position',
  /** column name */
  ScoreType = 'score_type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "achievement" */
export type Achievement_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Scalars['jsonb']['input']>;
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Scalars['Int']['input']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Scalars['Int']['input']>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Scalars['Int']['input']>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Achievement_Stddev_Fields = {
  __typename?: 'achievement_stddev_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Float']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Float']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "achievement" */
export type Achievement_Stddev_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Achievement_Stddev_Pop_Fields = {
  __typename?: 'achievement_stddev_pop_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Float']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Float']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "achievement" */
export type Achievement_Stddev_Pop_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Achievement_Stddev_Samp_Fields = {
  __typename?: 'achievement_stddev_samp_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Float']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Float']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "achievement" */
export type Achievement_Stddev_Samp_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "achievement" */
export type Achievement_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Achievement_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Achievement_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** The template that will be used to send the OneSignal notification. Uses postgres formatting to fill the %s patterns. %1$s is the month in pt, %2$s is the position on ranking, %3$s is the note */
  notification_template_payload?: InputMaybe<Scalars['jsonb']['input']>;
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Scalars['Int']['input']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Scalars['Int']['input']>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Scalars['Int']['input']>;
  /** For which score_type this achievement is related to (daily, monthly) */
  score_type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Achievement_Sum_Fields = {
  __typename?: 'achievement_sum_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Int']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Int']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "achievement" */
export type Achievement_Sum_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** update columns of table "achievement" */
export enum Achievement_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  NotificationTemplatePayload = 'notification_template_payload',
  /** column name */
  RankingMinPosition = 'ranking_min_position',
  /** column name */
  RankingMinScore = 'ranking_min_score',
  /** column name */
  RankingPosition = 'ranking_position',
  /** column name */
  ScoreType = 'score_type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Achievement_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Achievement_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Achievement_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Achievement_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Achievement_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Achievement_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Achievement_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Achievement_Set_Input>;
  /** filter the rows which have to be updated */
  where: Achievement_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Achievement_Var_Pop_Fields = {
  __typename?: 'achievement_var_pop_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Float']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Float']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "achievement" */
export type Achievement_Var_Pop_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Achievement_Var_Samp_Fields = {
  __typename?: 'achievement_var_samp_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Float']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Float']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "achievement" */
export type Achievement_Var_Samp_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Achievement_Variance_Fields = {
  __typename?: 'achievement_variance_fields';
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position: Maybe<Scalars['Float']['output']>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score: Maybe<Scalars['Float']['output']>;
  /** The ranking position of the user to get this achievement */
  ranking_position: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "achievement" */
export type Achievement_Variance_Order_By = {
  /** The minimum position to get this achievement. It's exclusive with ranking* columns only one can be set at the same time. The condition is <= */
  ranking_min_position?: InputMaybe<Order_By>;
  /** The minimum score to get this achievement. It's exclusive with ranking*, only one can be set at the same time. The condition is >= */
  ranking_min_score?: InputMaybe<Order_By>;
  /** The ranking position of the user to get this achievement */
  ranking_position?: InputMaybe<Order_By>;
};

/** columns and relationships of "admin" */
export type Admin = {
  __typename?: 'admin';
  /** An array relationship */
  admin_fk_notifications: Array<Admin_Fk_Notifications>;
  /** An aggregate relationship */
  admin_fk_notifications_aggregate: Admin_Fk_Notifications_Aggregate;
  /** An array relationship */
  admin_fk_profiles: Array<Admin_Fk_Profile>;
  /** An aggregate relationship */
  admin_fk_profiles_aggregate: Admin_Fk_Profile_Aggregate;
  /** An array relationship */
  admin_permissions: Array<Admin_Permission>;
  /** An aggregate relationship */
  admin_permissions_aggregate: Admin_Permission_Aggregate;
  avatar_url: Scalars['String']['output'];
  /** The cpf of the admin, used for login in the app */
  cpf: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  driver_warning_comments: Array<Driver_Warning_Comment>;
  /** An aggregate relationship */
  driver_warning_comments_aggregate: Driver_Warning_Comment_Aggregate;
  email: Scalars['String']['output'];
  /** If the admin can access the panel */
  enabled: Scalars['Boolean']['output'];
  /** An array relationship */
  instructorSupervisionsByInstructorUuid: Array<Instructor_Supervision>;
  /** An aggregate relationship */
  instructorSupervisionsByInstructorUuid_aggregate: Instructor_Supervision_Aggregate;
  /** An array relationship */
  instructor_supervisions: Array<Instructor_Supervision>;
  /** An aggregate relationship */
  instructor_supervisions_aggregate: Instructor_Supervision_Aggregate;
  name: Scalars['String']['output'];
  /** An array relationship */
  notifications: Array<Notification>;
  /** An aggregate relationship */
  notifications_aggregate: Notification_Aggregate;
  /** Password of the admin. Used to access the panel. It's a hash + salt */
  password: Scalars['String']['output'];
  /** An array relationship */
  product_requests: Array<Product_Request>;
  /** An aggregate relationship */
  product_requests_aggregate: Product_Request_Aggregate;
  /** An array relationship */
  recognized_deliveries: Array<Delivery>;
  /** An aggregate relationship */
  recognized_deliveries_aggregate: Delivery_Aggregate;
  /** An array relationship */
  refresh_tokens: Array<Refresh_Token>;
  /** An aggregate relationship */
  refresh_tokens_aggregate: Refresh_Token_Aggregate;
  updated_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  user_km_points_approvals: Array<User_Km_Points_Approval>;
  /** An aggregate relationship */
  user_km_points_approvals_aggregate: User_Km_Points_Approval_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "admin" */
export type AdminAdmin_Fk_NotificationsArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminAdmin_Fk_Notifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminAdmin_Fk_ProfilesArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminAdmin_Fk_Profiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminAdmin_PermissionsArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminAdmin_Permissions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminDriver_Warning_CommentsArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminDriver_Warning_Comments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminInstructorSupervisionsByInstructorUuidArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminInstructorSupervisionsByInstructorUuid_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminInstructor_SupervisionsArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminInstructor_Supervisions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminNotificationsArgs = {
  distinct_on?: InputMaybe<Array<Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notification_Order_By>>;
  where?: InputMaybe<Notification_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminNotifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notification_Order_By>>;
  where?: InputMaybe<Notification_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminProduct_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminProduct_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminRecognized_DeliveriesArgs = {
  distinct_on?: InputMaybe<Array<Delivery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Delivery_Order_By>>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminRecognized_Deliveries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Delivery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Delivery_Order_By>>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminRefresh_TokensArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminRefresh_Tokens_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminUser_Km_Points_ApprovalsArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


/** columns and relationships of "admin" */
export type AdminUser_Km_Points_Approvals_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};

/** aggregated selection of "admin" */
export type Admin_Aggregate = {
  __typename?: 'admin_aggregate';
  aggregate: Maybe<Admin_Aggregate_Fields>;
  nodes: Array<Admin>;
};

/** aggregate fields of "admin" */
export type Admin_Aggregate_Fields = {
  __typename?: 'admin_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Admin_Max_Fields>;
  min: Maybe<Admin_Min_Fields>;
};


/** aggregate fields of "admin" */
export type Admin_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Admin_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "admin". All fields are combined with a logical 'AND'. */
export type Admin_Bool_Exp = {
  _and?: InputMaybe<Array<Admin_Bool_Exp>>;
  _not?: InputMaybe<Admin_Bool_Exp>;
  _or?: InputMaybe<Array<Admin_Bool_Exp>>;
  admin_fk_notifications?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
  admin_fk_notifications_aggregate?: InputMaybe<Admin_Fk_Notifications_Aggregate_Bool_Exp>;
  admin_fk_profiles?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
  admin_fk_profiles_aggregate?: InputMaybe<Admin_Fk_Profile_Aggregate_Bool_Exp>;
  admin_permissions?: InputMaybe<Admin_Permission_Bool_Exp>;
  admin_permissions_aggregate?: InputMaybe<Admin_Permission_Aggregate_Bool_Exp>;
  avatar_url?: InputMaybe<String_Comparison_Exp>;
  cpf?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver_warning_comments?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
  driver_warning_comments_aggregate?: InputMaybe<Driver_Warning_Comment_Aggregate_Bool_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  enabled?: InputMaybe<Boolean_Comparison_Exp>;
  instructorSupervisionsByInstructorUuid?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  instructorSupervisionsByInstructorUuid_aggregate?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp>;
  instructor_supervisions?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  instructor_supervisions_aggregate?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notifications?: InputMaybe<Notification_Bool_Exp>;
  notifications_aggregate?: InputMaybe<Notification_Aggregate_Bool_Exp>;
  password?: InputMaybe<String_Comparison_Exp>;
  product_requests?: InputMaybe<Product_Request_Bool_Exp>;
  product_requests_aggregate?: InputMaybe<Product_Request_Aggregate_Bool_Exp>;
  recognized_deliveries?: InputMaybe<Delivery_Bool_Exp>;
  recognized_deliveries_aggregate?: InputMaybe<Delivery_Aggregate_Bool_Exp>;
  refresh_tokens?: InputMaybe<Refresh_Token_Bool_Exp>;
  refresh_tokens_aggregate?: InputMaybe<Refresh_Token_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_km_points_approvals?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  user_km_points_approvals_aggregate?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "admin" */
export enum Admin_Constraint {
  /** unique or primary key constraint on columns "email" */
  AdminEmailKey = 'admin_email_key',
  /** unique or primary key constraint on columns "uuid" */
  AdminPkey = 'admin_pkey'
}

/** Admins that will receive a specific notification. Same as user_fk_notification but for admins */
export type Admin_Fk_Notifications = {
  __typename?: 'admin_fk_notifications';
  /** An object relationship */
  admin: Admin;
  admin_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  notification: Notification;
  notification_uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "admin_fk_notifications" */
export type Admin_Fk_Notifications_Aggregate = {
  __typename?: 'admin_fk_notifications_aggregate';
  aggregate: Maybe<Admin_Fk_Notifications_Aggregate_Fields>;
  nodes: Array<Admin_Fk_Notifications>;
};

export type Admin_Fk_Notifications_Aggregate_Bool_Exp = {
  count?: InputMaybe<Admin_Fk_Notifications_Aggregate_Bool_Exp_Count>;
};

export type Admin_Fk_Notifications_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "admin_fk_notifications" */
export type Admin_Fk_Notifications_Aggregate_Fields = {
  __typename?: 'admin_fk_notifications_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Admin_Fk_Notifications_Max_Fields>;
  min: Maybe<Admin_Fk_Notifications_Min_Fields>;
};


/** aggregate fields of "admin_fk_notifications" */
export type Admin_Fk_Notifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Admin_Fk_Notifications_Max_Order_By>;
  min?: InputMaybe<Admin_Fk_Notifications_Min_Order_By>;
};

/** input type for inserting array relation for remote table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Arr_Rel_Insert_Input = {
  data: Array<Admin_Fk_Notifications_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Admin_Fk_Notifications_On_Conflict>;
};

/** Boolean expression to filter rows from the table "admin_fk_notifications". All fields are combined with a logical 'AND'. */
export type Admin_Fk_Notifications_Bool_Exp = {
  _and?: InputMaybe<Array<Admin_Fk_Notifications_Bool_Exp>>;
  _not?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
  _or?: InputMaybe<Array<Admin_Fk_Notifications_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  notification?: InputMaybe<Notification_Bool_Exp>;
  notification_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "admin_fk_notifications" */
export enum Admin_Fk_Notifications_Constraint {
  /** unique or primary key constraint on columns "admin_uuid", "notification_uuid" */
  AdminFkNotificationsPkey = 'admin_fk_notifications_pkey'
}

/** input type for inserting data into table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  notification?: InputMaybe<Notification_Obj_Rel_Insert_Input>;
  notification_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Admin_Fk_Notifications_Max_Fields = {
  __typename?: 'admin_fk_notifications_max_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  notification_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Max_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  notification_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Admin_Fk_Notifications_Min_Fields = {
  __typename?: 'admin_fk_notifications_min_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  notification_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Min_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  notification_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Mutation_Response = {
  __typename?: 'admin_fk_notifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Admin_Fk_Notifications>;
};

/** on_conflict condition type for table "admin_fk_notifications" */
export type Admin_Fk_Notifications_On_Conflict = {
  constraint: Admin_Fk_Notifications_Constraint;
  update_columns?: Array<Admin_Fk_Notifications_Update_Column>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};

/** Ordering options when selecting data from "admin_fk_notifications". */
export type Admin_Fk_Notifications_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  notification?: InputMaybe<Notification_Order_By>;
  notification_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: admin_fk_notifications */
export type Admin_Fk_Notifications_Pk_Columns_Input = {
  admin_uuid: Scalars['uuid']['input'];
  notification_uuid: Scalars['uuid']['input'];
};

/** select columns of table "admin_fk_notifications" */
export enum Admin_Fk_Notifications_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  NotificationUuid = 'notification_uuid'
}

/** input type for updating data in table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Set_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  notification_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "admin_fk_notifications" */
export type Admin_Fk_Notifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Admin_Fk_Notifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Admin_Fk_Notifications_Stream_Cursor_Value_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  notification_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "admin_fk_notifications" */
export enum Admin_Fk_Notifications_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  NotificationUuid = 'notification_uuid'
}

export type Admin_Fk_Notifications_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Admin_Fk_Notifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Admin_Fk_Notifications_Bool_Exp;
};

/** columns and relationships of "admin_fk_profile" */
export type Admin_Fk_Profile = {
  __typename?: 'admin_fk_profile';
  /** An object relationship */
  admin: Admin;
  admin_uuid: Scalars['uuid']['output'];
  created_at: Scalars['timestamptz']['output'];
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  profile: Profile;
  profile_uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "admin_fk_profile" */
export type Admin_Fk_Profile_Aggregate = {
  __typename?: 'admin_fk_profile_aggregate';
  aggregate: Maybe<Admin_Fk_Profile_Aggregate_Fields>;
  nodes: Array<Admin_Fk_Profile>;
};

export type Admin_Fk_Profile_Aggregate_Bool_Exp = {
  count?: InputMaybe<Admin_Fk_Profile_Aggregate_Bool_Exp_Count>;
};

export type Admin_Fk_Profile_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "admin_fk_profile" */
export type Admin_Fk_Profile_Aggregate_Fields = {
  __typename?: 'admin_fk_profile_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Admin_Fk_Profile_Max_Fields>;
  min: Maybe<Admin_Fk_Profile_Min_Fields>;
};


/** aggregate fields of "admin_fk_profile" */
export type Admin_Fk_Profile_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "admin_fk_profile" */
export type Admin_Fk_Profile_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Admin_Fk_Profile_Max_Order_By>;
  min?: InputMaybe<Admin_Fk_Profile_Min_Order_By>;
};

/** input type for inserting array relation for remote table "admin_fk_profile" */
export type Admin_Fk_Profile_Arr_Rel_Insert_Input = {
  data: Array<Admin_Fk_Profile_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Admin_Fk_Profile_On_Conflict>;
};

/** Boolean expression to filter rows from the table "admin_fk_profile". All fields are combined with a logical 'AND'. */
export type Admin_Fk_Profile_Bool_Exp = {
  _and?: InputMaybe<Array<Admin_Fk_Profile_Bool_Exp>>;
  _not?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
  _or?: InputMaybe<Array<Admin_Fk_Profile_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deleted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "admin_fk_profile" */
export enum Admin_Fk_Profile_Constraint {
  /** unique or primary key constraint on columns "admin_uuid", "created_at", "profile_uuid" */
  AdminFkProfilePkey = 'admin_fk_profile_pkey'
}

/** input type for inserting data into table "admin_fk_profile" */
export type Admin_Fk_Profile_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Admin_Fk_Profile_Max_Fields = {
  __typename?: 'admin_fk_profile_max_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  profile_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "admin_fk_profile" */
export type Admin_Fk_Profile_Max_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  profile_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Admin_Fk_Profile_Min_Fields = {
  __typename?: 'admin_fk_profile_min_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  profile_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "admin_fk_profile" */
export type Admin_Fk_Profile_Min_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  profile_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "admin_fk_profile" */
export type Admin_Fk_Profile_Mutation_Response = {
  __typename?: 'admin_fk_profile_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Admin_Fk_Profile>;
};

/** on_conflict condition type for table "admin_fk_profile" */
export type Admin_Fk_Profile_On_Conflict = {
  constraint: Admin_Fk_Profile_Constraint;
  update_columns?: Array<Admin_Fk_Profile_Update_Column>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};

/** Ordering options when selecting data from "admin_fk_profile". */
export type Admin_Fk_Profile_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: admin_fk_profile */
export type Admin_Fk_Profile_Pk_Columns_Input = {
  admin_uuid: Scalars['uuid']['input'];
  created_at: Scalars['timestamptz']['input'];
  profile_uuid: Scalars['uuid']['input'];
};

/** select columns of table "admin_fk_profile" */
export enum Admin_Fk_Profile_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  ProfileUuid = 'profile_uuid'
}

/** input type for updating data in table "admin_fk_profile" */
export type Admin_Fk_Profile_Set_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  profile_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "admin_fk_profile" */
export type Admin_Fk_Profile_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Admin_Fk_Profile_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Admin_Fk_Profile_Stream_Cursor_Value_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  profile_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "admin_fk_profile" */
export enum Admin_Fk_Profile_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  ProfileUuid = 'profile_uuid'
}

export type Admin_Fk_Profile_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Admin_Fk_Profile_Set_Input>;
  /** filter the rows which have to be updated */
  where: Admin_Fk_Profile_Bool_Exp;
};

/** input type for inserting data into table "admin" */
export type Admin_Insert_Input = {
  admin_fk_notifications?: InputMaybe<Admin_Fk_Notifications_Arr_Rel_Insert_Input>;
  admin_fk_profiles?: InputMaybe<Admin_Fk_Profile_Arr_Rel_Insert_Input>;
  admin_permissions?: InputMaybe<Admin_Permission_Arr_Rel_Insert_Input>;
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  /** The cpf of the admin, used for login in the app */
  cpf?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_comments?: InputMaybe<Driver_Warning_Comment_Arr_Rel_Insert_Input>;
  email?: InputMaybe<Scalars['String']['input']>;
  /** If the admin can access the panel */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  instructorSupervisionsByInstructorUuid?: InputMaybe<Instructor_Supervision_Arr_Rel_Insert_Input>;
  instructor_supervisions?: InputMaybe<Instructor_Supervision_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  notifications?: InputMaybe<Notification_Arr_Rel_Insert_Input>;
  /** Password of the admin. Used to access the panel. It's a hash + salt */
  password?: InputMaybe<Scalars['String']['input']>;
  product_requests?: InputMaybe<Product_Request_Arr_Rel_Insert_Input>;
  recognized_deliveries?: InputMaybe<Delivery_Arr_Rel_Insert_Input>;
  refresh_tokens?: InputMaybe<Refresh_Token_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_km_points_approvals?: InputMaybe<User_Km_Points_Approval_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Admin_Max_Fields = {
  __typename?: 'admin_max_fields';
  avatar_url: Maybe<Scalars['String']['output']>;
  /** The cpf of the admin, used for login in the app */
  cpf: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  email: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  /** Password of the admin. Used to access the panel. It's a hash + salt */
  password: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Admin_Min_Fields = {
  __typename?: 'admin_min_fields';
  avatar_url: Maybe<Scalars['String']['output']>;
  /** The cpf of the admin, used for login in the app */
  cpf: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  email: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  /** Password of the admin. Used to access the panel. It's a hash + salt */
  password: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "admin" */
export type Admin_Mutation_Response = {
  __typename?: 'admin_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Admin>;
};

/** input type for inserting object relation for remote table "admin" */
export type Admin_Obj_Rel_Insert_Input = {
  data: Admin_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Admin_On_Conflict>;
};

/** on_conflict condition type for table "admin" */
export type Admin_On_Conflict = {
  constraint: Admin_Constraint;
  update_columns?: Array<Admin_Update_Column>;
  where?: InputMaybe<Admin_Bool_Exp>;
};

/** Ordering options when selecting data from "admin". */
export type Admin_Order_By = {
  admin_fk_notifications_aggregate?: InputMaybe<Admin_Fk_Notifications_Aggregate_Order_By>;
  admin_fk_profiles_aggregate?: InputMaybe<Admin_Fk_Profile_Aggregate_Order_By>;
  admin_permissions_aggregate?: InputMaybe<Admin_Permission_Aggregate_Order_By>;
  avatar_url?: InputMaybe<Order_By>;
  cpf?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning_comments_aggregate?: InputMaybe<Driver_Warning_Comment_Aggregate_Order_By>;
  email?: InputMaybe<Order_By>;
  enabled?: InputMaybe<Order_By>;
  instructorSupervisionsByInstructorUuid_aggregate?: InputMaybe<Instructor_Supervision_Aggregate_Order_By>;
  instructor_supervisions_aggregate?: InputMaybe<Instructor_Supervision_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  notifications_aggregate?: InputMaybe<Notification_Aggregate_Order_By>;
  password?: InputMaybe<Order_By>;
  product_requests_aggregate?: InputMaybe<Product_Request_Aggregate_Order_By>;
  recognized_deliveries_aggregate?: InputMaybe<Delivery_Aggregate_Order_By>;
  refresh_tokens_aggregate?: InputMaybe<Refresh_Token_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_km_points_approvals_aggregate?: InputMaybe<User_Km_Points_Approval_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** columns and relationships of "admin_permission" */
export type Admin_Permission = {
  __typename?: 'admin_permission';
  /** An object relationship */
  admin: Admin;
  admin_uuid: Scalars['uuid']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** If the admin has this permission or not */
  enabled: Scalars['Boolean']['output'];
  /** An object relationship */
  module: Module;
  /** Name of the module which this permission belongs too */
  module_name: Scalars['String']['output'];
  /** Name of the permission */
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "admin_permission" */
export type Admin_Permission_Aggregate = {
  __typename?: 'admin_permission_aggregate';
  aggregate: Maybe<Admin_Permission_Aggregate_Fields>;
  nodes: Array<Admin_Permission>;
};

export type Admin_Permission_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Admin_Permission_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Admin_Permission_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Admin_Permission_Aggregate_Bool_Exp_Count>;
};

export type Admin_Permission_Aggregate_Bool_Exp_Bool_And = {
  arguments: Admin_Permission_Select_Column_Admin_Permission_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Admin_Permission_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Admin_Permission_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Admin_Permission_Select_Column_Admin_Permission_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Admin_Permission_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Admin_Permission_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Admin_Permission_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "admin_permission" */
export type Admin_Permission_Aggregate_Fields = {
  __typename?: 'admin_permission_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Admin_Permission_Max_Fields>;
  min: Maybe<Admin_Permission_Min_Fields>;
};


/** aggregate fields of "admin_permission" */
export type Admin_Permission_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "admin_permission" */
export type Admin_Permission_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Admin_Permission_Max_Order_By>;
  min?: InputMaybe<Admin_Permission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "admin_permission" */
export type Admin_Permission_Arr_Rel_Insert_Input = {
  data: Array<Admin_Permission_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Admin_Permission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "admin_permission". All fields are combined with a logical 'AND'. */
export type Admin_Permission_Bool_Exp = {
  _and?: InputMaybe<Array<Admin_Permission_Bool_Exp>>;
  _not?: InputMaybe<Admin_Permission_Bool_Exp>;
  _or?: InputMaybe<Array<Admin_Permission_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  enabled?: InputMaybe<Boolean_Comparison_Exp>;
  module?: InputMaybe<Module_Bool_Exp>;
  module_name?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "admin_permission" */
export enum Admin_Permission_Constraint {
  /** unique or primary key constraint on columns "admin_uuid", "name" */
  AdminPermissionPkey = 'admin_permission_pkey'
}

/** input type for inserting data into table "admin_permission" */
export type Admin_Permission_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the admin has this permission or not */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  module?: InputMaybe<Module_Obj_Rel_Insert_Input>;
  /** Name of the module which this permission belongs too */
  module_name?: InputMaybe<Scalars['String']['input']>;
  /** Name of the permission */
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Admin_Permission_Max_Fields = {
  __typename?: 'admin_permission_max_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Name of the module which this permission belongs too */
  module_name: Maybe<Scalars['String']['output']>;
  /** Name of the permission */
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "admin_permission" */
export type Admin_Permission_Max_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** Name of the module which this permission belongs too */
  module_name?: InputMaybe<Order_By>;
  /** Name of the permission */
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Admin_Permission_Min_Fields = {
  __typename?: 'admin_permission_min_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Name of the module which this permission belongs too */
  module_name: Maybe<Scalars['String']['output']>;
  /** Name of the permission */
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "admin_permission" */
export type Admin_Permission_Min_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** Name of the module which this permission belongs too */
  module_name?: InputMaybe<Order_By>;
  /** Name of the permission */
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "admin_permission" */
export type Admin_Permission_Mutation_Response = {
  __typename?: 'admin_permission_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Admin_Permission>;
};

/** on_conflict condition type for table "admin_permission" */
export type Admin_Permission_On_Conflict = {
  constraint: Admin_Permission_Constraint;
  update_columns?: Array<Admin_Permission_Update_Column>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};

/** Ordering options when selecting data from "admin_permission". */
export type Admin_Permission_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  enabled?: InputMaybe<Order_By>;
  module?: InputMaybe<Module_Order_By>;
  module_name?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: admin_permission */
export type Admin_Permission_Pk_Columns_Input = {
  admin_uuid: Scalars['uuid']['input'];
  /** Name of the permission */
  name: Scalars['String']['input'];
};

/** select columns of table "admin_permission" */
export enum Admin_Permission_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  ModuleName = 'module_name',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "admin_permission_aggregate_bool_exp_bool_and_arguments_columns" columns of table "admin_permission" */
export enum Admin_Permission_Select_Column_Admin_Permission_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Enabled = 'enabled'
}

/** select "admin_permission_aggregate_bool_exp_bool_or_arguments_columns" columns of table "admin_permission" */
export enum Admin_Permission_Select_Column_Admin_Permission_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Enabled = 'enabled'
}

/** input type for updating data in table "admin_permission" */
export type Admin_Permission_Set_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the admin has this permission or not */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the module which this permission belongs too */
  module_name?: InputMaybe<Scalars['String']['input']>;
  /** Name of the permission */
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "admin_permission" */
export type Admin_Permission_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Admin_Permission_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Admin_Permission_Stream_Cursor_Value_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the admin has this permission or not */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the module which this permission belongs too */
  module_name?: InputMaybe<Scalars['String']['input']>;
  /** Name of the permission */
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "admin_permission" */
export enum Admin_Permission_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  ModuleName = 'module_name',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Admin_Permission_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Admin_Permission_Set_Input>;
  /** filter the rows which have to be updated */
  where: Admin_Permission_Bool_Exp;
};

/** primary key columns input for table: admin */
export type Admin_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "admin" */
export enum Admin_Select_Column {
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  Cpf = 'cpf',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Name = 'name',
  /** column name */
  Password = 'password',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "admin" */
export type Admin_Set_Input = {
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  /** The cpf of the admin, used for login in the app */
  cpf?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  /** If the admin can access the panel */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Password of the admin. Used to access the panel. It's a hash + salt */
  password?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "admin" */
export type Admin_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Admin_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Admin_Stream_Cursor_Value_Input = {
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  /** The cpf of the admin, used for login in the app */
  cpf?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  /** If the admin can access the panel */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Password of the admin. Used to access the panel. It's a hash + salt */
  password?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "admin" */
export enum Admin_Update_Column {
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  Cpf = 'cpf',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Name = 'name',
  /** column name */
  Password = 'password',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Admin_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Admin_Set_Input>;
  /** filter the rows which have to be updated */
  where: Admin_Bool_Exp;
};

/** columns and relationships of "auto" */
export type Auto = {
  __typename?: 'auto';
  DtValidaUltContManu: Maybe<Scalars['datetime']['output']>;
  KmBaseContManu: Maybe<Scalars['Int']['output']>;
  KmUltContManu: Maybe<Scalars['Int']['output']>;
  NumeroAET: Maybe<Scalars['String']['output']>;
  TamanhoAET: Maybe<Scalars['String']['output']>;
  TipoAlugado: Maybe<Scalars['String']['output']>;
  agregadorastreamentoibor: Scalars['Boolean']['output'];
  anof: Maybe<Scalars['String']['output']>;
  anom: Maybe<Scalars['String']['output']>;
  apolice: Maybe<Scalars['String']['output']>;
  arla32: Maybe<Scalars['String']['output']>;
  ativo: Maybe<Scalars['String']['output']>;
  baterias: Maybe<Scalars['Int']['output']>;
  bonusdm: Maybe<Scalars['Int']['output']>;
  cacamba: Maybe<Scalars['String']['output']>;
  capac: Scalars['Int']['output'];
  capacidadetanque: Maybe<Scalars['Int']['output']>;
  carbkp: Maybe<Scalars['Boolean']['output']>;
  chassi: Scalars['String']['output'];
  cia: Maybe<Scalars['String']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  codmoto: Maybe<Scalars['String']['output']>;
  codprop: Maybe<Scalars['String']['output']>;
  combu: Maybe<Scalars['String']['output']>;
  contmanu: Maybe<Scalars['Boolean']['output']>;
  contmanunacional: Scalars['Boolean']['output'];
  controlerota: Maybe<Scalars['Boolean']['output']>;
  cor: Maybe<Scalars['String']['output']>;
  dataInicioVolvoConnect: Maybe<Scalars['datetime']['output']>;
  dataenttec: Maybe<Scalars['datetime']['output']>;
  datapedagio: Maybe<Scalars['datetime']['output']>;
  digvel: Maybe<Scalars['Int']['output']>;
  digveldata: Maybe<Scalars['datetime']['output']>;
  discofreio: Maybe<Scalars['String']['output']>;
  dtVeriTacografo: Maybe<Scalars['datetime']['output']>;
  dtfimmanu: Maybe<Scalars['datetime']['output']>;
  dtinimanu: Maybe<Scalars['datetime']['output']>;
  dtmanutcompleta: Maybe<Scalars['date']['output']>;
  encerrante: Maybe<Scalars['Boolean']['output']>;
  especie: Scalars['String']['output'];
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Int']['output']>;
  funcionario: Maybe<Scalars['String']['output']>;
  ibuttons: Maybe<Scalars['String']['output']>;
  isVolvoConnect: Maybe<Scalars['Boolean']['output']>;
  kmalugadoparcial: Maybe<Scalars['Int']['output']>;
  kmman: Maybe<Scalars['Int']['output']>;
  kmrevisao: Maybe<Scalars['Int']['output']>;
  kmrodado: Maybe<Scalars['Int']['output']>;
  kmtelemetria: Maybe<Scalars['Boolean']['output']>;
  kmultmanu: Maybe<Scalars['Int']['output']>;
  lacre: Maybe<Scalars['Boolean']['output']>;
  licdesp1: Maybe<Scalars['String']['output']>;
  licdesp2: Maybe<Scalars['String']['output']>;
  licdespmg: Maybe<Scalars['String']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  licvenc1: Maybe<Scalars['datetime']['output']>;
  licvenc2: Maybe<Scalars['datetime']['output']>;
  licvenc11: Maybe<Scalars['datetime']['output']>;
  licvenc22: Maybe<Scalars['datetime']['output']>;
  licvencmg3: Maybe<Scalars['datetime']['output']>;
  licvencmg33: Maybe<Scalars['datetime']['output']>;
  lonadia: Maybe<Scalars['String']['output']>;
  lonatra: Maybe<Scalars['String']['output']>;
  lonatru: Maybe<Scalars['String']['output']>;
  marca: Maybe<Scalars['String']['output']>;
  modelo: Maybe<Scalars['String']['output']>;
  numvel: Maybe<Scalars['Int']['output']>;
  obs: Maybe<Scalars['String']['output']>;
  obssit: Maybe<Scalars['String']['output']>;
  osfreio01: Maybe<Scalars['String']['output']>;
  osfreio02: Maybe<Scalars['String']['output']>;
  osfreio03: Maybe<Scalars['String']['output']>;
  osfreio04: Maybe<Scalars['String']['output']>;
  osfreio5: Maybe<Scalars['String']['output']>;
  osfreio6: Maybe<Scalars['String']['output']>;
  osfreio11: Maybe<Scalars['String']['output']>;
  osfreio12: Maybe<Scalars['String']['output']>;
  osrevis01: Maybe<Scalars['String']['output']>;
  osrevis02: Maybe<Scalars['String']['output']>;
  osrevis03: Maybe<Scalars['String']['output']>;
  osrevis04: Maybe<Scalars['String']['output']>;
  osrevis5: Maybe<Scalars['String']['output']>;
  osrevis6: Maybe<Scalars['String']['output']>;
  osrevis11: Maybe<Scalars['String']['output']>;
  osrevis12: Maybe<Scalars['String']['output']>;
  particular: Maybe<Scalars['Boolean']['output']>;
  pedagio: Maybe<Scalars['Boolean']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Int']['output']>;
  placa: Scalars['String']['output'];
  placa1: Maybe<Scalars['String']['output']>;
  placaAntiga: Maybe<Scalars['String']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  proprio: Scalars['String']['output'];
  qtdpzmp: Maybe<Scalars['Int']['output']>;
  renavan: Scalars['String']['output'];
  reservatanque: Scalars['Int']['output'];
  rpmvalue: Maybe<Scalars['Int']['output']>;
  sinistros: Maybe<Scalars['Int']['output']>;
  sitauto: Maybe<Scalars['String']['output']>;
  tambordia: Maybe<Scalars['String']['output']>;
  tambortra: Maybe<Scalars['String']['output']>;
  tambortru: Maybe<Scalars['String']['output']>;
  tamp: Maybe<Scalars['String']['output']>;
  tampt: Maybe<Scalars['String']['output']>;
  tipocontmanu: Maybe<Scalars['Int']['output']>;
  tiporeb: Maybe<Scalars['String']['output']>;
  tipotruck: Maybe<Scalars['String']['output']>;
  totalcintas: Maybe<Scalars['Int']['output']>;
  tpcarro: Scalars['String']['output'];
  ultas: Maybe<Scalars['String']['output']>;
  ultmanu: Maybe<Scalars['String']['output']>;
  ultviag: Maybe<Scalars['String']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  venc1: Maybe<Scalars['datetime']['output']>;
  venc2: Maybe<Scalars['datetime']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** aggregated selection of "auto" */
export type Auto_Aggregate = {
  __typename?: 'auto_aggregate';
  aggregate: Maybe<Auto_Aggregate_Fields>;
  nodes: Array<Auto>;
};

/** aggregate fields of "auto" */
export type Auto_Aggregate_Fields = {
  __typename?: 'auto_aggregate_fields';
  avg: Maybe<Auto_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Auto_Max_Fields>;
  min: Maybe<Auto_Min_Fields>;
  stddev: Maybe<Auto_Stddev_Fields>;
  stddev_pop: Maybe<Auto_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Auto_Stddev_Samp_Fields>;
  sum: Maybe<Auto_Sum_Fields>;
  var_pop: Maybe<Auto_Var_Pop_Fields>;
  var_samp: Maybe<Auto_Var_Samp_Fields>;
  variance: Maybe<Auto_Variance_Fields>;
};


/** aggregate fields of "auto" */
export type Auto_Aggregate_FieldsCountArgs = {
  column?: InputMaybe<Auto_Select_Column>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Auto_Avg_Fields = {
  __typename?: 'auto_avg_fields';
  KmBaseContManu: Maybe<Scalars['Float']['output']>;
  KmUltContManu: Maybe<Scalars['Float']['output']>;
  baterias: Maybe<Scalars['Float']['output']>;
  bonusdm: Maybe<Scalars['Float']['output']>;
  capac: Maybe<Scalars['Float']['output']>;
  capacidadetanque: Maybe<Scalars['Float']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Float']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Float']['output']>;
  kmalugadoparcial: Maybe<Scalars['Float']['output']>;
  kmman: Maybe<Scalars['Float']['output']>;
  kmrevisao: Maybe<Scalars['Float']['output']>;
  kmrodado: Maybe<Scalars['Float']['output']>;
  kmultmanu: Maybe<Scalars['Float']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Float']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Float']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Float']['output']>;
  reservatanque: Maybe<Scalars['Float']['output']>;
  rpmvalue: Maybe<Scalars['Float']['output']>;
  sinistros: Maybe<Scalars['Float']['output']>;
  tipocontmanu: Maybe<Scalars['Float']['output']>;
  totalcintas: Maybe<Scalars['Float']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "auto". All fields are combined with a logical 'AND'. */
export type Auto_Bool_Exp = {
  DtValidaUltContManu?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  KmBaseContManu?: InputMaybe<Int_Mssql_Comparison_Exp>;
  KmUltContManu?: InputMaybe<Int_Mssql_Comparison_Exp>;
  NumeroAET?: InputMaybe<String_Mssql_Comparison_Exp>;
  TamanhoAET?: InputMaybe<String_Mssql_Comparison_Exp>;
  TipoAlugado?: InputMaybe<String_Mssql_Comparison_Exp>;
  _and?: InputMaybe<Array<Auto_Bool_Exp>>;
  _not?: InputMaybe<Auto_Bool_Exp>;
  _or?: InputMaybe<Array<Auto_Bool_Exp>>;
  agregadorastreamentoibor?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  anof?: InputMaybe<String_Mssql_Comparison_Exp>;
  anom?: InputMaybe<String_Mssql_Comparison_Exp>;
  apolice?: InputMaybe<String_Mssql_Comparison_Exp>;
  arla32?: InputMaybe<String_Mssql_Comparison_Exp>;
  ativo?: InputMaybe<String_Mssql_Comparison_Exp>;
  baterias?: InputMaybe<Int_Mssql_Comparison_Exp>;
  bonusdm?: InputMaybe<Int_Mssql_Comparison_Exp>;
  cacamba?: InputMaybe<String_Mssql_Comparison_Exp>;
  capac?: InputMaybe<Int_Mssql_Comparison_Exp>;
  capacidadetanque?: InputMaybe<Int_Mssql_Comparison_Exp>;
  carbkp?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  chassi?: InputMaybe<String_Mssql_Comparison_Exp>;
  cia?: InputMaybe<String_Mssql_Comparison_Exp>;
  cobertdm?: InputMaybe<Float_Mssql_Comparison_Exp>;
  cobertdp?: InputMaybe<Float_Mssql_Comparison_Exp>;
  cobertmp?: InputMaybe<Float_Mssql_Comparison_Exp>;
  codmoto?: InputMaybe<String_Mssql_Comparison_Exp>;
  codprop?: InputMaybe<String_Mssql_Comparison_Exp>;
  combu?: InputMaybe<String_Mssql_Comparison_Exp>;
  contmanu?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  contmanunacional?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  controlerota?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  cor?: InputMaybe<String_Mssql_Comparison_Exp>;
  dataInicioVolvoConnect?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  dataenttec?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  datapedagio?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  digvel?: InputMaybe<Int_Mssql_Comparison_Exp>;
  digveldata?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  discofreio?: InputMaybe<String_Mssql_Comparison_Exp>;
  dtVeriTacografo?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  dtfimmanu?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  dtinimanu?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  dtmanutcompleta?: InputMaybe<Date_Mssql_Comparison_Exp>;
  encerrante?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  especie?: InputMaybe<String_Mssql_Comparison_Exp>;
  fatorcombust?: InputMaybe<Float_Mssql_Comparison_Exp>;
  fatordist?: InputMaybe<Float_Mssql_Comparison_Exp>;
  fauto?: InputMaybe<Int_Mssql_Comparison_Exp>;
  funcionario?: InputMaybe<String_Mssql_Comparison_Exp>;
  ibuttons?: InputMaybe<String_Mssql_Comparison_Exp>;
  isVolvoConnect?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  kmalugadoparcial?: InputMaybe<Int_Mssql_Comparison_Exp>;
  kmman?: InputMaybe<Int_Mssql_Comparison_Exp>;
  kmrevisao?: InputMaybe<Int_Mssql_Comparison_Exp>;
  kmrodado?: InputMaybe<Int_Mssql_Comparison_Exp>;
  kmtelemetria?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  kmultmanu?: InputMaybe<Int_Mssql_Comparison_Exp>;
  lacre?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  licdesp1?: InputMaybe<String_Mssql_Comparison_Exp>;
  licdesp2?: InputMaybe<String_Mssql_Comparison_Exp>;
  licdespmg?: InputMaybe<String_Mssql_Comparison_Exp>;
  licvalor1?: InputMaybe<Float_Mssql_Comparison_Exp>;
  licvalor2?: InputMaybe<Float_Mssql_Comparison_Exp>;
  licvalormg?: InputMaybe<Float_Mssql_Comparison_Exp>;
  licvenc1?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  licvenc2?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  licvenc11?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  licvenc22?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  licvencmg3?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  licvencmg33?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  lonadia?: InputMaybe<String_Mssql_Comparison_Exp>;
  lonatra?: InputMaybe<String_Mssql_Comparison_Exp>;
  lonatru?: InputMaybe<String_Mssql_Comparison_Exp>;
  marca?: InputMaybe<String_Mssql_Comparison_Exp>;
  modelo?: InputMaybe<String_Mssql_Comparison_Exp>;
  numvel?: InputMaybe<Int_Mssql_Comparison_Exp>;
  obs?: InputMaybe<String_Mssql_Comparison_Exp>;
  obssit?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio01?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio02?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio03?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio04?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio5?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio6?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio11?: InputMaybe<String_Mssql_Comparison_Exp>;
  osfreio12?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis01?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis02?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis03?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis04?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis5?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis6?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis11?: InputMaybe<String_Mssql_Comparison_Exp>;
  osrevis12?: InputMaybe<String_Mssql_Comparison_Exp>;
  particular?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  pedagio?: InputMaybe<Boolean_Mssql_Comparison_Exp>;
  percminimotanque?: InputMaybe<Float_Mssql_Comparison_Exp>;
  periodomanutbasica?: InputMaybe<Int_Mssql_Comparison_Exp>;
  placa?: InputMaybe<String_Mssql_Comparison_Exp>;
  placa1?: InputMaybe<String_Mssql_Comparison_Exp>;
  placaAntiga?: InputMaybe<String_Mssql_Comparison_Exp>;
  prazomp?: InputMaybe<Float_Mssql_Comparison_Exp>;
  proprio?: InputMaybe<String_Mssql_Comparison_Exp>;
  qtdpzmp?: InputMaybe<Int_Mssql_Comparison_Exp>;
  renavan?: InputMaybe<String_Mssql_Comparison_Exp>;
  reservatanque?: InputMaybe<Int_Mssql_Comparison_Exp>;
  rpmvalue?: InputMaybe<Int_Mssql_Comparison_Exp>;
  sinistros?: InputMaybe<Int_Mssql_Comparison_Exp>;
  sitauto?: InputMaybe<String_Mssql_Comparison_Exp>;
  tambordia?: InputMaybe<String_Mssql_Comparison_Exp>;
  tambortra?: InputMaybe<String_Mssql_Comparison_Exp>;
  tambortru?: InputMaybe<String_Mssql_Comparison_Exp>;
  tamp?: InputMaybe<String_Mssql_Comparison_Exp>;
  tampt?: InputMaybe<String_Mssql_Comparison_Exp>;
  tipocontmanu?: InputMaybe<Int_Mssql_Comparison_Exp>;
  tiporeb?: InputMaybe<String_Mssql_Comparison_Exp>;
  tipotruck?: InputMaybe<String_Mssql_Comparison_Exp>;
  totalcintas?: InputMaybe<Int_Mssql_Comparison_Exp>;
  tpcarro?: InputMaybe<String_Mssql_Comparison_Exp>;
  ultas?: InputMaybe<String_Mssql_Comparison_Exp>;
  ultmanu?: InputMaybe<String_Mssql_Comparison_Exp>;
  ultviag?: InputMaybe<String_Mssql_Comparison_Exp>;
  velanormal?: InputMaybe<Float_Mssql_Comparison_Exp>;
  velnormal?: InputMaybe<Float_Mssql_Comparison_Exp>;
  venc1?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  venc2?: InputMaybe<Datetime_Mssql_Comparison_Exp>;
  vistamp?: InputMaybe<Float_Mssql_Comparison_Exp>;
};

/** upsert condition type for table "auto" */
export type Auto_If_Matched = {
  match_columns?: Array<Auto_Insert_Match_Column>;
  update_columns?: Array<Auto_Update_Column>;
  where?: InputMaybe<Auto_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "auto" */
export type Auto_Inc_Input = {
  KmBaseContManu?: InputMaybe<Scalars['Int']['input']>;
  KmUltContManu?: InputMaybe<Scalars['Int']['input']>;
  baterias?: InputMaybe<Scalars['Int']['input']>;
  bonusdm?: InputMaybe<Scalars['Int']['input']>;
  capac?: InputMaybe<Scalars['Int']['input']>;
  capacidadetanque?: InputMaybe<Scalars['Int']['input']>;
  cobertdm?: InputMaybe<Scalars['Float']['input']>;
  cobertdp?: InputMaybe<Scalars['Float']['input']>;
  cobertmp?: InputMaybe<Scalars['Float']['input']>;
  digvel?: InputMaybe<Scalars['Int']['input']>;
  fatorcombust?: InputMaybe<Scalars['Float']['input']>;
  fatordist?: InputMaybe<Scalars['Float']['input']>;
  fauto?: InputMaybe<Scalars['Int']['input']>;
  kmalugadoparcial?: InputMaybe<Scalars['Int']['input']>;
  kmman?: InputMaybe<Scalars['Int']['input']>;
  kmrevisao?: InputMaybe<Scalars['Int']['input']>;
  kmrodado?: InputMaybe<Scalars['Int']['input']>;
  kmultmanu?: InputMaybe<Scalars['Int']['input']>;
  licvalor1?: InputMaybe<Scalars['Float']['input']>;
  licvalor2?: InputMaybe<Scalars['Float']['input']>;
  licvalormg?: InputMaybe<Scalars['Float']['input']>;
  numvel?: InputMaybe<Scalars['Int']['input']>;
  percminimotanque?: InputMaybe<Scalars['Float']['input']>;
  periodomanutbasica?: InputMaybe<Scalars['Int']['input']>;
  prazomp?: InputMaybe<Scalars['Float']['input']>;
  qtdpzmp?: InputMaybe<Scalars['Int']['input']>;
  reservatanque?: InputMaybe<Scalars['Int']['input']>;
  rpmvalue?: InputMaybe<Scalars['Int']['input']>;
  sinistros?: InputMaybe<Scalars['Int']['input']>;
  tipocontmanu?: InputMaybe<Scalars['Int']['input']>;
  totalcintas?: InputMaybe<Scalars['Int']['input']>;
  velanormal?: InputMaybe<Scalars['Float']['input']>;
  velnormal?: InputMaybe<Scalars['Float']['input']>;
  vistamp?: InputMaybe<Scalars['Float']['input']>;
};

/** input type for inserting data into table "auto" */
export type Auto_Insert_Input = {
  DtValidaUltContManu?: InputMaybe<Scalars['datetime']['input']>;
  KmBaseContManu?: InputMaybe<Scalars['Int']['input']>;
  KmUltContManu?: InputMaybe<Scalars['Int']['input']>;
  NumeroAET?: InputMaybe<Scalars['String']['input']>;
  TamanhoAET?: InputMaybe<Scalars['String']['input']>;
  TipoAlugado?: InputMaybe<Scalars['String']['input']>;
  agregadorastreamentoibor?: InputMaybe<Scalars['Boolean']['input']>;
  anof?: InputMaybe<Scalars['String']['input']>;
  anom?: InputMaybe<Scalars['String']['input']>;
  apolice?: InputMaybe<Scalars['String']['input']>;
  arla32?: InputMaybe<Scalars['String']['input']>;
  ativo?: InputMaybe<Scalars['String']['input']>;
  baterias?: InputMaybe<Scalars['Int']['input']>;
  bonusdm?: InputMaybe<Scalars['Int']['input']>;
  cacamba?: InputMaybe<Scalars['String']['input']>;
  capac?: InputMaybe<Scalars['Int']['input']>;
  capacidadetanque?: InputMaybe<Scalars['Int']['input']>;
  carbkp?: InputMaybe<Scalars['Boolean']['input']>;
  chassi?: InputMaybe<Scalars['String']['input']>;
  cia?: InputMaybe<Scalars['String']['input']>;
  cobertdm?: InputMaybe<Scalars['Float']['input']>;
  cobertdp?: InputMaybe<Scalars['Float']['input']>;
  cobertmp?: InputMaybe<Scalars['Float']['input']>;
  codmoto?: InputMaybe<Scalars['String']['input']>;
  codprop?: InputMaybe<Scalars['String']['input']>;
  combu?: InputMaybe<Scalars['String']['input']>;
  contmanu?: InputMaybe<Scalars['Boolean']['input']>;
  contmanunacional?: InputMaybe<Scalars['Boolean']['input']>;
  controlerota?: InputMaybe<Scalars['Boolean']['input']>;
  cor?: InputMaybe<Scalars['String']['input']>;
  dataInicioVolvoConnect?: InputMaybe<Scalars['datetime']['input']>;
  dataenttec?: InputMaybe<Scalars['datetime']['input']>;
  datapedagio?: InputMaybe<Scalars['datetime']['input']>;
  digvel?: InputMaybe<Scalars['Int']['input']>;
  digveldata?: InputMaybe<Scalars['datetime']['input']>;
  discofreio?: InputMaybe<Scalars['String']['input']>;
  dtVeriTacografo?: InputMaybe<Scalars['datetime']['input']>;
  dtfimmanu?: InputMaybe<Scalars['datetime']['input']>;
  dtinimanu?: InputMaybe<Scalars['datetime']['input']>;
  dtmanutcompleta?: InputMaybe<Scalars['date']['input']>;
  encerrante?: InputMaybe<Scalars['Boolean']['input']>;
  especie?: InputMaybe<Scalars['String']['input']>;
  fatorcombust?: InputMaybe<Scalars['Float']['input']>;
  fatordist?: InputMaybe<Scalars['Float']['input']>;
  fauto?: InputMaybe<Scalars['Int']['input']>;
  funcionario?: InputMaybe<Scalars['String']['input']>;
  ibuttons?: InputMaybe<Scalars['String']['input']>;
  isVolvoConnect?: InputMaybe<Scalars['Boolean']['input']>;
  kmalugadoparcial?: InputMaybe<Scalars['Int']['input']>;
  kmman?: InputMaybe<Scalars['Int']['input']>;
  kmrevisao?: InputMaybe<Scalars['Int']['input']>;
  kmrodado?: InputMaybe<Scalars['Int']['input']>;
  kmtelemetria?: InputMaybe<Scalars['Boolean']['input']>;
  kmultmanu?: InputMaybe<Scalars['Int']['input']>;
  lacre?: InputMaybe<Scalars['Boolean']['input']>;
  licdesp1?: InputMaybe<Scalars['String']['input']>;
  licdesp2?: InputMaybe<Scalars['String']['input']>;
  licdespmg?: InputMaybe<Scalars['String']['input']>;
  licvalor1?: InputMaybe<Scalars['Float']['input']>;
  licvalor2?: InputMaybe<Scalars['Float']['input']>;
  licvalormg?: InputMaybe<Scalars['Float']['input']>;
  licvenc1?: InputMaybe<Scalars['datetime']['input']>;
  licvenc2?: InputMaybe<Scalars['datetime']['input']>;
  licvenc11?: InputMaybe<Scalars['datetime']['input']>;
  licvenc22?: InputMaybe<Scalars['datetime']['input']>;
  licvencmg3?: InputMaybe<Scalars['datetime']['input']>;
  licvencmg33?: InputMaybe<Scalars['datetime']['input']>;
  lonadia?: InputMaybe<Scalars['String']['input']>;
  lonatra?: InputMaybe<Scalars['String']['input']>;
  lonatru?: InputMaybe<Scalars['String']['input']>;
  marca?: InputMaybe<Scalars['String']['input']>;
  modelo?: InputMaybe<Scalars['String']['input']>;
  numvel?: InputMaybe<Scalars['Int']['input']>;
  obs?: InputMaybe<Scalars['String']['input']>;
  obssit?: InputMaybe<Scalars['String']['input']>;
  osfreio01?: InputMaybe<Scalars['String']['input']>;
  osfreio02?: InputMaybe<Scalars['String']['input']>;
  osfreio03?: InputMaybe<Scalars['String']['input']>;
  osfreio04?: InputMaybe<Scalars['String']['input']>;
  osfreio5?: InputMaybe<Scalars['String']['input']>;
  osfreio6?: InputMaybe<Scalars['String']['input']>;
  osfreio11?: InputMaybe<Scalars['String']['input']>;
  osfreio12?: InputMaybe<Scalars['String']['input']>;
  osrevis01?: InputMaybe<Scalars['String']['input']>;
  osrevis02?: InputMaybe<Scalars['String']['input']>;
  osrevis03?: InputMaybe<Scalars['String']['input']>;
  osrevis04?: InputMaybe<Scalars['String']['input']>;
  osrevis5?: InputMaybe<Scalars['String']['input']>;
  osrevis6?: InputMaybe<Scalars['String']['input']>;
  osrevis11?: InputMaybe<Scalars['String']['input']>;
  osrevis12?: InputMaybe<Scalars['String']['input']>;
  particular?: InputMaybe<Scalars['Boolean']['input']>;
  pedagio?: InputMaybe<Scalars['Boolean']['input']>;
  percminimotanque?: InputMaybe<Scalars['Float']['input']>;
  periodomanutbasica?: InputMaybe<Scalars['Int']['input']>;
  placa?: InputMaybe<Scalars['String']['input']>;
  placa1?: InputMaybe<Scalars['String']['input']>;
  placaAntiga?: InputMaybe<Scalars['String']['input']>;
  prazomp?: InputMaybe<Scalars['Float']['input']>;
  proprio?: InputMaybe<Scalars['String']['input']>;
  qtdpzmp?: InputMaybe<Scalars['Int']['input']>;
  renavan?: InputMaybe<Scalars['String']['input']>;
  reservatanque?: InputMaybe<Scalars['Int']['input']>;
  rpmvalue?: InputMaybe<Scalars['Int']['input']>;
  sinistros?: InputMaybe<Scalars['Int']['input']>;
  sitauto?: InputMaybe<Scalars['String']['input']>;
  tambordia?: InputMaybe<Scalars['String']['input']>;
  tambortra?: InputMaybe<Scalars['String']['input']>;
  tambortru?: InputMaybe<Scalars['String']['input']>;
  tamp?: InputMaybe<Scalars['String']['input']>;
  tampt?: InputMaybe<Scalars['String']['input']>;
  tipocontmanu?: InputMaybe<Scalars['Int']['input']>;
  tiporeb?: InputMaybe<Scalars['String']['input']>;
  tipotruck?: InputMaybe<Scalars['String']['input']>;
  totalcintas?: InputMaybe<Scalars['Int']['input']>;
  tpcarro?: InputMaybe<Scalars['String']['input']>;
  ultas?: InputMaybe<Scalars['String']['input']>;
  ultmanu?: InputMaybe<Scalars['String']['input']>;
  ultviag?: InputMaybe<Scalars['String']['input']>;
  velanormal?: InputMaybe<Scalars['Float']['input']>;
  velnormal?: InputMaybe<Scalars['Float']['input']>;
  venc1?: InputMaybe<Scalars['datetime']['input']>;
  venc2?: InputMaybe<Scalars['datetime']['input']>;
  vistamp?: InputMaybe<Scalars['Float']['input']>;
};

/** select match_columns of table "auto" */
export enum Auto_Insert_Match_Column {
  /** column name */
  DtValidaUltContManu = 'DtValidaUltContManu',
  /** column name */
  KmBaseContManu = 'KmBaseContManu',
  /** column name */
  KmUltContManu = 'KmUltContManu',
  /** column name */
  NumeroAet = 'NumeroAET',
  /** column name */
  TamanhoAet = 'TamanhoAET',
  /** column name */
  TipoAlugado = 'TipoAlugado',
  /** column name */
  Agregadorastreamentoibor = 'agregadorastreamentoibor',
  /** column name */
  Anof = 'anof',
  /** column name */
  Anom = 'anom',
  /** column name */
  Apolice = 'apolice',
  /** column name */
  Arla32 = 'arla32',
  /** column name */
  Ativo = 'ativo',
  /** column name */
  Baterias = 'baterias',
  /** column name */
  Bonusdm = 'bonusdm',
  /** column name */
  Cacamba = 'cacamba',
  /** column name */
  Capac = 'capac',
  /** column name */
  Capacidadetanque = 'capacidadetanque',
  /** column name */
  Carbkp = 'carbkp',
  /** column name */
  Chassi = 'chassi',
  /** column name */
  Cia = 'cia',
  /** column name */
  Cobertdm = 'cobertdm',
  /** column name */
  Cobertdp = 'cobertdp',
  /** column name */
  Cobertmp = 'cobertmp',
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  Codprop = 'codprop',
  /** column name */
  Combu = 'combu',
  /** column name */
  Contmanu = 'contmanu',
  /** column name */
  Contmanunacional = 'contmanunacional',
  /** column name */
  Controlerota = 'controlerota',
  /** column name */
  Cor = 'cor',
  /** column name */
  DataInicioVolvoConnect = 'dataInicioVolvoConnect',
  /** column name */
  Dataenttec = 'dataenttec',
  /** column name */
  Datapedagio = 'datapedagio',
  /** column name */
  Digvel = 'digvel',
  /** column name */
  Digveldata = 'digveldata',
  /** column name */
  Discofreio = 'discofreio',
  /** column name */
  DtVeriTacografo = 'dtVeriTacografo',
  /** column name */
  Dtfimmanu = 'dtfimmanu',
  /** column name */
  Dtinimanu = 'dtinimanu',
  /** column name */
  Dtmanutcompleta = 'dtmanutcompleta',
  /** column name */
  Encerrante = 'encerrante',
  /** column name */
  Especie = 'especie',
  /** column name */
  Fatorcombust = 'fatorcombust',
  /** column name */
  Fatordist = 'fatordist',
  /** column name */
  Fauto = 'fauto',
  /** column name */
  Funcionario = 'funcionario',
  /** column name */
  Ibuttons = 'ibuttons',
  /** column name */
  IsVolvoConnect = 'isVolvoConnect',
  /** column name */
  Kmalugadoparcial = 'kmalugadoparcial',
  /** column name */
  Kmman = 'kmman',
  /** column name */
  Kmrevisao = 'kmrevisao',
  /** column name */
  Kmrodado = 'kmrodado',
  /** column name */
  Kmtelemetria = 'kmtelemetria',
  /** column name */
  Kmultmanu = 'kmultmanu',
  /** column name */
  Lacre = 'lacre',
  /** column name */
  Licdesp1 = 'licdesp1',
  /** column name */
  Licdesp2 = 'licdesp2',
  /** column name */
  Licdespmg = 'licdespmg',
  /** column name */
  Licvalor1 = 'licvalor1',
  /** column name */
  Licvalor2 = 'licvalor2',
  /** column name */
  Licvalormg = 'licvalormg',
  /** column name */
  Licvenc1 = 'licvenc1',
  /** column name */
  Licvenc2 = 'licvenc2',
  /** column name */
  Licvenc11 = 'licvenc11',
  /** column name */
  Licvenc22 = 'licvenc22',
  /** column name */
  Licvencmg3 = 'licvencmg3',
  /** column name */
  Licvencmg33 = 'licvencmg33',
  /** column name */
  Lonadia = 'lonadia',
  /** column name */
  Lonatra = 'lonatra',
  /** column name */
  Lonatru = 'lonatru',
  /** column name */
  Marca = 'marca',
  /** column name */
  Modelo = 'modelo',
  /** column name */
  Numvel = 'numvel',
  /** column name */
  Obs = 'obs',
  /** column name */
  Obssit = 'obssit',
  /** column name */
  Osfreio01 = 'osfreio01',
  /** column name */
  Osfreio02 = 'osfreio02',
  /** column name */
  Osfreio03 = 'osfreio03',
  /** column name */
  Osfreio04 = 'osfreio04',
  /** column name */
  Osfreio5 = 'osfreio5',
  /** column name */
  Osfreio6 = 'osfreio6',
  /** column name */
  Osfreio11 = 'osfreio11',
  /** column name */
  Osfreio12 = 'osfreio12',
  /** column name */
  Osrevis01 = 'osrevis01',
  /** column name */
  Osrevis02 = 'osrevis02',
  /** column name */
  Osrevis03 = 'osrevis03',
  /** column name */
  Osrevis04 = 'osrevis04',
  /** column name */
  Osrevis5 = 'osrevis5',
  /** column name */
  Osrevis6 = 'osrevis6',
  /** column name */
  Osrevis11 = 'osrevis11',
  /** column name */
  Osrevis12 = 'osrevis12',
  /** column name */
  Particular = 'particular',
  /** column name */
  Pedagio = 'pedagio',
  /** column name */
  Percminimotanque = 'percminimotanque',
  /** column name */
  Periodomanutbasica = 'periodomanutbasica',
  /** column name */
  Placa = 'placa',
  /** column name */
  Placa1 = 'placa1',
  /** column name */
  PlacaAntiga = 'placaAntiga',
  /** column name */
  Prazomp = 'prazomp',
  /** column name */
  Proprio = 'proprio',
  /** column name */
  Qtdpzmp = 'qtdpzmp',
  /** column name */
  Renavan = 'renavan',
  /** column name */
  Reservatanque = 'reservatanque',
  /** column name */
  Rpmvalue = 'rpmvalue',
  /** column name */
  Sinistros = 'sinistros',
  /** column name */
  Sitauto = 'sitauto',
  /** column name */
  Tambordia = 'tambordia',
  /** column name */
  Tambortra = 'tambortra',
  /** column name */
  Tambortru = 'tambortru',
  /** column name */
  Tamp = 'tamp',
  /** column name */
  Tampt = 'tampt',
  /** column name */
  Tipocontmanu = 'tipocontmanu',
  /** column name */
  Tiporeb = 'tiporeb',
  /** column name */
  Tipotruck = 'tipotruck',
  /** column name */
  Totalcintas = 'totalcintas',
  /** column name */
  Tpcarro = 'tpcarro',
  /** column name */
  Ultas = 'ultas',
  /** column name */
  Ultmanu = 'ultmanu',
  /** column name */
  Ultviag = 'ultviag',
  /** column name */
  Velanormal = 'velanormal',
  /** column name */
  Velnormal = 'velnormal',
  /** column name */
  Venc1 = 'venc1',
  /** column name */
  Venc2 = 'venc2',
  /** column name */
  Vistamp = 'vistamp'
}

/** aggregate max on columns */
export type Auto_Max_Fields = {
  __typename?: 'auto_max_fields';
  DtValidaUltContManu: Maybe<Scalars['datetime']['output']>;
  KmBaseContManu: Maybe<Scalars['Int']['output']>;
  KmUltContManu: Maybe<Scalars['Int']['output']>;
  NumeroAET: Maybe<Scalars['String']['output']>;
  TamanhoAET: Maybe<Scalars['String']['output']>;
  TipoAlugado: Maybe<Scalars['String']['output']>;
  anof: Maybe<Scalars['String']['output']>;
  anom: Maybe<Scalars['String']['output']>;
  apolice: Maybe<Scalars['String']['output']>;
  arla32: Maybe<Scalars['String']['output']>;
  ativo: Maybe<Scalars['String']['output']>;
  baterias: Maybe<Scalars['Int']['output']>;
  bonusdm: Maybe<Scalars['Int']['output']>;
  cacamba: Maybe<Scalars['String']['output']>;
  capac: Maybe<Scalars['Int']['output']>;
  capacidadetanque: Maybe<Scalars['Int']['output']>;
  chassi: Maybe<Scalars['String']['output']>;
  cia: Maybe<Scalars['String']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  codmoto: Maybe<Scalars['String']['output']>;
  codprop: Maybe<Scalars['String']['output']>;
  combu: Maybe<Scalars['String']['output']>;
  cor: Maybe<Scalars['String']['output']>;
  dataInicioVolvoConnect: Maybe<Scalars['datetime']['output']>;
  dataenttec: Maybe<Scalars['datetime']['output']>;
  datapedagio: Maybe<Scalars['datetime']['output']>;
  digvel: Maybe<Scalars['Int']['output']>;
  digveldata: Maybe<Scalars['datetime']['output']>;
  discofreio: Maybe<Scalars['String']['output']>;
  dtVeriTacografo: Maybe<Scalars['datetime']['output']>;
  dtfimmanu: Maybe<Scalars['datetime']['output']>;
  dtinimanu: Maybe<Scalars['datetime']['output']>;
  dtmanutcompleta: Maybe<Scalars['date']['output']>;
  especie: Maybe<Scalars['String']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Int']['output']>;
  funcionario: Maybe<Scalars['String']['output']>;
  ibuttons: Maybe<Scalars['String']['output']>;
  kmalugadoparcial: Maybe<Scalars['Int']['output']>;
  kmman: Maybe<Scalars['Int']['output']>;
  kmrevisao: Maybe<Scalars['Int']['output']>;
  kmrodado: Maybe<Scalars['Int']['output']>;
  kmultmanu: Maybe<Scalars['Int']['output']>;
  licdesp1: Maybe<Scalars['String']['output']>;
  licdesp2: Maybe<Scalars['String']['output']>;
  licdespmg: Maybe<Scalars['String']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  licvenc1: Maybe<Scalars['datetime']['output']>;
  licvenc2: Maybe<Scalars['datetime']['output']>;
  licvenc11: Maybe<Scalars['datetime']['output']>;
  licvenc22: Maybe<Scalars['datetime']['output']>;
  licvencmg3: Maybe<Scalars['datetime']['output']>;
  licvencmg33: Maybe<Scalars['datetime']['output']>;
  lonadia: Maybe<Scalars['String']['output']>;
  lonatra: Maybe<Scalars['String']['output']>;
  lonatru: Maybe<Scalars['String']['output']>;
  marca: Maybe<Scalars['String']['output']>;
  modelo: Maybe<Scalars['String']['output']>;
  numvel: Maybe<Scalars['Int']['output']>;
  obs: Maybe<Scalars['String']['output']>;
  obssit: Maybe<Scalars['String']['output']>;
  osfreio01: Maybe<Scalars['String']['output']>;
  osfreio02: Maybe<Scalars['String']['output']>;
  osfreio03: Maybe<Scalars['String']['output']>;
  osfreio04: Maybe<Scalars['String']['output']>;
  osfreio5: Maybe<Scalars['String']['output']>;
  osfreio6: Maybe<Scalars['String']['output']>;
  osfreio11: Maybe<Scalars['String']['output']>;
  osfreio12: Maybe<Scalars['String']['output']>;
  osrevis01: Maybe<Scalars['String']['output']>;
  osrevis02: Maybe<Scalars['String']['output']>;
  osrevis03: Maybe<Scalars['String']['output']>;
  osrevis04: Maybe<Scalars['String']['output']>;
  osrevis5: Maybe<Scalars['String']['output']>;
  osrevis6: Maybe<Scalars['String']['output']>;
  osrevis11: Maybe<Scalars['String']['output']>;
  osrevis12: Maybe<Scalars['String']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Int']['output']>;
  placa: Maybe<Scalars['String']['output']>;
  placa1: Maybe<Scalars['String']['output']>;
  placaAntiga: Maybe<Scalars['String']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  proprio: Maybe<Scalars['String']['output']>;
  qtdpzmp: Maybe<Scalars['Int']['output']>;
  renavan: Maybe<Scalars['String']['output']>;
  reservatanque: Maybe<Scalars['Int']['output']>;
  rpmvalue: Maybe<Scalars['Int']['output']>;
  sinistros: Maybe<Scalars['Int']['output']>;
  sitauto: Maybe<Scalars['String']['output']>;
  tambordia: Maybe<Scalars['String']['output']>;
  tambortra: Maybe<Scalars['String']['output']>;
  tambortru: Maybe<Scalars['String']['output']>;
  tamp: Maybe<Scalars['String']['output']>;
  tampt: Maybe<Scalars['String']['output']>;
  tipocontmanu: Maybe<Scalars['Int']['output']>;
  tiporeb: Maybe<Scalars['String']['output']>;
  tipotruck: Maybe<Scalars['String']['output']>;
  totalcintas: Maybe<Scalars['Int']['output']>;
  tpcarro: Maybe<Scalars['String']['output']>;
  ultas: Maybe<Scalars['String']['output']>;
  ultmanu: Maybe<Scalars['String']['output']>;
  ultviag: Maybe<Scalars['String']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  venc1: Maybe<Scalars['datetime']['output']>;
  venc2: Maybe<Scalars['datetime']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** aggregate min on columns */
export type Auto_Min_Fields = {
  __typename?: 'auto_min_fields';
  DtValidaUltContManu: Maybe<Scalars['datetime']['output']>;
  KmBaseContManu: Maybe<Scalars['Int']['output']>;
  KmUltContManu: Maybe<Scalars['Int']['output']>;
  NumeroAET: Maybe<Scalars['String']['output']>;
  TamanhoAET: Maybe<Scalars['String']['output']>;
  TipoAlugado: Maybe<Scalars['String']['output']>;
  anof: Maybe<Scalars['String']['output']>;
  anom: Maybe<Scalars['String']['output']>;
  apolice: Maybe<Scalars['String']['output']>;
  arla32: Maybe<Scalars['String']['output']>;
  ativo: Maybe<Scalars['String']['output']>;
  baterias: Maybe<Scalars['Int']['output']>;
  bonusdm: Maybe<Scalars['Int']['output']>;
  cacamba: Maybe<Scalars['String']['output']>;
  capac: Maybe<Scalars['Int']['output']>;
  capacidadetanque: Maybe<Scalars['Int']['output']>;
  chassi: Maybe<Scalars['String']['output']>;
  cia: Maybe<Scalars['String']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  codmoto: Maybe<Scalars['String']['output']>;
  codprop: Maybe<Scalars['String']['output']>;
  combu: Maybe<Scalars['String']['output']>;
  cor: Maybe<Scalars['String']['output']>;
  dataInicioVolvoConnect: Maybe<Scalars['datetime']['output']>;
  dataenttec: Maybe<Scalars['datetime']['output']>;
  datapedagio: Maybe<Scalars['datetime']['output']>;
  digvel: Maybe<Scalars['Int']['output']>;
  digveldata: Maybe<Scalars['datetime']['output']>;
  discofreio: Maybe<Scalars['String']['output']>;
  dtVeriTacografo: Maybe<Scalars['datetime']['output']>;
  dtfimmanu: Maybe<Scalars['datetime']['output']>;
  dtinimanu: Maybe<Scalars['datetime']['output']>;
  dtmanutcompleta: Maybe<Scalars['date']['output']>;
  especie: Maybe<Scalars['String']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Int']['output']>;
  funcionario: Maybe<Scalars['String']['output']>;
  ibuttons: Maybe<Scalars['String']['output']>;
  kmalugadoparcial: Maybe<Scalars['Int']['output']>;
  kmman: Maybe<Scalars['Int']['output']>;
  kmrevisao: Maybe<Scalars['Int']['output']>;
  kmrodado: Maybe<Scalars['Int']['output']>;
  kmultmanu: Maybe<Scalars['Int']['output']>;
  licdesp1: Maybe<Scalars['String']['output']>;
  licdesp2: Maybe<Scalars['String']['output']>;
  licdespmg: Maybe<Scalars['String']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  licvenc1: Maybe<Scalars['datetime']['output']>;
  licvenc2: Maybe<Scalars['datetime']['output']>;
  licvenc11: Maybe<Scalars['datetime']['output']>;
  licvenc22: Maybe<Scalars['datetime']['output']>;
  licvencmg3: Maybe<Scalars['datetime']['output']>;
  licvencmg33: Maybe<Scalars['datetime']['output']>;
  lonadia: Maybe<Scalars['String']['output']>;
  lonatra: Maybe<Scalars['String']['output']>;
  lonatru: Maybe<Scalars['String']['output']>;
  marca: Maybe<Scalars['String']['output']>;
  modelo: Maybe<Scalars['String']['output']>;
  numvel: Maybe<Scalars['Int']['output']>;
  obs: Maybe<Scalars['String']['output']>;
  obssit: Maybe<Scalars['String']['output']>;
  osfreio01: Maybe<Scalars['String']['output']>;
  osfreio02: Maybe<Scalars['String']['output']>;
  osfreio03: Maybe<Scalars['String']['output']>;
  osfreio04: Maybe<Scalars['String']['output']>;
  osfreio5: Maybe<Scalars['String']['output']>;
  osfreio6: Maybe<Scalars['String']['output']>;
  osfreio11: Maybe<Scalars['String']['output']>;
  osfreio12: Maybe<Scalars['String']['output']>;
  osrevis01: Maybe<Scalars['String']['output']>;
  osrevis02: Maybe<Scalars['String']['output']>;
  osrevis03: Maybe<Scalars['String']['output']>;
  osrevis04: Maybe<Scalars['String']['output']>;
  osrevis5: Maybe<Scalars['String']['output']>;
  osrevis6: Maybe<Scalars['String']['output']>;
  osrevis11: Maybe<Scalars['String']['output']>;
  osrevis12: Maybe<Scalars['String']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Int']['output']>;
  placa: Maybe<Scalars['String']['output']>;
  placa1: Maybe<Scalars['String']['output']>;
  placaAntiga: Maybe<Scalars['String']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  proprio: Maybe<Scalars['String']['output']>;
  qtdpzmp: Maybe<Scalars['Int']['output']>;
  renavan: Maybe<Scalars['String']['output']>;
  reservatanque: Maybe<Scalars['Int']['output']>;
  rpmvalue: Maybe<Scalars['Int']['output']>;
  sinistros: Maybe<Scalars['Int']['output']>;
  sitauto: Maybe<Scalars['String']['output']>;
  tambordia: Maybe<Scalars['String']['output']>;
  tambortra: Maybe<Scalars['String']['output']>;
  tambortru: Maybe<Scalars['String']['output']>;
  tamp: Maybe<Scalars['String']['output']>;
  tampt: Maybe<Scalars['String']['output']>;
  tipocontmanu: Maybe<Scalars['Int']['output']>;
  tiporeb: Maybe<Scalars['String']['output']>;
  tipotruck: Maybe<Scalars['String']['output']>;
  totalcintas: Maybe<Scalars['Int']['output']>;
  tpcarro: Maybe<Scalars['String']['output']>;
  ultas: Maybe<Scalars['String']['output']>;
  ultmanu: Maybe<Scalars['String']['output']>;
  ultviag: Maybe<Scalars['String']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  venc1: Maybe<Scalars['datetime']['output']>;
  venc2: Maybe<Scalars['datetime']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** response of any mutation on the table "auto" */
export type Auto_Mutation_Response = {
  __typename?: 'auto_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Auto>;
};

/** Ordering options when selecting data from "auto". */
export type Auto_Order_By = {
  DtValidaUltContManu?: InputMaybe<Order_By>;
  KmBaseContManu?: InputMaybe<Order_By>;
  KmUltContManu?: InputMaybe<Order_By>;
  NumeroAET?: InputMaybe<Order_By>;
  TamanhoAET?: InputMaybe<Order_By>;
  TipoAlugado?: InputMaybe<Order_By>;
  agregadorastreamentoibor?: InputMaybe<Order_By>;
  anof?: InputMaybe<Order_By>;
  anom?: InputMaybe<Order_By>;
  apolice?: InputMaybe<Order_By>;
  arla32?: InputMaybe<Order_By>;
  ativo?: InputMaybe<Order_By>;
  baterias?: InputMaybe<Order_By>;
  bonusdm?: InputMaybe<Order_By>;
  cacamba?: InputMaybe<Order_By>;
  capac?: InputMaybe<Order_By>;
  capacidadetanque?: InputMaybe<Order_By>;
  carbkp?: InputMaybe<Order_By>;
  chassi?: InputMaybe<Order_By>;
  cia?: InputMaybe<Order_By>;
  cobertdm?: InputMaybe<Order_By>;
  cobertdp?: InputMaybe<Order_By>;
  cobertmp?: InputMaybe<Order_By>;
  codmoto?: InputMaybe<Order_By>;
  codprop?: InputMaybe<Order_By>;
  combu?: InputMaybe<Order_By>;
  contmanu?: InputMaybe<Order_By>;
  contmanunacional?: InputMaybe<Order_By>;
  controlerota?: InputMaybe<Order_By>;
  cor?: InputMaybe<Order_By>;
  dataInicioVolvoConnect?: InputMaybe<Order_By>;
  dataenttec?: InputMaybe<Order_By>;
  datapedagio?: InputMaybe<Order_By>;
  digvel?: InputMaybe<Order_By>;
  digveldata?: InputMaybe<Order_By>;
  discofreio?: InputMaybe<Order_By>;
  dtVeriTacografo?: InputMaybe<Order_By>;
  dtfimmanu?: InputMaybe<Order_By>;
  dtinimanu?: InputMaybe<Order_By>;
  dtmanutcompleta?: InputMaybe<Order_By>;
  encerrante?: InputMaybe<Order_By>;
  especie?: InputMaybe<Order_By>;
  fatorcombust?: InputMaybe<Order_By>;
  fatordist?: InputMaybe<Order_By>;
  fauto?: InputMaybe<Order_By>;
  funcionario?: InputMaybe<Order_By>;
  ibuttons?: InputMaybe<Order_By>;
  isVolvoConnect?: InputMaybe<Order_By>;
  kmalugadoparcial?: InputMaybe<Order_By>;
  kmman?: InputMaybe<Order_By>;
  kmrevisao?: InputMaybe<Order_By>;
  kmrodado?: InputMaybe<Order_By>;
  kmtelemetria?: InputMaybe<Order_By>;
  kmultmanu?: InputMaybe<Order_By>;
  lacre?: InputMaybe<Order_By>;
  licdesp1?: InputMaybe<Order_By>;
  licdesp2?: InputMaybe<Order_By>;
  licdespmg?: InputMaybe<Order_By>;
  licvalor1?: InputMaybe<Order_By>;
  licvalor2?: InputMaybe<Order_By>;
  licvalormg?: InputMaybe<Order_By>;
  licvenc1?: InputMaybe<Order_By>;
  licvenc2?: InputMaybe<Order_By>;
  licvenc11?: InputMaybe<Order_By>;
  licvenc22?: InputMaybe<Order_By>;
  licvencmg3?: InputMaybe<Order_By>;
  licvencmg33?: InputMaybe<Order_By>;
  lonadia?: InputMaybe<Order_By>;
  lonatra?: InputMaybe<Order_By>;
  lonatru?: InputMaybe<Order_By>;
  marca?: InputMaybe<Order_By>;
  modelo?: InputMaybe<Order_By>;
  numvel?: InputMaybe<Order_By>;
  obs?: InputMaybe<Order_By>;
  obssit?: InputMaybe<Order_By>;
  osfreio01?: InputMaybe<Order_By>;
  osfreio02?: InputMaybe<Order_By>;
  osfreio03?: InputMaybe<Order_By>;
  osfreio04?: InputMaybe<Order_By>;
  osfreio5?: InputMaybe<Order_By>;
  osfreio6?: InputMaybe<Order_By>;
  osfreio11?: InputMaybe<Order_By>;
  osfreio12?: InputMaybe<Order_By>;
  osrevis01?: InputMaybe<Order_By>;
  osrevis02?: InputMaybe<Order_By>;
  osrevis03?: InputMaybe<Order_By>;
  osrevis04?: InputMaybe<Order_By>;
  osrevis5?: InputMaybe<Order_By>;
  osrevis6?: InputMaybe<Order_By>;
  osrevis11?: InputMaybe<Order_By>;
  osrevis12?: InputMaybe<Order_By>;
  particular?: InputMaybe<Order_By>;
  pedagio?: InputMaybe<Order_By>;
  percminimotanque?: InputMaybe<Order_By>;
  periodomanutbasica?: InputMaybe<Order_By>;
  placa?: InputMaybe<Order_By>;
  placa1?: InputMaybe<Order_By>;
  placaAntiga?: InputMaybe<Order_By>;
  prazomp?: InputMaybe<Order_By>;
  proprio?: InputMaybe<Order_By>;
  qtdpzmp?: InputMaybe<Order_By>;
  renavan?: InputMaybe<Order_By>;
  reservatanque?: InputMaybe<Order_By>;
  rpmvalue?: InputMaybe<Order_By>;
  sinistros?: InputMaybe<Order_By>;
  sitauto?: InputMaybe<Order_By>;
  tambordia?: InputMaybe<Order_By>;
  tambortra?: InputMaybe<Order_By>;
  tambortru?: InputMaybe<Order_By>;
  tamp?: InputMaybe<Order_By>;
  tampt?: InputMaybe<Order_By>;
  tipocontmanu?: InputMaybe<Order_By>;
  tiporeb?: InputMaybe<Order_By>;
  tipotruck?: InputMaybe<Order_By>;
  totalcintas?: InputMaybe<Order_By>;
  tpcarro?: InputMaybe<Order_By>;
  ultas?: InputMaybe<Order_By>;
  ultmanu?: InputMaybe<Order_By>;
  ultviag?: InputMaybe<Order_By>;
  velanormal?: InputMaybe<Order_By>;
  velnormal?: InputMaybe<Order_By>;
  venc1?: InputMaybe<Order_By>;
  venc2?: InputMaybe<Order_By>;
  vistamp?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auto */
export type Auto_Pk_Columns_Input = {
  placa: Scalars['String']['input'];
};

/** select columns of table "auto" */
export enum Auto_Select_Column {
  /** column name */
  DtValidaUltContManu = 'DtValidaUltContManu',
  /** column name */
  KmBaseContManu = 'KmBaseContManu',
  /** column name */
  KmUltContManu = 'KmUltContManu',
  /** column name */
  NumeroAet = 'NumeroAET',
  /** column name */
  TamanhoAet = 'TamanhoAET',
  /** column name */
  TipoAlugado = 'TipoAlugado',
  /** column name */
  Agregadorastreamentoibor = 'agregadorastreamentoibor',
  /** column name */
  Anof = 'anof',
  /** column name */
  Anom = 'anom',
  /** column name */
  Apolice = 'apolice',
  /** column name */
  Arla32 = 'arla32',
  /** column name */
  Ativo = 'ativo',
  /** column name */
  Baterias = 'baterias',
  /** column name */
  Bonusdm = 'bonusdm',
  /** column name */
  Cacamba = 'cacamba',
  /** column name */
  Capac = 'capac',
  /** column name */
  Capacidadetanque = 'capacidadetanque',
  /** column name */
  Carbkp = 'carbkp',
  /** column name */
  Chassi = 'chassi',
  /** column name */
  Cia = 'cia',
  /** column name */
  Cobertdm = 'cobertdm',
  /** column name */
  Cobertdp = 'cobertdp',
  /** column name */
  Cobertmp = 'cobertmp',
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  Codprop = 'codprop',
  /** column name */
  Combu = 'combu',
  /** column name */
  Contmanu = 'contmanu',
  /** column name */
  Contmanunacional = 'contmanunacional',
  /** column name */
  Controlerota = 'controlerota',
  /** column name */
  Cor = 'cor',
  /** column name */
  DataInicioVolvoConnect = 'dataInicioVolvoConnect',
  /** column name */
  Dataenttec = 'dataenttec',
  /** column name */
  Datapedagio = 'datapedagio',
  /** column name */
  Digvel = 'digvel',
  /** column name */
  Digveldata = 'digveldata',
  /** column name */
  Discofreio = 'discofreio',
  /** column name */
  DtVeriTacografo = 'dtVeriTacografo',
  /** column name */
  Dtfimmanu = 'dtfimmanu',
  /** column name */
  Dtinimanu = 'dtinimanu',
  /** column name */
  Dtmanutcompleta = 'dtmanutcompleta',
  /** column name */
  Encerrante = 'encerrante',
  /** column name */
  Especie = 'especie',
  /** column name */
  Fatorcombust = 'fatorcombust',
  /** column name */
  Fatordist = 'fatordist',
  /** column name */
  Fauto = 'fauto',
  /** column name */
  Funcionario = 'funcionario',
  /** column name */
  Ibuttons = 'ibuttons',
  /** column name */
  IsVolvoConnect = 'isVolvoConnect',
  /** column name */
  Kmalugadoparcial = 'kmalugadoparcial',
  /** column name */
  Kmman = 'kmman',
  /** column name */
  Kmrevisao = 'kmrevisao',
  /** column name */
  Kmrodado = 'kmrodado',
  /** column name */
  Kmtelemetria = 'kmtelemetria',
  /** column name */
  Kmultmanu = 'kmultmanu',
  /** column name */
  Lacre = 'lacre',
  /** column name */
  Licdesp1 = 'licdesp1',
  /** column name */
  Licdesp2 = 'licdesp2',
  /** column name */
  Licdespmg = 'licdespmg',
  /** column name */
  Licvalor1 = 'licvalor1',
  /** column name */
  Licvalor2 = 'licvalor2',
  /** column name */
  Licvalormg = 'licvalormg',
  /** column name */
  Licvenc1 = 'licvenc1',
  /** column name */
  Licvenc2 = 'licvenc2',
  /** column name */
  Licvenc11 = 'licvenc11',
  /** column name */
  Licvenc22 = 'licvenc22',
  /** column name */
  Licvencmg3 = 'licvencmg3',
  /** column name */
  Licvencmg33 = 'licvencmg33',
  /** column name */
  Lonadia = 'lonadia',
  /** column name */
  Lonatra = 'lonatra',
  /** column name */
  Lonatru = 'lonatru',
  /** column name */
  Marca = 'marca',
  /** column name */
  Modelo = 'modelo',
  /** column name */
  Numvel = 'numvel',
  /** column name */
  Obs = 'obs',
  /** column name */
  Obssit = 'obssit',
  /** column name */
  Osfreio01 = 'osfreio01',
  /** column name */
  Osfreio02 = 'osfreio02',
  /** column name */
  Osfreio03 = 'osfreio03',
  /** column name */
  Osfreio04 = 'osfreio04',
  /** column name */
  Osfreio5 = 'osfreio5',
  /** column name */
  Osfreio6 = 'osfreio6',
  /** column name */
  Osfreio11 = 'osfreio11',
  /** column name */
  Osfreio12 = 'osfreio12',
  /** column name */
  Osrevis01 = 'osrevis01',
  /** column name */
  Osrevis02 = 'osrevis02',
  /** column name */
  Osrevis03 = 'osrevis03',
  /** column name */
  Osrevis04 = 'osrevis04',
  /** column name */
  Osrevis5 = 'osrevis5',
  /** column name */
  Osrevis6 = 'osrevis6',
  /** column name */
  Osrevis11 = 'osrevis11',
  /** column name */
  Osrevis12 = 'osrevis12',
  /** column name */
  Particular = 'particular',
  /** column name */
  Pedagio = 'pedagio',
  /** column name */
  Percminimotanque = 'percminimotanque',
  /** column name */
  Periodomanutbasica = 'periodomanutbasica',
  /** column name */
  Placa = 'placa',
  /** column name */
  Placa1 = 'placa1',
  /** column name */
  PlacaAntiga = 'placaAntiga',
  /** column name */
  Prazomp = 'prazomp',
  /** column name */
  Proprio = 'proprio',
  /** column name */
  Qtdpzmp = 'qtdpzmp',
  /** column name */
  Renavan = 'renavan',
  /** column name */
  Reservatanque = 'reservatanque',
  /** column name */
  Rpmvalue = 'rpmvalue',
  /** column name */
  Sinistros = 'sinistros',
  /** column name */
  Sitauto = 'sitauto',
  /** column name */
  Tambordia = 'tambordia',
  /** column name */
  Tambortra = 'tambortra',
  /** column name */
  Tambortru = 'tambortru',
  /** column name */
  Tamp = 'tamp',
  /** column name */
  Tampt = 'tampt',
  /** column name */
  Tipocontmanu = 'tipocontmanu',
  /** column name */
  Tiporeb = 'tiporeb',
  /** column name */
  Tipotruck = 'tipotruck',
  /** column name */
  Totalcintas = 'totalcintas',
  /** column name */
  Tpcarro = 'tpcarro',
  /** column name */
  Ultas = 'ultas',
  /** column name */
  Ultmanu = 'ultmanu',
  /** column name */
  Ultviag = 'ultviag',
  /** column name */
  Velanormal = 'velanormal',
  /** column name */
  Velnormal = 'velnormal',
  /** column name */
  Venc1 = 'venc1',
  /** column name */
  Venc2 = 'venc2',
  /** column name */
  Vistamp = 'vistamp'
}

/** input type for updating data in table "auto" */
export type Auto_Set_Input = {
  DtValidaUltContManu?: InputMaybe<Scalars['datetime']['input']>;
  KmBaseContManu?: InputMaybe<Scalars['Int']['input']>;
  KmUltContManu?: InputMaybe<Scalars['Int']['input']>;
  NumeroAET?: InputMaybe<Scalars['String']['input']>;
  TamanhoAET?: InputMaybe<Scalars['String']['input']>;
  TipoAlugado?: InputMaybe<Scalars['String']['input']>;
  agregadorastreamentoibor?: InputMaybe<Scalars['Boolean']['input']>;
  anof?: InputMaybe<Scalars['String']['input']>;
  anom?: InputMaybe<Scalars['String']['input']>;
  apolice?: InputMaybe<Scalars['String']['input']>;
  arla32?: InputMaybe<Scalars['String']['input']>;
  ativo?: InputMaybe<Scalars['String']['input']>;
  baterias?: InputMaybe<Scalars['Int']['input']>;
  bonusdm?: InputMaybe<Scalars['Int']['input']>;
  cacamba?: InputMaybe<Scalars['String']['input']>;
  capac?: InputMaybe<Scalars['Int']['input']>;
  capacidadetanque?: InputMaybe<Scalars['Int']['input']>;
  carbkp?: InputMaybe<Scalars['Boolean']['input']>;
  chassi?: InputMaybe<Scalars['String']['input']>;
  cia?: InputMaybe<Scalars['String']['input']>;
  cobertdm?: InputMaybe<Scalars['Float']['input']>;
  cobertdp?: InputMaybe<Scalars['Float']['input']>;
  cobertmp?: InputMaybe<Scalars['Float']['input']>;
  codmoto?: InputMaybe<Scalars['String']['input']>;
  codprop?: InputMaybe<Scalars['String']['input']>;
  combu?: InputMaybe<Scalars['String']['input']>;
  contmanu?: InputMaybe<Scalars['Boolean']['input']>;
  contmanunacional?: InputMaybe<Scalars['Boolean']['input']>;
  controlerota?: InputMaybe<Scalars['Boolean']['input']>;
  cor?: InputMaybe<Scalars['String']['input']>;
  dataInicioVolvoConnect?: InputMaybe<Scalars['datetime']['input']>;
  dataenttec?: InputMaybe<Scalars['datetime']['input']>;
  datapedagio?: InputMaybe<Scalars['datetime']['input']>;
  digvel?: InputMaybe<Scalars['Int']['input']>;
  digveldata?: InputMaybe<Scalars['datetime']['input']>;
  discofreio?: InputMaybe<Scalars['String']['input']>;
  dtVeriTacografo?: InputMaybe<Scalars['datetime']['input']>;
  dtfimmanu?: InputMaybe<Scalars['datetime']['input']>;
  dtinimanu?: InputMaybe<Scalars['datetime']['input']>;
  dtmanutcompleta?: InputMaybe<Scalars['date']['input']>;
  encerrante?: InputMaybe<Scalars['Boolean']['input']>;
  especie?: InputMaybe<Scalars['String']['input']>;
  fatorcombust?: InputMaybe<Scalars['Float']['input']>;
  fatordist?: InputMaybe<Scalars['Float']['input']>;
  fauto?: InputMaybe<Scalars['Int']['input']>;
  funcionario?: InputMaybe<Scalars['String']['input']>;
  ibuttons?: InputMaybe<Scalars['String']['input']>;
  isVolvoConnect?: InputMaybe<Scalars['Boolean']['input']>;
  kmalugadoparcial?: InputMaybe<Scalars['Int']['input']>;
  kmman?: InputMaybe<Scalars['Int']['input']>;
  kmrevisao?: InputMaybe<Scalars['Int']['input']>;
  kmrodado?: InputMaybe<Scalars['Int']['input']>;
  kmtelemetria?: InputMaybe<Scalars['Boolean']['input']>;
  kmultmanu?: InputMaybe<Scalars['Int']['input']>;
  lacre?: InputMaybe<Scalars['Boolean']['input']>;
  licdesp1?: InputMaybe<Scalars['String']['input']>;
  licdesp2?: InputMaybe<Scalars['String']['input']>;
  licdespmg?: InputMaybe<Scalars['String']['input']>;
  licvalor1?: InputMaybe<Scalars['Float']['input']>;
  licvalor2?: InputMaybe<Scalars['Float']['input']>;
  licvalormg?: InputMaybe<Scalars['Float']['input']>;
  licvenc1?: InputMaybe<Scalars['datetime']['input']>;
  licvenc2?: InputMaybe<Scalars['datetime']['input']>;
  licvenc11?: InputMaybe<Scalars['datetime']['input']>;
  licvenc22?: InputMaybe<Scalars['datetime']['input']>;
  licvencmg3?: InputMaybe<Scalars['datetime']['input']>;
  licvencmg33?: InputMaybe<Scalars['datetime']['input']>;
  lonadia?: InputMaybe<Scalars['String']['input']>;
  lonatra?: InputMaybe<Scalars['String']['input']>;
  lonatru?: InputMaybe<Scalars['String']['input']>;
  marca?: InputMaybe<Scalars['String']['input']>;
  modelo?: InputMaybe<Scalars['String']['input']>;
  numvel?: InputMaybe<Scalars['Int']['input']>;
  obs?: InputMaybe<Scalars['String']['input']>;
  obssit?: InputMaybe<Scalars['String']['input']>;
  osfreio01?: InputMaybe<Scalars['String']['input']>;
  osfreio02?: InputMaybe<Scalars['String']['input']>;
  osfreio03?: InputMaybe<Scalars['String']['input']>;
  osfreio04?: InputMaybe<Scalars['String']['input']>;
  osfreio5?: InputMaybe<Scalars['String']['input']>;
  osfreio6?: InputMaybe<Scalars['String']['input']>;
  osfreio11?: InputMaybe<Scalars['String']['input']>;
  osfreio12?: InputMaybe<Scalars['String']['input']>;
  osrevis01?: InputMaybe<Scalars['String']['input']>;
  osrevis02?: InputMaybe<Scalars['String']['input']>;
  osrevis03?: InputMaybe<Scalars['String']['input']>;
  osrevis04?: InputMaybe<Scalars['String']['input']>;
  osrevis5?: InputMaybe<Scalars['String']['input']>;
  osrevis6?: InputMaybe<Scalars['String']['input']>;
  osrevis11?: InputMaybe<Scalars['String']['input']>;
  osrevis12?: InputMaybe<Scalars['String']['input']>;
  particular?: InputMaybe<Scalars['Boolean']['input']>;
  pedagio?: InputMaybe<Scalars['Boolean']['input']>;
  percminimotanque?: InputMaybe<Scalars['Float']['input']>;
  periodomanutbasica?: InputMaybe<Scalars['Int']['input']>;
  placa?: InputMaybe<Scalars['String']['input']>;
  placa1?: InputMaybe<Scalars['String']['input']>;
  placaAntiga?: InputMaybe<Scalars['String']['input']>;
  prazomp?: InputMaybe<Scalars['Float']['input']>;
  proprio?: InputMaybe<Scalars['String']['input']>;
  qtdpzmp?: InputMaybe<Scalars['Int']['input']>;
  renavan?: InputMaybe<Scalars['String']['input']>;
  reservatanque?: InputMaybe<Scalars['Int']['input']>;
  rpmvalue?: InputMaybe<Scalars['Int']['input']>;
  sinistros?: InputMaybe<Scalars['Int']['input']>;
  sitauto?: InputMaybe<Scalars['String']['input']>;
  tambordia?: InputMaybe<Scalars['String']['input']>;
  tambortra?: InputMaybe<Scalars['String']['input']>;
  tambortru?: InputMaybe<Scalars['String']['input']>;
  tamp?: InputMaybe<Scalars['String']['input']>;
  tampt?: InputMaybe<Scalars['String']['input']>;
  tipocontmanu?: InputMaybe<Scalars['Int']['input']>;
  tiporeb?: InputMaybe<Scalars['String']['input']>;
  tipotruck?: InputMaybe<Scalars['String']['input']>;
  totalcintas?: InputMaybe<Scalars['Int']['input']>;
  tpcarro?: InputMaybe<Scalars['String']['input']>;
  ultas?: InputMaybe<Scalars['String']['input']>;
  ultmanu?: InputMaybe<Scalars['String']['input']>;
  ultviag?: InputMaybe<Scalars['String']['input']>;
  velanormal?: InputMaybe<Scalars['Float']['input']>;
  velnormal?: InputMaybe<Scalars['Float']['input']>;
  venc1?: InputMaybe<Scalars['datetime']['input']>;
  venc2?: InputMaybe<Scalars['datetime']['input']>;
  vistamp?: InputMaybe<Scalars['Float']['input']>;
};

/** aggregate stddev on columns */
export type Auto_Stddev_Fields = {
  __typename?: 'auto_stddev_fields';
  KmBaseContManu: Maybe<Scalars['Float']['output']>;
  KmUltContManu: Maybe<Scalars['Float']['output']>;
  baterias: Maybe<Scalars['Float']['output']>;
  bonusdm: Maybe<Scalars['Float']['output']>;
  capac: Maybe<Scalars['Float']['output']>;
  capacidadetanque: Maybe<Scalars['Float']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Float']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Float']['output']>;
  kmalugadoparcial: Maybe<Scalars['Float']['output']>;
  kmman: Maybe<Scalars['Float']['output']>;
  kmrevisao: Maybe<Scalars['Float']['output']>;
  kmrodado: Maybe<Scalars['Float']['output']>;
  kmultmanu: Maybe<Scalars['Float']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Float']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Float']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Float']['output']>;
  reservatanque: Maybe<Scalars['Float']['output']>;
  rpmvalue: Maybe<Scalars['Float']['output']>;
  sinistros: Maybe<Scalars['Float']['output']>;
  tipocontmanu: Maybe<Scalars['Float']['output']>;
  totalcintas: Maybe<Scalars['Float']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Auto_Stddev_Pop_Fields = {
  __typename?: 'auto_stddev_pop_fields';
  KmBaseContManu: Maybe<Scalars['Float']['output']>;
  KmUltContManu: Maybe<Scalars['Float']['output']>;
  baterias: Maybe<Scalars['Float']['output']>;
  bonusdm: Maybe<Scalars['Float']['output']>;
  capac: Maybe<Scalars['Float']['output']>;
  capacidadetanque: Maybe<Scalars['Float']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Float']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Float']['output']>;
  kmalugadoparcial: Maybe<Scalars['Float']['output']>;
  kmman: Maybe<Scalars['Float']['output']>;
  kmrevisao: Maybe<Scalars['Float']['output']>;
  kmrodado: Maybe<Scalars['Float']['output']>;
  kmultmanu: Maybe<Scalars['Float']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Float']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Float']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Float']['output']>;
  reservatanque: Maybe<Scalars['Float']['output']>;
  rpmvalue: Maybe<Scalars['Float']['output']>;
  sinistros: Maybe<Scalars['Float']['output']>;
  tipocontmanu: Maybe<Scalars['Float']['output']>;
  totalcintas: Maybe<Scalars['Float']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Auto_Stddev_Samp_Fields = {
  __typename?: 'auto_stddev_samp_fields';
  KmBaseContManu: Maybe<Scalars['Float']['output']>;
  KmUltContManu: Maybe<Scalars['Float']['output']>;
  baterias: Maybe<Scalars['Float']['output']>;
  bonusdm: Maybe<Scalars['Float']['output']>;
  capac: Maybe<Scalars['Float']['output']>;
  capacidadetanque: Maybe<Scalars['Float']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Float']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Float']['output']>;
  kmalugadoparcial: Maybe<Scalars['Float']['output']>;
  kmman: Maybe<Scalars['Float']['output']>;
  kmrevisao: Maybe<Scalars['Float']['output']>;
  kmrodado: Maybe<Scalars['Float']['output']>;
  kmultmanu: Maybe<Scalars['Float']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Float']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Float']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Float']['output']>;
  reservatanque: Maybe<Scalars['Float']['output']>;
  rpmvalue: Maybe<Scalars['Float']['output']>;
  sinistros: Maybe<Scalars['Float']['output']>;
  tipocontmanu: Maybe<Scalars['Float']['output']>;
  totalcintas: Maybe<Scalars['Float']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** aggregate sum on columns */
export type Auto_Sum_Fields = {
  __typename?: 'auto_sum_fields';
  KmBaseContManu: Maybe<Scalars['Int']['output']>;
  KmUltContManu: Maybe<Scalars['Int']['output']>;
  baterias: Maybe<Scalars['Int']['output']>;
  bonusdm: Maybe<Scalars['Int']['output']>;
  capac: Maybe<Scalars['Int']['output']>;
  capacidadetanque: Maybe<Scalars['Int']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Int']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Int']['output']>;
  kmalugadoparcial: Maybe<Scalars['Int']['output']>;
  kmman: Maybe<Scalars['Int']['output']>;
  kmrevisao: Maybe<Scalars['Int']['output']>;
  kmrodado: Maybe<Scalars['Int']['output']>;
  kmultmanu: Maybe<Scalars['Int']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Int']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Int']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Int']['output']>;
  reservatanque: Maybe<Scalars['Int']['output']>;
  rpmvalue: Maybe<Scalars['Int']['output']>;
  sinistros: Maybe<Scalars['Int']['output']>;
  tipocontmanu: Maybe<Scalars['Int']['output']>;
  totalcintas: Maybe<Scalars['Int']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** update columns of table "auto" */
export enum Auto_Update_Column {
  /** column name */
  DtValidaUltContManu = 'DtValidaUltContManu',
  /** column name */
  KmBaseContManu = 'KmBaseContManu',
  /** column name */
  KmUltContManu = 'KmUltContManu',
  /** column name */
  NumeroAet = 'NumeroAET',
  /** column name */
  TamanhoAet = 'TamanhoAET',
  /** column name */
  TipoAlugado = 'TipoAlugado',
  /** column name */
  Agregadorastreamentoibor = 'agregadorastreamentoibor',
  /** column name */
  Anof = 'anof',
  /** column name */
  Anom = 'anom',
  /** column name */
  Apolice = 'apolice',
  /** column name */
  Arla32 = 'arla32',
  /** column name */
  Ativo = 'ativo',
  /** column name */
  Baterias = 'baterias',
  /** column name */
  Bonusdm = 'bonusdm',
  /** column name */
  Cacamba = 'cacamba',
  /** column name */
  Capac = 'capac',
  /** column name */
  Capacidadetanque = 'capacidadetanque',
  /** column name */
  Carbkp = 'carbkp',
  /** column name */
  Chassi = 'chassi',
  /** column name */
  Cia = 'cia',
  /** column name */
  Cobertdm = 'cobertdm',
  /** column name */
  Cobertdp = 'cobertdp',
  /** column name */
  Cobertmp = 'cobertmp',
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  Codprop = 'codprop',
  /** column name */
  Combu = 'combu',
  /** column name */
  Contmanu = 'contmanu',
  /** column name */
  Contmanunacional = 'contmanunacional',
  /** column name */
  Controlerota = 'controlerota',
  /** column name */
  Cor = 'cor',
  /** column name */
  DataInicioVolvoConnect = 'dataInicioVolvoConnect',
  /** column name */
  Dataenttec = 'dataenttec',
  /** column name */
  Datapedagio = 'datapedagio',
  /** column name */
  Digvel = 'digvel',
  /** column name */
  Digveldata = 'digveldata',
  /** column name */
  Discofreio = 'discofreio',
  /** column name */
  DtVeriTacografo = 'dtVeriTacografo',
  /** column name */
  Dtfimmanu = 'dtfimmanu',
  /** column name */
  Dtinimanu = 'dtinimanu',
  /** column name */
  Dtmanutcompleta = 'dtmanutcompleta',
  /** column name */
  Encerrante = 'encerrante',
  /** column name */
  Especie = 'especie',
  /** column name */
  Fatorcombust = 'fatorcombust',
  /** column name */
  Fatordist = 'fatordist',
  /** column name */
  Fauto = 'fauto',
  /** column name */
  Funcionario = 'funcionario',
  /** column name */
  Ibuttons = 'ibuttons',
  /** column name */
  IsVolvoConnect = 'isVolvoConnect',
  /** column name */
  Kmalugadoparcial = 'kmalugadoparcial',
  /** column name */
  Kmman = 'kmman',
  /** column name */
  Kmrevisao = 'kmrevisao',
  /** column name */
  Kmrodado = 'kmrodado',
  /** column name */
  Kmtelemetria = 'kmtelemetria',
  /** column name */
  Kmultmanu = 'kmultmanu',
  /** column name */
  Lacre = 'lacre',
  /** column name */
  Licdesp1 = 'licdesp1',
  /** column name */
  Licdesp2 = 'licdesp2',
  /** column name */
  Licdespmg = 'licdespmg',
  /** column name */
  Licvalor1 = 'licvalor1',
  /** column name */
  Licvalor2 = 'licvalor2',
  /** column name */
  Licvalormg = 'licvalormg',
  /** column name */
  Licvenc1 = 'licvenc1',
  /** column name */
  Licvenc2 = 'licvenc2',
  /** column name */
  Licvenc11 = 'licvenc11',
  /** column name */
  Licvenc22 = 'licvenc22',
  /** column name */
  Licvencmg3 = 'licvencmg3',
  /** column name */
  Licvencmg33 = 'licvencmg33',
  /** column name */
  Lonadia = 'lonadia',
  /** column name */
  Lonatra = 'lonatra',
  /** column name */
  Lonatru = 'lonatru',
  /** column name */
  Marca = 'marca',
  /** column name */
  Modelo = 'modelo',
  /** column name */
  Numvel = 'numvel',
  /** column name */
  Obs = 'obs',
  /** column name */
  Obssit = 'obssit',
  /** column name */
  Osfreio01 = 'osfreio01',
  /** column name */
  Osfreio02 = 'osfreio02',
  /** column name */
  Osfreio03 = 'osfreio03',
  /** column name */
  Osfreio04 = 'osfreio04',
  /** column name */
  Osfreio5 = 'osfreio5',
  /** column name */
  Osfreio6 = 'osfreio6',
  /** column name */
  Osfreio11 = 'osfreio11',
  /** column name */
  Osfreio12 = 'osfreio12',
  /** column name */
  Osrevis01 = 'osrevis01',
  /** column name */
  Osrevis02 = 'osrevis02',
  /** column name */
  Osrevis03 = 'osrevis03',
  /** column name */
  Osrevis04 = 'osrevis04',
  /** column name */
  Osrevis5 = 'osrevis5',
  /** column name */
  Osrevis6 = 'osrevis6',
  /** column name */
  Osrevis11 = 'osrevis11',
  /** column name */
  Osrevis12 = 'osrevis12',
  /** column name */
  Particular = 'particular',
  /** column name */
  Pedagio = 'pedagio',
  /** column name */
  Percminimotanque = 'percminimotanque',
  /** column name */
  Periodomanutbasica = 'periodomanutbasica',
  /** column name */
  Placa = 'placa',
  /** column name */
  Placa1 = 'placa1',
  /** column name */
  PlacaAntiga = 'placaAntiga',
  /** column name */
  Prazomp = 'prazomp',
  /** column name */
  Proprio = 'proprio',
  /** column name */
  Qtdpzmp = 'qtdpzmp',
  /** column name */
  Renavan = 'renavan',
  /** column name */
  Reservatanque = 'reservatanque',
  /** column name */
  Rpmvalue = 'rpmvalue',
  /** column name */
  Sinistros = 'sinistros',
  /** column name */
  Sitauto = 'sitauto',
  /** column name */
  Tambordia = 'tambordia',
  /** column name */
  Tambortra = 'tambortra',
  /** column name */
  Tambortru = 'tambortru',
  /** column name */
  Tamp = 'tamp',
  /** column name */
  Tampt = 'tampt',
  /** column name */
  Tipocontmanu = 'tipocontmanu',
  /** column name */
  Tiporeb = 'tiporeb',
  /** column name */
  Tipotruck = 'tipotruck',
  /** column name */
  Totalcintas = 'totalcintas',
  /** column name */
  Tpcarro = 'tpcarro',
  /** column name */
  Ultas = 'ultas',
  /** column name */
  Ultmanu = 'ultmanu',
  /** column name */
  Ultviag = 'ultviag',
  /** column name */
  Velanormal = 'velanormal',
  /** column name */
  Velnormal = 'velnormal',
  /** column name */
  Venc1 = 'venc1',
  /** column name */
  Venc2 = 'venc2',
  /** column name */
  Vistamp = 'vistamp'
}

/** aggregate var_pop on columns */
export type Auto_Var_Pop_Fields = {
  __typename?: 'auto_var_pop_fields';
  KmBaseContManu: Maybe<Scalars['Float']['output']>;
  KmUltContManu: Maybe<Scalars['Float']['output']>;
  baterias: Maybe<Scalars['Float']['output']>;
  bonusdm: Maybe<Scalars['Float']['output']>;
  capac: Maybe<Scalars['Float']['output']>;
  capacidadetanque: Maybe<Scalars['Float']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Float']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Float']['output']>;
  kmalugadoparcial: Maybe<Scalars['Float']['output']>;
  kmman: Maybe<Scalars['Float']['output']>;
  kmrevisao: Maybe<Scalars['Float']['output']>;
  kmrodado: Maybe<Scalars['Float']['output']>;
  kmultmanu: Maybe<Scalars['Float']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Float']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Float']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Float']['output']>;
  reservatanque: Maybe<Scalars['Float']['output']>;
  rpmvalue: Maybe<Scalars['Float']['output']>;
  sinistros: Maybe<Scalars['Float']['output']>;
  tipocontmanu: Maybe<Scalars['Float']['output']>;
  totalcintas: Maybe<Scalars['Float']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Auto_Var_Samp_Fields = {
  __typename?: 'auto_var_samp_fields';
  KmBaseContManu: Maybe<Scalars['Float']['output']>;
  KmUltContManu: Maybe<Scalars['Float']['output']>;
  baterias: Maybe<Scalars['Float']['output']>;
  bonusdm: Maybe<Scalars['Float']['output']>;
  capac: Maybe<Scalars['Float']['output']>;
  capacidadetanque: Maybe<Scalars['Float']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Float']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Float']['output']>;
  kmalugadoparcial: Maybe<Scalars['Float']['output']>;
  kmman: Maybe<Scalars['Float']['output']>;
  kmrevisao: Maybe<Scalars['Float']['output']>;
  kmrodado: Maybe<Scalars['Float']['output']>;
  kmultmanu: Maybe<Scalars['Float']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Float']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Float']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Float']['output']>;
  reservatanque: Maybe<Scalars['Float']['output']>;
  rpmvalue: Maybe<Scalars['Float']['output']>;
  sinistros: Maybe<Scalars['Float']['output']>;
  tipocontmanu: Maybe<Scalars['Float']['output']>;
  totalcintas: Maybe<Scalars['Float']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Auto_Variance_Fields = {
  __typename?: 'auto_variance_fields';
  KmBaseContManu: Maybe<Scalars['Float']['output']>;
  KmUltContManu: Maybe<Scalars['Float']['output']>;
  baterias: Maybe<Scalars['Float']['output']>;
  bonusdm: Maybe<Scalars['Float']['output']>;
  capac: Maybe<Scalars['Float']['output']>;
  capacidadetanque: Maybe<Scalars['Float']['output']>;
  cobertdm: Maybe<Scalars['Float']['output']>;
  cobertdp: Maybe<Scalars['Float']['output']>;
  cobertmp: Maybe<Scalars['Float']['output']>;
  digvel: Maybe<Scalars['Float']['output']>;
  fatorcombust: Maybe<Scalars['Float']['output']>;
  fatordist: Maybe<Scalars['Float']['output']>;
  fauto: Maybe<Scalars['Float']['output']>;
  kmalugadoparcial: Maybe<Scalars['Float']['output']>;
  kmman: Maybe<Scalars['Float']['output']>;
  kmrevisao: Maybe<Scalars['Float']['output']>;
  kmrodado: Maybe<Scalars['Float']['output']>;
  kmultmanu: Maybe<Scalars['Float']['output']>;
  licvalor1: Maybe<Scalars['Float']['output']>;
  licvalor2: Maybe<Scalars['Float']['output']>;
  licvalormg: Maybe<Scalars['Float']['output']>;
  numvel: Maybe<Scalars['Float']['output']>;
  percminimotanque: Maybe<Scalars['Float']['output']>;
  periodomanutbasica: Maybe<Scalars['Float']['output']>;
  prazomp: Maybe<Scalars['Float']['output']>;
  qtdpzmp: Maybe<Scalars['Float']['output']>;
  reservatanque: Maybe<Scalars['Float']['output']>;
  rpmvalue: Maybe<Scalars['Float']['output']>;
  sinistros: Maybe<Scalars['Float']['output']>;
  tipocontmanu: Maybe<Scalars['Float']['output']>;
  totalcintas: Maybe<Scalars['Float']['output']>;
  velanormal: Maybe<Scalars['Float']['output']>;
  velnormal: Maybe<Scalars['Float']['output']>;
  vistamp: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "bi.dashboard" */
export type Bi_Dashboard = {
  __typename?: 'bi_dashboard';
  color: Scalars['String']['output'];
  /** An array relationship */
  dashboard_items: Array<Bi_Dashboard_Item>;
  /** An aggregate relationship */
  dashboard_items_aggregate: Bi_Dashboard_Item_Aggregate;
  grid_layout_config: Maybe<Scalars['jsonb']['output']>;
  icon: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  public_links: Array<Bi_Public_Link>;
  /** An aggregate relationship */
  public_links_aggregate: Bi_Public_Link_Aggregate;
  /** An array relationship */
  query_caches: Array<Bi_Query_Cache>;
  /** An aggregate relationship */
  query_caches_aggregate: Bi_Query_Cache_Aggregate;
  /** In seconds */
  refresh_interval: Scalars['Int']['output'];
  uuid: Scalars['uuid']['output'];
  variable_overrides: Maybe<Scalars['jsonb']['output']>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardDashboard_ItemsArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardDashboard_Items_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardGrid_Layout_ConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardPublic_LinksArgs = {
  distinct_on?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Public_Link_Order_By>>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardPublic_Links_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Public_Link_Order_By>>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardQuery_CachesArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardQuery_Caches_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


/** columns and relationships of "bi.dashboard" */
export type Bi_DashboardVariable_OverridesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "bi.dashboard" */
export type Bi_Dashboard_Aggregate = {
  __typename?: 'bi_dashboard_aggregate';
  aggregate: Maybe<Bi_Dashboard_Aggregate_Fields>;
  nodes: Array<Bi_Dashboard>;
};

/** aggregate fields of "bi.dashboard" */
export type Bi_Dashboard_Aggregate_Fields = {
  __typename?: 'bi_dashboard_aggregate_fields';
  avg: Maybe<Bi_Dashboard_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Dashboard_Max_Fields>;
  min: Maybe<Bi_Dashboard_Min_Fields>;
  stddev: Maybe<Bi_Dashboard_Stddev_Fields>;
  stddev_pop: Maybe<Bi_Dashboard_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Bi_Dashboard_Stddev_Samp_Fields>;
  sum: Maybe<Bi_Dashboard_Sum_Fields>;
  var_pop: Maybe<Bi_Dashboard_Var_Pop_Fields>;
  var_samp: Maybe<Bi_Dashboard_Var_Samp_Fields>;
  variance: Maybe<Bi_Dashboard_Variance_Fields>;
};


/** aggregate fields of "bi.dashboard" */
export type Bi_Dashboard_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Dashboard_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Bi_Dashboard_Append_Input = {
  grid_layout_config?: InputMaybe<Scalars['jsonb']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Bi_Dashboard_Avg_Fields = {
  __typename?: 'bi_dashboard_avg_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "bi.dashboard". All fields are combined with a logical 'AND'. */
export type Bi_Dashboard_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Dashboard_Bool_Exp>>;
  _not?: InputMaybe<Bi_Dashboard_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Dashboard_Bool_Exp>>;
  color?: InputMaybe<String_Comparison_Exp>;
  dashboard_items?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
  dashboard_items_aggregate?: InputMaybe<Bi_Dashboard_Item_Aggregate_Bool_Exp>;
  grid_layout_config?: InputMaybe<Jsonb_Comparison_Exp>;
  icon?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  public_links?: InputMaybe<Bi_Public_Link_Bool_Exp>;
  public_links_aggregate?: InputMaybe<Bi_Public_Link_Aggregate_Bool_Exp>;
  query_caches?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
  query_caches_aggregate?: InputMaybe<Bi_Query_Cache_Aggregate_Bool_Exp>;
  refresh_interval?: InputMaybe<Int_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  variable_overrides?: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.dashboard" */
export enum Bi_Dashboard_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  DashboardPkey = 'dashboard_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Bi_Dashboard_Delete_At_Path_Input = {
  grid_layout_config?: InputMaybe<Array<Scalars['String']['input']>>;
  variable_overrides?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Bi_Dashboard_Delete_Elem_Input = {
  grid_layout_config?: InputMaybe<Scalars['Int']['input']>;
  variable_overrides?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Bi_Dashboard_Delete_Key_Input = {
  grid_layout_config?: InputMaybe<Scalars['String']['input']>;
  variable_overrides?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "bi.dashboard" */
export type Bi_Dashboard_Inc_Input = {
  /** In seconds */
  refresh_interval?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "bi.dashboard" */
export type Bi_Dashboard_Insert_Input = {
  color?: InputMaybe<Scalars['String']['input']>;
  dashboard_items?: InputMaybe<Bi_Dashboard_Item_Arr_Rel_Insert_Input>;
  grid_layout_config?: InputMaybe<Scalars['jsonb']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  public_links?: InputMaybe<Bi_Public_Link_Arr_Rel_Insert_Input>;
  query_caches?: InputMaybe<Bi_Query_Cache_Arr_Rel_Insert_Input>;
  /** In seconds */
  refresh_interval?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** columns and relationships of "bi.dashboard_item" */
export type Bi_Dashboard_Item = {
  __typename?: 'bi_dashboard_item';
  config: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  dashboard: Bi_Dashboard;
  /** An object relationship */
  dashboard_item_type: Bi_Dashboard_Item_Type;
  dashboard_uuid: Scalars['uuid']['output'];
  header_color: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** An object relationship */
  query: Bi_Query;
  query_uuid: Scalars['uuid']['output'];
  type: Scalars['String']['output'];
  uuid: Scalars['uuid']['output'];
  variable_overrides: Maybe<Scalars['jsonb']['output']>;
};


/** columns and relationships of "bi.dashboard_item" */
export type Bi_Dashboard_ItemConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "bi.dashboard_item" */
export type Bi_Dashboard_ItemVariable_OverridesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "bi.dashboard_item" */
export type Bi_Dashboard_Item_Aggregate = {
  __typename?: 'bi_dashboard_item_aggregate';
  aggregate: Maybe<Bi_Dashboard_Item_Aggregate_Fields>;
  nodes: Array<Bi_Dashboard_Item>;
};

export type Bi_Dashboard_Item_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Dashboard_Item_Aggregate_Bool_Exp_Count>;
};

export type Bi_Dashboard_Item_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.dashboard_item" */
export type Bi_Dashboard_Item_Aggregate_Fields = {
  __typename?: 'bi_dashboard_item_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Dashboard_Item_Max_Fields>;
  min: Maybe<Bi_Dashboard_Item_Min_Fields>;
};


/** aggregate fields of "bi.dashboard_item" */
export type Bi_Dashboard_Item_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.dashboard_item" */
export type Bi_Dashboard_Item_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Dashboard_Item_Max_Order_By>;
  min?: InputMaybe<Bi_Dashboard_Item_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Bi_Dashboard_Item_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "bi.dashboard_item" */
export type Bi_Dashboard_Item_Arr_Rel_Insert_Input = {
  data: Array<Bi_Dashboard_Item_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Dashboard_Item_On_Conflict>;
};

/** Boolean expression to filter rows from the table "bi.dashboard_item". All fields are combined with a logical 'AND'. */
export type Bi_Dashboard_Item_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Dashboard_Item_Bool_Exp>>;
  _not?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Dashboard_Item_Bool_Exp>>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  dashboard?: InputMaybe<Bi_Dashboard_Bool_Exp>;
  dashboard_item_type?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
  dashboard_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  header_color?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  query?: InputMaybe<Bi_Query_Bool_Exp>;
  query_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  variable_overrides?: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.dashboard_item" */
export enum Bi_Dashboard_Item_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  DashboardItemPkey = 'dashboard_item_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Bi_Dashboard_Item_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
  variable_overrides?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Bi_Dashboard_Item_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
  variable_overrides?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Bi_Dashboard_Item_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
  variable_overrides?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "bi.dashboard_item" */
export type Bi_Dashboard_Item_Insert_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  dashboard?: InputMaybe<Bi_Dashboard_Obj_Rel_Insert_Input>;
  dashboard_item_type?: InputMaybe<Bi_Dashboard_Item_Type_Obj_Rel_Insert_Input>;
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  header_color?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Bi_Query_Obj_Rel_Insert_Input>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate max on columns */
export type Bi_Dashboard_Item_Max_Fields = {
  __typename?: 'bi_dashboard_item_max_fields';
  dashboard_uuid: Maybe<Scalars['uuid']['output']>;
  header_color: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  query_uuid: Maybe<Scalars['uuid']['output']>;
  type: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "bi.dashboard_item" */
export type Bi_Dashboard_Item_Max_Order_By = {
  dashboard_uuid?: InputMaybe<Order_By>;
  header_color?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Dashboard_Item_Min_Fields = {
  __typename?: 'bi_dashboard_item_min_fields';
  dashboard_uuid: Maybe<Scalars['uuid']['output']>;
  header_color: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  query_uuid: Maybe<Scalars['uuid']['output']>;
  type: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "bi.dashboard_item" */
export type Bi_Dashboard_Item_Min_Order_By = {
  dashboard_uuid?: InputMaybe<Order_By>;
  header_color?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.dashboard_item" */
export type Bi_Dashboard_Item_Mutation_Response = {
  __typename?: 'bi_dashboard_item_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Dashboard_Item>;
};

/** on_conflict condition type for table "bi.dashboard_item" */
export type Bi_Dashboard_Item_On_Conflict = {
  constraint: Bi_Dashboard_Item_Constraint;
  update_columns?: Array<Bi_Dashboard_Item_Update_Column>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.dashboard_item". */
export type Bi_Dashboard_Item_Order_By = {
  config?: InputMaybe<Order_By>;
  dashboard?: InputMaybe<Bi_Dashboard_Order_By>;
  dashboard_item_type?: InputMaybe<Bi_Dashboard_Item_Type_Order_By>;
  dashboard_uuid?: InputMaybe<Order_By>;
  header_color?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  query?: InputMaybe<Bi_Query_Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  variable_overrides?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.dashboard_item */
export type Bi_Dashboard_Item_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Bi_Dashboard_Item_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "bi.dashboard_item" */
export enum Bi_Dashboard_Item_Select_Column {
  /** column name */
  Config = 'config',
  /** column name */
  DashboardUuid = 'dashboard_uuid',
  /** column name */
  HeaderColor = 'header_color',
  /** column name */
  Name = 'name',
  /** column name */
  QueryUuid = 'query_uuid',
  /** column name */
  Type = 'type',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VariableOverrides = 'variable_overrides'
}

/** input type for updating data in table "bi.dashboard_item" */
export type Bi_Dashboard_Item_Set_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  header_color?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Streaming cursor of the table "bi_dashboard_item" */
export type Bi_Dashboard_Item_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Dashboard_Item_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Dashboard_Item_Stream_Cursor_Value_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  header_color?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** columns and relationships of "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type = {
  __typename?: 'bi_dashboard_item_type';
  /** An array relationship */
  dashboard_items: Array<Bi_Dashboard_Item>;
  /** An aggregate relationship */
  dashboard_items_aggregate: Bi_Dashboard_Item_Aggregate;
  type: Scalars['String']['output'];
};


/** columns and relationships of "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_TypeDashboard_ItemsArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


/** columns and relationships of "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_TypeDashboard_Items_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};

/** aggregated selection of "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Aggregate = {
  __typename?: 'bi_dashboard_item_type_aggregate';
  aggregate: Maybe<Bi_Dashboard_Item_Type_Aggregate_Fields>;
  nodes: Array<Bi_Dashboard_Item_Type>;
};

/** aggregate fields of "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Aggregate_Fields = {
  __typename?: 'bi_dashboard_item_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Dashboard_Item_Type_Max_Fields>;
  min: Maybe<Bi_Dashboard_Item_Type_Min_Fields>;
};


/** aggregate fields of "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Dashboard_Item_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "bi.dashboard_item_type". All fields are combined with a logical 'AND'. */
export type Bi_Dashboard_Item_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Dashboard_Item_Type_Bool_Exp>>;
  _not?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Dashboard_Item_Type_Bool_Exp>>;
  dashboard_items?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
  dashboard_items_aggregate?: InputMaybe<Bi_Dashboard_Item_Aggregate_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.dashboard_item_type" */
export enum Bi_Dashboard_Item_Type_Constraint {
  /** unique or primary key constraint on columns "type" */
  DashboardItemTypePkey = 'dashboard_item_type_pkey'
}

/** input type for inserting data into table "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Insert_Input = {
  dashboard_items?: InputMaybe<Bi_Dashboard_Item_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Bi_Dashboard_Item_Type_Max_Fields = {
  __typename?: 'bi_dashboard_item_type_max_fields';
  type: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Bi_Dashboard_Item_Type_Min_Fields = {
  __typename?: 'bi_dashboard_item_type_min_fields';
  type: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Mutation_Response = {
  __typename?: 'bi_dashboard_item_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Dashboard_Item_Type>;
};

/** input type for inserting object relation for remote table "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Obj_Rel_Insert_Input = {
  data: Bi_Dashboard_Item_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Dashboard_Item_Type_On_Conflict>;
};

/** on_conflict condition type for table "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_On_Conflict = {
  constraint: Bi_Dashboard_Item_Type_Constraint;
  update_columns?: Array<Bi_Dashboard_Item_Type_Update_Column>;
  where?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.dashboard_item_type". */
export type Bi_Dashboard_Item_Type_Order_By = {
  dashboard_items_aggregate?: InputMaybe<Bi_Dashboard_Item_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.dashboard_item_type */
export type Bi_Dashboard_Item_Type_Pk_Columns_Input = {
  type: Scalars['String']['input'];
};

/** select columns of table "bi.dashboard_item_type" */
export enum Bi_Dashboard_Item_Type_Select_Column {
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "bi.dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Set_Input = {
  type?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "bi_dashboard_item_type" */
export type Bi_Dashboard_Item_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Dashboard_Item_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Dashboard_Item_Type_Stream_Cursor_Value_Input = {
  type?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "bi.dashboard_item_type" */
export enum Bi_Dashboard_Item_Type_Update_Column {
  /** column name */
  Type = 'type'
}

export type Bi_Dashboard_Item_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Dashboard_Item_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Dashboard_Item_Type_Bool_Exp;
};

/** update columns of table "bi.dashboard_item" */
export enum Bi_Dashboard_Item_Update_Column {
  /** column name */
  Config = 'config',
  /** column name */
  DashboardUuid = 'dashboard_uuid',
  /** column name */
  HeaderColor = 'header_color',
  /** column name */
  Name = 'name',
  /** column name */
  QueryUuid = 'query_uuid',
  /** column name */
  Type = 'type',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VariableOverrides = 'variable_overrides'
}

export type Bi_Dashboard_Item_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Bi_Dashboard_Item_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Bi_Dashboard_Item_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Bi_Dashboard_Item_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Bi_Dashboard_Item_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Bi_Dashboard_Item_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Dashboard_Item_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Dashboard_Item_Bool_Exp;
};

/** aggregate max on columns */
export type Bi_Dashboard_Max_Fields = {
  __typename?: 'bi_dashboard_max_fields';
  color: Maybe<Scalars['String']['output']>;
  icon: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  /** In seconds */
  refresh_interval: Maybe<Scalars['Int']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Bi_Dashboard_Min_Fields = {
  __typename?: 'bi_dashboard_min_fields';
  color: Maybe<Scalars['String']['output']>;
  icon: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  /** In seconds */
  refresh_interval: Maybe<Scalars['Int']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "bi.dashboard" */
export type Bi_Dashboard_Mutation_Response = {
  __typename?: 'bi_dashboard_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Dashboard>;
};

/** input type for inserting object relation for remote table "bi.dashboard" */
export type Bi_Dashboard_Obj_Rel_Insert_Input = {
  data: Bi_Dashboard_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Dashboard_On_Conflict>;
};

/** on_conflict condition type for table "bi.dashboard" */
export type Bi_Dashboard_On_Conflict = {
  constraint: Bi_Dashboard_Constraint;
  update_columns?: Array<Bi_Dashboard_Update_Column>;
  where?: InputMaybe<Bi_Dashboard_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.dashboard". */
export type Bi_Dashboard_Order_By = {
  color?: InputMaybe<Order_By>;
  dashboard_items_aggregate?: InputMaybe<Bi_Dashboard_Item_Aggregate_Order_By>;
  grid_layout_config?: InputMaybe<Order_By>;
  icon?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  public_links_aggregate?: InputMaybe<Bi_Public_Link_Aggregate_Order_By>;
  query_caches_aggregate?: InputMaybe<Bi_Query_Cache_Aggregate_Order_By>;
  refresh_interval?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  variable_overrides?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.dashboard */
export type Bi_Dashboard_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Bi_Dashboard_Prepend_Input = {
  grid_layout_config?: InputMaybe<Scalars['jsonb']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "bi.dashboard" */
export enum Bi_Dashboard_Select_Column {
  /** column name */
  Color = 'color',
  /** column name */
  GridLayoutConfig = 'grid_layout_config',
  /** column name */
  Icon = 'icon',
  /** column name */
  Name = 'name',
  /** column name */
  RefreshInterval = 'refresh_interval',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VariableOverrides = 'variable_overrides'
}

/** input type for updating data in table "bi.dashboard" */
export type Bi_Dashboard_Set_Input = {
  color?: InputMaybe<Scalars['String']['input']>;
  grid_layout_config?: InputMaybe<Scalars['jsonb']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** In seconds */
  refresh_interval?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate stddev on columns */
export type Bi_Dashboard_Stddev_Fields = {
  __typename?: 'bi_dashboard_stddev_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Bi_Dashboard_Stddev_Pop_Fields = {
  __typename?: 'bi_dashboard_stddev_pop_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Bi_Dashboard_Stddev_Samp_Fields = {
  __typename?: 'bi_dashboard_stddev_samp_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "bi_dashboard" */
export type Bi_Dashboard_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Dashboard_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Dashboard_Stream_Cursor_Value_Input = {
  color?: InputMaybe<Scalars['String']['input']>;
  grid_layout_config?: InputMaybe<Scalars['jsonb']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** In seconds */
  refresh_interval?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  variable_overrides?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type Bi_Dashboard_Sum_Fields = {
  __typename?: 'bi_dashboard_sum_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "bi.dashboard" */
export enum Bi_Dashboard_Update_Column {
  /** column name */
  Color = 'color',
  /** column name */
  GridLayoutConfig = 'grid_layout_config',
  /** column name */
  Icon = 'icon',
  /** column name */
  Name = 'name',
  /** column name */
  RefreshInterval = 'refresh_interval',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VariableOverrides = 'variable_overrides'
}

export type Bi_Dashboard_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Bi_Dashboard_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Bi_Dashboard_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Bi_Dashboard_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Bi_Dashboard_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bi_Dashboard_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Bi_Dashboard_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Dashboard_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Dashboard_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bi_Dashboard_Var_Pop_Fields = {
  __typename?: 'bi_dashboard_var_pop_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Bi_Dashboard_Var_Samp_Fields = {
  __typename?: 'bi_dashboard_var_samp_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Bi_Dashboard_Variance_Fields = {
  __typename?: 'bi_dashboard_variance_fields';
  /** In seconds */
  refresh_interval: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "bi.datasource" */
export type Bi_Datasource = {
  __typename?: 'bi_datasource';
  database: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  datasource_type: Bi_Datasource_Type;
  host: Scalars['String']['output'];
  name: Scalars['String']['output'];
  password: Scalars['String']['output'];
  port: Scalars['Int']['output'];
  /** An array relationship */
  queries: Array<Bi_Query>;
  /** An aggregate relationship */
  queries_aggregate: Bi_Query_Aggregate;
  type: Scalars['String']['output'];
  user: Scalars['String']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "bi.datasource" */
export type Bi_DatasourceQueriesArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Order_By>>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};


/** columns and relationships of "bi.datasource" */
export type Bi_DatasourceQueries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Order_By>>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};

/** aggregated selection of "bi.datasource" */
export type Bi_Datasource_Aggregate = {
  __typename?: 'bi_datasource_aggregate';
  aggregate: Maybe<Bi_Datasource_Aggregate_Fields>;
  nodes: Array<Bi_Datasource>;
};

export type Bi_Datasource_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Datasource_Aggregate_Bool_Exp_Count>;
};

export type Bi_Datasource_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Datasource_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.datasource" */
export type Bi_Datasource_Aggregate_Fields = {
  __typename?: 'bi_datasource_aggregate_fields';
  avg: Maybe<Bi_Datasource_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Datasource_Max_Fields>;
  min: Maybe<Bi_Datasource_Min_Fields>;
  stddev: Maybe<Bi_Datasource_Stddev_Fields>;
  stddev_pop: Maybe<Bi_Datasource_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Bi_Datasource_Stddev_Samp_Fields>;
  sum: Maybe<Bi_Datasource_Sum_Fields>;
  var_pop: Maybe<Bi_Datasource_Var_Pop_Fields>;
  var_samp: Maybe<Bi_Datasource_Var_Samp_Fields>;
  variance: Maybe<Bi_Datasource_Variance_Fields>;
};


/** aggregate fields of "bi.datasource" */
export type Bi_Datasource_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.datasource" */
export type Bi_Datasource_Aggregate_Order_By = {
  avg?: InputMaybe<Bi_Datasource_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Datasource_Max_Order_By>;
  min?: InputMaybe<Bi_Datasource_Min_Order_By>;
  stddev?: InputMaybe<Bi_Datasource_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Bi_Datasource_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Bi_Datasource_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Bi_Datasource_Sum_Order_By>;
  var_pop?: InputMaybe<Bi_Datasource_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Bi_Datasource_Var_Samp_Order_By>;
  variance?: InputMaybe<Bi_Datasource_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "bi.datasource" */
export type Bi_Datasource_Arr_Rel_Insert_Input = {
  data: Array<Bi_Datasource_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Datasource_On_Conflict>;
};

/** aggregate avg on columns */
export type Bi_Datasource_Avg_Fields = {
  __typename?: 'bi_datasource_avg_fields';
  port: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "bi.datasource" */
export type Bi_Datasource_Avg_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "bi.datasource". All fields are combined with a logical 'AND'. */
export type Bi_Datasource_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Datasource_Bool_Exp>>;
  _not?: InputMaybe<Bi_Datasource_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Datasource_Bool_Exp>>;
  database?: InputMaybe<String_Comparison_Exp>;
  datasource_type?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
  host?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  password?: InputMaybe<String_Comparison_Exp>;
  port?: InputMaybe<Int_Comparison_Exp>;
  queries?: InputMaybe<Bi_Query_Bool_Exp>;
  queries_aggregate?: InputMaybe<Bi_Query_Aggregate_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<String_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.datasource" */
export enum Bi_Datasource_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  DatasourcePkey = 'datasource_pkey'
}

/** input type for incrementing numeric columns in table "bi.datasource" */
export type Bi_Datasource_Inc_Input = {
  port?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "bi.datasource" */
export type Bi_Datasource_Insert_Input = {
  database?: InputMaybe<Scalars['String']['input']>;
  datasource_type?: InputMaybe<Bi_Datasource_Type_Obj_Rel_Insert_Input>;
  host?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  queries?: InputMaybe<Bi_Query_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Bi_Datasource_Max_Fields = {
  __typename?: 'bi_datasource_max_fields';
  database: Maybe<Scalars['String']['output']>;
  host: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  password: Maybe<Scalars['String']['output']>;
  port: Maybe<Scalars['Int']['output']>;
  type: Maybe<Scalars['String']['output']>;
  user: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "bi.datasource" */
export type Bi_Datasource_Max_Order_By = {
  database?: InputMaybe<Order_By>;
  host?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  password?: InputMaybe<Order_By>;
  port?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  user?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Datasource_Min_Fields = {
  __typename?: 'bi_datasource_min_fields';
  database: Maybe<Scalars['String']['output']>;
  host: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  password: Maybe<Scalars['String']['output']>;
  port: Maybe<Scalars['Int']['output']>;
  type: Maybe<Scalars['String']['output']>;
  user: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "bi.datasource" */
export type Bi_Datasource_Min_Order_By = {
  database?: InputMaybe<Order_By>;
  host?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  password?: InputMaybe<Order_By>;
  port?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  user?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.datasource" */
export type Bi_Datasource_Mutation_Response = {
  __typename?: 'bi_datasource_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Datasource>;
};

/** input type for inserting object relation for remote table "bi.datasource" */
export type Bi_Datasource_Obj_Rel_Insert_Input = {
  data: Bi_Datasource_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Datasource_On_Conflict>;
};

/** on_conflict condition type for table "bi.datasource" */
export type Bi_Datasource_On_Conflict = {
  constraint: Bi_Datasource_Constraint;
  update_columns?: Array<Bi_Datasource_Update_Column>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.datasource". */
export type Bi_Datasource_Order_By = {
  database?: InputMaybe<Order_By>;
  datasource_type?: InputMaybe<Bi_Datasource_Type_Order_By>;
  host?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  password?: InputMaybe<Order_By>;
  port?: InputMaybe<Order_By>;
  queries_aggregate?: InputMaybe<Bi_Query_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
  user?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.datasource */
export type Bi_Datasource_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "bi.datasource" */
export enum Bi_Datasource_Select_Column {
  /** column name */
  Database = 'database',
  /** column name */
  Host = 'host',
  /** column name */
  Name = 'name',
  /** column name */
  Password = 'password',
  /** column name */
  Port = 'port',
  /** column name */
  Type = 'type',
  /** column name */
  User = 'user',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "bi.datasource" */
export type Bi_Datasource_Set_Input = {
  database?: InputMaybe<Scalars['String']['input']>;
  host?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Bi_Datasource_Stddev_Fields = {
  __typename?: 'bi_datasource_stddev_fields';
  port: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "bi.datasource" */
export type Bi_Datasource_Stddev_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Bi_Datasource_Stddev_Pop_Fields = {
  __typename?: 'bi_datasource_stddev_pop_fields';
  port: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "bi.datasource" */
export type Bi_Datasource_Stddev_Pop_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Bi_Datasource_Stddev_Samp_Fields = {
  __typename?: 'bi_datasource_stddev_samp_fields';
  port: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "bi.datasource" */
export type Bi_Datasource_Stddev_Samp_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "bi_datasource" */
export type Bi_Datasource_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Datasource_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Datasource_Stream_Cursor_Value_Input = {
  database?: InputMaybe<Scalars['String']['input']>;
  host?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Bi_Datasource_Sum_Fields = {
  __typename?: 'bi_datasource_sum_fields';
  port: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "bi.datasource" */
export type Bi_Datasource_Sum_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** columns and relationships of "bi.datasource_type" */
export type Bi_Datasource_Type = {
  __typename?: 'bi_datasource_type';
  /** An array relationship */
  datasources: Array<Bi_Datasource>;
  /** An aggregate relationship */
  datasources_aggregate: Bi_Datasource_Aggregate;
  type: Scalars['String']['output'];
};


/** columns and relationships of "bi.datasource_type" */
export type Bi_Datasource_TypeDatasourcesArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};


/** columns and relationships of "bi.datasource_type" */
export type Bi_Datasource_TypeDatasources_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};

/** aggregated selection of "bi.datasource_type" */
export type Bi_Datasource_Type_Aggregate = {
  __typename?: 'bi_datasource_type_aggregate';
  aggregate: Maybe<Bi_Datasource_Type_Aggregate_Fields>;
  nodes: Array<Bi_Datasource_Type>;
};

/** aggregate fields of "bi.datasource_type" */
export type Bi_Datasource_Type_Aggregate_Fields = {
  __typename?: 'bi_datasource_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Datasource_Type_Max_Fields>;
  min: Maybe<Bi_Datasource_Type_Min_Fields>;
};


/** aggregate fields of "bi.datasource_type" */
export type Bi_Datasource_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Datasource_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "bi.datasource_type". All fields are combined with a logical 'AND'. */
export type Bi_Datasource_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Datasource_Type_Bool_Exp>>;
  _not?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Datasource_Type_Bool_Exp>>;
  datasources?: InputMaybe<Bi_Datasource_Bool_Exp>;
  datasources_aggregate?: InputMaybe<Bi_Datasource_Aggregate_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.datasource_type" */
export enum Bi_Datasource_Type_Constraint {
  /** unique or primary key constraint on columns "type" */
  DatasourceTypePkey = 'datasource_type_pkey'
}

/** input type for inserting data into table "bi.datasource_type" */
export type Bi_Datasource_Type_Insert_Input = {
  datasources?: InputMaybe<Bi_Datasource_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Bi_Datasource_Type_Max_Fields = {
  __typename?: 'bi_datasource_type_max_fields';
  type: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Bi_Datasource_Type_Min_Fields = {
  __typename?: 'bi_datasource_type_min_fields';
  type: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "bi.datasource_type" */
export type Bi_Datasource_Type_Mutation_Response = {
  __typename?: 'bi_datasource_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Datasource_Type>;
};

/** input type for inserting object relation for remote table "bi.datasource_type" */
export type Bi_Datasource_Type_Obj_Rel_Insert_Input = {
  data: Bi_Datasource_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Datasource_Type_On_Conflict>;
};

/** on_conflict condition type for table "bi.datasource_type" */
export type Bi_Datasource_Type_On_Conflict = {
  constraint: Bi_Datasource_Type_Constraint;
  update_columns?: Array<Bi_Datasource_Type_Update_Column>;
  where?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.datasource_type". */
export type Bi_Datasource_Type_Order_By = {
  datasources_aggregate?: InputMaybe<Bi_Datasource_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.datasource_type */
export type Bi_Datasource_Type_Pk_Columns_Input = {
  type: Scalars['String']['input'];
};

/** select columns of table "bi.datasource_type" */
export enum Bi_Datasource_Type_Select_Column {
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "bi.datasource_type" */
export type Bi_Datasource_Type_Set_Input = {
  type?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "bi_datasource_type" */
export type Bi_Datasource_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Datasource_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Datasource_Type_Stream_Cursor_Value_Input = {
  type?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "bi.datasource_type" */
export enum Bi_Datasource_Type_Update_Column {
  /** column name */
  Type = 'type'
}

export type Bi_Datasource_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Datasource_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Datasource_Type_Bool_Exp;
};

/** update columns of table "bi.datasource" */
export enum Bi_Datasource_Update_Column {
  /** column name */
  Database = 'database',
  /** column name */
  Host = 'host',
  /** column name */
  Name = 'name',
  /** column name */
  Password = 'password',
  /** column name */
  Port = 'port',
  /** column name */
  Type = 'type',
  /** column name */
  User = 'user',
  /** column name */
  Uuid = 'uuid'
}

export type Bi_Datasource_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bi_Datasource_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Datasource_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Datasource_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bi_Datasource_Var_Pop_Fields = {
  __typename?: 'bi_datasource_var_pop_fields';
  port: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "bi.datasource" */
export type Bi_Datasource_Var_Pop_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Bi_Datasource_Var_Samp_Fields = {
  __typename?: 'bi_datasource_var_samp_fields';
  port: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "bi.datasource" */
export type Bi_Datasource_Var_Samp_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Bi_Datasource_Variance_Fields = {
  __typename?: 'bi_datasource_variance_fields';
  port: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "bi.datasource" */
export type Bi_Datasource_Variance_Order_By = {
  port?: InputMaybe<Order_By>;
};

/** columns and relationships of "bi.permission" */
export type Bi_Permission = {
  __typename?: 'bi_permission';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  order: Scalars['Int']['output'];
  /** An object relationship */
  permission_module: Bi_Permission_Module;
  permission_module_id: Scalars['String']['output'];
  /** An array relationship */
  user_permissions: Array<Bi_User_Permission>;
  /** An aggregate relationship */
  user_permissions_aggregate: Bi_User_Permission_Aggregate;
};


/** columns and relationships of "bi.permission" */
export type Bi_PermissionUser_PermissionsArgs = {
  distinct_on?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_User_Permission_Order_By>>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};


/** columns and relationships of "bi.permission" */
export type Bi_PermissionUser_Permissions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_User_Permission_Order_By>>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};

/** aggregated selection of "bi.permission" */
export type Bi_Permission_Aggregate = {
  __typename?: 'bi_permission_aggregate';
  aggregate: Maybe<Bi_Permission_Aggregate_Fields>;
  nodes: Array<Bi_Permission>;
};

export type Bi_Permission_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Permission_Aggregate_Bool_Exp_Count>;
};

export type Bi_Permission_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Permission_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.permission" */
export type Bi_Permission_Aggregate_Fields = {
  __typename?: 'bi_permission_aggregate_fields';
  avg: Maybe<Bi_Permission_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Permission_Max_Fields>;
  min: Maybe<Bi_Permission_Min_Fields>;
  stddev: Maybe<Bi_Permission_Stddev_Fields>;
  stddev_pop: Maybe<Bi_Permission_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Bi_Permission_Stddev_Samp_Fields>;
  sum: Maybe<Bi_Permission_Sum_Fields>;
  var_pop: Maybe<Bi_Permission_Var_Pop_Fields>;
  var_samp: Maybe<Bi_Permission_Var_Samp_Fields>;
  variance: Maybe<Bi_Permission_Variance_Fields>;
};


/** aggregate fields of "bi.permission" */
export type Bi_Permission_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.permission" */
export type Bi_Permission_Aggregate_Order_By = {
  avg?: InputMaybe<Bi_Permission_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Permission_Max_Order_By>;
  min?: InputMaybe<Bi_Permission_Min_Order_By>;
  stddev?: InputMaybe<Bi_Permission_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Bi_Permission_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Bi_Permission_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Bi_Permission_Sum_Order_By>;
  var_pop?: InputMaybe<Bi_Permission_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Bi_Permission_Var_Samp_Order_By>;
  variance?: InputMaybe<Bi_Permission_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "bi.permission" */
export type Bi_Permission_Arr_Rel_Insert_Input = {
  data: Array<Bi_Permission_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Permission_On_Conflict>;
};

/** aggregate avg on columns */
export type Bi_Permission_Avg_Fields = {
  __typename?: 'bi_permission_avg_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "bi.permission" */
export type Bi_Permission_Avg_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "bi.permission". All fields are combined with a logical 'AND'. */
export type Bi_Permission_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Permission_Bool_Exp>>;
  _not?: InputMaybe<Bi_Permission_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Permission_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  order?: InputMaybe<Int_Comparison_Exp>;
  permission_module?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
  permission_module_id?: InputMaybe<String_Comparison_Exp>;
  user_permissions?: InputMaybe<Bi_User_Permission_Bool_Exp>;
  user_permissions_aggregate?: InputMaybe<Bi_User_Permission_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "bi.permission" */
export enum Bi_Permission_Constraint {
  /** unique or primary key constraint on columns "id" */
  PermissionPkey = 'permission_pkey'
}

/** input type for incrementing numeric columns in table "bi.permission" */
export type Bi_Permission_Inc_Input = {
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "bi.permission" */
export type Bi_Permission_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  permission_module?: InputMaybe<Bi_Permission_Module_Obj_Rel_Insert_Input>;
  permission_module_id?: InputMaybe<Scalars['String']['input']>;
  user_permissions?: InputMaybe<Bi_User_Permission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Bi_Permission_Max_Fields = {
  __typename?: 'bi_permission_max_fields';
  id: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  order: Maybe<Scalars['Int']['output']>;
  permission_module_id: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "bi.permission" */
export type Bi_Permission_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  permission_module_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Permission_Min_Fields = {
  __typename?: 'bi_permission_min_fields';
  id: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  order: Maybe<Scalars['Int']['output']>;
  permission_module_id: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "bi.permission" */
export type Bi_Permission_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  permission_module_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "bi.permission_module" */
export type Bi_Permission_Module = {
  __typename?: 'bi_permission_module';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  order: Scalars['Int']['output'];
  /** An array relationship */
  permissions: Array<Bi_Permission>;
  /** An aggregate relationship */
  permissions_aggregate: Bi_Permission_Aggregate;
};


/** columns and relationships of "bi.permission_module" */
export type Bi_Permission_ModulePermissionsArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Order_By>>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};


/** columns and relationships of "bi.permission_module" */
export type Bi_Permission_ModulePermissions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Order_By>>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};

/** aggregated selection of "bi.permission_module" */
export type Bi_Permission_Module_Aggregate = {
  __typename?: 'bi_permission_module_aggregate';
  aggregate: Maybe<Bi_Permission_Module_Aggregate_Fields>;
  nodes: Array<Bi_Permission_Module>;
};

/** aggregate fields of "bi.permission_module" */
export type Bi_Permission_Module_Aggregate_Fields = {
  __typename?: 'bi_permission_module_aggregate_fields';
  avg: Maybe<Bi_Permission_Module_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Permission_Module_Max_Fields>;
  min: Maybe<Bi_Permission_Module_Min_Fields>;
  stddev: Maybe<Bi_Permission_Module_Stddev_Fields>;
  stddev_pop: Maybe<Bi_Permission_Module_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Bi_Permission_Module_Stddev_Samp_Fields>;
  sum: Maybe<Bi_Permission_Module_Sum_Fields>;
  var_pop: Maybe<Bi_Permission_Module_Var_Pop_Fields>;
  var_samp: Maybe<Bi_Permission_Module_Var_Samp_Fields>;
  variance: Maybe<Bi_Permission_Module_Variance_Fields>;
};


/** aggregate fields of "bi.permission_module" */
export type Bi_Permission_Module_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Permission_Module_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Bi_Permission_Module_Avg_Fields = {
  __typename?: 'bi_permission_module_avg_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "bi.permission_module". All fields are combined with a logical 'AND'. */
export type Bi_Permission_Module_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Permission_Module_Bool_Exp>>;
  _not?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Permission_Module_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  order?: InputMaybe<Int_Comparison_Exp>;
  permissions?: InputMaybe<Bi_Permission_Bool_Exp>;
  permissions_aggregate?: InputMaybe<Bi_Permission_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "bi.permission_module" */
export enum Bi_Permission_Module_Constraint {
  /** unique or primary key constraint on columns "id" */
  PermissionModulePkey = 'permission_module_pkey'
}

/** input type for incrementing numeric columns in table "bi.permission_module" */
export type Bi_Permission_Module_Inc_Input = {
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "bi.permission_module" */
export type Bi_Permission_Module_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  permissions?: InputMaybe<Bi_Permission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Bi_Permission_Module_Max_Fields = {
  __typename?: 'bi_permission_module_max_fields';
  id: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  order: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Bi_Permission_Module_Min_Fields = {
  __typename?: 'bi_permission_module_min_fields';
  id: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  order: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "bi.permission_module" */
export type Bi_Permission_Module_Mutation_Response = {
  __typename?: 'bi_permission_module_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Permission_Module>;
};

/** input type for inserting object relation for remote table "bi.permission_module" */
export type Bi_Permission_Module_Obj_Rel_Insert_Input = {
  data: Bi_Permission_Module_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Permission_Module_On_Conflict>;
};

/** on_conflict condition type for table "bi.permission_module" */
export type Bi_Permission_Module_On_Conflict = {
  constraint: Bi_Permission_Module_Constraint;
  update_columns?: Array<Bi_Permission_Module_Update_Column>;
  where?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.permission_module". */
export type Bi_Permission_Module_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  permissions_aggregate?: InputMaybe<Bi_Permission_Aggregate_Order_By>;
};

/** primary key columns input for table: bi.permission_module */
export type Bi_Permission_Module_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "bi.permission_module" */
export enum Bi_Permission_Module_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order'
}

/** input type for updating data in table "bi.permission_module" */
export type Bi_Permission_Module_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Bi_Permission_Module_Stddev_Fields = {
  __typename?: 'bi_permission_module_stddev_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Bi_Permission_Module_Stddev_Pop_Fields = {
  __typename?: 'bi_permission_module_stddev_pop_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Bi_Permission_Module_Stddev_Samp_Fields = {
  __typename?: 'bi_permission_module_stddev_samp_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "bi_permission_module" */
export type Bi_Permission_Module_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Permission_Module_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Permission_Module_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Bi_Permission_Module_Sum_Fields = {
  __typename?: 'bi_permission_module_sum_fields';
  order: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "bi.permission_module" */
export enum Bi_Permission_Module_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order'
}

export type Bi_Permission_Module_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bi_Permission_Module_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Permission_Module_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Permission_Module_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bi_Permission_Module_Var_Pop_Fields = {
  __typename?: 'bi_permission_module_var_pop_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Bi_Permission_Module_Var_Samp_Fields = {
  __typename?: 'bi_permission_module_var_samp_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Bi_Permission_Module_Variance_Fields = {
  __typename?: 'bi_permission_module_variance_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** response of any mutation on the table "bi.permission" */
export type Bi_Permission_Mutation_Response = {
  __typename?: 'bi_permission_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Permission>;
};

/** input type for inserting object relation for remote table "bi.permission" */
export type Bi_Permission_Obj_Rel_Insert_Input = {
  data: Bi_Permission_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Permission_On_Conflict>;
};

/** on_conflict condition type for table "bi.permission" */
export type Bi_Permission_On_Conflict = {
  constraint: Bi_Permission_Constraint;
  update_columns?: Array<Bi_Permission_Update_Column>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.permission". */
export type Bi_Permission_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  permission_module?: InputMaybe<Bi_Permission_Module_Order_By>;
  permission_module_id?: InputMaybe<Order_By>;
  user_permissions_aggregate?: InputMaybe<Bi_User_Permission_Aggregate_Order_By>;
};

/** primary key columns input for table: bi.permission */
export type Bi_Permission_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "bi.permission" */
export enum Bi_Permission_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  PermissionModuleId = 'permission_module_id'
}

/** input type for updating data in table "bi.permission" */
export type Bi_Permission_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  permission_module_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Bi_Permission_Stddev_Fields = {
  __typename?: 'bi_permission_stddev_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "bi.permission" */
export type Bi_Permission_Stddev_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Bi_Permission_Stddev_Pop_Fields = {
  __typename?: 'bi_permission_stddev_pop_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "bi.permission" */
export type Bi_Permission_Stddev_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Bi_Permission_Stddev_Samp_Fields = {
  __typename?: 'bi_permission_stddev_samp_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "bi.permission" */
export type Bi_Permission_Stddev_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "bi_permission" */
export type Bi_Permission_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Permission_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Permission_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  permission_module_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Bi_Permission_Sum_Fields = {
  __typename?: 'bi_permission_sum_fields';
  order: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "bi.permission" */
export type Bi_Permission_Sum_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** update columns of table "bi.permission" */
export enum Bi_Permission_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  PermissionModuleId = 'permission_module_id'
}

export type Bi_Permission_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bi_Permission_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Permission_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Permission_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bi_Permission_Var_Pop_Fields = {
  __typename?: 'bi_permission_var_pop_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "bi.permission" */
export type Bi_Permission_Var_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Bi_Permission_Var_Samp_Fields = {
  __typename?: 'bi_permission_var_samp_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "bi.permission" */
export type Bi_Permission_Var_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Bi_Permission_Variance_Fields = {
  __typename?: 'bi_permission_variance_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "bi.permission" */
export type Bi_Permission_Variance_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** columns and relationships of "bi.public_link" */
export type Bi_Public_Link = {
  __typename?: 'bi_public_link';
  created_at: Scalars['timestamptz']['output'];
  created_by_user_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  dashboard: Bi_Dashboard;
  dashboard_uuid: Scalars['uuid']['output'];
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "bi.public_link" */
export type Bi_Public_Link_Aggregate = {
  __typename?: 'bi_public_link_aggregate';
  aggregate: Maybe<Bi_Public_Link_Aggregate_Fields>;
  nodes: Array<Bi_Public_Link>;
};

export type Bi_Public_Link_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Public_Link_Aggregate_Bool_Exp_Count>;
};

export type Bi_Public_Link_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Public_Link_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.public_link" */
export type Bi_Public_Link_Aggregate_Fields = {
  __typename?: 'bi_public_link_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Public_Link_Max_Fields>;
  min: Maybe<Bi_Public_Link_Min_Fields>;
};


/** aggregate fields of "bi.public_link" */
export type Bi_Public_Link_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.public_link" */
export type Bi_Public_Link_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Public_Link_Max_Order_By>;
  min?: InputMaybe<Bi_Public_Link_Min_Order_By>;
};

/** input type for inserting array relation for remote table "bi.public_link" */
export type Bi_Public_Link_Arr_Rel_Insert_Input = {
  data: Array<Bi_Public_Link_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Public_Link_On_Conflict>;
};

/** Boolean expression to filter rows from the table "bi.public_link". All fields are combined with a logical 'AND'. */
export type Bi_Public_Link_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Public_Link_Bool_Exp>>;
  _not?: InputMaybe<Bi_Public_Link_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Public_Link_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by_user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  dashboard?: InputMaybe<Bi_Dashboard_Bool_Exp>;
  dashboard_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  deleted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.public_link" */
export enum Bi_Public_Link_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  PublicLinkPkey = 'public_link_pkey'
}

/** input type for inserting data into table "bi.public_link" */
export type Bi_Public_Link_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by_user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  dashboard?: InputMaybe<Bi_Dashboard_Obj_Rel_Insert_Input>;
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Bi_Public_Link_Max_Fields = {
  __typename?: 'bi_public_link_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  created_by_user_uuid: Maybe<Scalars['uuid']['output']>;
  dashboard_uuid: Maybe<Scalars['uuid']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "bi.public_link" */
export type Bi_Public_Link_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by_user_uuid?: InputMaybe<Order_By>;
  dashboard_uuid?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Public_Link_Min_Fields = {
  __typename?: 'bi_public_link_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  created_by_user_uuid: Maybe<Scalars['uuid']['output']>;
  dashboard_uuid: Maybe<Scalars['uuid']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "bi.public_link" */
export type Bi_Public_Link_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by_user_uuid?: InputMaybe<Order_By>;
  dashboard_uuid?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.public_link" */
export type Bi_Public_Link_Mutation_Response = {
  __typename?: 'bi_public_link_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Public_Link>;
};

/** on_conflict condition type for table "bi.public_link" */
export type Bi_Public_Link_On_Conflict = {
  constraint: Bi_Public_Link_Constraint;
  update_columns?: Array<Bi_Public_Link_Update_Column>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.public_link". */
export type Bi_Public_Link_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by_user_uuid?: InputMaybe<Order_By>;
  dashboard?: InputMaybe<Bi_Dashboard_Order_By>;
  dashboard_uuid?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.public_link */
export type Bi_Public_Link_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "bi.public_link" */
export enum Bi_Public_Link_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserUuid = 'created_by_user_uuid',
  /** column name */
  DashboardUuid = 'dashboard_uuid',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "bi.public_link" */
export type Bi_Public_Link_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by_user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "bi_public_link" */
export type Bi_Public_Link_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Public_Link_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Public_Link_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by_user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "bi.public_link" */
export enum Bi_Public_Link_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserUuid = 'created_by_user_uuid',
  /** column name */
  DashboardUuid = 'dashboard_uuid',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  Uuid = 'uuid'
}

export type Bi_Public_Link_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Public_Link_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Public_Link_Bool_Exp;
};

/** columns and relationships of "bi.query" */
export type Bi_Query = {
  __typename?: 'bi_query';
  /** An array relationship */
  dashboard_items: Array<Bi_Dashboard_Item>;
  /** An aggregate relationship */
  dashboard_items_aggregate: Bi_Dashboard_Item_Aggregate;
  /** An object relationship */
  datasource: Bi_Datasource;
  datasource_uuid: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  query: Scalars['String']['output'];
  /** An array relationship */
  query_analytics: Array<Bi_Query_Analytics>;
  /** An aggregate relationship */
  query_analytics_aggregate: Bi_Query_Analytics_Aggregate;
  /** An array relationship */
  query_caches: Array<Bi_Query_Cache>;
  /** An aggregate relationship */
  query_caches_aggregate: Bi_Query_Cache_Aggregate;
  /** An array relationship */
  subqueries: Array<Bi_Subquery>;
  /** An array relationship */
  subqueriesByTargetQueryUuid: Array<Bi_Subquery>;
  /** An aggregate relationship */
  subqueriesByTargetQueryUuid_aggregate: Bi_Subquery_Aggregate;
  /** An aggregate relationship */
  subqueries_aggregate: Bi_Subquery_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "bi.query" */
export type Bi_QueryDashboard_ItemsArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QueryDashboard_Items_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QueryQuery_AnalyticsArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Analytics_Order_By>>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QueryQuery_Analytics_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Analytics_Order_By>>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QueryQuery_CachesArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QueryQuery_Caches_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QuerySubqueriesArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QuerySubqueriesByTargetQueryUuidArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QuerySubqueriesByTargetQueryUuid_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


/** columns and relationships of "bi.query" */
export type Bi_QuerySubqueries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};

/** aggregated selection of "bi.query" */
export type Bi_Query_Aggregate = {
  __typename?: 'bi_query_aggregate';
  aggregate: Maybe<Bi_Query_Aggregate_Fields>;
  nodes: Array<Bi_Query>;
};

export type Bi_Query_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Query_Aggregate_Bool_Exp_Count>;
};

export type Bi_Query_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Query_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Query_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.query" */
export type Bi_Query_Aggregate_Fields = {
  __typename?: 'bi_query_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Query_Max_Fields>;
  min: Maybe<Bi_Query_Min_Fields>;
};


/** aggregate fields of "bi.query" */
export type Bi_Query_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Query_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.query" */
export type Bi_Query_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Query_Max_Order_By>;
  min?: InputMaybe<Bi_Query_Min_Order_By>;
};

/** columns and relationships of "bi.query_analytics" */
export type Bi_Query_Analytics = {
  __typename?: 'bi_query_analytics';
  error: Maybe<Scalars['jsonb']['output']>;
  executed_at: Scalars['timestamptz']['output'];
  params: Scalars['jsonb']['output'];
  /** An object relationship */
  query: Bi_Query;
  query_uuid: Scalars['uuid']['output'];
  response_time_ms: Scalars['Int']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "bi.query_analytics" */
export type Bi_Query_AnalyticsErrorArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "bi.query_analytics" */
export type Bi_Query_AnalyticsParamsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "bi.query_analytics" */
export type Bi_Query_Analytics_Aggregate = {
  __typename?: 'bi_query_analytics_aggregate';
  aggregate: Maybe<Bi_Query_Analytics_Aggregate_Fields>;
  nodes: Array<Bi_Query_Analytics>;
};

export type Bi_Query_Analytics_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Query_Analytics_Aggregate_Bool_Exp_Count>;
};

export type Bi_Query_Analytics_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.query_analytics" */
export type Bi_Query_Analytics_Aggregate_Fields = {
  __typename?: 'bi_query_analytics_aggregate_fields';
  avg: Maybe<Bi_Query_Analytics_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Query_Analytics_Max_Fields>;
  min: Maybe<Bi_Query_Analytics_Min_Fields>;
  stddev: Maybe<Bi_Query_Analytics_Stddev_Fields>;
  stddev_pop: Maybe<Bi_Query_Analytics_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Bi_Query_Analytics_Stddev_Samp_Fields>;
  sum: Maybe<Bi_Query_Analytics_Sum_Fields>;
  var_pop: Maybe<Bi_Query_Analytics_Var_Pop_Fields>;
  var_samp: Maybe<Bi_Query_Analytics_Var_Samp_Fields>;
  variance: Maybe<Bi_Query_Analytics_Variance_Fields>;
};


/** aggregate fields of "bi.query_analytics" */
export type Bi_Query_Analytics_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.query_analytics" */
export type Bi_Query_Analytics_Aggregate_Order_By = {
  avg?: InputMaybe<Bi_Query_Analytics_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Query_Analytics_Max_Order_By>;
  min?: InputMaybe<Bi_Query_Analytics_Min_Order_By>;
  stddev?: InputMaybe<Bi_Query_Analytics_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Bi_Query_Analytics_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Bi_Query_Analytics_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Bi_Query_Analytics_Sum_Order_By>;
  var_pop?: InputMaybe<Bi_Query_Analytics_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Bi_Query_Analytics_Var_Samp_Order_By>;
  variance?: InputMaybe<Bi_Query_Analytics_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Bi_Query_Analytics_Append_Input = {
  error?: InputMaybe<Scalars['jsonb']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "bi.query_analytics" */
export type Bi_Query_Analytics_Arr_Rel_Insert_Input = {
  data: Array<Bi_Query_Analytics_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Query_Analytics_On_Conflict>;
};

/** aggregate avg on columns */
export type Bi_Query_Analytics_Avg_Fields = {
  __typename?: 'bi_query_analytics_avg_fields';
  response_time_ms: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Avg_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "bi.query_analytics". All fields are combined with a logical 'AND'. */
export type Bi_Query_Analytics_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Query_Analytics_Bool_Exp>>;
  _not?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Query_Analytics_Bool_Exp>>;
  error?: InputMaybe<Jsonb_Comparison_Exp>;
  executed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  params?: InputMaybe<Jsonb_Comparison_Exp>;
  query?: InputMaybe<Bi_Query_Bool_Exp>;
  query_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  response_time_ms?: InputMaybe<Int_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.query_analytics" */
export enum Bi_Query_Analytics_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  QueryAnalyticsPkey = 'query_analytics_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Bi_Query_Analytics_Delete_At_Path_Input = {
  error?: InputMaybe<Array<Scalars['String']['input']>>;
  params?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Bi_Query_Analytics_Delete_Elem_Input = {
  error?: InputMaybe<Scalars['Int']['input']>;
  params?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Bi_Query_Analytics_Delete_Key_Input = {
  error?: InputMaybe<Scalars['String']['input']>;
  params?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "bi.query_analytics" */
export type Bi_Query_Analytics_Inc_Input = {
  response_time_ms?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "bi.query_analytics" */
export type Bi_Query_Analytics_Insert_Input = {
  error?: InputMaybe<Scalars['jsonb']['input']>;
  executed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
  query?: InputMaybe<Bi_Query_Obj_Rel_Insert_Input>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  response_time_ms?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Bi_Query_Analytics_Max_Fields = {
  __typename?: 'bi_query_analytics_max_fields';
  executed_at: Maybe<Scalars['timestamptz']['output']>;
  query_uuid: Maybe<Scalars['uuid']['output']>;
  response_time_ms: Maybe<Scalars['Int']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Max_Order_By = {
  executed_at?: InputMaybe<Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  response_time_ms?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Query_Analytics_Min_Fields = {
  __typename?: 'bi_query_analytics_min_fields';
  executed_at: Maybe<Scalars['timestamptz']['output']>;
  query_uuid: Maybe<Scalars['uuid']['output']>;
  response_time_ms: Maybe<Scalars['Int']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Min_Order_By = {
  executed_at?: InputMaybe<Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  response_time_ms?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.query_analytics" */
export type Bi_Query_Analytics_Mutation_Response = {
  __typename?: 'bi_query_analytics_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Query_Analytics>;
};

/** on_conflict condition type for table "bi.query_analytics" */
export type Bi_Query_Analytics_On_Conflict = {
  constraint: Bi_Query_Analytics_Constraint;
  update_columns?: Array<Bi_Query_Analytics_Update_Column>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.query_analytics". */
export type Bi_Query_Analytics_Order_By = {
  error?: InputMaybe<Order_By>;
  executed_at?: InputMaybe<Order_By>;
  params?: InputMaybe<Order_By>;
  query?: InputMaybe<Bi_Query_Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  response_time_ms?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.query_analytics */
export type Bi_Query_Analytics_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Bi_Query_Analytics_Prepend_Input = {
  error?: InputMaybe<Scalars['jsonb']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "bi.query_analytics" */
export enum Bi_Query_Analytics_Select_Column {
  /** column name */
  Error = 'error',
  /** column name */
  ExecutedAt = 'executed_at',
  /** column name */
  Params = 'params',
  /** column name */
  QueryUuid = 'query_uuid',
  /** column name */
  ResponseTimeMs = 'response_time_ms',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "bi.query_analytics" */
export type Bi_Query_Analytics_Set_Input = {
  error?: InputMaybe<Scalars['jsonb']['input']>;
  executed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  response_time_ms?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Bi_Query_Analytics_Stddev_Fields = {
  __typename?: 'bi_query_analytics_stddev_fields';
  response_time_ms: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Stddev_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Bi_Query_Analytics_Stddev_Pop_Fields = {
  __typename?: 'bi_query_analytics_stddev_pop_fields';
  response_time_ms: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Stddev_Pop_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Bi_Query_Analytics_Stddev_Samp_Fields = {
  __typename?: 'bi_query_analytics_stddev_samp_fields';
  response_time_ms: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Stddev_Samp_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "bi_query_analytics" */
export type Bi_Query_Analytics_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Query_Analytics_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Query_Analytics_Stream_Cursor_Value_Input = {
  error?: InputMaybe<Scalars['jsonb']['input']>;
  executed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  response_time_ms?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Bi_Query_Analytics_Sum_Fields = {
  __typename?: 'bi_query_analytics_sum_fields';
  response_time_ms: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Sum_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** update columns of table "bi.query_analytics" */
export enum Bi_Query_Analytics_Update_Column {
  /** column name */
  Error = 'error',
  /** column name */
  ExecutedAt = 'executed_at',
  /** column name */
  Params = 'params',
  /** column name */
  QueryUuid = 'query_uuid',
  /** column name */
  ResponseTimeMs = 'response_time_ms',
  /** column name */
  Uuid = 'uuid'
}

export type Bi_Query_Analytics_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Bi_Query_Analytics_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Bi_Query_Analytics_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Bi_Query_Analytics_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Bi_Query_Analytics_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bi_Query_Analytics_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Bi_Query_Analytics_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Query_Analytics_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Query_Analytics_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bi_Query_Analytics_Var_Pop_Fields = {
  __typename?: 'bi_query_analytics_var_pop_fields';
  response_time_ms: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Var_Pop_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Bi_Query_Analytics_Var_Samp_Fields = {
  __typename?: 'bi_query_analytics_var_samp_fields';
  response_time_ms: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Var_Samp_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Bi_Query_Analytics_Variance_Fields = {
  __typename?: 'bi_query_analytics_variance_fields';
  response_time_ms: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "bi.query_analytics" */
export type Bi_Query_Analytics_Variance_Order_By = {
  response_time_ms?: InputMaybe<Order_By>;
};

/** input type for inserting array relation for remote table "bi.query" */
export type Bi_Query_Arr_Rel_Insert_Input = {
  data: Array<Bi_Query_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Query_On_Conflict>;
};

/** Boolean expression to filter rows from the table "bi.query". All fields are combined with a logical 'AND'. */
export type Bi_Query_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Query_Bool_Exp>>;
  _not?: InputMaybe<Bi_Query_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Query_Bool_Exp>>;
  dashboard_items?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
  dashboard_items_aggregate?: InputMaybe<Bi_Dashboard_Item_Aggregate_Bool_Exp>;
  datasource?: InputMaybe<Bi_Datasource_Bool_Exp>;
  datasource_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  query?: InputMaybe<String_Comparison_Exp>;
  query_analytics?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
  query_analytics_aggregate?: InputMaybe<Bi_Query_Analytics_Aggregate_Bool_Exp>;
  query_caches?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
  query_caches_aggregate?: InputMaybe<Bi_Query_Cache_Aggregate_Bool_Exp>;
  subqueries?: InputMaybe<Bi_Subquery_Bool_Exp>;
  subqueriesByTargetQueryUuid?: InputMaybe<Bi_Subquery_Bool_Exp>;
  subqueriesByTargetQueryUuid_aggregate?: InputMaybe<Bi_Subquery_Aggregate_Bool_Exp>;
  subqueries_aggregate?: InputMaybe<Bi_Subquery_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** columns and relationships of "bi.query_cache" */
export type Bi_Query_Cache = {
  __typename?: 'bi_query_cache';
  /** An object relationship */
  dashboard: Bi_Dashboard;
  /** Used to verify user permission on query cache */
  dashboard_uuid: Scalars['uuid']['output'];
  data: Scalars['json']['output'];
  params: Scalars['jsonb']['output'];
  params_hash: Scalars['String']['output'];
  /** An object relationship */
  query: Bi_Query;
  query_uuid: Scalars['uuid']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "bi.query_cache" */
export type Bi_Query_CacheDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "bi.query_cache" */
export type Bi_Query_CacheParamsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "bi.query_cache" */
export type Bi_Query_Cache_Aggregate = {
  __typename?: 'bi_query_cache_aggregate';
  aggregate: Maybe<Bi_Query_Cache_Aggregate_Fields>;
  nodes: Array<Bi_Query_Cache>;
};

export type Bi_Query_Cache_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Query_Cache_Aggregate_Bool_Exp_Count>;
};

export type Bi_Query_Cache_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.query_cache" */
export type Bi_Query_Cache_Aggregate_Fields = {
  __typename?: 'bi_query_cache_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Query_Cache_Max_Fields>;
  min: Maybe<Bi_Query_Cache_Min_Fields>;
};


/** aggregate fields of "bi.query_cache" */
export type Bi_Query_Cache_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.query_cache" */
export type Bi_Query_Cache_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Query_Cache_Max_Order_By>;
  min?: InputMaybe<Bi_Query_Cache_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Bi_Query_Cache_Append_Input = {
  params?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "bi.query_cache" */
export type Bi_Query_Cache_Arr_Rel_Insert_Input = {
  data: Array<Bi_Query_Cache_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Query_Cache_On_Conflict>;
};

/** Boolean expression to filter rows from the table "bi.query_cache". All fields are combined with a logical 'AND'. */
export type Bi_Query_Cache_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Query_Cache_Bool_Exp>>;
  _not?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Query_Cache_Bool_Exp>>;
  dashboard?: InputMaybe<Bi_Dashboard_Bool_Exp>;
  dashboard_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  data?: InputMaybe<Json_Comparison_Exp>;
  params?: InputMaybe<Jsonb_Comparison_Exp>;
  params_hash?: InputMaybe<String_Comparison_Exp>;
  query?: InputMaybe<Bi_Query_Bool_Exp>;
  query_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.query_cache" */
export enum Bi_Query_Cache_Constraint {
  /** unique or primary key constraint on columns "params_hash", "dashboard_uuid", "query_uuid" */
  QueryCachePkey = 'query_cache_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Bi_Query_Cache_Delete_At_Path_Input = {
  params?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Bi_Query_Cache_Delete_Elem_Input = {
  params?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Bi_Query_Cache_Delete_Key_Input = {
  params?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "bi.query_cache" */
export type Bi_Query_Cache_Insert_Input = {
  dashboard?: InputMaybe<Bi_Dashboard_Obj_Rel_Insert_Input>;
  /** Used to verify user permission on query cache */
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  data?: InputMaybe<Scalars['json']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
  params_hash?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Bi_Query_Obj_Rel_Insert_Input>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Bi_Query_Cache_Max_Fields = {
  __typename?: 'bi_query_cache_max_fields';
  /** Used to verify user permission on query cache */
  dashboard_uuid: Maybe<Scalars['uuid']['output']>;
  params_hash: Maybe<Scalars['String']['output']>;
  query_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "bi.query_cache" */
export type Bi_Query_Cache_Max_Order_By = {
  /** Used to verify user permission on query cache */
  dashboard_uuid?: InputMaybe<Order_By>;
  params_hash?: InputMaybe<Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Query_Cache_Min_Fields = {
  __typename?: 'bi_query_cache_min_fields';
  /** Used to verify user permission on query cache */
  dashboard_uuid: Maybe<Scalars['uuid']['output']>;
  params_hash: Maybe<Scalars['String']['output']>;
  query_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "bi.query_cache" */
export type Bi_Query_Cache_Min_Order_By = {
  /** Used to verify user permission on query cache */
  dashboard_uuid?: InputMaybe<Order_By>;
  params_hash?: InputMaybe<Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.query_cache" */
export type Bi_Query_Cache_Mutation_Response = {
  __typename?: 'bi_query_cache_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Query_Cache>;
};

/** on_conflict condition type for table "bi.query_cache" */
export type Bi_Query_Cache_On_Conflict = {
  constraint: Bi_Query_Cache_Constraint;
  update_columns?: Array<Bi_Query_Cache_Update_Column>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.query_cache". */
export type Bi_Query_Cache_Order_By = {
  dashboard?: InputMaybe<Bi_Dashboard_Order_By>;
  dashboard_uuid?: InputMaybe<Order_By>;
  data?: InputMaybe<Order_By>;
  params?: InputMaybe<Order_By>;
  params_hash?: InputMaybe<Order_By>;
  query?: InputMaybe<Bi_Query_Order_By>;
  query_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.query_cache */
export type Bi_Query_Cache_Pk_Columns_Input = {
  /** Used to verify user permission on query cache */
  dashboard_uuid: Scalars['uuid']['input'];
  params_hash: Scalars['String']['input'];
  query_uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Bi_Query_Cache_Prepend_Input = {
  params?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "bi.query_cache" */
export enum Bi_Query_Cache_Select_Column {
  /** column name */
  DashboardUuid = 'dashboard_uuid',
  /** column name */
  Data = 'data',
  /** column name */
  Params = 'params',
  /** column name */
  ParamsHash = 'params_hash',
  /** column name */
  QueryUuid = 'query_uuid',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "bi.query_cache" */
export type Bi_Query_Cache_Set_Input = {
  /** Used to verify user permission on query cache */
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  data?: InputMaybe<Scalars['json']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
  params_hash?: InputMaybe<Scalars['String']['input']>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "bi_query_cache" */
export type Bi_Query_Cache_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Query_Cache_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Query_Cache_Stream_Cursor_Value_Input = {
  /** Used to verify user permission on query cache */
  dashboard_uuid?: InputMaybe<Scalars['uuid']['input']>;
  data?: InputMaybe<Scalars['json']['input']>;
  params?: InputMaybe<Scalars['jsonb']['input']>;
  params_hash?: InputMaybe<Scalars['String']['input']>;
  query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "bi.query_cache" */
export enum Bi_Query_Cache_Update_Column {
  /** column name */
  DashboardUuid = 'dashboard_uuid',
  /** column name */
  Data = 'data',
  /** column name */
  Params = 'params',
  /** column name */
  ParamsHash = 'params_hash',
  /** column name */
  QueryUuid = 'query_uuid',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Bi_Query_Cache_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Bi_Query_Cache_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Bi_Query_Cache_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Bi_Query_Cache_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Bi_Query_Cache_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Bi_Query_Cache_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Query_Cache_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Query_Cache_Bool_Exp;
};

/** unique or primary key constraints on table "bi.query" */
export enum Bi_Query_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  QueryPkey = 'query_pkey'
}

/** input type for inserting data into table "bi.query" */
export type Bi_Query_Insert_Input = {
  dashboard_items?: InputMaybe<Bi_Dashboard_Item_Arr_Rel_Insert_Input>;
  datasource?: InputMaybe<Bi_Datasource_Obj_Rel_Insert_Input>;
  datasource_uuid?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  query_analytics?: InputMaybe<Bi_Query_Analytics_Arr_Rel_Insert_Input>;
  query_caches?: InputMaybe<Bi_Query_Cache_Arr_Rel_Insert_Input>;
  subqueries?: InputMaybe<Bi_Subquery_Arr_Rel_Insert_Input>;
  subqueriesByTargetQueryUuid?: InputMaybe<Bi_Subquery_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Bi_Query_Max_Fields = {
  __typename?: 'bi_query_max_fields';
  datasource_uuid: Maybe<Scalars['uuid']['output']>;
  name: Maybe<Scalars['String']['output']>;
  query: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "bi.query" */
export type Bi_Query_Max_Order_By = {
  datasource_uuid?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  query?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Query_Min_Fields = {
  __typename?: 'bi_query_min_fields';
  datasource_uuid: Maybe<Scalars['uuid']['output']>;
  name: Maybe<Scalars['String']['output']>;
  query: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "bi.query" */
export type Bi_Query_Min_Order_By = {
  datasource_uuid?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  query?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.query" */
export type Bi_Query_Mutation_Response = {
  __typename?: 'bi_query_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Query>;
};

/** input type for inserting object relation for remote table "bi.query" */
export type Bi_Query_Obj_Rel_Insert_Input = {
  data: Bi_Query_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Query_On_Conflict>;
};

/** on_conflict condition type for table "bi.query" */
export type Bi_Query_On_Conflict = {
  constraint: Bi_Query_Constraint;
  update_columns?: Array<Bi_Query_Update_Column>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.query". */
export type Bi_Query_Order_By = {
  dashboard_items_aggregate?: InputMaybe<Bi_Dashboard_Item_Aggregate_Order_By>;
  datasource?: InputMaybe<Bi_Datasource_Order_By>;
  datasource_uuid?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  query?: InputMaybe<Order_By>;
  query_analytics_aggregate?: InputMaybe<Bi_Query_Analytics_Aggregate_Order_By>;
  query_caches_aggregate?: InputMaybe<Bi_Query_Cache_Aggregate_Order_By>;
  subqueriesByTargetQueryUuid_aggregate?: InputMaybe<Bi_Subquery_Aggregate_Order_By>;
  subqueries_aggregate?: InputMaybe<Bi_Subquery_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.query */
export type Bi_Query_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "bi.query" */
export enum Bi_Query_Select_Column {
  /** column name */
  DatasourceUuid = 'datasource_uuid',
  /** column name */
  Name = 'name',
  /** column name */
  Query = 'query',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "bi.query" */
export type Bi_Query_Set_Input = {
  datasource_uuid?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "bi_query" */
export type Bi_Query_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Query_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Query_Stream_Cursor_Value_Input = {
  datasource_uuid?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "bi.query" */
export enum Bi_Query_Update_Column {
  /** column name */
  DatasourceUuid = 'datasource_uuid',
  /** column name */
  Name = 'name',
  /** column name */
  Query = 'query',
  /** column name */
  Uuid = 'uuid'
}

export type Bi_Query_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Query_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Query_Bool_Exp;
};

/** columns and relationships of "bi.subquery" */
export type Bi_Subquery = {
  __typename?: 'bi_subquery';
  config: Scalars['jsonb']['output'];
  origin_query_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  query: Bi_Query;
  /** An object relationship */
  queryByTargetQueryUuid: Bi_Query;
  target_query_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "bi.subquery" */
export type Bi_SubqueryConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "bi.subquery" */
export type Bi_Subquery_Aggregate = {
  __typename?: 'bi_subquery_aggregate';
  aggregate: Maybe<Bi_Subquery_Aggregate_Fields>;
  nodes: Array<Bi_Subquery>;
};

export type Bi_Subquery_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_Subquery_Aggregate_Bool_Exp_Count>;
};

export type Bi_Subquery_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_Subquery_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.subquery" */
export type Bi_Subquery_Aggregate_Fields = {
  __typename?: 'bi_subquery_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_Subquery_Max_Fields>;
  min: Maybe<Bi_Subquery_Min_Fields>;
};


/** aggregate fields of "bi.subquery" */
export type Bi_Subquery_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.subquery" */
export type Bi_Subquery_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_Subquery_Max_Order_By>;
  min?: InputMaybe<Bi_Subquery_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Bi_Subquery_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "bi.subquery" */
export type Bi_Subquery_Arr_Rel_Insert_Input = {
  data: Array<Bi_Subquery_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_Subquery_On_Conflict>;
};

/** Boolean expression to filter rows from the table "bi.subquery". All fields are combined with a logical 'AND'. */
export type Bi_Subquery_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_Subquery_Bool_Exp>>;
  _not?: InputMaybe<Bi_Subquery_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_Subquery_Bool_Exp>>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  origin_query_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  query?: InputMaybe<Bi_Query_Bool_Exp>;
  queryByTargetQueryUuid?: InputMaybe<Bi_Query_Bool_Exp>;
  target_query_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.subquery" */
export enum Bi_Subquery_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  SubqueryPkey = 'subquery_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Bi_Subquery_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Bi_Subquery_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Bi_Subquery_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "bi.subquery" */
export type Bi_Subquery_Insert_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  origin_query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  query?: InputMaybe<Bi_Query_Obj_Rel_Insert_Input>;
  queryByTargetQueryUuid?: InputMaybe<Bi_Query_Obj_Rel_Insert_Input>;
  target_query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Bi_Subquery_Max_Fields = {
  __typename?: 'bi_subquery_max_fields';
  origin_query_uuid: Maybe<Scalars['uuid']['output']>;
  target_query_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "bi.subquery" */
export type Bi_Subquery_Max_Order_By = {
  origin_query_uuid?: InputMaybe<Order_By>;
  target_query_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_Subquery_Min_Fields = {
  __typename?: 'bi_subquery_min_fields';
  origin_query_uuid: Maybe<Scalars['uuid']['output']>;
  target_query_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "bi.subquery" */
export type Bi_Subquery_Min_Order_By = {
  origin_query_uuid?: InputMaybe<Order_By>;
  target_query_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.subquery" */
export type Bi_Subquery_Mutation_Response = {
  __typename?: 'bi_subquery_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_Subquery>;
};

/** on_conflict condition type for table "bi.subquery" */
export type Bi_Subquery_On_Conflict = {
  constraint: Bi_Subquery_Constraint;
  update_columns?: Array<Bi_Subquery_Update_Column>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.subquery". */
export type Bi_Subquery_Order_By = {
  config?: InputMaybe<Order_By>;
  origin_query_uuid?: InputMaybe<Order_By>;
  query?: InputMaybe<Bi_Query_Order_By>;
  queryByTargetQueryUuid?: InputMaybe<Bi_Query_Order_By>;
  target_query_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.subquery */
export type Bi_Subquery_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Bi_Subquery_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "bi.subquery" */
export enum Bi_Subquery_Select_Column {
  /** column name */
  Config = 'config',
  /** column name */
  OriginQueryUuid = 'origin_query_uuid',
  /** column name */
  TargetQueryUuid = 'target_query_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "bi.subquery" */
export type Bi_Subquery_Set_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  origin_query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  target_query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "bi_subquery" */
export type Bi_Subquery_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_Subquery_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_Subquery_Stream_Cursor_Value_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  origin_query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  target_query_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "bi.subquery" */
export enum Bi_Subquery_Update_Column {
  /** column name */
  Config = 'config',
  /** column name */
  OriginQueryUuid = 'origin_query_uuid',
  /** column name */
  TargetQueryUuid = 'target_query_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Bi_Subquery_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Bi_Subquery_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Bi_Subquery_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Bi_Subquery_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Bi_Subquery_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Bi_Subquery_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_Subquery_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_Subquery_Bool_Exp;
};

/** columns and relationships of "bi.user_permission" */
export type Bi_User_Permission = {
  __typename?: 'bi_user_permission';
  created_at: Scalars['timestamptz']['output'];
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  permission: Bi_Permission;
  permission_id: Scalars['String']['output'];
  relationship_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "bi.user_permission" */
export type Bi_User_Permission_Aggregate = {
  __typename?: 'bi_user_permission_aggregate';
  aggregate: Maybe<Bi_User_Permission_Aggregate_Fields>;
  nodes: Array<Bi_User_Permission>;
};

export type Bi_User_Permission_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bi_User_Permission_Aggregate_Bool_Exp_Count>;
};

export type Bi_User_Permission_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bi_User_Permission_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bi.user_permission" */
export type Bi_User_Permission_Aggregate_Fields = {
  __typename?: 'bi_user_permission_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Bi_User_Permission_Max_Fields>;
  min: Maybe<Bi_User_Permission_Min_Fields>;
};


/** aggregate fields of "bi.user_permission" */
export type Bi_User_Permission_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bi.user_permission" */
export type Bi_User_Permission_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bi_User_Permission_Max_Order_By>;
  min?: InputMaybe<Bi_User_Permission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "bi.user_permission" */
export type Bi_User_Permission_Arr_Rel_Insert_Input = {
  data: Array<Bi_User_Permission_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bi_User_Permission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "bi.user_permission". All fields are combined with a logical 'AND'. */
export type Bi_User_Permission_Bool_Exp = {
  _and?: InputMaybe<Array<Bi_User_Permission_Bool_Exp>>;
  _not?: InputMaybe<Bi_User_Permission_Bool_Exp>;
  _or?: InputMaybe<Array<Bi_User_Permission_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deleted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  permission?: InputMaybe<Bi_Permission_Bool_Exp>;
  permission_id?: InputMaybe<String_Comparison_Exp>;
  relationship_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "bi.user_permission" */
export enum Bi_User_Permission_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserPermissionPkey = 'user_permission_pkey'
}

/** input type for inserting data into table "bi.user_permission" */
export type Bi_User_Permission_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  permission?: InputMaybe<Bi_Permission_Obj_Rel_Insert_Input>;
  permission_id?: InputMaybe<Scalars['String']['input']>;
  relationship_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Bi_User_Permission_Max_Fields = {
  __typename?: 'bi_user_permission_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  permission_id: Maybe<Scalars['String']['output']>;
  relationship_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "bi.user_permission" */
export type Bi_User_Permission_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  permission_id?: InputMaybe<Order_By>;
  relationship_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bi_User_Permission_Min_Fields = {
  __typename?: 'bi_user_permission_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  permission_id: Maybe<Scalars['String']['output']>;
  relationship_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "bi.user_permission" */
export type Bi_User_Permission_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  permission_id?: InputMaybe<Order_By>;
  relationship_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bi.user_permission" */
export type Bi_User_Permission_Mutation_Response = {
  __typename?: 'bi_user_permission_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bi_User_Permission>;
};

/** on_conflict condition type for table "bi.user_permission" */
export type Bi_User_Permission_On_Conflict = {
  constraint: Bi_User_Permission_Constraint;
  update_columns?: Array<Bi_User_Permission_Update_Column>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};

/** Ordering options when selecting data from "bi.user_permission". */
export type Bi_User_Permission_Order_By = {
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  permission?: InputMaybe<Bi_Permission_Order_By>;
  permission_id?: InputMaybe<Order_By>;
  relationship_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bi.user_permission */
export type Bi_User_Permission_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "bi.user_permission" */
export enum Bi_User_Permission_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  PermissionId = 'permission_id',
  /** column name */
  RelationshipUuid = 'relationship_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "bi.user_permission" */
export type Bi_User_Permission_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  permission_id?: InputMaybe<Scalars['String']['input']>;
  relationship_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "bi_user_permission" */
export type Bi_User_Permission_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bi_User_Permission_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bi_User_Permission_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  permission_id?: InputMaybe<Scalars['String']['input']>;
  relationship_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "bi.user_permission" */
export enum Bi_User_Permission_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  PermissionId = 'permission_id',
  /** column name */
  RelationshipUuid = 'relationship_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Bi_User_Permission_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bi_User_Permission_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bi_User_Permission_Bool_Exp;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bigint']['input']>;
  _gt?: InputMaybe<Scalars['bigint']['input']>;
  _gte?: InputMaybe<Scalars['bigint']['input']>;
  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['bigint']['input']>;
  _lte?: InputMaybe<Scalars['bigint']['input']>;
  _neq?: InputMaybe<Scalars['bigint']['input']>;
  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};

/** Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'. */
export type Bpchar_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bpchar']['input']>;
  _gt?: InputMaybe<Scalars['bpchar']['input']>;
  _gte?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['bpchar']['input']>;
  _in?: InputMaybe<Array<Scalars['bpchar']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['bpchar']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['bpchar']['input']>;
  _lt?: InputMaybe<Scalars['bpchar']['input']>;
  _lte?: InputMaybe<Scalars['bpchar']['input']>;
  _neq?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['bpchar']['input']>;
  _nin?: InputMaybe<Array<Scalars['bpchar']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['bpchar']['input']>;
};

export type Buy_Product_Args = {
  uuid_product?: InputMaybe<Scalars['uuid']['input']>;
};

export type Cancel_Product_Request_Args = {
  new_cancel_reason?: InputMaybe<Scalars['String']['input']>;
  uuid_product_request?: InputMaybe<Scalars['uuid']['input']>;
};

/** columns and relationships of "challenge" */
export type Challenge = {
  __typename?: 'challenge';
  /** The type of the challenge */
  challenge_type: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** Description of this challenge to be shown to the user */
  description: Scalars['String']['output'];
  /** When this challenge will finish. If null then it will never end */
  end_at: Maybe<Scalars['timestamptz']['output']>;
  /** The number of points that this challenge give when completed */
  kmps: Scalars['Int']['output'];
  /** The last time this challenge was processed for all the drivers */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "challenge_need_to_be_processed" */
  need_to_be_processed: Maybe<Scalars['Boolean']['output']>;
  /** When this challenge will start */
  start_at: Scalars['timestamptz']['output'];
  /** The title of this challenge to be shown to the user */
  title: Scalars['String']['output'];
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Scalars['float8']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  user_fk_challenges: Array<User_Fk_Challenge>;
  /** An aggregate relationship */
  user_fk_challenges_aggregate: User_Fk_Challenge_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "challenge" */
export type ChallengeUser_Fk_ChallengesArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Challenge_Order_By>>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};


/** columns and relationships of "challenge" */
export type ChallengeUser_Fk_Challenges_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Challenge_Order_By>>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};

/** aggregated selection of "challenge" */
export type Challenge_Aggregate = {
  __typename?: 'challenge_aggregate';
  aggregate: Maybe<Challenge_Aggregate_Fields>;
  nodes: Array<Challenge>;
};

/** aggregate fields of "challenge" */
export type Challenge_Aggregate_Fields = {
  __typename?: 'challenge_aggregate_fields';
  avg: Maybe<Challenge_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Challenge_Max_Fields>;
  min: Maybe<Challenge_Min_Fields>;
  stddev: Maybe<Challenge_Stddev_Fields>;
  stddev_pop: Maybe<Challenge_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Challenge_Stddev_Samp_Fields>;
  sum: Maybe<Challenge_Sum_Fields>;
  var_pop: Maybe<Challenge_Var_Pop_Fields>;
  var_samp: Maybe<Challenge_Var_Samp_Fields>;
  variance: Maybe<Challenge_Variance_Fields>;
};


/** aggregate fields of "challenge" */
export type Challenge_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Challenge_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Challenge_Avg_Fields = {
  __typename?: 'challenge_avg_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Float']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "challenge". All fields are combined with a logical 'AND'. */
export type Challenge_Bool_Exp = {
  _and?: InputMaybe<Array<Challenge_Bool_Exp>>;
  _not?: InputMaybe<Challenge_Bool_Exp>;
  _or?: InputMaybe<Array<Challenge_Bool_Exp>>;
  challenge_type?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  end_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  kmps?: InputMaybe<Int_Comparison_Exp>;
  last_processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  need_to_be_processed?: InputMaybe<Boolean_Comparison_Exp>;
  start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  title?: InputMaybe<String_Comparison_Exp>;
  total_kilometers?: InputMaybe<Float8_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_fk_challenges?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  user_fk_challenges_aggregate?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "challenge" */
export enum Challenge_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  ChallengePkey = 'challenge_pkey'
}

/** input type for incrementing numeric columns in table "challenge" */
export type Challenge_Inc_Input = {
  /** The number of points that this challenge give when completed */
  kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "challenge" */
export type Challenge_Insert_Input = {
  /** The type of the challenge */
  challenge_type?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of this challenge to be shown to the user */
  description?: InputMaybe<Scalars['String']['input']>;
  /** When this challenge will finish. If null then it will never end */
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The number of points that this challenge give when completed */
  kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The last time this challenge was processed for all the drivers */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When this challenge will start */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The title of this challenge to be shown to the user */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_fk_challenges?: InputMaybe<User_Fk_Challenge_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Challenge_Max_Fields = {
  __typename?: 'challenge_max_fields';
  /** The type of the challenge */
  challenge_type: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Description of this challenge to be shown to the user */
  description: Maybe<Scalars['String']['output']>;
  /** When this challenge will finish. If null then it will never end */
  end_at: Maybe<Scalars['timestamptz']['output']>;
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Int']['output']>;
  /** The last time this challenge was processed for all the drivers */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** When this challenge will start */
  start_at: Maybe<Scalars['timestamptz']['output']>;
  /** The title of this challenge to be shown to the user */
  title: Maybe<Scalars['String']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Challenge_Min_Fields = {
  __typename?: 'challenge_min_fields';
  /** The type of the challenge */
  challenge_type: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Description of this challenge to be shown to the user */
  description: Maybe<Scalars['String']['output']>;
  /** When this challenge will finish. If null then it will never end */
  end_at: Maybe<Scalars['timestamptz']['output']>;
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Int']['output']>;
  /** The last time this challenge was processed for all the drivers */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** When this challenge will start */
  start_at: Maybe<Scalars['timestamptz']['output']>;
  /** The title of this challenge to be shown to the user */
  title: Maybe<Scalars['String']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "challenge" */
export type Challenge_Mutation_Response = {
  __typename?: 'challenge_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Challenge>;
};

/** input type for inserting object relation for remote table "challenge" */
export type Challenge_Obj_Rel_Insert_Input = {
  data: Challenge_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Challenge_On_Conflict>;
};

/** on_conflict condition type for table "challenge" */
export type Challenge_On_Conflict = {
  constraint: Challenge_Constraint;
  update_columns?: Array<Challenge_Update_Column>;
  where?: InputMaybe<Challenge_Bool_Exp>;
};

/** Ordering options when selecting data from "challenge". */
export type Challenge_Order_By = {
  challenge_type?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  end_at?: InputMaybe<Order_By>;
  kmps?: InputMaybe<Order_By>;
  last_processed_at?: InputMaybe<Order_By>;
  need_to_be_processed?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  total_kilometers?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_fk_challenges_aggregate?: InputMaybe<User_Fk_Challenge_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: challenge */
export type Challenge_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "challenge" */
export enum Challenge_Select_Column {
  /** column name */
  ChallengeType = 'challenge_type',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  Kmps = 'kmps',
  /** column name */
  LastProcessedAt = 'last_processed_at',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  Title = 'title',
  /** column name */
  TotalKilometers = 'total_kilometers',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "challenge" */
export type Challenge_Set_Input = {
  /** The type of the challenge */
  challenge_type?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of this challenge to be shown to the user */
  description?: InputMaybe<Scalars['String']['input']>;
  /** When this challenge will finish. If null then it will never end */
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The number of points that this challenge give when completed */
  kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The last time this challenge was processed for all the drivers */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When this challenge will start */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The title of this challenge to be shown to the user */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Challenge_Stddev_Fields = {
  __typename?: 'challenge_stddev_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Float']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Challenge_Stddev_Pop_Fields = {
  __typename?: 'challenge_stddev_pop_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Float']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Challenge_Stddev_Samp_Fields = {
  __typename?: 'challenge_stddev_samp_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Float']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "challenge" */
export type Challenge_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Challenge_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Challenge_Stream_Cursor_Value_Input = {
  /** The type of the challenge */
  challenge_type?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of this challenge to be shown to the user */
  description?: InputMaybe<Scalars['String']['input']>;
  /** When this challenge will finish. If null then it will never end */
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The number of points that this challenge give when completed */
  kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The last time this challenge was processed for all the drivers */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When this challenge will start */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The title of this challenge to be shown to the user */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Challenge_Sum_Fields = {
  __typename?: 'challenge_sum_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Int']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['float8']['output']>;
};

/** columns and relationships of "challenge_type" */
export type Challenge_Type = {
  __typename?: 'challenge_type';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The default number of points that this challenge give when completed */
  default_kmps: Scalars['Int']['output'];
  /** The default title of this challenge to be shown to the user */
  default_title: Scalars['String']['output'];
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Scalars['float8']['output'];
  /** The name of the challenge */
  name: Scalars['String']['output'];
};

/** aggregated selection of "challenge_type" */
export type Challenge_Type_Aggregate = {
  __typename?: 'challenge_type_aggregate';
  aggregate: Maybe<Challenge_Type_Aggregate_Fields>;
  nodes: Array<Challenge_Type>;
};

/** aggregate fields of "challenge_type" */
export type Challenge_Type_Aggregate_Fields = {
  __typename?: 'challenge_type_aggregate_fields';
  avg: Maybe<Challenge_Type_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Challenge_Type_Max_Fields>;
  min: Maybe<Challenge_Type_Min_Fields>;
  stddev: Maybe<Challenge_Type_Stddev_Fields>;
  stddev_pop: Maybe<Challenge_Type_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Challenge_Type_Stddev_Samp_Fields>;
  sum: Maybe<Challenge_Type_Sum_Fields>;
  var_pop: Maybe<Challenge_Type_Var_Pop_Fields>;
  var_samp: Maybe<Challenge_Type_Var_Samp_Fields>;
  variance: Maybe<Challenge_Type_Variance_Fields>;
};


/** aggregate fields of "challenge_type" */
export type Challenge_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Challenge_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Challenge_Type_Avg_Fields = {
  __typename?: 'challenge_type_avg_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Float']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "challenge_type". All fields are combined with a logical 'AND'. */
export type Challenge_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Challenge_Type_Bool_Exp>>;
  _not?: InputMaybe<Challenge_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Challenge_Type_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  default_kmps?: InputMaybe<Int_Comparison_Exp>;
  default_title?: InputMaybe<String_Comparison_Exp>;
  default_total_kilometers?: InputMaybe<Float8_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "challenge_type" */
export enum Challenge_Type_Constraint {
  /** unique or primary key constraint on columns "name" */
  ChallengeTypePkey = 'challenge_type_pkey'
}

/** input type for incrementing numeric columns in table "challenge_type" */
export type Challenge_Type_Inc_Input = {
  /** The default number of points that this challenge give when completed */
  default_kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "challenge_type" */
export type Challenge_Type_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The default number of points that this challenge give when completed */
  default_kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The default title of this challenge to be shown to the user */
  default_title?: InputMaybe<Scalars['String']['input']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers?: InputMaybe<Scalars['float8']['input']>;
  /** The name of the challenge */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Challenge_Type_Max_Fields = {
  __typename?: 'challenge_type_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Int']['output']>;
  /** The default title of this challenge to be shown to the user */
  default_title: Maybe<Scalars['String']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['float8']['output']>;
  /** The name of the challenge */
  name: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Challenge_Type_Min_Fields = {
  __typename?: 'challenge_type_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Int']['output']>;
  /** The default title of this challenge to be shown to the user */
  default_title: Maybe<Scalars['String']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['float8']['output']>;
  /** The name of the challenge */
  name: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "challenge_type" */
export type Challenge_Type_Mutation_Response = {
  __typename?: 'challenge_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Challenge_Type>;
};

/** on_conflict condition type for table "challenge_type" */
export type Challenge_Type_On_Conflict = {
  constraint: Challenge_Type_Constraint;
  update_columns?: Array<Challenge_Type_Update_Column>;
  where?: InputMaybe<Challenge_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "challenge_type". */
export type Challenge_Type_Order_By = {
  created_at?: InputMaybe<Order_By>;
  default_kmps?: InputMaybe<Order_By>;
  default_title?: InputMaybe<Order_By>;
  default_total_kilometers?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: challenge_type */
export type Challenge_Type_Pk_Columns_Input = {
  /** The name of the challenge */
  name: Scalars['String']['input'];
};

/** select columns of table "challenge_type" */
export enum Challenge_Type_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DefaultKmps = 'default_kmps',
  /** column name */
  DefaultTitle = 'default_title',
  /** column name */
  DefaultTotalKilometers = 'default_total_kilometers',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "challenge_type" */
export type Challenge_Type_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The default number of points that this challenge give when completed */
  default_kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The default title of this challenge to be shown to the user */
  default_title?: InputMaybe<Scalars['String']['input']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers?: InputMaybe<Scalars['float8']['input']>;
  /** The name of the challenge */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Challenge_Type_Stddev_Fields = {
  __typename?: 'challenge_type_stddev_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Float']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Challenge_Type_Stddev_Pop_Fields = {
  __typename?: 'challenge_type_stddev_pop_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Float']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Challenge_Type_Stddev_Samp_Fields = {
  __typename?: 'challenge_type_stddev_samp_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Float']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "challenge_type" */
export type Challenge_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Challenge_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Challenge_Type_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The default number of points that this challenge give when completed */
  default_kmps?: InputMaybe<Scalars['Int']['input']>;
  /** The default title of this challenge to be shown to the user */
  default_title?: InputMaybe<Scalars['String']['input']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers?: InputMaybe<Scalars['float8']['input']>;
  /** The name of the challenge */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Challenge_Type_Sum_Fields = {
  __typename?: 'challenge_type_sum_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Int']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['float8']['output']>;
};

/** update columns of table "challenge_type" */
export enum Challenge_Type_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DefaultKmps = 'default_kmps',
  /** column name */
  DefaultTitle = 'default_title',
  /** column name */
  DefaultTotalKilometers = 'default_total_kilometers',
  /** column name */
  Name = 'name'
}

export type Challenge_Type_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Challenge_Type_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Challenge_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Challenge_Type_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Challenge_Type_Var_Pop_Fields = {
  __typename?: 'challenge_type_var_pop_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Float']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Challenge_Type_Var_Samp_Fields = {
  __typename?: 'challenge_type_var_samp_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Float']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Challenge_Type_Variance_Fields = {
  __typename?: 'challenge_type_variance_fields';
  /** The default number of points that this challenge give when completed */
  default_kmps: Maybe<Scalars['Float']['output']>;
  /** The default number of kilometers to this challenge be considered as completed */
  default_total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** update columns of table "challenge" */
export enum Challenge_Update_Column {
  /** column name */
  ChallengeType = 'challenge_type',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  Kmps = 'kmps',
  /** column name */
  LastProcessedAt = 'last_processed_at',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  Title = 'title',
  /** column name */
  TotalKilometers = 'total_kilometers',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Challenge_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Challenge_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Challenge_Set_Input>;
  /** filter the rows which have to be updated */
  where: Challenge_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Challenge_Var_Pop_Fields = {
  __typename?: 'challenge_var_pop_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Float']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Challenge_Var_Samp_Fields = {
  __typename?: 'challenge_var_samp_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Float']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Challenge_Variance_Fields = {
  __typename?: 'challenge_variance_fields';
  /** The number of points that this challenge give when completed */
  kmps: Maybe<Scalars['Float']['output']>;
  /** The number of kilometers to this challenge be considered as completed */
  total_kilometers: Maybe<Scalars['Float']['output']>;
};

export type Change_Admin_Enabled_Args = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  new_enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Change_Driver_Enabled_Args = {
  new_enabled?: InputMaybe<Scalars['Boolean']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** columns and relationships of "config" */
export type Config = {
  __typename?: 'config';
  android_update_url: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['Int']['output'];
  ios_update_url: Maybe<Scalars['String']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Scalars['Int']['output'];
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Scalars['Int']['output'];
  min_android_version: Maybe<Scalars['String']['output']>;
  min_ios_version: Maybe<Scalars['String']['output']>;
  /** The id that is used to send the driver warnings to. Is the group that receives the driver warnings. The id comes from whatsapp-web.js */
  whatsapp_warnings_chat_id: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "config" */
export type Config_Aggregate = {
  __typename?: 'config_aggregate';
  aggregate: Maybe<Config_Aggregate_Fields>;
  nodes: Array<Config>;
};

/** aggregate fields of "config" */
export type Config_Aggregate_Fields = {
  __typename?: 'config_aggregate_fields';
  avg: Maybe<Config_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Config_Max_Fields>;
  min: Maybe<Config_Min_Fields>;
  stddev: Maybe<Config_Stddev_Fields>;
  stddev_pop: Maybe<Config_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Config_Stddev_Samp_Fields>;
  sum: Maybe<Config_Sum_Fields>;
  var_pop: Maybe<Config_Var_Pop_Fields>;
  var_samp: Maybe<Config_Var_Samp_Fields>;
  variance: Maybe<Config_Variance_Fields>;
};


/** aggregate fields of "config" */
export type Config_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Config_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Config_Avg_Fields = {
  __typename?: 'config_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "config". All fields are combined with a logical 'AND'. */
export type Config_Bool_Exp = {
  _and?: InputMaybe<Array<Config_Bool_Exp>>;
  _not?: InputMaybe<Config_Bool_Exp>;
  _or?: InputMaybe<Array<Config_Bool_Exp>>;
  android_update_url?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deleted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  ios_update_url?: InputMaybe<String_Comparison_Exp>;
  ips_by_delivery?: InputMaybe<Int_Comparison_Exp>;
  ips_by_delivery_before_confirmation?: InputMaybe<Int_Comparison_Exp>;
  min_android_version?: InputMaybe<String_Comparison_Exp>;
  min_ios_version?: InputMaybe<String_Comparison_Exp>;
  whatsapp_warnings_chat_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "config" */
export enum Config_Constraint {
  /** unique or primary key constraint on columns "id" */
  ConfigPkey = 'config_pkey'
}

/** input type for incrementing numeric columns in table "config" */
export type Config_Inc_Input = {
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery?: InputMaybe<Scalars['Int']['input']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "config" */
export type Config_Insert_Input = {
  android_update_url?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ios_update_url?: InputMaybe<Scalars['String']['input']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery?: InputMaybe<Scalars['Int']['input']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation?: InputMaybe<Scalars['Int']['input']>;
  min_android_version?: InputMaybe<Scalars['String']['input']>;
  min_ios_version?: InputMaybe<Scalars['String']['input']>;
  /** The id that is used to send the driver warnings to. Is the group that receives the driver warnings. The id comes from whatsapp-web.js */
  whatsapp_warnings_chat_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Config_Max_Fields = {
  __typename?: 'config_max_fields';
  android_update_url: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  ios_update_url: Maybe<Scalars['String']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Int']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Int']['output']>;
  min_android_version: Maybe<Scalars['String']['output']>;
  min_ios_version: Maybe<Scalars['String']['output']>;
  /** The id that is used to send the driver warnings to. Is the group that receives the driver warnings. The id comes from whatsapp-web.js */
  whatsapp_warnings_chat_id: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Config_Min_Fields = {
  __typename?: 'config_min_fields';
  android_update_url: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  ios_update_url: Maybe<Scalars['String']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Int']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Int']['output']>;
  min_android_version: Maybe<Scalars['String']['output']>;
  min_ios_version: Maybe<Scalars['String']['output']>;
  /** The id that is used to send the driver warnings to. Is the group that receives the driver warnings. The id comes from whatsapp-web.js */
  whatsapp_warnings_chat_id: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "config" */
export type Config_Mutation_Response = {
  __typename?: 'config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Config>;
};

/** on_conflict condition type for table "config" */
export type Config_On_Conflict = {
  constraint: Config_Constraint;
  update_columns?: Array<Config_Update_Column>;
  where?: InputMaybe<Config_Bool_Exp>;
};

/** Ordering options when selecting data from "config". */
export type Config_Order_By = {
  android_update_url?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  ios_update_url?: InputMaybe<Order_By>;
  ips_by_delivery?: InputMaybe<Order_By>;
  ips_by_delivery_before_confirmation?: InputMaybe<Order_By>;
  min_android_version?: InputMaybe<Order_By>;
  min_ios_version?: InputMaybe<Order_By>;
  whatsapp_warnings_chat_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: config */
export type Config_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "config" */
export enum Config_Select_Column {
  /** column name */
  AndroidUpdateUrl = 'android_update_url',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  Id = 'id',
  /** column name */
  IosUpdateUrl = 'ios_update_url',
  /** column name */
  IpsByDelivery = 'ips_by_delivery',
  /** column name */
  IpsByDeliveryBeforeConfirmation = 'ips_by_delivery_before_confirmation',
  /** column name */
  MinAndroidVersion = 'min_android_version',
  /** column name */
  MinIosVersion = 'min_ios_version',
  /** column name */
  WhatsappWarningsChatId = 'whatsapp_warnings_chat_id'
}

/** input type for updating data in table "config" */
export type Config_Set_Input = {
  android_update_url?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ios_update_url?: InputMaybe<Scalars['String']['input']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery?: InputMaybe<Scalars['Int']['input']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation?: InputMaybe<Scalars['Int']['input']>;
  min_android_version?: InputMaybe<Scalars['String']['input']>;
  min_ios_version?: InputMaybe<Scalars['String']['input']>;
  /** The id that is used to send the driver warnings to. Is the group that receives the driver warnings. The id comes from whatsapp-web.js */
  whatsapp_warnings_chat_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Config_Stddev_Fields = {
  __typename?: 'config_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Config_Stddev_Pop_Fields = {
  __typename?: 'config_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Config_Stddev_Samp_Fields = {
  __typename?: 'config_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "config" */
export type Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Config_Stream_Cursor_Value_Input = {
  android_update_url?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ios_update_url?: InputMaybe<Scalars['String']['input']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery?: InputMaybe<Scalars['Int']['input']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation?: InputMaybe<Scalars['Int']['input']>;
  min_android_version?: InputMaybe<Scalars['String']['input']>;
  min_ios_version?: InputMaybe<Scalars['String']['input']>;
  /** The id that is used to send the driver warnings to. Is the group that receives the driver warnings. The id comes from whatsapp-web.js */
  whatsapp_warnings_chat_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Config_Sum_Fields = {
  __typename?: 'config_sum_fields';
  id: Maybe<Scalars['Int']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Int']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "config" */
export enum Config_Update_Column {
  /** column name */
  AndroidUpdateUrl = 'android_update_url',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  IosUpdateUrl = 'ios_update_url',
  /** column name */
  IpsByDelivery = 'ips_by_delivery',
  /** column name */
  IpsByDeliveryBeforeConfirmation = 'ips_by_delivery_before_confirmation',
  /** column name */
  MinAndroidVersion = 'min_android_version',
  /** column name */
  MinIosVersion = 'min_ios_version',
  /** column name */
  WhatsappWarningsChatId = 'whatsapp_warnings_chat_id'
}

export type Config_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Config_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Config_Var_Pop_Fields = {
  __typename?: 'config_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Config_Var_Samp_Fields = {
  __typename?: 'config_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Config_Variance_Fields = {
  __typename?: 'config_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after the confirmation of delivery */
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  /** The amount that the driver will receive after uploading the receipt, but it can be not confirmed yet */
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

export type Consume_Whatsapp_Event_Args = {
  trigger_names_param?: InputMaybe<Scalars['_text']['input']>;
};

/** columns and relationships of "critical_point" */
export type Critical_Point = {
  __typename?: 'critical_point';
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  critical_segments: Array<Critical_Segment>;
  /** An aggregate relationship */
  critical_segments_aggregate: Critical_Segment_Aggregate;
  /** A computed field, executes function "critical_point_geojson" */
  geojson: Maybe<Scalars['jsonb']['output']>;
  id: Scalars['Int']['output'];
  latitude: Scalars['float8']['output'];
  location: Scalars['geography']['output'];
  longitude: Scalars['float8']['output'];
  max_velocity: Scalars['Float']['output'];
  name: Scalars['String']['output'];
  radius_meters: Scalars['float8']['output'];
};


/** columns and relationships of "critical_point" */
export type Critical_PointCritical_SegmentsArgs = {
  distinct_on?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Segment_Order_By>>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};


/** columns and relationships of "critical_point" */
export type Critical_PointCritical_Segments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Segment_Order_By>>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};


/** columns and relationships of "critical_point" */
export type Critical_PointGeojsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "critical_point" */
export type Critical_Point_Aggregate = {
  __typename?: 'critical_point_aggregate';
  aggregate: Maybe<Critical_Point_Aggregate_Fields>;
  nodes: Array<Critical_Point>;
};

/** aggregate fields of "critical_point" */
export type Critical_Point_Aggregate_Fields = {
  __typename?: 'critical_point_aggregate_fields';
  avg: Maybe<Critical_Point_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Critical_Point_Max_Fields>;
  min: Maybe<Critical_Point_Min_Fields>;
  stddev: Maybe<Critical_Point_Stddev_Fields>;
  stddev_pop: Maybe<Critical_Point_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Critical_Point_Stddev_Samp_Fields>;
  sum: Maybe<Critical_Point_Sum_Fields>;
  var_pop: Maybe<Critical_Point_Var_Pop_Fields>;
  var_samp: Maybe<Critical_Point_Var_Samp_Fields>;
  variance: Maybe<Critical_Point_Variance_Fields>;
};


/** aggregate fields of "critical_point" */
export type Critical_Point_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Critical_Point_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Critical_Point_Avg_Fields = {
  __typename?: 'critical_point_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
  latitude: Maybe<Scalars['Float']['output']>;
  longitude: Maybe<Scalars['Float']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "critical_point". All fields are combined with a logical 'AND'. */
export type Critical_Point_Bool_Exp = {
  _and?: InputMaybe<Array<Critical_Point_Bool_Exp>>;
  _not?: InputMaybe<Critical_Point_Bool_Exp>;
  _or?: InputMaybe<Array<Critical_Point_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  critical_segments?: InputMaybe<Critical_Segment_Bool_Exp>;
  critical_segments_aggregate?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp>;
  geojson?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  latitude?: InputMaybe<Float8_Comparison_Exp>;
  location?: InputMaybe<Geography_Comparison_Exp>;
  longitude?: InputMaybe<Float8_Comparison_Exp>;
  max_velocity?: InputMaybe<Float_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  radius_meters?: InputMaybe<Float8_Comparison_Exp>;
};

/** unique or primary key constraints on table "critical_point" */
export enum Critical_Point_Constraint {
  /** unique or primary key constraint on columns "id" */
  CriticalPointPkey = 'critical_point_pkey'
}

/** input type for incrementing numeric columns in table "critical_point" */
export type Critical_Point_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  latitude?: InputMaybe<Scalars['float8']['input']>;
  longitude?: InputMaybe<Scalars['float8']['input']>;
  max_velocity?: InputMaybe<Scalars['Float']['input']>;
  radius_meters?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "critical_point" */
export type Critical_Point_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  critical_segments?: InputMaybe<Critical_Segment_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
  latitude?: InputMaybe<Scalars['float8']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  longitude?: InputMaybe<Scalars['float8']['input']>;
  max_velocity?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  radius_meters?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate max on columns */
export type Critical_Point_Max_Fields = {
  __typename?: 'critical_point_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  latitude: Maybe<Scalars['float8']['output']>;
  longitude: Maybe<Scalars['float8']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  name: Maybe<Scalars['String']['output']>;
  radius_meters: Maybe<Scalars['float8']['output']>;
};

/** aggregate min on columns */
export type Critical_Point_Min_Fields = {
  __typename?: 'critical_point_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  latitude: Maybe<Scalars['float8']['output']>;
  longitude: Maybe<Scalars['float8']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  name: Maybe<Scalars['String']['output']>;
  radius_meters: Maybe<Scalars['float8']['output']>;
};

/** response of any mutation on the table "critical_point" */
export type Critical_Point_Mutation_Response = {
  __typename?: 'critical_point_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Critical_Point>;
};

/** input type for inserting object relation for remote table "critical_point" */
export type Critical_Point_Obj_Rel_Insert_Input = {
  data: Critical_Point_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Critical_Point_On_Conflict>;
};

/** on_conflict condition type for table "critical_point" */
export type Critical_Point_On_Conflict = {
  constraint: Critical_Point_Constraint;
  update_columns?: Array<Critical_Point_Update_Column>;
  where?: InputMaybe<Critical_Point_Bool_Exp>;
};

/** Ordering options when selecting data from "critical_point". */
export type Critical_Point_Order_By = {
  created_at?: InputMaybe<Order_By>;
  critical_segments_aggregate?: InputMaybe<Critical_Segment_Aggregate_Order_By>;
  geojson?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  location?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  max_velocity?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  radius_meters?: InputMaybe<Order_By>;
};

/** primary key columns input for table: critical_point */
export type Critical_Point_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "critical_point" */
export enum Critical_Point_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Location = 'location',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  MaxVelocity = 'max_velocity',
  /** column name */
  Name = 'name',
  /** column name */
  RadiusMeters = 'radius_meters'
}

/** input type for updating data in table "critical_point" */
export type Critical_Point_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  latitude?: InputMaybe<Scalars['float8']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  longitude?: InputMaybe<Scalars['float8']['input']>;
  max_velocity?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  radius_meters?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate stddev on columns */
export type Critical_Point_Stddev_Fields = {
  __typename?: 'critical_point_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
  latitude: Maybe<Scalars['Float']['output']>;
  longitude: Maybe<Scalars['Float']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Critical_Point_Stddev_Pop_Fields = {
  __typename?: 'critical_point_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  latitude: Maybe<Scalars['Float']['output']>;
  longitude: Maybe<Scalars['Float']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Critical_Point_Stddev_Samp_Fields = {
  __typename?: 'critical_point_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  latitude: Maybe<Scalars['Float']['output']>;
  longitude: Maybe<Scalars['Float']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "critical_point" */
export type Critical_Point_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Critical_Point_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Critical_Point_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  latitude?: InputMaybe<Scalars['float8']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  longitude?: InputMaybe<Scalars['float8']['input']>;
  max_velocity?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  radius_meters?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate sum on columns */
export type Critical_Point_Sum_Fields = {
  __typename?: 'critical_point_sum_fields';
  id: Maybe<Scalars['Int']['output']>;
  latitude: Maybe<Scalars['float8']['output']>;
  longitude: Maybe<Scalars['float8']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['float8']['output']>;
};

/** update columns of table "critical_point" */
export enum Critical_Point_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Location = 'location',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  MaxVelocity = 'max_velocity',
  /** column name */
  Name = 'name',
  /** column name */
  RadiusMeters = 'radius_meters'
}

export type Critical_Point_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Critical_Point_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Critical_Point_Set_Input>;
  /** filter the rows which have to be updated */
  where: Critical_Point_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Critical_Point_Var_Pop_Fields = {
  __typename?: 'critical_point_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  latitude: Maybe<Scalars['Float']['output']>;
  longitude: Maybe<Scalars['Float']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Critical_Point_Var_Samp_Fields = {
  __typename?: 'critical_point_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  latitude: Maybe<Scalars['Float']['output']>;
  longitude: Maybe<Scalars['Float']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Critical_Point_Variance_Fields = {
  __typename?: 'critical_point_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
  latitude: Maybe<Scalars['Float']['output']>;
  longitude: Maybe<Scalars['Float']['output']>;
  max_velocity: Maybe<Scalars['Float']['output']>;
  radius_meters: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "critical_segment" */
export type Critical_Segment = {
  __typename?: 'critical_segment';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  critical_point: Maybe<Critical_Point>;
  critical_point_id: Maybe<Scalars['Int']['output']>;
  end_point: Scalars['geometry']['output'];
  end_way_percentage: Scalars['float8']['output'];
  /** A computed field, executes function "critical_segment_geojson" */
  geojson: Maybe<Scalars['jsonb']['output']>;
  id: Scalars['Int']['output'];
  length_in_meters: Scalars['Int']['output'];
  max_speed: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  segment: Scalars['geometry']['output'];
  start_point: Scalars['geometry']['output'];
  start_way_percentage: Scalars['float8']['output'];
  way_osm_id: Scalars['bigint']['output'];
};


/** columns and relationships of "critical_segment" */
export type Critical_SegmentGeojsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "critical_segment" */
export type Critical_Segment_Aggregate = {
  __typename?: 'critical_segment_aggregate';
  aggregate: Maybe<Critical_Segment_Aggregate_Fields>;
  nodes: Array<Critical_Segment>;
};

export type Critical_Segment_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Critical_Segment_Aggregate_Bool_Exp_Var_Samp>;
};

export type Critical_Segment_Aggregate_Bool_Exp_Avg = {
  arguments: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Corr = {
  arguments: Critical_Segment_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Critical_Segment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Critical_Segment_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Critical_Segment_Aggregate_Bool_Exp_Max = {
  arguments: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Min = {
  arguments: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Sum = {
  arguments: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Critical_Segment_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Critical_Segment_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "critical_segment" */
export type Critical_Segment_Aggregate_Fields = {
  __typename?: 'critical_segment_aggregate_fields';
  avg: Maybe<Critical_Segment_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Critical_Segment_Max_Fields>;
  min: Maybe<Critical_Segment_Min_Fields>;
  stddev: Maybe<Critical_Segment_Stddev_Fields>;
  stddev_pop: Maybe<Critical_Segment_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Critical_Segment_Stddev_Samp_Fields>;
  sum: Maybe<Critical_Segment_Sum_Fields>;
  var_pop: Maybe<Critical_Segment_Var_Pop_Fields>;
  var_samp: Maybe<Critical_Segment_Var_Samp_Fields>;
  variance: Maybe<Critical_Segment_Variance_Fields>;
};


/** aggregate fields of "critical_segment" */
export type Critical_Segment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "critical_segment" */
export type Critical_Segment_Aggregate_Order_By = {
  avg?: InputMaybe<Critical_Segment_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Critical_Segment_Max_Order_By>;
  min?: InputMaybe<Critical_Segment_Min_Order_By>;
  stddev?: InputMaybe<Critical_Segment_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Critical_Segment_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Critical_Segment_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Critical_Segment_Sum_Order_By>;
  var_pop?: InputMaybe<Critical_Segment_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Critical_Segment_Var_Samp_Order_By>;
  variance?: InputMaybe<Critical_Segment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "critical_segment" */
export type Critical_Segment_Arr_Rel_Insert_Input = {
  data: Array<Critical_Segment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Critical_Segment_On_Conflict>;
};

/** aggregate avg on columns */
export type Critical_Segment_Avg_Fields = {
  __typename?: 'critical_segment_avg_fields';
  critical_point_id: Maybe<Scalars['Float']['output']>;
  end_way_percentage: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  length_in_meters: Maybe<Scalars['Float']['output']>;
  max_speed: Maybe<Scalars['Float']['output']>;
  start_way_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "critical_segment" */
export type Critical_Segment_Avg_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "critical_segment". All fields are combined with a logical 'AND'. */
export type Critical_Segment_Bool_Exp = {
  _and?: InputMaybe<Array<Critical_Segment_Bool_Exp>>;
  _not?: InputMaybe<Critical_Segment_Bool_Exp>;
  _or?: InputMaybe<Array<Critical_Segment_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  critical_point?: InputMaybe<Critical_Point_Bool_Exp>;
  critical_point_id?: InputMaybe<Int_Comparison_Exp>;
  end_point?: InputMaybe<Geometry_Comparison_Exp>;
  end_way_percentage?: InputMaybe<Float8_Comparison_Exp>;
  geojson?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  length_in_meters?: InputMaybe<Int_Comparison_Exp>;
  max_speed?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  segment?: InputMaybe<Geometry_Comparison_Exp>;
  start_point?: InputMaybe<Geometry_Comparison_Exp>;
  start_way_percentage?: InputMaybe<Float8_Comparison_Exp>;
  way_osm_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "critical_segment" */
export enum Critical_Segment_Constraint {
  /** unique or primary key constraint on columns "id" */
  CriticalSegmentPkey = 'critical_segment_pkey'
}

/** input type for incrementing numeric columns in table "critical_segment" */
export type Critical_Segment_Inc_Input = {
  critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  end_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  length_in_meters?: InputMaybe<Scalars['Int']['input']>;
  max_speed?: InputMaybe<Scalars['Int']['input']>;
  start_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "critical_segment" */
export type Critical_Segment_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  critical_point?: InputMaybe<Critical_Point_Obj_Rel_Insert_Input>;
  critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  end_point?: InputMaybe<Scalars['geometry']['input']>;
  end_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  length_in_meters?: InputMaybe<Scalars['Int']['input']>;
  max_speed?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  segment?: InputMaybe<Scalars['geometry']['input']>;
  start_point?: InputMaybe<Scalars['geometry']['input']>;
  start_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Critical_Segment_Max_Fields = {
  __typename?: 'critical_segment_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  critical_point_id: Maybe<Scalars['Int']['output']>;
  end_way_percentage: Maybe<Scalars['float8']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  length_in_meters: Maybe<Scalars['Int']['output']>;
  max_speed: Maybe<Scalars['Int']['output']>;
  name: Maybe<Scalars['String']['output']>;
  start_way_percentage: Maybe<Scalars['float8']['output']>;
  way_osm_id: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "critical_segment" */
export type Critical_Segment_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Critical_Segment_Min_Fields = {
  __typename?: 'critical_segment_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  critical_point_id: Maybe<Scalars['Int']['output']>;
  end_way_percentage: Maybe<Scalars['float8']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  length_in_meters: Maybe<Scalars['Int']['output']>;
  max_speed: Maybe<Scalars['Int']['output']>;
  name: Maybe<Scalars['String']['output']>;
  start_way_percentage: Maybe<Scalars['float8']['output']>;
  way_osm_id: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "critical_segment" */
export type Critical_Segment_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "critical_segment" */
export type Critical_Segment_Mutation_Response = {
  __typename?: 'critical_segment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Critical_Segment>;
};

/** on_conflict condition type for table "critical_segment" */
export type Critical_Segment_On_Conflict = {
  constraint: Critical_Segment_Constraint;
  update_columns?: Array<Critical_Segment_Update_Column>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};

/** Ordering options when selecting data from "critical_segment". */
export type Critical_Segment_Order_By = {
  created_at?: InputMaybe<Order_By>;
  critical_point?: InputMaybe<Critical_Point_Order_By>;
  critical_point_id?: InputMaybe<Order_By>;
  end_point?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  geojson?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  segment?: InputMaybe<Order_By>;
  start_point?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: critical_segment */
export type Critical_Segment_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "critical_segment" */
export enum Critical_Segment_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CriticalPointId = 'critical_point_id',
  /** column name */
  EndPoint = 'end_point',
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  Id = 'id',
  /** column name */
  LengthInMeters = 'length_in_meters',
  /** column name */
  MaxSpeed = 'max_speed',
  /** column name */
  Name = 'name',
  /** column name */
  Segment = 'segment',
  /** column name */
  StartPoint = 'start_point',
  /** column name */
  StartWayPercentage = 'start_way_percentage',
  /** column name */
  WayOsmId = 'way_osm_id'
}

/** select "critical_segment_aggregate_bool_exp_avg_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** select "critical_segment_aggregate_bool_exp_corr_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** select "critical_segment_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** select "critical_segment_aggregate_bool_exp_max_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** select "critical_segment_aggregate_bool_exp_min_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** select "critical_segment_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** select "critical_segment_aggregate_bool_exp_sum_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** select "critical_segment_aggregate_bool_exp_var_samp_arguments_columns" columns of table "critical_segment" */
export enum Critical_Segment_Select_Column_Critical_Segment_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  StartWayPercentage = 'start_way_percentage'
}

/** input type for updating data in table "critical_segment" */
export type Critical_Segment_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  end_point?: InputMaybe<Scalars['geometry']['input']>;
  end_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  length_in_meters?: InputMaybe<Scalars['Int']['input']>;
  max_speed?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  segment?: InputMaybe<Scalars['geometry']['input']>;
  start_point?: InputMaybe<Scalars['geometry']['input']>;
  start_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Critical_Segment_Stddev_Fields = {
  __typename?: 'critical_segment_stddev_fields';
  critical_point_id: Maybe<Scalars['Float']['output']>;
  end_way_percentage: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  length_in_meters: Maybe<Scalars['Float']['output']>;
  max_speed: Maybe<Scalars['Float']['output']>;
  start_way_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "critical_segment" */
export type Critical_Segment_Stddev_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Critical_Segment_Stddev_Pop_Fields = {
  __typename?: 'critical_segment_stddev_pop_fields';
  critical_point_id: Maybe<Scalars['Float']['output']>;
  end_way_percentage: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  length_in_meters: Maybe<Scalars['Float']['output']>;
  max_speed: Maybe<Scalars['Float']['output']>;
  start_way_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "critical_segment" */
export type Critical_Segment_Stddev_Pop_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Critical_Segment_Stddev_Samp_Fields = {
  __typename?: 'critical_segment_stddev_samp_fields';
  critical_point_id: Maybe<Scalars['Float']['output']>;
  end_way_percentage: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  length_in_meters: Maybe<Scalars['Float']['output']>;
  max_speed: Maybe<Scalars['Float']['output']>;
  start_way_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "critical_segment" */
export type Critical_Segment_Stddev_Samp_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "critical_segment" */
export type Critical_Segment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Critical_Segment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Critical_Segment_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  end_point?: InputMaybe<Scalars['geometry']['input']>;
  end_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  length_in_meters?: InputMaybe<Scalars['Int']['input']>;
  max_speed?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  segment?: InputMaybe<Scalars['geometry']['input']>;
  start_point?: InputMaybe<Scalars['geometry']['input']>;
  start_way_percentage?: InputMaybe<Scalars['float8']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Critical_Segment_Sum_Fields = {
  __typename?: 'critical_segment_sum_fields';
  critical_point_id: Maybe<Scalars['Int']['output']>;
  end_way_percentage: Maybe<Scalars['float8']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  length_in_meters: Maybe<Scalars['Int']['output']>;
  max_speed: Maybe<Scalars['Int']['output']>;
  start_way_percentage: Maybe<Scalars['float8']['output']>;
  way_osm_id: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "critical_segment" */
export type Critical_Segment_Sum_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** update columns of table "critical_segment" */
export enum Critical_Segment_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CriticalPointId = 'critical_point_id',
  /** column name */
  EndPoint = 'end_point',
  /** column name */
  EndWayPercentage = 'end_way_percentage',
  /** column name */
  LengthInMeters = 'length_in_meters',
  /** column name */
  MaxSpeed = 'max_speed',
  /** column name */
  Name = 'name',
  /** column name */
  Segment = 'segment',
  /** column name */
  StartPoint = 'start_point',
  /** column name */
  StartWayPercentage = 'start_way_percentage',
  /** column name */
  WayOsmId = 'way_osm_id'
}

export type Critical_Segment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Critical_Segment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Critical_Segment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Critical_Segment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Critical_Segment_Var_Pop_Fields = {
  __typename?: 'critical_segment_var_pop_fields';
  critical_point_id: Maybe<Scalars['Float']['output']>;
  end_way_percentage: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  length_in_meters: Maybe<Scalars['Float']['output']>;
  max_speed: Maybe<Scalars['Float']['output']>;
  start_way_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "critical_segment" */
export type Critical_Segment_Var_Pop_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Critical_Segment_Var_Samp_Fields = {
  __typename?: 'critical_segment_var_samp_fields';
  critical_point_id: Maybe<Scalars['Float']['output']>;
  end_way_percentage: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  length_in_meters: Maybe<Scalars['Float']['output']>;
  max_speed: Maybe<Scalars['Float']['output']>;
  start_way_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "critical_segment" */
export type Critical_Segment_Var_Samp_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Critical_Segment_Variance_Fields = {
  __typename?: 'critical_segment_variance_fields';
  critical_point_id: Maybe<Scalars['Float']['output']>;
  end_way_percentage: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  length_in_meters: Maybe<Scalars['Float']['output']>;
  max_speed: Maybe<Scalars['Float']['output']>;
  start_way_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "critical_segment" */
export type Critical_Segment_Variance_Order_By = {
  critical_point_id?: InputMaybe<Order_By>;
  end_way_percentage?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  length_in_meters?: InputMaybe<Order_By>;
  max_speed?: InputMaybe<Order_By>;
  start_way_percentage?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "cte.nf_lock" */
export type Cte_Nf_Lock = {
  __typename?: 'cte_nf_lock';
  /** An object relationship */
  admin: Admin;
  locked_at: Scalars['timestamptz']['output'];
  nf: Scalars['Int']['output'];
  user_uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "cte.nf_lock" */
export type Cte_Nf_Lock_Aggregate = {
  __typename?: 'cte_nf_lock_aggregate';
  aggregate: Maybe<Cte_Nf_Lock_Aggregate_Fields>;
  nodes: Array<Cte_Nf_Lock>;
};

/** aggregate fields of "cte.nf_lock" */
export type Cte_Nf_Lock_Aggregate_Fields = {
  __typename?: 'cte_nf_lock_aggregate_fields';
  avg: Maybe<Cte_Nf_Lock_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Cte_Nf_Lock_Max_Fields>;
  min: Maybe<Cte_Nf_Lock_Min_Fields>;
  stddev: Maybe<Cte_Nf_Lock_Stddev_Fields>;
  stddev_pop: Maybe<Cte_Nf_Lock_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Cte_Nf_Lock_Stddev_Samp_Fields>;
  sum: Maybe<Cte_Nf_Lock_Sum_Fields>;
  var_pop: Maybe<Cte_Nf_Lock_Var_Pop_Fields>;
  var_samp: Maybe<Cte_Nf_Lock_Var_Samp_Fields>;
  variance: Maybe<Cte_Nf_Lock_Variance_Fields>;
};


/** aggregate fields of "cte.nf_lock" */
export type Cte_Nf_Lock_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Cte_Nf_Lock_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Cte_Nf_Lock_Avg_Fields = {
  __typename?: 'cte_nf_lock_avg_fields';
  nf: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "cte.nf_lock". All fields are combined with a logical 'AND'. */
export type Cte_Nf_Lock_Bool_Exp = {
  _and?: InputMaybe<Array<Cte_Nf_Lock_Bool_Exp>>;
  _not?: InputMaybe<Cte_Nf_Lock_Bool_Exp>;
  _or?: InputMaybe<Array<Cte_Nf_Lock_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  locked_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  nf?: InputMaybe<Int_Comparison_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "cte.nf_lock" */
export enum Cte_Nf_Lock_Constraint {
  /** unique or primary key constraint on columns "nf" */
  LockedNfPkey = 'locked_nf_pkey'
}

/** input type for incrementing numeric columns in table "cte.nf_lock" */
export type Cte_Nf_Lock_Inc_Input = {
  nf?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "cte.nf_lock" */
export type Cte_Nf_Lock_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  locked_at?: InputMaybe<Scalars['timestamptz']['input']>;
  nf?: InputMaybe<Scalars['Int']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Cte_Nf_Lock_Max_Fields = {
  __typename?: 'cte_nf_lock_max_fields';
  locked_at: Maybe<Scalars['timestamptz']['output']>;
  nf: Maybe<Scalars['Int']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Cte_Nf_Lock_Min_Fields = {
  __typename?: 'cte_nf_lock_min_fields';
  locked_at: Maybe<Scalars['timestamptz']['output']>;
  nf: Maybe<Scalars['Int']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "cte.nf_lock" */
export type Cte_Nf_Lock_Mutation_Response = {
  __typename?: 'cte_nf_lock_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Cte_Nf_Lock>;
};

/** on_conflict condition type for table "cte.nf_lock" */
export type Cte_Nf_Lock_On_Conflict = {
  constraint: Cte_Nf_Lock_Constraint;
  update_columns?: Array<Cte_Nf_Lock_Update_Column>;
  where?: InputMaybe<Cte_Nf_Lock_Bool_Exp>;
};

/** Ordering options when selecting data from "cte.nf_lock". */
export type Cte_Nf_Lock_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  locked_at?: InputMaybe<Order_By>;
  nf?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: cte.nf_lock */
export type Cte_Nf_Lock_Pk_Columns_Input = {
  nf: Scalars['Int']['input'];
};

/** select columns of table "cte.nf_lock" */
export enum Cte_Nf_Lock_Select_Column {
  /** column name */
  LockedAt = 'locked_at',
  /** column name */
  Nf = 'nf',
  /** column name */
  UserUuid = 'user_uuid'
}

/** input type for updating data in table "cte.nf_lock" */
export type Cte_Nf_Lock_Set_Input = {
  locked_at?: InputMaybe<Scalars['timestamptz']['input']>;
  nf?: InputMaybe<Scalars['Int']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Cte_Nf_Lock_Stddev_Fields = {
  __typename?: 'cte_nf_lock_stddev_fields';
  nf: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Cte_Nf_Lock_Stddev_Pop_Fields = {
  __typename?: 'cte_nf_lock_stddev_pop_fields';
  nf: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Cte_Nf_Lock_Stddev_Samp_Fields = {
  __typename?: 'cte_nf_lock_stddev_samp_fields';
  nf: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "cte_nf_lock" */
export type Cte_Nf_Lock_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cte_Nf_Lock_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cte_Nf_Lock_Stream_Cursor_Value_Input = {
  locked_at?: InputMaybe<Scalars['timestamptz']['input']>;
  nf?: InputMaybe<Scalars['Int']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Cte_Nf_Lock_Sum_Fields = {
  __typename?: 'cte_nf_lock_sum_fields';
  nf: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "cte.nf_lock" */
export enum Cte_Nf_Lock_Update_Column {
  /** column name */
  LockedAt = 'locked_at',
  /** column name */
  Nf = 'nf',
  /** column name */
  UserUuid = 'user_uuid'
}

export type Cte_Nf_Lock_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Cte_Nf_Lock_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Cte_Nf_Lock_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cte_Nf_Lock_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Cte_Nf_Lock_Var_Pop_Fields = {
  __typename?: 'cte_nf_lock_var_pop_fields';
  nf: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Cte_Nf_Lock_Var_Samp_Fields = {
  __typename?: 'cte_nf_lock_var_samp_fields';
  nf: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Cte_Nf_Lock_Variance_Fields = {
  __typename?: 'cte_nf_lock_variance_fields';
  nf: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "current_config" */
export type Current_Config = {
  __typename?: 'current_config';
  android_update_url: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  ios_update_url: Maybe<Scalars['String']['output']>;
  ips_by_delivery: Maybe<Scalars['Int']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Int']['output']>;
  min_android_version: Maybe<Scalars['String']['output']>;
  min_ios_version: Maybe<Scalars['String']['output']>;
  whatsapp_warnings_chat_id: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "current_config" */
export type Current_Config_Aggregate = {
  __typename?: 'current_config_aggregate';
  aggregate: Maybe<Current_Config_Aggregate_Fields>;
  nodes: Array<Current_Config>;
};

/** aggregate fields of "current_config" */
export type Current_Config_Aggregate_Fields = {
  __typename?: 'current_config_aggregate_fields';
  avg: Maybe<Current_Config_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Current_Config_Max_Fields>;
  min: Maybe<Current_Config_Min_Fields>;
  stddev: Maybe<Current_Config_Stddev_Fields>;
  stddev_pop: Maybe<Current_Config_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Current_Config_Stddev_Samp_Fields>;
  sum: Maybe<Current_Config_Sum_Fields>;
  var_pop: Maybe<Current_Config_Var_Pop_Fields>;
  var_samp: Maybe<Current_Config_Var_Samp_Fields>;
  variance: Maybe<Current_Config_Variance_Fields>;
};


/** aggregate fields of "current_config" */
export type Current_Config_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Current_Config_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Current_Config_Avg_Fields = {
  __typename?: 'current_config_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "current_config". All fields are combined with a logical 'AND'. */
export type Current_Config_Bool_Exp = {
  _and?: InputMaybe<Array<Current_Config_Bool_Exp>>;
  _not?: InputMaybe<Current_Config_Bool_Exp>;
  _or?: InputMaybe<Array<Current_Config_Bool_Exp>>;
  android_update_url?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deleted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  ios_update_url?: InputMaybe<String_Comparison_Exp>;
  ips_by_delivery?: InputMaybe<Int_Comparison_Exp>;
  ips_by_delivery_before_confirmation?: InputMaybe<Int_Comparison_Exp>;
  min_android_version?: InputMaybe<String_Comparison_Exp>;
  min_ios_version?: InputMaybe<String_Comparison_Exp>;
  whatsapp_warnings_chat_id?: InputMaybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Current_Config_Max_Fields = {
  __typename?: 'current_config_max_fields';
  android_update_url: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  ios_update_url: Maybe<Scalars['String']['output']>;
  ips_by_delivery: Maybe<Scalars['Int']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Int']['output']>;
  min_android_version: Maybe<Scalars['String']['output']>;
  min_ios_version: Maybe<Scalars['String']['output']>;
  whatsapp_warnings_chat_id: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Current_Config_Min_Fields = {
  __typename?: 'current_config_min_fields';
  android_update_url: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  ios_update_url: Maybe<Scalars['String']['output']>;
  ips_by_delivery: Maybe<Scalars['Int']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Int']['output']>;
  min_android_version: Maybe<Scalars['String']['output']>;
  min_ios_version: Maybe<Scalars['String']['output']>;
  whatsapp_warnings_chat_id: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "current_config". */
export type Current_Config_Order_By = {
  android_update_url?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  ios_update_url?: InputMaybe<Order_By>;
  ips_by_delivery?: InputMaybe<Order_By>;
  ips_by_delivery_before_confirmation?: InputMaybe<Order_By>;
  min_android_version?: InputMaybe<Order_By>;
  min_ios_version?: InputMaybe<Order_By>;
  whatsapp_warnings_chat_id?: InputMaybe<Order_By>;
};

/** select columns of table "current_config" */
export enum Current_Config_Select_Column {
  /** column name */
  AndroidUpdateUrl = 'android_update_url',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  Id = 'id',
  /** column name */
  IosUpdateUrl = 'ios_update_url',
  /** column name */
  IpsByDelivery = 'ips_by_delivery',
  /** column name */
  IpsByDeliveryBeforeConfirmation = 'ips_by_delivery_before_confirmation',
  /** column name */
  MinAndroidVersion = 'min_android_version',
  /** column name */
  MinIosVersion = 'min_ios_version',
  /** column name */
  WhatsappWarningsChatId = 'whatsapp_warnings_chat_id'
}

/** aggregate stddev on columns */
export type Current_Config_Stddev_Fields = {
  __typename?: 'current_config_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Current_Config_Stddev_Pop_Fields = {
  __typename?: 'current_config_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Current_Config_Stddev_Samp_Fields = {
  __typename?: 'current_config_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "current_config" */
export type Current_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Current_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Current_Config_Stream_Cursor_Value_Input = {
  android_update_url?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ios_update_url?: InputMaybe<Scalars['String']['input']>;
  ips_by_delivery?: InputMaybe<Scalars['Int']['input']>;
  ips_by_delivery_before_confirmation?: InputMaybe<Scalars['Int']['input']>;
  min_android_version?: InputMaybe<Scalars['String']['input']>;
  min_ios_version?: InputMaybe<Scalars['String']['input']>;
  whatsapp_warnings_chat_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Current_Config_Sum_Fields = {
  __typename?: 'current_config_sum_fields';
  id: Maybe<Scalars['Int']['output']>;
  ips_by_delivery: Maybe<Scalars['Int']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Current_Config_Var_Pop_Fields = {
  __typename?: 'current_config_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Current_Config_Var_Samp_Fields = {
  __typename?: 'current_config_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Current_Config_Variance_Fields = {
  __typename?: 'current_config_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
  ips_by_delivery: Maybe<Scalars['Float']['output']>;
  ips_by_delivery_before_confirmation: Maybe<Scalars['Float']['output']>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['date']['input']>;
  _gt?: InputMaybe<Scalars['date']['input']>;
  _gte?: InputMaybe<Scalars['date']['input']>;
  _in?: InputMaybe<Array<Scalars['date']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['date']['input']>;
  _lte?: InputMaybe<Scalars['date']['input']>;
  _neq?: InputMaybe<Scalars['date']['input']>;
  _nin?: InputMaybe<Array<Scalars['date']['input']>>;
};

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['date']['input']>;
  _gt?: InputMaybe<Scalars['date']['input']>;
  _gte?: InputMaybe<Scalars['date']['input']>;
  _in?: InputMaybe<Array<Scalars['date']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['date']['input']>;
  _lte?: InputMaybe<Scalars['date']['input']>;
  _neq?: InputMaybe<Scalars['date']['input']>;
  _nin?: InputMaybe<Array<Scalars['date']['input']>>;
};

/** Boolean expression to compare columns of type "datetime". All fields are combined with logical 'AND'. */
export type Datetime_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['datetime']['input']>;
  _gt?: InputMaybe<Scalars['datetime']['input']>;
  _gte?: InputMaybe<Scalars['datetime']['input']>;
  _in?: InputMaybe<Array<Scalars['datetime']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['datetime']['input']>;
  _lte?: InputMaybe<Scalars['datetime']['input']>;
  _neq?: InputMaybe<Scalars['datetime']['input']>;
  _nin?: InputMaybe<Array<Scalars['datetime']['input']>>;
};

/** Boolean expression to compare columns of type "datetimeoffset". All fields are combined with logical 'AND'. */
export type Datetimeoffset_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['datetimeoffset']['input']>;
  _gt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  _gte?: InputMaybe<Scalars['datetimeoffset']['input']>;
  _in?: InputMaybe<Array<Scalars['datetimeoffset']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['datetimeoffset']['input']>;
  _lte?: InputMaybe<Scalars['datetimeoffset']['input']>;
  _neq?: InputMaybe<Scalars['datetimeoffset']['input']>;
  _nin?: InputMaybe<Array<Scalars['datetimeoffset']['input']>>;
};

/** Table that holds deleted rows from other tables. This is for synchronization in other devices. */
export type Deleted_Row = {
  __typename?: 'deleted_row';
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  row_uuid: Scalars['uuid']['output'];
  table_name: Scalars['String']['output'];
};

/** aggregated selection of "deleted_row" */
export type Deleted_Row_Aggregate = {
  __typename?: 'deleted_row_aggregate';
  aggregate: Maybe<Deleted_Row_Aggregate_Fields>;
  nodes: Array<Deleted_Row>;
};

/** aggregate fields of "deleted_row" */
export type Deleted_Row_Aggregate_Fields = {
  __typename?: 'deleted_row_aggregate_fields';
  avg: Maybe<Deleted_Row_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Deleted_Row_Max_Fields>;
  min: Maybe<Deleted_Row_Min_Fields>;
  stddev: Maybe<Deleted_Row_Stddev_Fields>;
  stddev_pop: Maybe<Deleted_Row_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Deleted_Row_Stddev_Samp_Fields>;
  sum: Maybe<Deleted_Row_Sum_Fields>;
  var_pop: Maybe<Deleted_Row_Var_Pop_Fields>;
  var_samp: Maybe<Deleted_Row_Var_Samp_Fields>;
  variance: Maybe<Deleted_Row_Variance_Fields>;
};


/** aggregate fields of "deleted_row" */
export type Deleted_Row_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Deleted_Row_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Deleted_Row_Avg_Fields = {
  __typename?: 'deleted_row_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "deleted_row". All fields are combined with a logical 'AND'. */
export type Deleted_Row_Bool_Exp = {
  _and?: InputMaybe<Array<Deleted_Row_Bool_Exp>>;
  _not?: InputMaybe<Deleted_Row_Bool_Exp>;
  _or?: InputMaybe<Array<Deleted_Row_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  row_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  table_name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "deleted_row" */
export enum Deleted_Row_Constraint {
  /** unique or primary key constraint on columns "id" */
  DeletedRowPkey = 'deleted_row_pkey'
}

/** input type for incrementing numeric columns in table "deleted_row" */
export type Deleted_Row_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "deleted_row" */
export type Deleted_Row_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  row_uuid?: InputMaybe<Scalars['uuid']['input']>;
  table_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Deleted_Row_Max_Fields = {
  __typename?: 'deleted_row_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  row_uuid: Maybe<Scalars['uuid']['output']>;
  table_name: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Deleted_Row_Min_Fields = {
  __typename?: 'deleted_row_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  row_uuid: Maybe<Scalars['uuid']['output']>;
  table_name: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "deleted_row" */
export type Deleted_Row_Mutation_Response = {
  __typename?: 'deleted_row_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Deleted_Row>;
};

/** on_conflict condition type for table "deleted_row" */
export type Deleted_Row_On_Conflict = {
  constraint: Deleted_Row_Constraint;
  update_columns?: Array<Deleted_Row_Update_Column>;
  where?: InputMaybe<Deleted_Row_Bool_Exp>;
};

/** Ordering options when selecting data from "deleted_row". */
export type Deleted_Row_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  row_uuid?: InputMaybe<Order_By>;
  table_name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: deleted_row */
export type Deleted_Row_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "deleted_row" */
export enum Deleted_Row_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  RowUuid = 'row_uuid',
  /** column name */
  TableName = 'table_name'
}

/** input type for updating data in table "deleted_row" */
export type Deleted_Row_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  row_uuid?: InputMaybe<Scalars['uuid']['input']>;
  table_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Deleted_Row_Stddev_Fields = {
  __typename?: 'deleted_row_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Deleted_Row_Stddev_Pop_Fields = {
  __typename?: 'deleted_row_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Deleted_Row_Stddev_Samp_Fields = {
  __typename?: 'deleted_row_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "deleted_row" */
export type Deleted_Row_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Deleted_Row_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Deleted_Row_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  row_uuid?: InputMaybe<Scalars['uuid']['input']>;
  table_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Deleted_Row_Sum_Fields = {
  __typename?: 'deleted_row_sum_fields';
  id: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "deleted_row" */
export enum Deleted_Row_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  RowUuid = 'row_uuid',
  /** column name */
  TableName = 'table_name'
}

export type Deleted_Row_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Deleted_Row_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Deleted_Row_Set_Input>;
  /** filter the rows which have to be updated */
  where: Deleted_Row_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Deleted_Row_Var_Pop_Fields = {
  __typename?: 'deleted_row_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Deleted_Row_Var_Samp_Fields = {
  __typename?: 'deleted_row_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Deleted_Row_Variance_Fields = {
  __typename?: 'deleted_row_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Tabela referente a entregas com o nmero do documento e nota fiscal */
export type Delivery = {
  __typename?: 'delivery';
  /** An object relationship */
  admin: Maybe<Admin>;
  approved_at: Maybe<Scalars['timestamptz']['output']>;
  approved_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id: Scalars['String']['output'];
  codmoto: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** Referente ao A1_NOME no Protheus */
  customer_name: Scalars['String']['output'];
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at: Maybe<Scalars['String']['output']>;
  denied_at: Maybe<Scalars['timestamptz']['output']>;
  /** Referente ao DT6_DOC no Protheus */
  document_number: Scalars['String']['output'];
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at: Maybe<Scalars['date']['output']>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number: Scalars['String']['output'];
  /** If the delivery needs to check the extra weight receipt from ArcelorMittal. This is based on DT6_SERVIC being "SNA" (waste) or "SNR" (ore) and the A1_NOME being like ARCELORMITTAL */
  is_weight_receipt: Scalars['Boolean']['output'];
  license_plate: Scalars['String']['output'];
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2: Maybe<Scalars['String']['output']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3: Maybe<Scalars['String']['output']>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at: Maybe<Scalars['timestamptz']['output']>;
  /** The full receipt image */
  receipt_image_url: Maybe<Scalars['String']['output']>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url: Maybe<Scalars['String']['output']>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at: Maybe<Scalars['timestamptz']['output']>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number: Maybe<Scalars['String']['output']>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at: Maybe<Scalars['timestamptz']['output']>;
  recognized_brm: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  recognized_by_admin: Maybe<Admin>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  recognized_first_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_first_ipz: Maybe<Scalars['Int']['output']>;
  recognized_first_mp: Maybe<Scalars['String']['output']>;
  recognized_first_weight: Maybe<Scalars['Int']['output']>;
  recognized_gross_weight: Maybe<Scalars['Int']['output']>;
  recognized_is_metalic: Maybe<Scalars['Boolean']['output']>;
  recognized_license_plate: Maybe<Scalars['String']['output']>;
  recognized_net_weight: Maybe<Scalars['Int']['output']>;
  recognized_second_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_second_ipz: Maybe<Scalars['Int']['output']>;
  recognized_second_mp: Maybe<Scalars['String']['output']>;
  recognized_second_weight: Maybe<Scalars['Int']['output']>;
  recognized_third_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_third_ipz: Maybe<Scalars['Int']['output']>;
  recognized_third_mp: Maybe<Scalars['String']['output']>;
  recognized_third_weight: Maybe<Scalars['Int']['output']>;
  recognized_weighing_at: Maybe<Scalars['timestamptz']['output']>;
  status: Maybe<Scalars['String']['output']>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Maybe<User>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid: Scalars['uuid']['output'];
  /** Referente ao DTC_PESO no Protheus */
  weight: Scalars['float8']['output'];
  /** Se o usurio editou o canhoto de peso aps o reconhecimento automtico. Isso  usado pela API para no aprovar automaticamente os que foram editados */
  weight_receipt_was_edited: Maybe<Scalars['Boolean']['output']>;
};

/** aggregated selection of "delivery" */
export type Delivery_Aggregate = {
  __typename?: 'delivery_aggregate';
  aggregate: Maybe<Delivery_Aggregate_Fields>;
  nodes: Array<Delivery>;
};

export type Delivery_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Delivery_Aggregate_Bool_Exp_Avg>;
  bool_and?: InputMaybe<Delivery_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Delivery_Aggregate_Bool_Exp_Bool_Or>;
  corr?: InputMaybe<Delivery_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Delivery_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Delivery_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Delivery_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Delivery_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Delivery_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Delivery_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Delivery_Aggregate_Bool_Exp_Var_Samp>;
};

export type Delivery_Aggregate_Bool_Exp_Avg = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Bool_And = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Corr = {
  arguments: Delivery_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Delivery_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Delivery_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Delivery_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Delivery_Aggregate_Bool_Exp_Max = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Min = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Sum = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Delivery_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Delivery_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "delivery" */
export type Delivery_Aggregate_Fields = {
  __typename?: 'delivery_aggregate_fields';
  avg: Maybe<Delivery_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Delivery_Max_Fields>;
  min: Maybe<Delivery_Min_Fields>;
  stddev: Maybe<Delivery_Stddev_Fields>;
  stddev_pop: Maybe<Delivery_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Delivery_Stddev_Samp_Fields>;
  sum: Maybe<Delivery_Sum_Fields>;
  var_pop: Maybe<Delivery_Var_Pop_Fields>;
  var_samp: Maybe<Delivery_Var_Samp_Fields>;
  variance: Maybe<Delivery_Variance_Fields>;
};


/** aggregate fields of "delivery" */
export type Delivery_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Delivery_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "delivery" */
export type Delivery_Aggregate_Order_By = {
  avg?: InputMaybe<Delivery_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Delivery_Max_Order_By>;
  min?: InputMaybe<Delivery_Min_Order_By>;
  stddev?: InputMaybe<Delivery_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Delivery_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Delivery_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Delivery_Sum_Order_By>;
  var_pop?: InputMaybe<Delivery_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Delivery_Var_Samp_Order_By>;
  variance?: InputMaybe<Delivery_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "delivery" */
export type Delivery_Arr_Rel_Insert_Input = {
  data: Array<Delivery_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Delivery_On_Conflict>;
};

/** aggregate avg on columns */
export type Delivery_Avg_Fields = {
  __typename?: 'delivery_avg_fields';
  recognized_first_ipz: Maybe<Scalars['Float']['output']>;
  recognized_first_weight: Maybe<Scalars['Float']['output']>;
  recognized_gross_weight: Maybe<Scalars['Float']['output']>;
  recognized_net_weight: Maybe<Scalars['Float']['output']>;
  recognized_second_ipz: Maybe<Scalars['Float']['output']>;
  recognized_second_weight: Maybe<Scalars['Float']['output']>;
  recognized_third_ipz: Maybe<Scalars['Float']['output']>;
  recognized_third_weight: Maybe<Scalars['Float']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "delivery" */
export type Delivery_Avg_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "delivery". All fields are combined with a logical 'AND'. */
export type Delivery_Bool_Exp = {
  _and?: InputMaybe<Array<Delivery_Bool_Exp>>;
  _not?: InputMaybe<Delivery_Bool_Exp>;
  _or?: InputMaybe<Array<Delivery_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  approved_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  approved_by_admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  batch_invoice_id?: InputMaybe<String_Comparison_Exp>;
  codmoto?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer_name?: InputMaybe<String_Comparison_Exp>;
  delivered_at?: InputMaybe<String_Comparison_Exp>;
  denied_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  document_number?: InputMaybe<String_Comparison_Exp>;
  invoice_issued_at?: InputMaybe<Date_Comparison_Exp>;
  invoice_number?: InputMaybe<String_Comparison_Exp>;
  is_weight_receipt?: InputMaybe<Boolean_Comparison_Exp>;
  license_plate?: InputMaybe<String_Comparison_Exp>;
  license_plate2?: InputMaybe<String_Comparison_Exp>;
  license_plate3?: InputMaybe<String_Comparison_Exp>;
  marked_as_delivered_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  receipt_image_url?: InputMaybe<String_Comparison_Exp>;
  receipt_invoice_image_url?: InputMaybe<String_Comparison_Exp>;
  receipt_recognized_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  receipt_recognized_invoice_number?: InputMaybe<String_Comparison_Exp>;
  receipt_uploaded_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  recognized_brm?: InputMaybe<String_Comparison_Exp>;
  recognized_by_admin?: InputMaybe<Admin_Bool_Exp>;
  recognized_by_admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  recognized_first_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  recognized_first_ipz?: InputMaybe<Int_Comparison_Exp>;
  recognized_first_mp?: InputMaybe<String_Comparison_Exp>;
  recognized_first_weight?: InputMaybe<Int_Comparison_Exp>;
  recognized_gross_weight?: InputMaybe<Int_Comparison_Exp>;
  recognized_is_metalic?: InputMaybe<Boolean_Comparison_Exp>;
  recognized_license_plate?: InputMaybe<String_Comparison_Exp>;
  recognized_net_weight?: InputMaybe<Int_Comparison_Exp>;
  recognized_second_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  recognized_second_ipz?: InputMaybe<Int_Comparison_Exp>;
  recognized_second_mp?: InputMaybe<String_Comparison_Exp>;
  recognized_second_weight?: InputMaybe<Int_Comparison_Exp>;
  recognized_third_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  recognized_third_ipz?: InputMaybe<Int_Comparison_Exp>;
  recognized_third_mp?: InputMaybe<String_Comparison_Exp>;
  recognized_third_weight?: InputMaybe<Int_Comparison_Exp>;
  recognized_weighing_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  trip_id?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  weight?: InputMaybe<Float8_Comparison_Exp>;
  weight_receipt_was_edited?: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "delivery" */
export enum Delivery_Constraint {
  /** unique or primary key constraint on columns "invoice_number", "document_number" */
  DeliveryInvoiceNumberDocumentNumberKey = 'delivery_invoice_number_document_number_key',
  /** unique or primary key constraint on columns "invoice_number", "document_number", "trip_id" */
  DeliveryPkey = 'delivery_pkey'
}

/** input type for incrementing numeric columns in table "delivery" */
export type Delivery_Inc_Input = {
  recognized_first_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_first_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_gross_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_net_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_weight?: InputMaybe<Scalars['Int']['input']>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "delivery" */
export type Delivery_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  approved_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id?: InputMaybe<Scalars['String']['input']>;
  codmoto?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao A1_NOME no Protheus */
  customer_name?: InputMaybe<Scalars['String']['input']>;
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at?: InputMaybe<Scalars['String']['input']>;
  denied_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao DT6_DOC no Protheus */
  document_number?: InputMaybe<Scalars['String']['input']>;
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at?: InputMaybe<Scalars['date']['input']>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number?: InputMaybe<Scalars['String']['input']>;
  /** If the delivery needs to check the extra weight receipt from ArcelorMittal. This is based on DT6_SERVIC being "SNA" (waste) or "SNR" (ore) and the A1_NOME being like ARCELORMITTAL */
  is_weight_receipt?: InputMaybe<Scalars['Boolean']['input']>;
  license_plate?: InputMaybe<Scalars['String']['input']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2?: InputMaybe<Scalars['String']['input']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3?: InputMaybe<Scalars['String']['input']>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The full receipt image */
  receipt_image_url?: InputMaybe<Scalars['String']['input']>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url?: InputMaybe<Scalars['String']['input']>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number?: InputMaybe<Scalars['String']['input']>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_brm?: InputMaybe<Scalars['String']['input']>;
  recognized_by_admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  recognized_first_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_first_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_first_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_first_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_gross_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_is_metalic?: InputMaybe<Scalars['Boolean']['input']>;
  recognized_license_plate?: InputMaybe<Scalars['String']['input']>;
  recognized_net_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_second_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_second_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_third_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_third_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_weighing_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Scalars['float8']['input']>;
  /** Se o usurio editou o canhoto de peso aps o reconhecimento automtico. Isso  usado pela API para no aprovar automaticamente os que foram editados */
  weight_receipt_was_edited?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type Delivery_Max_Fields = {
  __typename?: 'delivery_max_fields';
  approved_at: Maybe<Scalars['timestamptz']['output']>;
  approved_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id: Maybe<Scalars['String']['output']>;
  codmoto: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Referente ao A1_NOME no Protheus */
  customer_name: Maybe<Scalars['String']['output']>;
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at: Maybe<Scalars['String']['output']>;
  denied_at: Maybe<Scalars['timestamptz']['output']>;
  /** Referente ao DT6_DOC no Protheus */
  document_number: Maybe<Scalars['String']['output']>;
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at: Maybe<Scalars['date']['output']>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number: Maybe<Scalars['String']['output']>;
  license_plate: Maybe<Scalars['String']['output']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2: Maybe<Scalars['String']['output']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3: Maybe<Scalars['String']['output']>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at: Maybe<Scalars['timestamptz']['output']>;
  /** The full receipt image */
  receipt_image_url: Maybe<Scalars['String']['output']>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url: Maybe<Scalars['String']['output']>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at: Maybe<Scalars['timestamptz']['output']>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number: Maybe<Scalars['String']['output']>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at: Maybe<Scalars['timestamptz']['output']>;
  recognized_brm: Maybe<Scalars['String']['output']>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  recognized_first_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_first_ipz: Maybe<Scalars['Int']['output']>;
  recognized_first_mp: Maybe<Scalars['String']['output']>;
  recognized_first_weight: Maybe<Scalars['Int']['output']>;
  recognized_gross_weight: Maybe<Scalars['Int']['output']>;
  recognized_license_plate: Maybe<Scalars['String']['output']>;
  recognized_net_weight: Maybe<Scalars['Int']['output']>;
  recognized_second_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_second_ipz: Maybe<Scalars['Int']['output']>;
  recognized_second_mp: Maybe<Scalars['String']['output']>;
  recognized_second_weight: Maybe<Scalars['Int']['output']>;
  recognized_third_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_third_ipz: Maybe<Scalars['Int']['output']>;
  recognized_third_mp: Maybe<Scalars['String']['output']>;
  recognized_third_weight: Maybe<Scalars['Int']['output']>;
  recognized_weighing_at: Maybe<Scalars['timestamptz']['output']>;
  status: Maybe<Scalars['String']['output']>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid: Maybe<Scalars['uuid']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['float8']['output']>;
};

/** order by max() on columns of table "delivery" */
export type Delivery_Max_Order_By = {
  approved_at?: InputMaybe<Order_By>;
  approved_by_admin_uuid?: InputMaybe<Order_By>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id?: InputMaybe<Order_By>;
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** Referente ao A1_NOME no Protheus */
  customer_name?: InputMaybe<Order_By>;
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at?: InputMaybe<Order_By>;
  denied_at?: InputMaybe<Order_By>;
  /** Referente ao DT6_DOC no Protheus */
  document_number?: InputMaybe<Order_By>;
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at?: InputMaybe<Order_By>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number?: InputMaybe<Order_By>;
  license_plate?: InputMaybe<Order_By>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2?: InputMaybe<Order_By>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3?: InputMaybe<Order_By>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at?: InputMaybe<Order_By>;
  /** The full receipt image */
  receipt_image_url?: InputMaybe<Order_By>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url?: InputMaybe<Order_By>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at?: InputMaybe<Order_By>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number?: InputMaybe<Order_By>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at?: InputMaybe<Order_By>;
  recognized_brm?: InputMaybe<Order_By>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid?: InputMaybe<Order_By>;
  recognized_first_datetime?: InputMaybe<Order_By>;
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_mp?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_license_plate?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_datetime?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_mp?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_datetime?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_mp?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  recognized_weighing_at?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Delivery_Min_Fields = {
  __typename?: 'delivery_min_fields';
  approved_at: Maybe<Scalars['timestamptz']['output']>;
  approved_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id: Maybe<Scalars['String']['output']>;
  codmoto: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Referente ao A1_NOME no Protheus */
  customer_name: Maybe<Scalars['String']['output']>;
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at: Maybe<Scalars['String']['output']>;
  denied_at: Maybe<Scalars['timestamptz']['output']>;
  /** Referente ao DT6_DOC no Protheus */
  document_number: Maybe<Scalars['String']['output']>;
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at: Maybe<Scalars['date']['output']>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number: Maybe<Scalars['String']['output']>;
  license_plate: Maybe<Scalars['String']['output']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2: Maybe<Scalars['String']['output']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3: Maybe<Scalars['String']['output']>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at: Maybe<Scalars['timestamptz']['output']>;
  /** The full receipt image */
  receipt_image_url: Maybe<Scalars['String']['output']>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url: Maybe<Scalars['String']['output']>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at: Maybe<Scalars['timestamptz']['output']>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number: Maybe<Scalars['String']['output']>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at: Maybe<Scalars['timestamptz']['output']>;
  recognized_brm: Maybe<Scalars['String']['output']>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  recognized_first_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_first_ipz: Maybe<Scalars['Int']['output']>;
  recognized_first_mp: Maybe<Scalars['String']['output']>;
  recognized_first_weight: Maybe<Scalars['Int']['output']>;
  recognized_gross_weight: Maybe<Scalars['Int']['output']>;
  recognized_license_plate: Maybe<Scalars['String']['output']>;
  recognized_net_weight: Maybe<Scalars['Int']['output']>;
  recognized_second_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_second_ipz: Maybe<Scalars['Int']['output']>;
  recognized_second_mp: Maybe<Scalars['String']['output']>;
  recognized_second_weight: Maybe<Scalars['Int']['output']>;
  recognized_third_datetime: Maybe<Scalars['timestamptz']['output']>;
  recognized_third_ipz: Maybe<Scalars['Int']['output']>;
  recognized_third_mp: Maybe<Scalars['String']['output']>;
  recognized_third_weight: Maybe<Scalars['Int']['output']>;
  recognized_weighing_at: Maybe<Scalars['timestamptz']['output']>;
  status: Maybe<Scalars['String']['output']>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid: Maybe<Scalars['uuid']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['float8']['output']>;
};

/** order by min() on columns of table "delivery" */
export type Delivery_Min_Order_By = {
  approved_at?: InputMaybe<Order_By>;
  approved_by_admin_uuid?: InputMaybe<Order_By>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id?: InputMaybe<Order_By>;
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** Referente ao A1_NOME no Protheus */
  customer_name?: InputMaybe<Order_By>;
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at?: InputMaybe<Order_By>;
  denied_at?: InputMaybe<Order_By>;
  /** Referente ao DT6_DOC no Protheus */
  document_number?: InputMaybe<Order_By>;
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at?: InputMaybe<Order_By>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number?: InputMaybe<Order_By>;
  license_plate?: InputMaybe<Order_By>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2?: InputMaybe<Order_By>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3?: InputMaybe<Order_By>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at?: InputMaybe<Order_By>;
  /** The full receipt image */
  receipt_image_url?: InputMaybe<Order_By>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url?: InputMaybe<Order_By>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at?: InputMaybe<Order_By>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number?: InputMaybe<Order_By>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at?: InputMaybe<Order_By>;
  recognized_brm?: InputMaybe<Order_By>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid?: InputMaybe<Order_By>;
  recognized_first_datetime?: InputMaybe<Order_By>;
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_mp?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_license_plate?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_datetime?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_mp?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_datetime?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_mp?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  recognized_weighing_at?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "delivery" */
export type Delivery_Mutation_Response = {
  __typename?: 'delivery_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Delivery>;
};

/** on_conflict condition type for table "delivery" */
export type Delivery_On_Conflict = {
  constraint: Delivery_Constraint;
  update_columns?: Array<Delivery_Update_Column>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};

/** Ordering options when selecting data from "delivery". */
export type Delivery_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  approved_at?: InputMaybe<Order_By>;
  approved_by_admin_uuid?: InputMaybe<Order_By>;
  batch_invoice_id?: InputMaybe<Order_By>;
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  customer_name?: InputMaybe<Order_By>;
  delivered_at?: InputMaybe<Order_By>;
  denied_at?: InputMaybe<Order_By>;
  document_number?: InputMaybe<Order_By>;
  invoice_issued_at?: InputMaybe<Order_By>;
  invoice_number?: InputMaybe<Order_By>;
  is_weight_receipt?: InputMaybe<Order_By>;
  license_plate?: InputMaybe<Order_By>;
  license_plate2?: InputMaybe<Order_By>;
  license_plate3?: InputMaybe<Order_By>;
  marked_as_delivered_at?: InputMaybe<Order_By>;
  receipt_image_url?: InputMaybe<Order_By>;
  receipt_invoice_image_url?: InputMaybe<Order_By>;
  receipt_recognized_at?: InputMaybe<Order_By>;
  receipt_recognized_invoice_number?: InputMaybe<Order_By>;
  receipt_uploaded_at?: InputMaybe<Order_By>;
  recognized_brm?: InputMaybe<Order_By>;
  recognized_by_admin?: InputMaybe<Admin_Order_By>;
  recognized_by_admin_uuid?: InputMaybe<Order_By>;
  recognized_first_datetime?: InputMaybe<Order_By>;
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_mp?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_is_metalic?: InputMaybe<Order_By>;
  recognized_license_plate?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_datetime?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_mp?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_datetime?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_mp?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  recognized_weighing_at?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  uuid?: InputMaybe<Order_By>;
  weight?: InputMaybe<Order_By>;
  weight_receipt_was_edited?: InputMaybe<Order_By>;
};

/** primary key columns input for table: delivery */
export type Delivery_Pk_Columns_Input = {
  /** Referente ao DT6_DOC no Protheus */
  document_number: Scalars['String']['input'];
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number: Scalars['String']['input'];
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id: Scalars['String']['input'];
};

/** select columns of table "delivery" */
export enum Delivery_Select_Column {
  /** column name */
  ApprovedAt = 'approved_at',
  /** column name */
  ApprovedByAdminUuid = 'approved_by_admin_uuid',
  /** column name */
  BatchInvoiceId = 'batch_invoice_id',
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerName = 'customer_name',
  /** column name */
  DeliveredAt = 'delivered_at',
  /** column name */
  DeniedAt = 'denied_at',
  /** column name */
  DocumentNumber = 'document_number',
  /** column name */
  InvoiceIssuedAt = 'invoice_issued_at',
  /** column name */
  InvoiceNumber = 'invoice_number',
  /** column name */
  IsWeightReceipt = 'is_weight_receipt',
  /** column name */
  LicensePlate = 'license_plate',
  /** column name */
  LicensePlate2 = 'license_plate2',
  /** column name */
  LicensePlate3 = 'license_plate3',
  /** column name */
  MarkedAsDeliveredAt = 'marked_as_delivered_at',
  /** column name */
  ReceiptImageUrl = 'receipt_image_url',
  /** column name */
  ReceiptInvoiceImageUrl = 'receipt_invoice_image_url',
  /** column name */
  ReceiptRecognizedAt = 'receipt_recognized_at',
  /** column name */
  ReceiptRecognizedInvoiceNumber = 'receipt_recognized_invoice_number',
  /** column name */
  ReceiptUploadedAt = 'receipt_uploaded_at',
  /** column name */
  RecognizedBrm = 'recognized_brm',
  /** column name */
  RecognizedByAdminUuid = 'recognized_by_admin_uuid',
  /** column name */
  RecognizedFirstDatetime = 'recognized_first_datetime',
  /** column name */
  RecognizedFirstIpz = 'recognized_first_ipz',
  /** column name */
  RecognizedFirstMp = 'recognized_first_mp',
  /** column name */
  RecognizedFirstWeight = 'recognized_first_weight',
  /** column name */
  RecognizedGrossWeight = 'recognized_gross_weight',
  /** column name */
  RecognizedIsMetalic = 'recognized_is_metalic',
  /** column name */
  RecognizedLicensePlate = 'recognized_license_plate',
  /** column name */
  RecognizedNetWeight = 'recognized_net_weight',
  /** column name */
  RecognizedSecondDatetime = 'recognized_second_datetime',
  /** column name */
  RecognizedSecondIpz = 'recognized_second_ipz',
  /** column name */
  RecognizedSecondMp = 'recognized_second_mp',
  /** column name */
  RecognizedSecondWeight = 'recognized_second_weight',
  /** column name */
  RecognizedThirdDatetime = 'recognized_third_datetime',
  /** column name */
  RecognizedThirdIpz = 'recognized_third_ipz',
  /** column name */
  RecognizedThirdMp = 'recognized_third_mp',
  /** column name */
  RecognizedThirdWeight = 'recognized_third_weight',
  /** column name */
  RecognizedWeighingAt = 'recognized_weighing_at',
  /** column name */
  Status = 'status',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  Weight = 'weight',
  /** column name */
  WeightReceiptWasEdited = 'weight_receipt_was_edited'
}

/** select "delivery_aggregate_bool_exp_avg_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** select "delivery_aggregate_bool_exp_bool_and_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsWeightReceipt = 'is_weight_receipt',
  /** column name */
  RecognizedIsMetalic = 'recognized_is_metalic',
  /** column name */
  WeightReceiptWasEdited = 'weight_receipt_was_edited'
}

/** select "delivery_aggregate_bool_exp_bool_or_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsWeightReceipt = 'is_weight_receipt',
  /** column name */
  RecognizedIsMetalic = 'recognized_is_metalic',
  /** column name */
  WeightReceiptWasEdited = 'weight_receipt_was_edited'
}

/** select "delivery_aggregate_bool_exp_corr_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** select "delivery_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** select "delivery_aggregate_bool_exp_max_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** select "delivery_aggregate_bool_exp_min_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** select "delivery_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** select "delivery_aggregate_bool_exp_sum_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** select "delivery_aggregate_bool_exp_var_samp_arguments_columns" columns of table "delivery" */
export enum Delivery_Select_Column_Delivery_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  Weight = 'weight'
}

/** input type for updating data in table "delivery" */
export type Delivery_Set_Input = {
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  approved_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id?: InputMaybe<Scalars['String']['input']>;
  codmoto?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao A1_NOME no Protheus */
  customer_name?: InputMaybe<Scalars['String']['input']>;
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at?: InputMaybe<Scalars['String']['input']>;
  denied_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao DT6_DOC no Protheus */
  document_number?: InputMaybe<Scalars['String']['input']>;
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at?: InputMaybe<Scalars['date']['input']>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number?: InputMaybe<Scalars['String']['input']>;
  /** If the delivery needs to check the extra weight receipt from ArcelorMittal. This is based on DT6_SERVIC being "SNA" (waste) or "SNR" (ore) and the A1_NOME being like ARCELORMITTAL */
  is_weight_receipt?: InputMaybe<Scalars['Boolean']['input']>;
  license_plate?: InputMaybe<Scalars['String']['input']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2?: InputMaybe<Scalars['String']['input']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3?: InputMaybe<Scalars['String']['input']>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The full receipt image */
  receipt_image_url?: InputMaybe<Scalars['String']['input']>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url?: InputMaybe<Scalars['String']['input']>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number?: InputMaybe<Scalars['String']['input']>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_brm?: InputMaybe<Scalars['String']['input']>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  recognized_first_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_first_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_first_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_first_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_gross_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_is_metalic?: InputMaybe<Scalars['Boolean']['input']>;
  recognized_license_plate?: InputMaybe<Scalars['String']['input']>;
  recognized_net_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_second_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_second_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_third_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_third_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_weighing_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Scalars['float8']['input']>;
  /** Se o usurio editou o canhoto de peso aps o reconhecimento automtico. Isso  usado pela API para no aprovar automaticamente os que foram editados */
  weight_receipt_was_edited?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate stddev on columns */
export type Delivery_Stddev_Fields = {
  __typename?: 'delivery_stddev_fields';
  recognized_first_ipz: Maybe<Scalars['Float']['output']>;
  recognized_first_weight: Maybe<Scalars['Float']['output']>;
  recognized_gross_weight: Maybe<Scalars['Float']['output']>;
  recognized_net_weight: Maybe<Scalars['Float']['output']>;
  recognized_second_ipz: Maybe<Scalars['Float']['output']>;
  recognized_second_weight: Maybe<Scalars['Float']['output']>;
  recognized_third_ipz: Maybe<Scalars['Float']['output']>;
  recognized_third_weight: Maybe<Scalars['Float']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "delivery" */
export type Delivery_Stddev_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Delivery_Stddev_Pop_Fields = {
  __typename?: 'delivery_stddev_pop_fields';
  recognized_first_ipz: Maybe<Scalars['Float']['output']>;
  recognized_first_weight: Maybe<Scalars['Float']['output']>;
  recognized_gross_weight: Maybe<Scalars['Float']['output']>;
  recognized_net_weight: Maybe<Scalars['Float']['output']>;
  recognized_second_ipz: Maybe<Scalars['Float']['output']>;
  recognized_second_weight: Maybe<Scalars['Float']['output']>;
  recognized_third_ipz: Maybe<Scalars['Float']['output']>;
  recognized_third_weight: Maybe<Scalars['Float']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "delivery" */
export type Delivery_Stddev_Pop_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Delivery_Stddev_Samp_Fields = {
  __typename?: 'delivery_stddev_samp_fields';
  recognized_first_ipz: Maybe<Scalars['Float']['output']>;
  recognized_first_weight: Maybe<Scalars['Float']['output']>;
  recognized_gross_weight: Maybe<Scalars['Float']['output']>;
  recognized_net_weight: Maybe<Scalars['Float']['output']>;
  recognized_second_ipz: Maybe<Scalars['Float']['output']>;
  recognized_second_weight: Maybe<Scalars['Float']['output']>;
  recognized_third_ipz: Maybe<Scalars['Float']['output']>;
  recognized_third_weight: Maybe<Scalars['Float']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "delivery" */
export type Delivery_Stddev_Samp_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "delivery" */
export type Delivery_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Delivery_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Delivery_Stream_Cursor_Value_Input = {
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  approved_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** Referente ao campo DT6_LOTNFC no Protheus */
  batch_invoice_id?: InputMaybe<Scalars['String']['input']>;
  codmoto?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao A1_NOME no Protheus */
  customer_name?: InputMaybe<Scalars['String']['input']>;
  /** Referente aos campos DUA_DATOCO e DUA_HOROCO no Protheus */
  delivered_at?: InputMaybe<Scalars['String']['input']>;
  denied_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referente ao DT6_DOC no Protheus */
  document_number?: InputMaybe<Scalars['String']['input']>;
  /** Data em que a nota fiscal foi emitida, referente ao campo DTC_EMINFC no Protheus */
  invoice_issued_at?: InputMaybe<Scalars['date']['input']>;
  /** Referente ao DTC_NUMNFC no Protheus */
  invoice_number?: InputMaybe<Scalars['String']['input']>;
  /** If the delivery needs to check the extra weight receipt from ArcelorMittal. This is based on DT6_SERVIC being "SNA" (waste) or "SNR" (ore) and the A1_NOME being like ARCELORMITTAL */
  is_weight_receipt?: InputMaybe<Scalars['Boolean']['input']>;
  license_plate?: InputMaybe<Scalars['String']['input']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB1 Protheus field */
  license_plate2?: InputMaybe<Scalars['String']['input']>;
  /** This is an additional license plate of the vehicle, refers to the DTR_XPLRB2 Protheus field */
  license_plate3?: InputMaybe<Scalars['String']['input']>;
  /** Data em que foi marcado como entregue. Esse campo difere do delivered_at pois o delivered_at  pego das ocorrncias no Protheus. Esse campo marked_as_delivered_at pega a informao de FROTA..conhece, e  onde as entregas que devem ser mostradas no painel/app so filtradas */
  marked_as_delivered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The full receipt image */
  receipt_image_url?: InputMaybe<Scalars['String']['input']>;
  /** Cropped image of the receipt */
  receipt_invoice_image_url?: InputMaybe<Scalars['String']['input']>;
  /** When the user made the picture of the receipt */
  receipt_recognized_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The receipt recognized invoice number by the scanner, not always equal to the exact invoice number */
  receipt_recognized_invoice_number?: InputMaybe<Scalars['String']['input']>;
  /** When the receipt was uploaded by the app */
  receipt_uploaded_at?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_brm?: InputMaybe<Scalars['String']['input']>;
  /** The admin that have recognized this receipt. The admin made the photos and send it. When the admin recognizes it the user does not get points */
  recognized_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  recognized_first_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_first_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_first_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_first_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_gross_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_is_metalic?: InputMaybe<Scalars['Boolean']['input']>;
  recognized_license_plate?: InputMaybe<Scalars['String']['input']>;
  recognized_net_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_second_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_second_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_second_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  recognized_third_ipz?: InputMaybe<Scalars['Int']['input']>;
  recognized_third_mp?: InputMaybe<Scalars['String']['input']>;
  recognized_third_weight?: InputMaybe<Scalars['Int']['input']>;
  recognized_weighing_at?: InputMaybe<Scalars['timestamptz']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  /** Referente ao DUP_VIAGEM no Protheus */
  trip_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** This is only used for inner relationships. Specifically for user_kmps. Also used for deleted_row trigger on delete */
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Scalars['float8']['input']>;
  /** Se o usurio editou o canhoto de peso aps o reconhecimento automtico. Isso  usado pela API para no aprovar automaticamente os que foram editados */
  weight_receipt_was_edited?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate sum on columns */
export type Delivery_Sum_Fields = {
  __typename?: 'delivery_sum_fields';
  recognized_first_ipz: Maybe<Scalars['Int']['output']>;
  recognized_first_weight: Maybe<Scalars['Int']['output']>;
  recognized_gross_weight: Maybe<Scalars['Int']['output']>;
  recognized_net_weight: Maybe<Scalars['Int']['output']>;
  recognized_second_ipz: Maybe<Scalars['Int']['output']>;
  recognized_second_weight: Maybe<Scalars['Int']['output']>;
  recognized_third_ipz: Maybe<Scalars['Int']['output']>;
  recognized_third_weight: Maybe<Scalars['Int']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "delivery" */
export type Delivery_Sum_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** update columns of table "delivery" */
export enum Delivery_Update_Column {
  /** column name */
  ApprovedAt = 'approved_at',
  /** column name */
  ApprovedByAdminUuid = 'approved_by_admin_uuid',
  /** column name */
  BatchInvoiceId = 'batch_invoice_id',
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerName = 'customer_name',
  /** column name */
  DeliveredAt = 'delivered_at',
  /** column name */
  DeniedAt = 'denied_at',
  /** column name */
  DocumentNumber = 'document_number',
  /** column name */
  InvoiceIssuedAt = 'invoice_issued_at',
  /** column name */
  InvoiceNumber = 'invoice_number',
  /** column name */
  IsWeightReceipt = 'is_weight_receipt',
  /** column name */
  LicensePlate = 'license_plate',
  /** column name */
  LicensePlate2 = 'license_plate2',
  /** column name */
  LicensePlate3 = 'license_plate3',
  /** column name */
  MarkedAsDeliveredAt = 'marked_as_delivered_at',
  /** column name */
  ReceiptImageUrl = 'receipt_image_url',
  /** column name */
  ReceiptInvoiceImageUrl = 'receipt_invoice_image_url',
  /** column name */
  ReceiptRecognizedAt = 'receipt_recognized_at',
  /** column name */
  ReceiptRecognizedInvoiceNumber = 'receipt_recognized_invoice_number',
  /** column name */
  ReceiptUploadedAt = 'receipt_uploaded_at',
  /** column name */
  RecognizedBrm = 'recognized_brm',
  /** column name */
  RecognizedByAdminUuid = 'recognized_by_admin_uuid',
  /** column name */
  RecognizedFirstDatetime = 'recognized_first_datetime',
  /** column name */
  RecognizedFirstIpz = 'recognized_first_ipz',
  /** column name */
  RecognizedFirstMp = 'recognized_first_mp',
  /** column name */
  RecognizedFirstWeight = 'recognized_first_weight',
  /** column name */
  RecognizedGrossWeight = 'recognized_gross_weight',
  /** column name */
  RecognizedIsMetalic = 'recognized_is_metalic',
  /** column name */
  RecognizedLicensePlate = 'recognized_license_plate',
  /** column name */
  RecognizedNetWeight = 'recognized_net_weight',
  /** column name */
  RecognizedSecondDatetime = 'recognized_second_datetime',
  /** column name */
  RecognizedSecondIpz = 'recognized_second_ipz',
  /** column name */
  RecognizedSecondMp = 'recognized_second_mp',
  /** column name */
  RecognizedSecondWeight = 'recognized_second_weight',
  /** column name */
  RecognizedThirdDatetime = 'recognized_third_datetime',
  /** column name */
  RecognizedThirdIpz = 'recognized_third_ipz',
  /** column name */
  RecognizedThirdMp = 'recognized_third_mp',
  /** column name */
  RecognizedThirdWeight = 'recognized_third_weight',
  /** column name */
  RecognizedWeighingAt = 'recognized_weighing_at',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  Weight = 'weight',
  /** column name */
  WeightReceiptWasEdited = 'weight_receipt_was_edited'
}

export type Delivery_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Delivery_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Delivery_Set_Input>;
  /** filter the rows which have to be updated */
  where: Delivery_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Delivery_Var_Pop_Fields = {
  __typename?: 'delivery_var_pop_fields';
  recognized_first_ipz: Maybe<Scalars['Float']['output']>;
  recognized_first_weight: Maybe<Scalars['Float']['output']>;
  recognized_gross_weight: Maybe<Scalars['Float']['output']>;
  recognized_net_weight: Maybe<Scalars['Float']['output']>;
  recognized_second_ipz: Maybe<Scalars['Float']['output']>;
  recognized_second_weight: Maybe<Scalars['Float']['output']>;
  recognized_third_ipz: Maybe<Scalars['Float']['output']>;
  recognized_third_weight: Maybe<Scalars['Float']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "delivery" */
export type Delivery_Var_Pop_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Delivery_Var_Samp_Fields = {
  __typename?: 'delivery_var_samp_fields';
  recognized_first_ipz: Maybe<Scalars['Float']['output']>;
  recognized_first_weight: Maybe<Scalars['Float']['output']>;
  recognized_gross_weight: Maybe<Scalars['Float']['output']>;
  recognized_net_weight: Maybe<Scalars['Float']['output']>;
  recognized_second_ipz: Maybe<Scalars['Float']['output']>;
  recognized_second_weight: Maybe<Scalars['Float']['output']>;
  recognized_third_ipz: Maybe<Scalars['Float']['output']>;
  recognized_third_weight: Maybe<Scalars['Float']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "delivery" */
export type Delivery_Var_Samp_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Delivery_Variance_Fields = {
  __typename?: 'delivery_variance_fields';
  recognized_first_ipz: Maybe<Scalars['Float']['output']>;
  recognized_first_weight: Maybe<Scalars['Float']['output']>;
  recognized_gross_weight: Maybe<Scalars['Float']['output']>;
  recognized_net_weight: Maybe<Scalars['Float']['output']>;
  recognized_second_ipz: Maybe<Scalars['Float']['output']>;
  recognized_second_weight: Maybe<Scalars['Float']['output']>;
  recognized_third_ipz: Maybe<Scalars['Float']['output']>;
  recognized_third_weight: Maybe<Scalars['Float']['output']>;
  /** Referente ao DTC_PESO no Protheus */
  weight: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "delivery" */
export type Delivery_Variance_Order_By = {
  recognized_first_ipz?: InputMaybe<Order_By>;
  recognized_first_weight?: InputMaybe<Order_By>;
  recognized_gross_weight?: InputMaybe<Order_By>;
  recognized_net_weight?: InputMaybe<Order_By>;
  recognized_second_ipz?: InputMaybe<Order_By>;
  recognized_second_weight?: InputMaybe<Order_By>;
  recognized_third_ipz?: InputMaybe<Order_By>;
  recognized_third_weight?: InputMaybe<Order_By>;
  /** Referente ao DTC_PESO no Protheus */
  weight?: InputMaybe<Order_By>;
};

export type Driver_Performance_Data_Args = {
  exclusive_end_date?: InputMaybe<Scalars['date']['input']>;
  inclusive_start_date?: InputMaybe<Scalars['date']['input']>;
  score_type?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "driver_warning" */
export type Driver_Warning = {
  __typename?: 'driver_warning';
  codmoto: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  driver_warning_comments: Array<Driver_Warning_Comment>;
  /** An aggregate relationship */
  driver_warning_comments_aggregate: Driver_Warning_Comment_Aggregate;
  /** An array relationship */
  driver_warning_trips: Array<Driver_Warning_Trip>;
  /** An aggregate relationship */
  driver_warning_trips_aggregate: Driver_Warning_Trip_Aggregate;
  processed_at: Scalars['timestamptz']['output'];
  reference_date: Scalars['date']['output'];
  risk_intensity: Scalars['Int']['output'];
  risk_intesity: Scalars['Int']['output'];
  /** An object relationship */
  risk_level: Maybe<Driver_Warning_Risk_Level_View>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: User;
  uuid: Scalars['uuid']['output'];
  warning_message: Scalars['String']['output'];
};


/** columns and relationships of "driver_warning" */
export type Driver_WarningDriver_Warning_CommentsArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


/** columns and relationships of "driver_warning" */
export type Driver_WarningDriver_Warning_Comments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


/** columns and relationships of "driver_warning" */
export type Driver_WarningDriver_Warning_TripsArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};


/** columns and relationships of "driver_warning" */
export type Driver_WarningDriver_Warning_Trips_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};

/** aggregated selection of "driver_warning" */
export type Driver_Warning_Aggregate = {
  __typename?: 'driver_warning_aggregate';
  aggregate: Maybe<Driver_Warning_Aggregate_Fields>;
  nodes: Array<Driver_Warning>;
};

export type Driver_Warning_Aggregate_Bool_Exp = {
  count?: InputMaybe<Driver_Warning_Aggregate_Bool_Exp_Count>;
};

export type Driver_Warning_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driver_warning" */
export type Driver_Warning_Aggregate_Fields = {
  __typename?: 'driver_warning_aggregate_fields';
  avg: Maybe<Driver_Warning_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Max_Fields>;
  min: Maybe<Driver_Warning_Min_Fields>;
  stddev: Maybe<Driver_Warning_Stddev_Fields>;
  stddev_pop: Maybe<Driver_Warning_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Driver_Warning_Stddev_Samp_Fields>;
  sum: Maybe<Driver_Warning_Sum_Fields>;
  var_pop: Maybe<Driver_Warning_Var_Pop_Fields>;
  var_samp: Maybe<Driver_Warning_Var_Samp_Fields>;
  variance: Maybe<Driver_Warning_Variance_Fields>;
};


/** aggregate fields of "driver_warning" */
export type Driver_Warning_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driver_warning" */
export type Driver_Warning_Aggregate_Order_By = {
  avg?: InputMaybe<Driver_Warning_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driver_Warning_Max_Order_By>;
  min?: InputMaybe<Driver_Warning_Min_Order_By>;
  stddev?: InputMaybe<Driver_Warning_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driver_Warning_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driver_Warning_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driver_Warning_Sum_Order_By>;
  var_pop?: InputMaybe<Driver_Warning_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driver_Warning_Var_Samp_Order_By>;
  variance?: InputMaybe<Driver_Warning_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "driver_warning" */
export type Driver_Warning_Arr_Rel_Insert_Input = {
  data: Array<Driver_Warning_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driver_Warning_On_Conflict>;
};

/** aggregate avg on columns */
export type Driver_Warning_Avg_Fields = {
  __typename?: 'driver_warning_avg_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
  risk_intesity: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driver_warning" */
export type Driver_Warning_Avg_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driver_warning". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Bool_Exp>>;
  codmoto?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver_warning_comments?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
  driver_warning_comments_aggregate?: InputMaybe<Driver_Warning_Comment_Aggregate_Bool_Exp>;
  driver_warning_trips?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  driver_warning_trips_aggregate?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp>;
  processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  reference_date?: InputMaybe<Date_Comparison_Exp>;
  risk_intensity?: InputMaybe<Int_Comparison_Exp>;
  risk_intesity?: InputMaybe<Int_Comparison_Exp>;
  risk_level?: InputMaybe<Driver_Warning_Risk_Level_View_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  warning_message?: InputMaybe<String_Comparison_Exp>;
};

/** columns and relationships of "driver_warning_comment" */
export type Driver_Warning_Comment = {
  __typename?: 'driver_warning_comment';
  /** An object relationship */
  admin: Admin;
  admin_uuid: Scalars['uuid']['output'];
  called_to_driver_phone: Scalars['Boolean']['output'];
  comment_text: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  driver_warning: Driver_Warning;
  driver_warning_uuid: Scalars['uuid']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "driver_warning_comment" */
export type Driver_Warning_Comment_Aggregate = {
  __typename?: 'driver_warning_comment_aggregate';
  aggregate: Maybe<Driver_Warning_Comment_Aggregate_Fields>;
  nodes: Array<Driver_Warning_Comment>;
};

export type Driver_Warning_Comment_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Driver_Warning_Comment_Aggregate_Bool_Exp_Count>;
};

export type Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_And = {
  arguments: Driver_Warning_Comment_Select_Column_Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Driver_Warning_Comment_Select_Column_Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Driver_Warning_Comment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driver_warning_comment" */
export type Driver_Warning_Comment_Aggregate_Fields = {
  __typename?: 'driver_warning_comment_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Comment_Max_Fields>;
  min: Maybe<Driver_Warning_Comment_Min_Fields>;
};


/** aggregate fields of "driver_warning_comment" */
export type Driver_Warning_Comment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driver_warning_comment" */
export type Driver_Warning_Comment_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driver_Warning_Comment_Max_Order_By>;
  min?: InputMaybe<Driver_Warning_Comment_Min_Order_By>;
};

/** input type for inserting array relation for remote table "driver_warning_comment" */
export type Driver_Warning_Comment_Arr_Rel_Insert_Input = {
  data: Array<Driver_Warning_Comment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driver_Warning_Comment_On_Conflict>;
};

/** Boolean expression to filter rows from the table "driver_warning_comment". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Comment_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Comment_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Comment_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  called_to_driver_phone?: InputMaybe<Boolean_Comparison_Exp>;
  comment_text?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver_warning?: InputMaybe<Driver_Warning_Bool_Exp>;
  driver_warning_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "driver_warning_comment" */
export enum Driver_Warning_Comment_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  DriverWarningCommentPkey = 'driver_warning_comment_pkey'
}

/** input type for inserting data into table "driver_warning_comment" */
export type Driver_Warning_Comment_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  called_to_driver_phone?: InputMaybe<Scalars['Boolean']['input']>;
  comment_text?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning?: InputMaybe<Driver_Warning_Obj_Rel_Insert_Input>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Comment_Max_Fields = {
  __typename?: 'driver_warning_comment_max_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  comment_text: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "driver_warning_comment" */
export type Driver_Warning_Comment_Max_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  comment_text?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driver_Warning_Comment_Min_Fields = {
  __typename?: 'driver_warning_comment_min_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  comment_text: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "driver_warning_comment" */
export type Driver_Warning_Comment_Min_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  comment_text?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driver_warning_comment" */
export type Driver_Warning_Comment_Mutation_Response = {
  __typename?: 'driver_warning_comment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driver_Warning_Comment>;
};

/** on_conflict condition type for table "driver_warning_comment" */
export type Driver_Warning_Comment_On_Conflict = {
  constraint: Driver_Warning_Comment_Constraint;
  update_columns?: Array<Driver_Warning_Comment_Update_Column>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};

/** Ordering options when selecting data from "driver_warning_comment". */
export type Driver_Warning_Comment_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  called_to_driver_phone?: InputMaybe<Order_By>;
  comment_text?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning?: InputMaybe<Driver_Warning_Order_By>;
  driver_warning_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driver_warning_comment */
export type Driver_Warning_Comment_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "driver_warning_comment" */
export enum Driver_Warning_Comment_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CalledToDriverPhone = 'called_to_driver_phone',
  /** column name */
  CommentText = 'comment_text',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverWarningUuid = 'driver_warning_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** select "driver_warning_comment_aggregate_bool_exp_bool_and_arguments_columns" columns of table "driver_warning_comment" */
export enum Driver_Warning_Comment_Select_Column_Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  CalledToDriverPhone = 'called_to_driver_phone'
}

/** select "driver_warning_comment_aggregate_bool_exp_bool_or_arguments_columns" columns of table "driver_warning_comment" */
export enum Driver_Warning_Comment_Select_Column_Driver_Warning_Comment_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  CalledToDriverPhone = 'called_to_driver_phone'
}

/** input type for updating data in table "driver_warning_comment" */
export type Driver_Warning_Comment_Set_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  called_to_driver_phone?: InputMaybe<Scalars['Boolean']['input']>;
  comment_text?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "driver_warning_comment" */
export type Driver_Warning_Comment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Comment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Comment_Stream_Cursor_Value_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  called_to_driver_phone?: InputMaybe<Scalars['Boolean']['input']>;
  comment_text?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "driver_warning_comment" */
export enum Driver_Warning_Comment_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CalledToDriverPhone = 'called_to_driver_phone',
  /** column name */
  CommentText = 'comment_text',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverWarningUuid = 'driver_warning_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Driver_Warning_Comment_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driver_Warning_Comment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driver_Warning_Comment_Bool_Exp;
};

/** unique or primary key constraints on table "driver_warning" */
export enum Driver_Warning_Constraint {
  /** unique or primary key constraint on columns "codmoto", "reference_date" */
  DriverWarningCodmotoReferenceDateKey = 'driver_warning_codmoto_reference_date_key',
  /** unique or primary key constraint on columns "uuid" */
  DriverWarningPkey = 'driver_warning_pkey'
}

/** columns and relationships of "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message = {
  __typename?: 'driver_warning_fk_whatsapp_message';
  created_at: Scalars['timestamptz']['output'];
  driver_warning_uuid: Scalars['uuid']['output'];
  risk_intensity: Scalars['Int']['output'];
  whatsapp_message_uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Aggregate = {
  __typename?: 'driver_warning_fk_whatsapp_message_aggregate';
  aggregate: Maybe<Driver_Warning_Fk_Whatsapp_Message_Aggregate_Fields>;
  nodes: Array<Driver_Warning_Fk_Whatsapp_Message>;
};

/** aggregate fields of "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Aggregate_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_aggregate_fields';
  avg: Maybe<Driver_Warning_Fk_Whatsapp_Message_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Fk_Whatsapp_Message_Max_Fields>;
  min: Maybe<Driver_Warning_Fk_Whatsapp_Message_Min_Fields>;
  stddev: Maybe<Driver_Warning_Fk_Whatsapp_Message_Stddev_Fields>;
  stddev_pop: Maybe<Driver_Warning_Fk_Whatsapp_Message_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Driver_Warning_Fk_Whatsapp_Message_Stddev_Samp_Fields>;
  sum: Maybe<Driver_Warning_Fk_Whatsapp_Message_Sum_Fields>;
  var_pop: Maybe<Driver_Warning_Fk_Whatsapp_Message_Var_Pop_Fields>;
  var_samp: Maybe<Driver_Warning_Fk_Whatsapp_Message_Var_Samp_Fields>;
  variance: Maybe<Driver_Warning_Fk_Whatsapp_Message_Variance_Fields>;
};


/** aggregate fields of "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Avg_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_avg_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driver_warning_fk_whatsapp_message". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Fk_Whatsapp_Message_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver_warning_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  risk_intensity?: InputMaybe<Int_Comparison_Exp>;
  whatsapp_message_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "driver_warning_fk_whatsapp_message" */
export enum Driver_Warning_Fk_Whatsapp_Message_Constraint {
  /** unique or primary key constraint on columns "driver_warning_uuid", "whatsapp_message_uuid" */
  DriverWarningFkWhatsappMessagePkey = 'driver_warning_fk_whatsapp_message_pkey'
}

/** input type for incrementing numeric columns in table "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Inc_Input = {
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
  whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Max_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  risk_intensity: Maybe<Scalars['Int']['output']>;
  whatsapp_message_uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Min_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  risk_intensity: Maybe<Scalars['Int']['output']>;
  whatsapp_message_uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Mutation_Response = {
  __typename?: 'driver_warning_fk_whatsapp_message_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driver_Warning_Fk_Whatsapp_Message>;
};

/** on_conflict condition type for table "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_On_Conflict = {
  constraint: Driver_Warning_Fk_Whatsapp_Message_Constraint;
  update_columns?: Array<Driver_Warning_Fk_Whatsapp_Message_Update_Column>;
  where?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>;
};

/** Ordering options when selecting data from "driver_warning_fk_whatsapp_message". */
export type Driver_Warning_Fk_Whatsapp_Message_Order_By = {
  created_at?: InputMaybe<Order_By>;
  driver_warning_uuid?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  whatsapp_message_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driver_warning_fk_whatsapp_message */
export type Driver_Warning_Fk_Whatsapp_Message_Pk_Columns_Input = {
  driver_warning_uuid: Scalars['uuid']['input'];
  whatsapp_message_uuid: Scalars['uuid']['input'];
};

/** select columns of table "driver_warning_fk_whatsapp_message" */
export enum Driver_Warning_Fk_Whatsapp_Message_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverWarningUuid = 'driver_warning_uuid',
  /** column name */
  RiskIntensity = 'risk_intensity',
  /** column name */
  WhatsappMessageUuid = 'whatsapp_message_uuid'
}

/** input type for updating data in table "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
  whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Stddev_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_stddev_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Stddev_Pop_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_stddev_pop_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Stddev_Samp_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_stddev_samp_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driver_warning_fk_whatsapp_message" */
export type Driver_Warning_Fk_Whatsapp_Message_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Fk_Whatsapp_Message_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Fk_Whatsapp_Message_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
  whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Sum_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_sum_fields';
  risk_intensity: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "driver_warning_fk_whatsapp_message" */
export enum Driver_Warning_Fk_Whatsapp_Message_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverWarningUuid = 'driver_warning_uuid',
  /** column name */
  RiskIntensity = 'risk_intensity',
  /** column name */
  WhatsappMessageUuid = 'whatsapp_message_uuid'
}

export type Driver_Warning_Fk_Whatsapp_Message_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driver_Warning_Fk_Whatsapp_Message_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Var_Pop_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_var_pop_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Var_Samp_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_var_samp_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driver_Warning_Fk_Whatsapp_Message_Variance_Fields = {
  __typename?: 'driver_warning_fk_whatsapp_message_variance_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
};

/** input type for incrementing numeric columns in table "driver_warning" */
export type Driver_Warning_Inc_Input = {
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
  risk_intesity?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "driver_warning" */
export type Driver_Warning_Insert_Input = {
  codmoto?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_comments?: InputMaybe<Driver_Warning_Comment_Arr_Rel_Insert_Input>;
  driver_warning_trips?: InputMaybe<Driver_Warning_Trip_Arr_Rel_Insert_Input>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_date?: InputMaybe<Scalars['date']['input']>;
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
  risk_intesity?: InputMaybe<Scalars['Int']['input']>;
  risk_level?: InputMaybe<Driver_Warning_Risk_Level_View_Obj_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  warning_message?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Max_Fields = {
  __typename?: 'driver_warning_max_fields';
  codmoto: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  reference_date: Maybe<Scalars['date']['output']>;
  risk_intensity: Maybe<Scalars['Int']['output']>;
  risk_intesity: Maybe<Scalars['Int']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  warning_message: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "driver_warning" */
export type Driver_Warning_Max_Order_By = {
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  reference_date?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  warning_message?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driver_Warning_Min_Fields = {
  __typename?: 'driver_warning_min_fields';
  codmoto: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  reference_date: Maybe<Scalars['date']['output']>;
  risk_intensity: Maybe<Scalars['Int']['output']>;
  risk_intesity: Maybe<Scalars['Int']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  warning_message: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "driver_warning" */
export type Driver_Warning_Min_Order_By = {
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  reference_date?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  warning_message?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driver_warning" */
export type Driver_Warning_Mutation_Response = {
  __typename?: 'driver_warning_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driver_Warning>;
};

/** input type for inserting object relation for remote table "driver_warning" */
export type Driver_Warning_Obj_Rel_Insert_Input = {
  data: Driver_Warning_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Driver_Warning_On_Conflict>;
};

/** on_conflict condition type for table "driver_warning" */
export type Driver_Warning_On_Conflict = {
  constraint: Driver_Warning_Constraint;
  update_columns?: Array<Driver_Warning_Update_Column>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};

/** Ordering options when selecting data from "driver_warning". */
export type Driver_Warning_Order_By = {
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning_comments_aggregate?: InputMaybe<Driver_Warning_Comment_Aggregate_Order_By>;
  driver_warning_trips_aggregate?: InputMaybe<Driver_Warning_Trip_Aggregate_Order_By>;
  processed_at?: InputMaybe<Order_By>;
  reference_date?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
  risk_level?: InputMaybe<Driver_Warning_Risk_Level_View_Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  uuid?: InputMaybe<Order_By>;
  warning_message?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driver_warning */
export type Driver_Warning_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level = {
  __typename?: 'driver_warning_risk_level';
  level_name: Scalars['String']['output'];
  risk_range: Scalars['int4range']['output'];
  should_send_whatsapp_message: Scalars['Boolean']['output'];
};

/** aggregated selection of "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_Aggregate = {
  __typename?: 'driver_warning_risk_level_aggregate';
  aggregate: Maybe<Driver_Warning_Risk_Level_Aggregate_Fields>;
  nodes: Array<Driver_Warning_Risk_Level>;
};

/** aggregate fields of "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_Aggregate_Fields = {
  __typename?: 'driver_warning_risk_level_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Risk_Level_Max_Fields>;
  min: Maybe<Driver_Warning_Risk_Level_Min_Fields>;
};


/** aggregate fields of "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Risk_Level_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "driver_warning_risk_level". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Risk_Level_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Risk_Level_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Risk_Level_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Risk_Level_Bool_Exp>>;
  level_name?: InputMaybe<String_Comparison_Exp>;
  risk_range?: InputMaybe<Int4range_Comparison_Exp>;
  should_send_whatsapp_message?: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "driver_warning_risk_level" */
export enum Driver_Warning_Risk_Level_Constraint {
  /** unique or primary key constraint on columns "level_name" */
  DriverWarningRiskLevelPkey = 'driver_warning_risk_level_pkey'
}

/** input type for inserting data into table "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_Insert_Input = {
  level_name?: InputMaybe<Scalars['String']['input']>;
  risk_range?: InputMaybe<Scalars['int4range']['input']>;
  should_send_whatsapp_message?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Risk_Level_Max_Fields = {
  __typename?: 'driver_warning_risk_level_max_fields';
  level_name: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Driver_Warning_Risk_Level_Min_Fields = {
  __typename?: 'driver_warning_risk_level_min_fields';
  level_name: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_Mutation_Response = {
  __typename?: 'driver_warning_risk_level_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driver_Warning_Risk_Level>;
};

/** on_conflict condition type for table "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_On_Conflict = {
  constraint: Driver_Warning_Risk_Level_Constraint;
  update_columns?: Array<Driver_Warning_Risk_Level_Update_Column>;
  where?: InputMaybe<Driver_Warning_Risk_Level_Bool_Exp>;
};

/** Ordering options when selecting data from "driver_warning_risk_level". */
export type Driver_Warning_Risk_Level_Order_By = {
  level_name?: InputMaybe<Order_By>;
  risk_range?: InputMaybe<Order_By>;
  should_send_whatsapp_message?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driver_warning_risk_level */
export type Driver_Warning_Risk_Level_Pk_Columns_Input = {
  level_name: Scalars['String']['input'];
};

/** select columns of table "driver_warning_risk_level" */
export enum Driver_Warning_Risk_Level_Select_Column {
  /** column name */
  LevelName = 'level_name',
  /** column name */
  RiskRange = 'risk_range',
  /** column name */
  ShouldSendWhatsappMessage = 'should_send_whatsapp_message'
}

/** input type for updating data in table "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_Set_Input = {
  level_name?: InputMaybe<Scalars['String']['input']>;
  risk_range?: InputMaybe<Scalars['int4range']['input']>;
  should_send_whatsapp_message?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Streaming cursor of the table "driver_warning_risk_level" */
export type Driver_Warning_Risk_Level_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Risk_Level_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Risk_Level_Stream_Cursor_Value_Input = {
  level_name?: InputMaybe<Scalars['String']['input']>;
  risk_range?: InputMaybe<Scalars['int4range']['input']>;
  should_send_whatsapp_message?: InputMaybe<Scalars['Boolean']['input']>;
};

/** update columns of table "driver_warning_risk_level" */
export enum Driver_Warning_Risk_Level_Update_Column {
  /** column name */
  LevelName = 'level_name',
  /** column name */
  RiskRange = 'risk_range',
  /** column name */
  ShouldSendWhatsappMessage = 'should_send_whatsapp_message'
}

export type Driver_Warning_Risk_Level_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driver_Warning_Risk_Level_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driver_Warning_Risk_Level_Bool_Exp;
};

/** columns and relationships of "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_View = {
  __typename?: 'driver_warning_risk_level_view';
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  driver_warnings: Array<Driver_Warning>;
  /** An aggregate relationship */
  driver_warnings_aggregate: Driver_Warning_Aggregate;
  level_name: Maybe<Scalars['String']['output']>;
  risk_range: Maybe<Scalars['int4range']['output']>;
  should_send_whatsapp_message: Maybe<Scalars['Boolean']['output']>;
};


/** columns and relationships of "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_ViewDriver_WarningsArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


/** columns and relationships of "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_ViewDriver_Warnings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};

/** aggregated selection of "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_View_Aggregate = {
  __typename?: 'driver_warning_risk_level_view_aggregate';
  aggregate: Maybe<Driver_Warning_Risk_Level_View_Aggregate_Fields>;
  nodes: Array<Driver_Warning_Risk_Level_View>;
};

/** aggregate fields of "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_View_Aggregate_Fields = {
  __typename?: 'driver_warning_risk_level_view_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Risk_Level_View_Max_Fields>;
  min: Maybe<Driver_Warning_Risk_Level_View_Min_Fields>;
};


/** aggregate fields of "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_View_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "driver_warning_risk_level_view". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Risk_Level_View_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Risk_Level_View_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Bool_Exp>>;
  driver_warning_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  driver_warnings?: InputMaybe<Driver_Warning_Bool_Exp>;
  driver_warnings_aggregate?: InputMaybe<Driver_Warning_Aggregate_Bool_Exp>;
  level_name?: InputMaybe<String_Comparison_Exp>;
  risk_range?: InputMaybe<Int4range_Comparison_Exp>;
  should_send_whatsapp_message?: InputMaybe<Boolean_Comparison_Exp>;
};

/** input type for inserting data into table "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_View_Insert_Input = {
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  driver_warnings?: InputMaybe<Driver_Warning_Arr_Rel_Insert_Input>;
  level_name?: InputMaybe<Scalars['String']['input']>;
  risk_range?: InputMaybe<Scalars['int4range']['input']>;
  should_send_whatsapp_message?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Risk_Level_View_Max_Fields = {
  __typename?: 'driver_warning_risk_level_view_max_fields';
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  level_name: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Driver_Warning_Risk_Level_View_Min_Fields = {
  __typename?: 'driver_warning_risk_level_view_min_fields';
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  level_name: Maybe<Scalars['String']['output']>;
};

/** input type for inserting object relation for remote table "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_View_Obj_Rel_Insert_Input = {
  data: Driver_Warning_Risk_Level_View_Insert_Input;
};

/** Ordering options when selecting data from "driver_warning_risk_level_view". */
export type Driver_Warning_Risk_Level_View_Order_By = {
  driver_warning_uuid?: InputMaybe<Order_By>;
  driver_warnings_aggregate?: InputMaybe<Driver_Warning_Aggregate_Order_By>;
  level_name?: InputMaybe<Order_By>;
  risk_range?: InputMaybe<Order_By>;
  should_send_whatsapp_message?: InputMaybe<Order_By>;
};

/** select columns of table "driver_warning_risk_level_view" */
export enum Driver_Warning_Risk_Level_View_Select_Column {
  /** column name */
  DriverWarningUuid = 'driver_warning_uuid',
  /** column name */
  LevelName = 'level_name',
  /** column name */
  RiskRange = 'risk_range',
  /** column name */
  ShouldSendWhatsappMessage = 'should_send_whatsapp_message'
}

/** Streaming cursor of the table "driver_warning_risk_level_view" */
export type Driver_Warning_Risk_Level_View_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Risk_Level_View_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Risk_Level_View_Stream_Cursor_Value_Input = {
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  level_name?: InputMaybe<Scalars['String']['input']>;
  risk_range?: InputMaybe<Scalars['int4range']['input']>;
  should_send_whatsapp_message?: InputMaybe<Scalars['Boolean']['input']>;
};

/** select columns of table "driver_warning" */
export enum Driver_Warning_Select_Column {
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ProcessedAt = 'processed_at',
  /** column name */
  ReferenceDate = 'reference_date',
  /** column name */
  RiskIntensity = 'risk_intensity',
  /** column name */
  RiskIntesity = 'risk_intesity',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WarningMessage = 'warning_message'
}

/** input type for updating data in table "driver_warning" */
export type Driver_Warning_Set_Input = {
  codmoto?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_date?: InputMaybe<Scalars['date']['input']>;
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
  risk_intesity?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  warning_message?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Driver_Warning_Stddev_Fields = {
  __typename?: 'driver_warning_stddev_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
  risk_intesity: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driver_warning" */
export type Driver_Warning_Stddev_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driver_Warning_Stddev_Pop_Fields = {
  __typename?: 'driver_warning_stddev_pop_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
  risk_intesity: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driver_warning" */
export type Driver_Warning_Stddev_Pop_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driver_Warning_Stddev_Samp_Fields = {
  __typename?: 'driver_warning_stddev_samp_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
  risk_intesity: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driver_warning" */
export type Driver_Warning_Stddev_Samp_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driver_warning" */
export type Driver_Warning_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Stream_Cursor_Value_Input = {
  codmoto?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_date?: InputMaybe<Scalars['date']['input']>;
  risk_intensity?: InputMaybe<Scalars['Int']['input']>;
  risk_intesity?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  warning_message?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Driver_Warning_Sum_Fields = {
  __typename?: 'driver_warning_sum_fields';
  risk_intensity: Maybe<Scalars['Int']['output']>;
  risk_intesity: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "driver_warning" */
export type Driver_Warning_Sum_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** columns and relationships of "driver_warning_trip" */
export type Driver_Warning_Trip = {
  __typename?: 'driver_warning_trip';
  codmoto: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  driver_warning: Driver_Warning;
  /** An array relationship */
  driver_warning_trip_points: Array<Driver_Warning_Trip_Point>;
  /** An aggregate relationship */
  driver_warning_trip_points_aggregate: Driver_Warning_Trip_Point_Aggregate;
  /** An object relationship */
  driver_warning_trip_severity: Maybe<Driver_Warning_Trip_Severity>;
  driver_warning_uuid: Scalars['uuid']['output'];
  dtfimanalise: Maybe<Scalars['String']['output']>;
  dtinicioanalise: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  last_sync_route_at: Maybe<Scalars['timestamptz']['output']>;
  license_plate: Maybe<Scalars['String']['output']>;
  odometrotrip: Maybe<Scalars['float8']['output']>;
  rastreadofim: Maybe<Scalars['String']['output']>;
  rastreadoinicio: Maybe<Scalars['String']['output']>;
  risk_intensity: Scalars['Float']['output'];
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Int']['output']>;
  /** When the severity level was set */
  severity_level_set_at: Maybe<Scalars['timestamptz']['output']>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  trip_data: Scalars['jsonb']['output'];
  trip_id: Maybe<Scalars['Int']['output']>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  warning_message: Scalars['String']['output'];
};


/** columns and relationships of "driver_warning_trip" */
export type Driver_Warning_TripDriver_Warning_Trip_PointsArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Point_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};


/** columns and relationships of "driver_warning_trip" */
export type Driver_Warning_TripDriver_Warning_Trip_Points_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Point_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};


/** columns and relationships of "driver_warning_trip" */
export type Driver_Warning_TripTrip_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "driver_warning_trip" */
export type Driver_Warning_Trip_Aggregate = {
  __typename?: 'driver_warning_trip_aggregate';
  aggregate: Maybe<Driver_Warning_Trip_Aggregate_Fields>;
  nodes: Array<Driver_Warning_Trip>;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp_Var_Samp>;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Avg = {
  arguments: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Corr = {
  arguments: Driver_Warning_Trip_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Driver_Warning_Trip_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Max = {
  arguments: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Min = {
  arguments: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Sum = {
  arguments: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Driver_Warning_Trip_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "driver_warning_trip" */
export type Driver_Warning_Trip_Aggregate_Fields = {
  __typename?: 'driver_warning_trip_aggregate_fields';
  avg: Maybe<Driver_Warning_Trip_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Trip_Max_Fields>;
  min: Maybe<Driver_Warning_Trip_Min_Fields>;
  stddev: Maybe<Driver_Warning_Trip_Stddev_Fields>;
  stddev_pop: Maybe<Driver_Warning_Trip_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Driver_Warning_Trip_Stddev_Samp_Fields>;
  sum: Maybe<Driver_Warning_Trip_Sum_Fields>;
  var_pop: Maybe<Driver_Warning_Trip_Var_Pop_Fields>;
  var_samp: Maybe<Driver_Warning_Trip_Var_Samp_Fields>;
  variance: Maybe<Driver_Warning_Trip_Variance_Fields>;
};


/** aggregate fields of "driver_warning_trip" */
export type Driver_Warning_Trip_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driver_warning_trip" */
export type Driver_Warning_Trip_Aggregate_Order_By = {
  avg?: InputMaybe<Driver_Warning_Trip_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driver_Warning_Trip_Max_Order_By>;
  min?: InputMaybe<Driver_Warning_Trip_Min_Order_By>;
  stddev?: InputMaybe<Driver_Warning_Trip_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driver_Warning_Trip_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driver_Warning_Trip_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driver_Warning_Trip_Sum_Order_By>;
  var_pop?: InputMaybe<Driver_Warning_Trip_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driver_Warning_Trip_Var_Samp_Order_By>;
  variance?: InputMaybe<Driver_Warning_Trip_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Driver_Warning_Trip_Append_Input = {
  trip_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "driver_warning_trip" */
export type Driver_Warning_Trip_Arr_Rel_Insert_Input = {
  data: Array<Driver_Warning_Trip_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driver_Warning_Trip_On_Conflict>;
};

/** aggregate avg on columns */
export type Driver_Warning_Trip_Avg_Fields = {
  __typename?: 'driver_warning_trip_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
  odometrotrip: Maybe<Scalars['Float']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driver_warning_trip". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Trip_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Trip_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Trip_Bool_Exp>>;
  codmoto?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver_warning?: InputMaybe<Driver_Warning_Bool_Exp>;
  driver_warning_trip_points?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
  driver_warning_trip_points_aggregate?: InputMaybe<Driver_Warning_Trip_Point_Aggregate_Bool_Exp>;
  driver_warning_trip_severity?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
  driver_warning_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  dtfimanalise?: InputMaybe<String_Comparison_Exp>;
  dtinicioanalise?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  last_sync_route_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  license_plate?: InputMaybe<String_Comparison_Exp>;
  odometrotrip?: InputMaybe<Float8_Comparison_Exp>;
  rastreadofim?: InputMaybe<String_Comparison_Exp>;
  rastreadoinicio?: InputMaybe<String_Comparison_Exp>;
  risk_intensity?: InputMaybe<Float_Comparison_Exp>;
  severity_level?: InputMaybe<Int_Comparison_Exp>;
  severity_level_set_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  severity_level_set_by_admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  trip_data?: InputMaybe<Jsonb_Comparison_Exp>;
  trip_id?: InputMaybe<Int_Comparison_Exp>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  warning_message?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "driver_warning_trip" */
export enum Driver_Warning_Trip_Constraint {
  /** unique or primary key constraint on columns "id" */
  DriverWarningTripPkey = 'driver_warning_trip_pkey',
  /** unique or primary key constraint on columns "trip_id" */
  DriverWarningTripTripIdKey = 'driver_warning_trip_trip_id_key',
  /** unique or primary key constraint on columns "trip_id_or_codmoto_license_plate_dtinicioanalise_key" */
  UniqueTripIdOrCodmotoLicensePlateDtinicioanaliseKey = 'unique_trip_id_or_codmoto_license_plate_dtinicioanalise_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Driver_Warning_Trip_Delete_At_Path_Input = {
  trip_data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Driver_Warning_Trip_Delete_Elem_Input = {
  trip_data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Driver_Warning_Trip_Delete_Key_Input = {
  trip_data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "driver_warning_trip" */
export type Driver_Warning_Trip_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  risk_intensity?: InputMaybe<Scalars['Float']['input']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Scalars['Int']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "driver_warning_trip" */
export type Driver_Warning_Trip_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning?: InputMaybe<Driver_Warning_Obj_Rel_Insert_Input>;
  driver_warning_trip_points?: InputMaybe<Driver_Warning_Trip_Point_Arr_Rel_Insert_Input>;
  driver_warning_trip_severity?: InputMaybe<Driver_Warning_Trip_Severity_Obj_Rel_Insert_Input>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  last_sync_route_at?: InputMaybe<Scalars['timestamptz']['input']>;
  risk_intensity?: InputMaybe<Scalars['Float']['input']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Scalars['Int']['input']>;
  /** When the severity level was set */
  severity_level_set_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  trip_data?: InputMaybe<Scalars['jsonb']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  warning_message?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Trip_Max_Fields = {
  __typename?: 'driver_warning_trip_max_fields';
  codmoto: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  dtfimanalise: Maybe<Scalars['String']['output']>;
  dtinicioanalise: Maybe<Scalars['String']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  last_sync_route_at: Maybe<Scalars['timestamptz']['output']>;
  license_plate: Maybe<Scalars['String']['output']>;
  odometrotrip: Maybe<Scalars['float8']['output']>;
  rastreadofim: Maybe<Scalars['String']['output']>;
  rastreadoinicio: Maybe<Scalars['String']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Int']['output']>;
  /** When the severity level was set */
  severity_level_set_at: Maybe<Scalars['timestamptz']['output']>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  trip_id: Maybe<Scalars['Int']['output']>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  warning_message: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Max_Order_By = {
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning_uuid?: InputMaybe<Order_By>;
  dtfimanalise?: InputMaybe<Order_By>;
  dtinicioanalise?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_sync_route_at?: InputMaybe<Order_By>;
  license_plate?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  rastreadofim?: InputMaybe<Order_By>;
  rastreadoinicio?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  /** When the severity level was set */
  severity_level_set_at?: InputMaybe<Order_By>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  warning_message?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driver_Warning_Trip_Min_Fields = {
  __typename?: 'driver_warning_trip_min_fields';
  codmoto: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  driver_warning_uuid: Maybe<Scalars['uuid']['output']>;
  dtfimanalise: Maybe<Scalars['String']['output']>;
  dtinicioanalise: Maybe<Scalars['String']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  last_sync_route_at: Maybe<Scalars['timestamptz']['output']>;
  license_plate: Maybe<Scalars['String']['output']>;
  odometrotrip: Maybe<Scalars['float8']['output']>;
  rastreadofim: Maybe<Scalars['String']['output']>;
  rastreadoinicio: Maybe<Scalars['String']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Int']['output']>;
  /** When the severity level was set */
  severity_level_set_at: Maybe<Scalars['timestamptz']['output']>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid: Maybe<Scalars['uuid']['output']>;
  trip_id: Maybe<Scalars['Int']['output']>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  warning_message: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Min_Order_By = {
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning_uuid?: InputMaybe<Order_By>;
  dtfimanalise?: InputMaybe<Order_By>;
  dtinicioanalise?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_sync_route_at?: InputMaybe<Order_By>;
  license_plate?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  rastreadofim?: InputMaybe<Order_By>;
  rastreadoinicio?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  /** When the severity level was set */
  severity_level_set_at?: InputMaybe<Order_By>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  warning_message?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driver_warning_trip" */
export type Driver_Warning_Trip_Mutation_Response = {
  __typename?: 'driver_warning_trip_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driver_Warning_Trip>;
};

/** input type for inserting object relation for remote table "driver_warning_trip" */
export type Driver_Warning_Trip_Obj_Rel_Insert_Input = {
  data: Driver_Warning_Trip_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Driver_Warning_Trip_On_Conflict>;
};

/** on_conflict condition type for table "driver_warning_trip" */
export type Driver_Warning_Trip_On_Conflict = {
  constraint: Driver_Warning_Trip_Constraint;
  update_columns?: Array<Driver_Warning_Trip_Update_Column>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};

/** Ordering options when selecting data from "driver_warning_trip". */
export type Driver_Warning_Trip_Order_By = {
  codmoto?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  driver_warning?: InputMaybe<Driver_Warning_Order_By>;
  driver_warning_trip_points_aggregate?: InputMaybe<Driver_Warning_Trip_Point_Aggregate_Order_By>;
  driver_warning_trip_severity?: InputMaybe<Driver_Warning_Trip_Severity_Order_By>;
  driver_warning_uuid?: InputMaybe<Order_By>;
  dtfimanalise?: InputMaybe<Order_By>;
  dtinicioanalise?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_sync_route_at?: InputMaybe<Order_By>;
  license_plate?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  rastreadofim?: InputMaybe<Order_By>;
  rastreadoinicio?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  severity_level?: InputMaybe<Order_By>;
  severity_level_set_at?: InputMaybe<Order_By>;
  severity_level_set_by_admin_uuid?: InputMaybe<Order_By>;
  trip_data?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  warning_message?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driver_warning_trip */
export type Driver_Warning_Trip_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** columns and relationships of "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point = {
  __typename?: 'driver_warning_trip_point';
  /** An object relationship */
  driver_warning_trip: Maybe<Driver_Warning_Trip>;
  driver_warning_trip_id: Maybe<Scalars['Int']['output']>;
  engine_temperature: Maybe<Scalars['smallint']['output']>;
  fuel_level: Maybe<Scalars['smallint']['output']>;
  gps_datetime: Scalars['timestamptz']['output'];
  gps_signal: Maybe<Scalars['Boolean']['output']>;
  gsm_signal: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['bigint']['output'];
  location: Maybe<Scalars['geography']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Int']['output']>;
  odometer: Maybe<Scalars['Int']['output']>;
  rpm: Maybe<Scalars['smallint']['output']>;
  sys_datetime: Scalars['timestamptz']['output'];
  tracker_device_model: Scalars['tracker_device_model']['output'];
  trip_id: Maybe<Scalars['Int']['output']>;
  velocity: Maybe<Scalars['smallint']['output']>;
};

/** aggregated selection of "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Aggregate = {
  __typename?: 'driver_warning_trip_point_aggregate';
  aggregate: Maybe<Driver_Warning_Trip_Point_Aggregate_Fields>;
  nodes: Array<Driver_Warning_Trip_Point>;
};

export type Driver_Warning_Trip_Point_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Count>;
};

export type Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_And = {
  arguments: Driver_Warning_Trip_Point_Select_Column_Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Driver_Warning_Trip_Point_Select_Column_Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Aggregate_Fields = {
  __typename?: 'driver_warning_trip_point_aggregate_fields';
  avg: Maybe<Driver_Warning_Trip_Point_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Trip_Point_Max_Fields>;
  min: Maybe<Driver_Warning_Trip_Point_Min_Fields>;
  stddev: Maybe<Driver_Warning_Trip_Point_Stddev_Fields>;
  stddev_pop: Maybe<Driver_Warning_Trip_Point_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Driver_Warning_Trip_Point_Stddev_Samp_Fields>;
  sum: Maybe<Driver_Warning_Trip_Point_Sum_Fields>;
  var_pop: Maybe<Driver_Warning_Trip_Point_Var_Pop_Fields>;
  var_samp: Maybe<Driver_Warning_Trip_Point_Var_Samp_Fields>;
  variance: Maybe<Driver_Warning_Trip_Point_Variance_Fields>;
};


/** aggregate fields of "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Aggregate_Order_By = {
  avg?: InputMaybe<Driver_Warning_Trip_Point_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driver_Warning_Trip_Point_Max_Order_By>;
  min?: InputMaybe<Driver_Warning_Trip_Point_Min_Order_By>;
  stddev?: InputMaybe<Driver_Warning_Trip_Point_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driver_Warning_Trip_Point_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driver_Warning_Trip_Point_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driver_Warning_Trip_Point_Sum_Order_By>;
  var_pop?: InputMaybe<Driver_Warning_Trip_Point_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driver_Warning_Trip_Point_Var_Samp_Order_By>;
  variance?: InputMaybe<Driver_Warning_Trip_Point_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Arr_Rel_Insert_Input = {
  data: Array<Driver_Warning_Trip_Point_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driver_Warning_Trip_Point_On_Conflict>;
};

/** aggregate avg on columns */
export type Driver_Warning_Trip_Point_Avg_Fields = {
  __typename?: 'driver_warning_trip_point_avg_fields';
  driver_warning_trip_id: Maybe<Scalars['Float']['output']>;
  engine_temperature: Maybe<Scalars['Float']['output']>;
  fuel_level: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Float']['output']>;
  odometer: Maybe<Scalars['Float']['output']>;
  rpm: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
  velocity: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Avg_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driver_warning_trip_point". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Trip_Point_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Trip_Point_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Trip_Point_Bool_Exp>>;
  driver_warning_trip?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  driver_warning_trip_id?: InputMaybe<Int_Comparison_Exp>;
  engine_temperature?: InputMaybe<Smallint_Comparison_Exp>;
  fuel_level?: InputMaybe<Smallint_Comparison_Exp>;
  gps_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  gps_signal?: InputMaybe<Boolean_Comparison_Exp>;
  gsm_signal?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  location?: InputMaybe<Geography_Comparison_Exp>;
  near_critical_point_distance?: InputMaybe<Float_Comparison_Exp>;
  near_critical_point_id?: InputMaybe<Int_Comparison_Exp>;
  odometer?: InputMaybe<Int_Comparison_Exp>;
  rpm?: InputMaybe<Smallint_Comparison_Exp>;
  sys_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  tracker_device_model?: InputMaybe<Tracker_Device_Model_Comparison_Exp>;
  trip_id?: InputMaybe<Int_Comparison_Exp>;
  velocity?: InputMaybe<Smallint_Comparison_Exp>;
};

/** unique or primary key constraints on table "driver_warning_trip_point" */
export enum Driver_Warning_Trip_Point_Constraint {
  /** unique or primary key constraint on columns "id" */
  DriverWarningTripPointsPkey = 'driver_warning_trip_points_pkey'
}

/** input type for incrementing numeric columns in table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Inc_Input = {
  driver_warning_trip_id?: InputMaybe<Scalars['Int']['input']>;
  engine_temperature?: InputMaybe<Scalars['smallint']['input']>;
  fuel_level?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  near_critical_point_distance?: InputMaybe<Scalars['Float']['input']>;
  near_critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  odometer?: InputMaybe<Scalars['Int']['input']>;
  rpm?: InputMaybe<Scalars['smallint']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
  velocity?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Insert_Input = {
  driver_warning_trip?: InputMaybe<Driver_Warning_Trip_Obj_Rel_Insert_Input>;
  driver_warning_trip_id?: InputMaybe<Scalars['Int']['input']>;
  engine_temperature?: InputMaybe<Scalars['smallint']['input']>;
  fuel_level?: InputMaybe<Scalars['smallint']['input']>;
  gps_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  gps_signal?: InputMaybe<Scalars['Boolean']['input']>;
  gsm_signal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  near_critical_point_distance?: InputMaybe<Scalars['Float']['input']>;
  near_critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  odometer?: InputMaybe<Scalars['Int']['input']>;
  rpm?: InputMaybe<Scalars['smallint']['input']>;
  sys_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  tracker_device_model?: InputMaybe<Scalars['tracker_device_model']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
  velocity?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Trip_Point_Max_Fields = {
  __typename?: 'driver_warning_trip_point_max_fields';
  driver_warning_trip_id: Maybe<Scalars['Int']['output']>;
  engine_temperature: Maybe<Scalars['smallint']['output']>;
  fuel_level: Maybe<Scalars['smallint']['output']>;
  gps_datetime: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Int']['output']>;
  odometer: Maybe<Scalars['Int']['output']>;
  rpm: Maybe<Scalars['smallint']['output']>;
  sys_datetime: Maybe<Scalars['timestamptz']['output']>;
  tracker_device_model: Maybe<Scalars['tracker_device_model']['output']>;
  trip_id: Maybe<Scalars['Int']['output']>;
  velocity: Maybe<Scalars['smallint']['output']>;
};

/** order by max() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Max_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  gps_datetime?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  sys_datetime?: InputMaybe<Order_By>;
  tracker_device_model?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driver_Warning_Trip_Point_Min_Fields = {
  __typename?: 'driver_warning_trip_point_min_fields';
  driver_warning_trip_id: Maybe<Scalars['Int']['output']>;
  engine_temperature: Maybe<Scalars['smallint']['output']>;
  fuel_level: Maybe<Scalars['smallint']['output']>;
  gps_datetime: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Int']['output']>;
  odometer: Maybe<Scalars['Int']['output']>;
  rpm: Maybe<Scalars['smallint']['output']>;
  sys_datetime: Maybe<Scalars['timestamptz']['output']>;
  tracker_device_model: Maybe<Scalars['tracker_device_model']['output']>;
  trip_id: Maybe<Scalars['Int']['output']>;
  velocity: Maybe<Scalars['smallint']['output']>;
};

/** order by min() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Min_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  gps_datetime?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  sys_datetime?: InputMaybe<Order_By>;
  tracker_device_model?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Mutation_Response = {
  __typename?: 'driver_warning_trip_point_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driver_Warning_Trip_Point>;
};

/** on_conflict condition type for table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_On_Conflict = {
  constraint: Driver_Warning_Trip_Point_Constraint;
  update_columns?: Array<Driver_Warning_Trip_Point_Update_Column>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};

/** Ordering options when selecting data from "driver_warning_trip_point". */
export type Driver_Warning_Trip_Point_Order_By = {
  driver_warning_trip?: InputMaybe<Driver_Warning_Trip_Order_By>;
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  gps_datetime?: InputMaybe<Order_By>;
  gps_signal?: InputMaybe<Order_By>;
  gsm_signal?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  sys_datetime?: InputMaybe<Order_By>;
  tracker_device_model?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driver_warning_trip_point */
export type Driver_Warning_Trip_Point_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "driver_warning_trip_point" */
export enum Driver_Warning_Trip_Point_Select_Column {
  /** column name */
  DriverWarningTripId = 'driver_warning_trip_id',
  /** column name */
  EngineTemperature = 'engine_temperature',
  /** column name */
  FuelLevel = 'fuel_level',
  /** column name */
  GpsDatetime = 'gps_datetime',
  /** column name */
  GpsSignal = 'gps_signal',
  /** column name */
  GsmSignal = 'gsm_signal',
  /** column name */
  Id = 'id',
  /** column name */
  Location = 'location',
  /** column name */
  NearCriticalPointDistance = 'near_critical_point_distance',
  /** column name */
  NearCriticalPointId = 'near_critical_point_id',
  /** column name */
  Odometer = 'odometer',
  /** column name */
  Rpm = 'rpm',
  /** column name */
  SysDatetime = 'sys_datetime',
  /** column name */
  TrackerDeviceModel = 'tracker_device_model',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  Velocity = 'velocity'
}

/** select "driver_warning_trip_point_aggregate_bool_exp_bool_and_arguments_columns" columns of table "driver_warning_trip_point" */
export enum Driver_Warning_Trip_Point_Select_Column_Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  GpsSignal = 'gps_signal',
  /** column name */
  GsmSignal = 'gsm_signal'
}

/** select "driver_warning_trip_point_aggregate_bool_exp_bool_or_arguments_columns" columns of table "driver_warning_trip_point" */
export enum Driver_Warning_Trip_Point_Select_Column_Driver_Warning_Trip_Point_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  GpsSignal = 'gps_signal',
  /** column name */
  GsmSignal = 'gsm_signal'
}

/** input type for updating data in table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Set_Input = {
  driver_warning_trip_id?: InputMaybe<Scalars['Int']['input']>;
  engine_temperature?: InputMaybe<Scalars['smallint']['input']>;
  fuel_level?: InputMaybe<Scalars['smallint']['input']>;
  gps_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  gps_signal?: InputMaybe<Scalars['Boolean']['input']>;
  gsm_signal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  near_critical_point_distance?: InputMaybe<Scalars['Float']['input']>;
  near_critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  odometer?: InputMaybe<Scalars['Int']['input']>;
  rpm?: InputMaybe<Scalars['smallint']['input']>;
  sys_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  tracker_device_model?: InputMaybe<Scalars['tracker_device_model']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
  velocity?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate stddev on columns */
export type Driver_Warning_Trip_Point_Stddev_Fields = {
  __typename?: 'driver_warning_trip_point_stddev_fields';
  driver_warning_trip_id: Maybe<Scalars['Float']['output']>;
  engine_temperature: Maybe<Scalars['Float']['output']>;
  fuel_level: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Float']['output']>;
  odometer: Maybe<Scalars['Float']['output']>;
  rpm: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
  velocity: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Stddev_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driver_Warning_Trip_Point_Stddev_Pop_Fields = {
  __typename?: 'driver_warning_trip_point_stddev_pop_fields';
  driver_warning_trip_id: Maybe<Scalars['Float']['output']>;
  engine_temperature: Maybe<Scalars['Float']['output']>;
  fuel_level: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Float']['output']>;
  odometer: Maybe<Scalars['Float']['output']>;
  rpm: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
  velocity: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Stddev_Pop_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driver_Warning_Trip_Point_Stddev_Samp_Fields = {
  __typename?: 'driver_warning_trip_point_stddev_samp_fields';
  driver_warning_trip_id: Maybe<Scalars['Float']['output']>;
  engine_temperature: Maybe<Scalars['Float']['output']>;
  fuel_level: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Float']['output']>;
  odometer: Maybe<Scalars['Float']['output']>;
  rpm: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
  velocity: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Stddev_Samp_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Trip_Point_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Trip_Point_Stream_Cursor_Value_Input = {
  driver_warning_trip_id?: InputMaybe<Scalars['Int']['input']>;
  engine_temperature?: InputMaybe<Scalars['smallint']['input']>;
  fuel_level?: InputMaybe<Scalars['smallint']['input']>;
  gps_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  gps_signal?: InputMaybe<Scalars['Boolean']['input']>;
  gsm_signal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  near_critical_point_distance?: InputMaybe<Scalars['Float']['input']>;
  near_critical_point_id?: InputMaybe<Scalars['Int']['input']>;
  odometer?: InputMaybe<Scalars['Int']['input']>;
  rpm?: InputMaybe<Scalars['smallint']['input']>;
  sys_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  tracker_device_model?: InputMaybe<Scalars['tracker_device_model']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
  velocity?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate sum on columns */
export type Driver_Warning_Trip_Point_Sum_Fields = {
  __typename?: 'driver_warning_trip_point_sum_fields';
  driver_warning_trip_id: Maybe<Scalars['Int']['output']>;
  engine_temperature: Maybe<Scalars['smallint']['output']>;
  fuel_level: Maybe<Scalars['smallint']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Int']['output']>;
  odometer: Maybe<Scalars['Int']['output']>;
  rpm: Maybe<Scalars['smallint']['output']>;
  trip_id: Maybe<Scalars['Int']['output']>;
  velocity: Maybe<Scalars['smallint']['output']>;
};

/** order by sum() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Sum_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** update columns of table "driver_warning_trip_point" */
export enum Driver_Warning_Trip_Point_Update_Column {
  /** column name */
  DriverWarningTripId = 'driver_warning_trip_id',
  /** column name */
  EngineTemperature = 'engine_temperature',
  /** column name */
  FuelLevel = 'fuel_level',
  /** column name */
  GpsDatetime = 'gps_datetime',
  /** column name */
  GpsSignal = 'gps_signal',
  /** column name */
  GsmSignal = 'gsm_signal',
  /** column name */
  Id = 'id',
  /** column name */
  Location = 'location',
  /** column name */
  NearCriticalPointDistance = 'near_critical_point_distance',
  /** column name */
  NearCriticalPointId = 'near_critical_point_id',
  /** column name */
  Odometer = 'odometer',
  /** column name */
  Rpm = 'rpm',
  /** column name */
  SysDatetime = 'sys_datetime',
  /** column name */
  TrackerDeviceModel = 'tracker_device_model',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  Velocity = 'velocity'
}

export type Driver_Warning_Trip_Point_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driver_Warning_Trip_Point_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driver_Warning_Trip_Point_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driver_Warning_Trip_Point_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driver_Warning_Trip_Point_Var_Pop_Fields = {
  __typename?: 'driver_warning_trip_point_var_pop_fields';
  driver_warning_trip_id: Maybe<Scalars['Float']['output']>;
  engine_temperature: Maybe<Scalars['Float']['output']>;
  fuel_level: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Float']['output']>;
  odometer: Maybe<Scalars['Float']['output']>;
  rpm: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
  velocity: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Var_Pop_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driver_Warning_Trip_Point_Var_Samp_Fields = {
  __typename?: 'driver_warning_trip_point_var_samp_fields';
  driver_warning_trip_id: Maybe<Scalars['Float']['output']>;
  engine_temperature: Maybe<Scalars['Float']['output']>;
  fuel_level: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Float']['output']>;
  odometer: Maybe<Scalars['Float']['output']>;
  rpm: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
  velocity: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Var_Samp_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driver_Warning_Trip_Point_Variance_Fields = {
  __typename?: 'driver_warning_trip_point_variance_fields';
  driver_warning_trip_id: Maybe<Scalars['Float']['output']>;
  engine_temperature: Maybe<Scalars['Float']['output']>;
  fuel_level: Maybe<Scalars['Float']['output']>;
  id: Maybe<Scalars['Float']['output']>;
  near_critical_point_distance: Maybe<Scalars['Float']['output']>;
  near_critical_point_id: Maybe<Scalars['Float']['output']>;
  odometer: Maybe<Scalars['Float']['output']>;
  rpm: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
  velocity: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driver_warning_trip_point" */
export type Driver_Warning_Trip_Point_Variance_Order_By = {
  driver_warning_trip_id?: InputMaybe<Order_By>;
  engine_temperature?: InputMaybe<Order_By>;
  fuel_level?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  near_critical_point_distance?: InputMaybe<Order_By>;
  near_critical_point_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  rpm?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  velocity?: InputMaybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Driver_Warning_Trip_Prepend_Input = {
  trip_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column {
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverWarningUuid = 'driver_warning_uuid',
  /** column name */
  Dtfimanalise = 'dtfimanalise',
  /** column name */
  Dtinicioanalise = 'dtinicioanalise',
  /** column name */
  Id = 'id',
  /** column name */
  LastSyncRouteAt = 'last_sync_route_at',
  /** column name */
  LicensePlate = 'license_plate',
  /** column name */
  Odometrotrip = 'odometrotrip',
  /** column name */
  Rastreadofim = 'rastreadofim',
  /** column name */
  Rastreadoinicio = 'rastreadoinicio',
  /** column name */
  RiskIntensity = 'risk_intensity',
  /** column name */
  SeverityLevel = 'severity_level',
  /** column name */
  SeverityLevelSetAt = 'severity_level_set_at',
  /** column name */
  SeverityLevelSetByAdminUuid = 'severity_level_set_by_admin_uuid',
  /** column name */
  TripData = 'trip_data',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  TripIdOrCodmotoLicensePlateDtinicioanaliseKey = 'trip_id_or_codmoto_license_plate_dtinicioanalise_key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WarningMessage = 'warning_message'
}

/** select "driver_warning_trip_aggregate_bool_exp_avg_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** select "driver_warning_trip_aggregate_bool_exp_corr_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** select "driver_warning_trip_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** select "driver_warning_trip_aggregate_bool_exp_max_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** select "driver_warning_trip_aggregate_bool_exp_min_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** select "driver_warning_trip_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** select "driver_warning_trip_aggregate_bool_exp_sum_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** select "driver_warning_trip_aggregate_bool_exp_var_samp_arguments_columns" columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Select_Column_Driver_Warning_Trip_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  Odometrotrip = 'odometrotrip'
}

/** input type for updating data in table "driver_warning_trip" */
export type Driver_Warning_Trip_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  last_sync_route_at?: InputMaybe<Scalars['timestamptz']['input']>;
  risk_intensity?: InputMaybe<Scalars['Float']['input']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Scalars['Int']['input']>;
  /** When the severity level was set */
  severity_level_set_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  trip_data?: InputMaybe<Scalars['jsonb']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  warning_message?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity = {
  __typename?: 'driver_warning_trip_severity';
  color_hex: Scalars['String']['output'];
  description: Scalars['String']['output'];
  /** An array relationship */
  driver_warning_trips: Array<Driver_Warning_Trip>;
  /** An aggregate relationship */
  driver_warning_trips_aggregate: Driver_Warning_Trip_Aggregate;
  severity_level: Scalars['Int']['output'];
};


/** columns and relationships of "driver_warning_trip_severity" */
export type Driver_Warning_Trip_SeverityDriver_Warning_TripsArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};


/** columns and relationships of "driver_warning_trip_severity" */
export type Driver_Warning_Trip_SeverityDriver_Warning_Trips_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};

/** aggregated selection of "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Aggregate = {
  __typename?: 'driver_warning_trip_severity_aggregate';
  aggregate: Maybe<Driver_Warning_Trip_Severity_Aggregate_Fields>;
  nodes: Array<Driver_Warning_Trip_Severity>;
};

/** aggregate fields of "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Aggregate_Fields = {
  __typename?: 'driver_warning_trip_severity_aggregate_fields';
  avg: Maybe<Driver_Warning_Trip_Severity_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Driver_Warning_Trip_Severity_Max_Fields>;
  min: Maybe<Driver_Warning_Trip_Severity_Min_Fields>;
  stddev: Maybe<Driver_Warning_Trip_Severity_Stddev_Fields>;
  stddev_pop: Maybe<Driver_Warning_Trip_Severity_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Driver_Warning_Trip_Severity_Stddev_Samp_Fields>;
  sum: Maybe<Driver_Warning_Trip_Severity_Sum_Fields>;
  var_pop: Maybe<Driver_Warning_Trip_Severity_Var_Pop_Fields>;
  var_samp: Maybe<Driver_Warning_Trip_Severity_Var_Samp_Fields>;
  variance: Maybe<Driver_Warning_Trip_Severity_Variance_Fields>;
};


/** aggregate fields of "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Warning_Trip_Severity_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driver_Warning_Trip_Severity_Avg_Fields = {
  __typename?: 'driver_warning_trip_severity_avg_fields';
  severity_level: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driver_warning_trip_severity". All fields are combined with a logical 'AND'. */
export type Driver_Warning_Trip_Severity_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Warning_Trip_Severity_Bool_Exp>>;
  _not?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Warning_Trip_Severity_Bool_Exp>>;
  color_hex?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  driver_warning_trips?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
  driver_warning_trips_aggregate?: InputMaybe<Driver_Warning_Trip_Aggregate_Bool_Exp>;
  severity_level?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "driver_warning_trip_severity" */
export enum Driver_Warning_Trip_Severity_Constraint {
  /** unique or primary key constraint on columns "severity_level" */
  DriverWarningTripSeverityPkey = 'driver_warning_trip_severity_pkey'
}

/** input type for incrementing numeric columns in table "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Inc_Input = {
  severity_level?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Insert_Input = {
  color_hex?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  driver_warning_trips?: InputMaybe<Driver_Warning_Trip_Arr_Rel_Insert_Input>;
  severity_level?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Driver_Warning_Trip_Severity_Max_Fields = {
  __typename?: 'driver_warning_trip_severity_max_fields';
  color_hex: Maybe<Scalars['String']['output']>;
  description: Maybe<Scalars['String']['output']>;
  severity_level: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Driver_Warning_Trip_Severity_Min_Fields = {
  __typename?: 'driver_warning_trip_severity_min_fields';
  color_hex: Maybe<Scalars['String']['output']>;
  description: Maybe<Scalars['String']['output']>;
  severity_level: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Mutation_Response = {
  __typename?: 'driver_warning_trip_severity_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driver_Warning_Trip_Severity>;
};

/** input type for inserting object relation for remote table "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Obj_Rel_Insert_Input = {
  data: Driver_Warning_Trip_Severity_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Driver_Warning_Trip_Severity_On_Conflict>;
};

/** on_conflict condition type for table "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_On_Conflict = {
  constraint: Driver_Warning_Trip_Severity_Constraint;
  update_columns?: Array<Driver_Warning_Trip_Severity_Update_Column>;
  where?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
};

/** Ordering options when selecting data from "driver_warning_trip_severity". */
export type Driver_Warning_Trip_Severity_Order_By = {
  color_hex?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  driver_warning_trips_aggregate?: InputMaybe<Driver_Warning_Trip_Aggregate_Order_By>;
  severity_level?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driver_warning_trip_severity */
export type Driver_Warning_Trip_Severity_Pk_Columns_Input = {
  severity_level: Scalars['Int']['input'];
};

/** select columns of table "driver_warning_trip_severity" */
export enum Driver_Warning_Trip_Severity_Select_Column {
  /** column name */
  ColorHex = 'color_hex',
  /** column name */
  Description = 'description',
  /** column name */
  SeverityLevel = 'severity_level'
}

/** input type for updating data in table "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Set_Input = {
  color_hex?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  severity_level?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Driver_Warning_Trip_Severity_Stddev_Fields = {
  __typename?: 'driver_warning_trip_severity_stddev_fields';
  severity_level: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driver_Warning_Trip_Severity_Stddev_Pop_Fields = {
  __typename?: 'driver_warning_trip_severity_stddev_pop_fields';
  severity_level: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driver_Warning_Trip_Severity_Stddev_Samp_Fields = {
  __typename?: 'driver_warning_trip_severity_stddev_samp_fields';
  severity_level: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driver_warning_trip_severity" */
export type Driver_Warning_Trip_Severity_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Trip_Severity_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Trip_Severity_Stream_Cursor_Value_Input = {
  color_hex?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  severity_level?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Driver_Warning_Trip_Severity_Sum_Fields = {
  __typename?: 'driver_warning_trip_severity_sum_fields';
  severity_level: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "driver_warning_trip_severity" */
export enum Driver_Warning_Trip_Severity_Update_Column {
  /** column name */
  ColorHex = 'color_hex',
  /** column name */
  Description = 'description',
  /** column name */
  SeverityLevel = 'severity_level'
}

export type Driver_Warning_Trip_Severity_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driver_Warning_Trip_Severity_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driver_Warning_Trip_Severity_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driver_Warning_Trip_Severity_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driver_Warning_Trip_Severity_Var_Pop_Fields = {
  __typename?: 'driver_warning_trip_severity_var_pop_fields';
  severity_level: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driver_Warning_Trip_Severity_Var_Samp_Fields = {
  __typename?: 'driver_warning_trip_severity_var_samp_fields';
  severity_level: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driver_Warning_Trip_Severity_Variance_Fields = {
  __typename?: 'driver_warning_trip_severity_variance_fields';
  severity_level: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev on columns */
export type Driver_Warning_Trip_Stddev_Fields = {
  __typename?: 'driver_warning_trip_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
  odometrotrip: Maybe<Scalars['Float']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driver_Warning_Trip_Stddev_Pop_Fields = {
  __typename?: 'driver_warning_trip_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  odometrotrip: Maybe<Scalars['Float']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driver_Warning_Trip_Stddev_Samp_Fields = {
  __typename?: 'driver_warning_trip_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  odometrotrip: Maybe<Scalars['Float']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driver_warning_trip" */
export type Driver_Warning_Trip_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Warning_Trip_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Warning_Trip_Stream_Cursor_Value_Input = {
  codmoto?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
  dtfimanalise?: InputMaybe<Scalars['String']['input']>;
  dtinicioanalise?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  last_sync_route_at?: InputMaybe<Scalars['timestamptz']['input']>;
  license_plate?: InputMaybe<Scalars['String']['input']>;
  odometrotrip?: InputMaybe<Scalars['float8']['input']>;
  rastreadofim?: InputMaybe<Scalars['String']['input']>;
  rastreadoinicio?: InputMaybe<Scalars['String']['input']>;
  risk_intensity?: InputMaybe<Scalars['Float']['input']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Scalars['Int']['input']>;
  /** When the severity level was set */
  severity_level_set_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** What admin set the severity level */
  severity_level_set_by_admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  trip_data?: InputMaybe<Scalars['jsonb']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
  trip_id_or_codmoto_license_plate_dtinicioanalise_key?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  warning_message?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Driver_Warning_Trip_Sum_Fields = {
  __typename?: 'driver_warning_trip_sum_fields';
  id: Maybe<Scalars['Int']['output']>;
  odometrotrip: Maybe<Scalars['float8']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Int']['output']>;
  trip_id: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** update columns of table "driver_warning_trip" */
export enum Driver_Warning_Trip_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverWarningUuid = 'driver_warning_uuid',
  /** column name */
  Id = 'id',
  /** column name */
  LastSyncRouteAt = 'last_sync_route_at',
  /** column name */
  RiskIntensity = 'risk_intensity',
  /** column name */
  SeverityLevel = 'severity_level',
  /** column name */
  SeverityLevelSetAt = 'severity_level_set_at',
  /** column name */
  SeverityLevelSetByAdminUuid = 'severity_level_set_by_admin_uuid',
  /** column name */
  TripData = 'trip_data',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WarningMessage = 'warning_message'
}

export type Driver_Warning_Trip_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Driver_Warning_Trip_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Driver_Warning_Trip_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Driver_Warning_Trip_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Driver_Warning_Trip_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driver_Warning_Trip_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Driver_Warning_Trip_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driver_Warning_Trip_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driver_Warning_Trip_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driver_Warning_Trip_Var_Pop_Fields = {
  __typename?: 'driver_warning_trip_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  odometrotrip: Maybe<Scalars['Float']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driver_Warning_Trip_Var_Samp_Fields = {
  __typename?: 'driver_warning_trip_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  odometrotrip: Maybe<Scalars['Float']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driver_Warning_Trip_Variance_Fields = {
  __typename?: 'driver_warning_trip_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
  odometrotrip: Maybe<Scalars['Float']['output']>;
  risk_intensity: Maybe<Scalars['Float']['output']>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level: Maybe<Scalars['Float']['output']>;
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driver_warning_trip" */
export type Driver_Warning_Trip_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  odometrotrip?: InputMaybe<Order_By>;
  risk_intensity?: InputMaybe<Order_By>;
  /** The severity level set by an admin that tells if the trip was good/bad and so on. */
  severity_level?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** update columns of table "driver_warning" */
export enum Driver_Warning_Update_Column {
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ProcessedAt = 'processed_at',
  /** column name */
  ReferenceDate = 'reference_date',
  /** column name */
  RiskIntensity = 'risk_intensity',
  /** column name */
  RiskIntesity = 'risk_intesity',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WarningMessage = 'warning_message'
}

export type Driver_Warning_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driver_Warning_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driver_Warning_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driver_Warning_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driver_Warning_Var_Pop_Fields = {
  __typename?: 'driver_warning_var_pop_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
  risk_intesity: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driver_warning" */
export type Driver_Warning_Var_Pop_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driver_Warning_Var_Samp_Fields = {
  __typename?: 'driver_warning_var_samp_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
  risk_intesity: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driver_warning" */
export type Driver_Warning_Var_Samp_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driver_Warning_Variance_Fields = {
  __typename?: 'driver_warning_variance_fields';
  risk_intensity: Maybe<Scalars['Float']['output']>;
  risk_intesity: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driver_warning" */
export type Driver_Warning_Variance_Order_By = {
  risk_intensity?: InputMaybe<Order_By>;
  risk_intesity?: InputMaybe<Order_By>;
};

/** columns and relationships of "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job = {
  __typename?: 'edi_busca_nfe_job';
  /** An array relationship */
  busca_nfe_responses: Array<Edi_Busca_Nfe_Response>;
  /** An aggregate relationship */
  busca_nfe_responses_aggregate: Edi_Busca_Nfe_Response_Aggregate;
  /** When there's a lot of NFs on the queue and you want to stop the job securely after the current NF finish processing. */
  end_requested_at: Maybe<Scalars['timestamptz']['output']>;
  ended_at: Maybe<Scalars['timestamptz']['output']>;
  error: Maybe<Scalars['jsonb']['output']>;
  last_keep_alive_at: Scalars['timestamptz']['output'];
  started_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_JobBusca_Nfe_ResponsesArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Response_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};


/** columns and relationships of "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_JobBusca_Nfe_Responses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Response_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};


/** columns and relationships of "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_JobErrorArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Aggregate = {
  __typename?: 'edi_busca_nfe_job_aggregate';
  aggregate: Maybe<Edi_Busca_Nfe_Job_Aggregate_Fields>;
  nodes: Array<Edi_Busca_Nfe_Job>;
};

/** aggregate fields of "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Aggregate_Fields = {
  __typename?: 'edi_busca_nfe_job_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Edi_Busca_Nfe_Job_Max_Fields>;
  min: Maybe<Edi_Busca_Nfe_Job_Min_Fields>;
};


/** aggregate fields of "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Edi_Busca_Nfe_Job_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Edi_Busca_Nfe_Job_Append_Input = {
  error?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "edi.busca_nfe_job". All fields are combined with a logical 'AND'. */
export type Edi_Busca_Nfe_Job_Bool_Exp = {
  _and?: InputMaybe<Array<Edi_Busca_Nfe_Job_Bool_Exp>>;
  _not?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
  _or?: InputMaybe<Array<Edi_Busca_Nfe_Job_Bool_Exp>>;
  busca_nfe_responses?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
  busca_nfe_responses_aggregate?: InputMaybe<Edi_Busca_Nfe_Response_Aggregate_Bool_Exp>;
  end_requested_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  ended_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  error?: InputMaybe<Jsonb_Comparison_Exp>;
  last_keep_alive_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "edi.busca_nfe_job" */
export enum Edi_Busca_Nfe_Job_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  BuscaNfeJobPkey = 'busca_nfe_job_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Edi_Busca_Nfe_Job_Delete_At_Path_Input = {
  error?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Edi_Busca_Nfe_Job_Delete_Elem_Input = {
  error?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Edi_Busca_Nfe_Job_Delete_Key_Input = {
  error?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Insert_Input = {
  busca_nfe_responses?: InputMaybe<Edi_Busca_Nfe_Response_Arr_Rel_Insert_Input>;
  /** When there's a lot of NFs on the queue and you want to stop the job securely after the current NF finish processing. */
  end_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ended_at?: InputMaybe<Scalars['timestamptz']['input']>;
  error?: InputMaybe<Scalars['jsonb']['input']>;
  last_keep_alive_at?: InputMaybe<Scalars['timestamptz']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Edi_Busca_Nfe_Job_Max_Fields = {
  __typename?: 'edi_busca_nfe_job_max_fields';
  /** When there's a lot of NFs on the queue and you want to stop the job securely after the current NF finish processing. */
  end_requested_at: Maybe<Scalars['timestamptz']['output']>;
  ended_at: Maybe<Scalars['timestamptz']['output']>;
  last_keep_alive_at: Maybe<Scalars['timestamptz']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Edi_Busca_Nfe_Job_Min_Fields = {
  __typename?: 'edi_busca_nfe_job_min_fields';
  /** When there's a lot of NFs on the queue and you want to stop the job securely after the current NF finish processing. */
  end_requested_at: Maybe<Scalars['timestamptz']['output']>;
  ended_at: Maybe<Scalars['timestamptz']['output']>;
  last_keep_alive_at: Maybe<Scalars['timestamptz']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Mutation_Response = {
  __typename?: 'edi_busca_nfe_job_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Edi_Busca_Nfe_Job>;
};

/** input type for inserting object relation for remote table "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Obj_Rel_Insert_Input = {
  data: Edi_Busca_Nfe_Job_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Edi_Busca_Nfe_Job_On_Conflict>;
};

/** on_conflict condition type for table "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_On_Conflict = {
  constraint: Edi_Busca_Nfe_Job_Constraint;
  update_columns?: Array<Edi_Busca_Nfe_Job_Update_Column>;
  where?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
};

/** Ordering options when selecting data from "edi.busca_nfe_job". */
export type Edi_Busca_Nfe_Job_Order_By = {
  busca_nfe_responses_aggregate?: InputMaybe<Edi_Busca_Nfe_Response_Aggregate_Order_By>;
  end_requested_at?: InputMaybe<Order_By>;
  ended_at?: InputMaybe<Order_By>;
  error?: InputMaybe<Order_By>;
  last_keep_alive_at?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: edi.busca_nfe_job */
export type Edi_Busca_Nfe_Job_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Edi_Busca_Nfe_Job_Prepend_Input = {
  error?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "edi.busca_nfe_job" */
export enum Edi_Busca_Nfe_Job_Select_Column {
  /** column name */
  EndRequestedAt = 'end_requested_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Error = 'error',
  /** column name */
  LastKeepAliveAt = 'last_keep_alive_at',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "edi.busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Set_Input = {
  /** When there's a lot of NFs on the queue and you want to stop the job securely after the current NF finish processing. */
  end_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ended_at?: InputMaybe<Scalars['timestamptz']['input']>;
  error?: InputMaybe<Scalars['jsonb']['input']>;
  last_keep_alive_at?: InputMaybe<Scalars['timestamptz']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "edi_busca_nfe_job" */
export type Edi_Busca_Nfe_Job_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Edi_Busca_Nfe_Job_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Edi_Busca_Nfe_Job_Stream_Cursor_Value_Input = {
  /** When there's a lot of NFs on the queue and you want to stop the job securely after the current NF finish processing. */
  end_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ended_at?: InputMaybe<Scalars['timestamptz']['input']>;
  error?: InputMaybe<Scalars['jsonb']['input']>;
  last_keep_alive_at?: InputMaybe<Scalars['timestamptz']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "edi.busca_nfe_job" */
export enum Edi_Busca_Nfe_Job_Update_Column {
  /** column name */
  EndRequestedAt = 'end_requested_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Error = 'error',
  /** column name */
  LastKeepAliveAt = 'last_keep_alive_at',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  Uuid = 'uuid'
}

export type Edi_Busca_Nfe_Job_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Edi_Busca_Nfe_Job_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Edi_Busca_Nfe_Job_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Edi_Busca_Nfe_Job_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Edi_Busca_Nfe_Job_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Edi_Busca_Nfe_Job_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Edi_Busca_Nfe_Job_Set_Input>;
  /** filter the rows which have to be updated */
  where: Edi_Busca_Nfe_Job_Bool_Exp;
};

/** columns and relationships of "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response = {
  __typename?: 'edi_busca_nfe_response';
  BRM: Maybe<Scalars['String']['output']>;
  CHAVE_INBOUND: Maybe<Scalars['String']['output']>;
  CNPJ_MOTORISTA: Maybe<Scalars['String']['output']>;
  CNPJ_TRANSPORTADORA: Maybe<Scalars['String']['output']>;
  DATA_BRM: Maybe<Scalars['String']['output']>;
  LASTNFE: Maybe<Scalars['String']['output']>;
  LOCAL_TRANSPORTE: Maybe<Scalars['String']['output']>;
  MOTORISTA: Maybe<Scalars['String']['output']>;
  PAGADOR_FRETE: Maybe<Scalars['String']['output']>;
  PESO_BRUTO: Maybe<Scalars['String']['output']>;
  PESO_DESCARREGADO: Maybe<Scalars['String']['output']>;
  PLACA: Maybe<Scalars['String']['output']>;
  PLACA_CAVALO: Maybe<Scalars['String']['output']>;
  TARA: Maybe<Scalars['String']['output']>;
  TRANSPORTE: Maybe<Scalars['String']['output']>;
  VALORCF: Maybe<Scalars['String']['output']>;
  XMLNFE: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  busca_nfe_job: Edi_Busca_Nfe_Job;
  busca_nfe_job_uuid: Scalars['uuid']['output'];
  created_at: Scalars['timestamptz']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Aggregate = {
  __typename?: 'edi_busca_nfe_response_aggregate';
  aggregate: Maybe<Edi_Busca_Nfe_Response_Aggregate_Fields>;
  nodes: Array<Edi_Busca_Nfe_Response>;
};

export type Edi_Busca_Nfe_Response_Aggregate_Bool_Exp = {
  count?: InputMaybe<Edi_Busca_Nfe_Response_Aggregate_Bool_Exp_Count>;
};

export type Edi_Busca_Nfe_Response_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Aggregate_Fields = {
  __typename?: 'edi_busca_nfe_response_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Edi_Busca_Nfe_Response_Max_Fields>;
  min: Maybe<Edi_Busca_Nfe_Response_Min_Fields>;
};


/** aggregate fields of "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Edi_Busca_Nfe_Response_Max_Order_By>;
  min?: InputMaybe<Edi_Busca_Nfe_Response_Min_Order_By>;
};

/** input type for inserting array relation for remote table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Arr_Rel_Insert_Input = {
  data: Array<Edi_Busca_Nfe_Response_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Edi_Busca_Nfe_Response_On_Conflict>;
};

/** Boolean expression to filter rows from the table "edi.busca_nfe_response". All fields are combined with a logical 'AND'. */
export type Edi_Busca_Nfe_Response_Bool_Exp = {
  BRM?: InputMaybe<String_Comparison_Exp>;
  CHAVE_INBOUND?: InputMaybe<String_Comparison_Exp>;
  CNPJ_MOTORISTA?: InputMaybe<String_Comparison_Exp>;
  CNPJ_TRANSPORTADORA?: InputMaybe<String_Comparison_Exp>;
  DATA_BRM?: InputMaybe<String_Comparison_Exp>;
  LASTNFE?: InputMaybe<String_Comparison_Exp>;
  LOCAL_TRANSPORTE?: InputMaybe<String_Comparison_Exp>;
  MOTORISTA?: InputMaybe<String_Comparison_Exp>;
  PAGADOR_FRETE?: InputMaybe<String_Comparison_Exp>;
  PESO_BRUTO?: InputMaybe<String_Comparison_Exp>;
  PESO_DESCARREGADO?: InputMaybe<String_Comparison_Exp>;
  PLACA?: InputMaybe<String_Comparison_Exp>;
  PLACA_CAVALO?: InputMaybe<String_Comparison_Exp>;
  TARA?: InputMaybe<String_Comparison_Exp>;
  TRANSPORTE?: InputMaybe<String_Comparison_Exp>;
  VALORCF?: InputMaybe<String_Comparison_Exp>;
  XMLNFE?: InputMaybe<String_Comparison_Exp>;
  _and?: InputMaybe<Array<Edi_Busca_Nfe_Response_Bool_Exp>>;
  _not?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
  _or?: InputMaybe<Array<Edi_Busca_Nfe_Response_Bool_Exp>>;
  busca_nfe_job?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
  busca_nfe_job_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "edi.busca_nfe_response" */
export enum Edi_Busca_Nfe_Response_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  BuscaNfeResponsePkey = 'busca_nfe_response_pkey'
}

/** input type for inserting data into table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Insert_Input = {
  BRM?: InputMaybe<Scalars['String']['input']>;
  CHAVE_INBOUND?: InputMaybe<Scalars['String']['input']>;
  CNPJ_MOTORISTA?: InputMaybe<Scalars['String']['input']>;
  CNPJ_TRANSPORTADORA?: InputMaybe<Scalars['String']['input']>;
  DATA_BRM?: InputMaybe<Scalars['String']['input']>;
  LASTNFE?: InputMaybe<Scalars['String']['input']>;
  LOCAL_TRANSPORTE?: InputMaybe<Scalars['String']['input']>;
  MOTORISTA?: InputMaybe<Scalars['String']['input']>;
  PAGADOR_FRETE?: InputMaybe<Scalars['String']['input']>;
  PESO_BRUTO?: InputMaybe<Scalars['String']['input']>;
  PESO_DESCARREGADO?: InputMaybe<Scalars['String']['input']>;
  PLACA?: InputMaybe<Scalars['String']['input']>;
  PLACA_CAVALO?: InputMaybe<Scalars['String']['input']>;
  TARA?: InputMaybe<Scalars['String']['input']>;
  TRANSPORTE?: InputMaybe<Scalars['String']['input']>;
  VALORCF?: InputMaybe<Scalars['String']['input']>;
  XMLNFE?: InputMaybe<Scalars['String']['input']>;
  busca_nfe_job?: InputMaybe<Edi_Busca_Nfe_Job_Obj_Rel_Insert_Input>;
  busca_nfe_job_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Edi_Busca_Nfe_Response_Max_Fields = {
  __typename?: 'edi_busca_nfe_response_max_fields';
  BRM: Maybe<Scalars['String']['output']>;
  CHAVE_INBOUND: Maybe<Scalars['String']['output']>;
  CNPJ_MOTORISTA: Maybe<Scalars['String']['output']>;
  CNPJ_TRANSPORTADORA: Maybe<Scalars['String']['output']>;
  DATA_BRM: Maybe<Scalars['String']['output']>;
  LASTNFE: Maybe<Scalars['String']['output']>;
  LOCAL_TRANSPORTE: Maybe<Scalars['String']['output']>;
  MOTORISTA: Maybe<Scalars['String']['output']>;
  PAGADOR_FRETE: Maybe<Scalars['String']['output']>;
  PESO_BRUTO: Maybe<Scalars['String']['output']>;
  PESO_DESCARREGADO: Maybe<Scalars['String']['output']>;
  PLACA: Maybe<Scalars['String']['output']>;
  PLACA_CAVALO: Maybe<Scalars['String']['output']>;
  TARA: Maybe<Scalars['String']['output']>;
  TRANSPORTE: Maybe<Scalars['String']['output']>;
  VALORCF: Maybe<Scalars['String']['output']>;
  XMLNFE: Maybe<Scalars['String']['output']>;
  busca_nfe_job_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Max_Order_By = {
  BRM?: InputMaybe<Order_By>;
  CHAVE_INBOUND?: InputMaybe<Order_By>;
  CNPJ_MOTORISTA?: InputMaybe<Order_By>;
  CNPJ_TRANSPORTADORA?: InputMaybe<Order_By>;
  DATA_BRM?: InputMaybe<Order_By>;
  LASTNFE?: InputMaybe<Order_By>;
  LOCAL_TRANSPORTE?: InputMaybe<Order_By>;
  MOTORISTA?: InputMaybe<Order_By>;
  PAGADOR_FRETE?: InputMaybe<Order_By>;
  PESO_BRUTO?: InputMaybe<Order_By>;
  PESO_DESCARREGADO?: InputMaybe<Order_By>;
  PLACA?: InputMaybe<Order_By>;
  PLACA_CAVALO?: InputMaybe<Order_By>;
  TARA?: InputMaybe<Order_By>;
  TRANSPORTE?: InputMaybe<Order_By>;
  VALORCF?: InputMaybe<Order_By>;
  XMLNFE?: InputMaybe<Order_By>;
  busca_nfe_job_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Edi_Busca_Nfe_Response_Min_Fields = {
  __typename?: 'edi_busca_nfe_response_min_fields';
  BRM: Maybe<Scalars['String']['output']>;
  CHAVE_INBOUND: Maybe<Scalars['String']['output']>;
  CNPJ_MOTORISTA: Maybe<Scalars['String']['output']>;
  CNPJ_TRANSPORTADORA: Maybe<Scalars['String']['output']>;
  DATA_BRM: Maybe<Scalars['String']['output']>;
  LASTNFE: Maybe<Scalars['String']['output']>;
  LOCAL_TRANSPORTE: Maybe<Scalars['String']['output']>;
  MOTORISTA: Maybe<Scalars['String']['output']>;
  PAGADOR_FRETE: Maybe<Scalars['String']['output']>;
  PESO_BRUTO: Maybe<Scalars['String']['output']>;
  PESO_DESCARREGADO: Maybe<Scalars['String']['output']>;
  PLACA: Maybe<Scalars['String']['output']>;
  PLACA_CAVALO: Maybe<Scalars['String']['output']>;
  TARA: Maybe<Scalars['String']['output']>;
  TRANSPORTE: Maybe<Scalars['String']['output']>;
  VALORCF: Maybe<Scalars['String']['output']>;
  XMLNFE: Maybe<Scalars['String']['output']>;
  busca_nfe_job_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Min_Order_By = {
  BRM?: InputMaybe<Order_By>;
  CHAVE_INBOUND?: InputMaybe<Order_By>;
  CNPJ_MOTORISTA?: InputMaybe<Order_By>;
  CNPJ_TRANSPORTADORA?: InputMaybe<Order_By>;
  DATA_BRM?: InputMaybe<Order_By>;
  LASTNFE?: InputMaybe<Order_By>;
  LOCAL_TRANSPORTE?: InputMaybe<Order_By>;
  MOTORISTA?: InputMaybe<Order_By>;
  PAGADOR_FRETE?: InputMaybe<Order_By>;
  PESO_BRUTO?: InputMaybe<Order_By>;
  PESO_DESCARREGADO?: InputMaybe<Order_By>;
  PLACA?: InputMaybe<Order_By>;
  PLACA_CAVALO?: InputMaybe<Order_By>;
  TARA?: InputMaybe<Order_By>;
  TRANSPORTE?: InputMaybe<Order_By>;
  VALORCF?: InputMaybe<Order_By>;
  XMLNFE?: InputMaybe<Order_By>;
  busca_nfe_job_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Mutation_Response = {
  __typename?: 'edi_busca_nfe_response_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Edi_Busca_Nfe_Response>;
};

/** on_conflict condition type for table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_On_Conflict = {
  constraint: Edi_Busca_Nfe_Response_Constraint;
  update_columns?: Array<Edi_Busca_Nfe_Response_Update_Column>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};

/** Ordering options when selecting data from "edi.busca_nfe_response". */
export type Edi_Busca_Nfe_Response_Order_By = {
  BRM?: InputMaybe<Order_By>;
  CHAVE_INBOUND?: InputMaybe<Order_By>;
  CNPJ_MOTORISTA?: InputMaybe<Order_By>;
  CNPJ_TRANSPORTADORA?: InputMaybe<Order_By>;
  DATA_BRM?: InputMaybe<Order_By>;
  LASTNFE?: InputMaybe<Order_By>;
  LOCAL_TRANSPORTE?: InputMaybe<Order_By>;
  MOTORISTA?: InputMaybe<Order_By>;
  PAGADOR_FRETE?: InputMaybe<Order_By>;
  PESO_BRUTO?: InputMaybe<Order_By>;
  PESO_DESCARREGADO?: InputMaybe<Order_By>;
  PLACA?: InputMaybe<Order_By>;
  PLACA_CAVALO?: InputMaybe<Order_By>;
  TARA?: InputMaybe<Order_By>;
  TRANSPORTE?: InputMaybe<Order_By>;
  VALORCF?: InputMaybe<Order_By>;
  XMLNFE?: InputMaybe<Order_By>;
  busca_nfe_job?: InputMaybe<Edi_Busca_Nfe_Job_Order_By>;
  busca_nfe_job_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: edi.busca_nfe_response */
export type Edi_Busca_Nfe_Response_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "edi.busca_nfe_response" */
export enum Edi_Busca_Nfe_Response_Select_Column {
  /** column name */
  Brm = 'BRM',
  /** column name */
  ChaveInbound = 'CHAVE_INBOUND',
  /** column name */
  CnpjMotorista = 'CNPJ_MOTORISTA',
  /** column name */
  CnpjTransportadora = 'CNPJ_TRANSPORTADORA',
  /** column name */
  DataBrm = 'DATA_BRM',
  /** column name */
  Lastnfe = 'LASTNFE',
  /** column name */
  LocalTransporte = 'LOCAL_TRANSPORTE',
  /** column name */
  Motorista = 'MOTORISTA',
  /** column name */
  PagadorFrete = 'PAGADOR_FRETE',
  /** column name */
  PesoBruto = 'PESO_BRUTO',
  /** column name */
  PesoDescarregado = 'PESO_DESCARREGADO',
  /** column name */
  Placa = 'PLACA',
  /** column name */
  PlacaCavalo = 'PLACA_CAVALO',
  /** column name */
  Tara = 'TARA',
  /** column name */
  Transporte = 'TRANSPORTE',
  /** column name */
  Valorcf = 'VALORCF',
  /** column name */
  Xmlnfe = 'XMLNFE',
  /** column name */
  BuscaNfeJobUuid = 'busca_nfe_job_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "edi.busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Set_Input = {
  BRM?: InputMaybe<Scalars['String']['input']>;
  CHAVE_INBOUND?: InputMaybe<Scalars['String']['input']>;
  CNPJ_MOTORISTA?: InputMaybe<Scalars['String']['input']>;
  CNPJ_TRANSPORTADORA?: InputMaybe<Scalars['String']['input']>;
  DATA_BRM?: InputMaybe<Scalars['String']['input']>;
  LASTNFE?: InputMaybe<Scalars['String']['input']>;
  LOCAL_TRANSPORTE?: InputMaybe<Scalars['String']['input']>;
  MOTORISTA?: InputMaybe<Scalars['String']['input']>;
  PAGADOR_FRETE?: InputMaybe<Scalars['String']['input']>;
  PESO_BRUTO?: InputMaybe<Scalars['String']['input']>;
  PESO_DESCARREGADO?: InputMaybe<Scalars['String']['input']>;
  PLACA?: InputMaybe<Scalars['String']['input']>;
  PLACA_CAVALO?: InputMaybe<Scalars['String']['input']>;
  TARA?: InputMaybe<Scalars['String']['input']>;
  TRANSPORTE?: InputMaybe<Scalars['String']['input']>;
  VALORCF?: InputMaybe<Scalars['String']['input']>;
  XMLNFE?: InputMaybe<Scalars['String']['input']>;
  busca_nfe_job_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "edi_busca_nfe_response" */
export type Edi_Busca_Nfe_Response_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Edi_Busca_Nfe_Response_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Edi_Busca_Nfe_Response_Stream_Cursor_Value_Input = {
  BRM?: InputMaybe<Scalars['String']['input']>;
  CHAVE_INBOUND?: InputMaybe<Scalars['String']['input']>;
  CNPJ_MOTORISTA?: InputMaybe<Scalars['String']['input']>;
  CNPJ_TRANSPORTADORA?: InputMaybe<Scalars['String']['input']>;
  DATA_BRM?: InputMaybe<Scalars['String']['input']>;
  LASTNFE?: InputMaybe<Scalars['String']['input']>;
  LOCAL_TRANSPORTE?: InputMaybe<Scalars['String']['input']>;
  MOTORISTA?: InputMaybe<Scalars['String']['input']>;
  PAGADOR_FRETE?: InputMaybe<Scalars['String']['input']>;
  PESO_BRUTO?: InputMaybe<Scalars['String']['input']>;
  PESO_DESCARREGADO?: InputMaybe<Scalars['String']['input']>;
  PLACA?: InputMaybe<Scalars['String']['input']>;
  PLACA_CAVALO?: InputMaybe<Scalars['String']['input']>;
  TARA?: InputMaybe<Scalars['String']['input']>;
  TRANSPORTE?: InputMaybe<Scalars['String']['input']>;
  VALORCF?: InputMaybe<Scalars['String']['input']>;
  XMLNFE?: InputMaybe<Scalars['String']['input']>;
  busca_nfe_job_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "edi.busca_nfe_response" */
export enum Edi_Busca_Nfe_Response_Update_Column {
  /** column name */
  Brm = 'BRM',
  /** column name */
  ChaveInbound = 'CHAVE_INBOUND',
  /** column name */
  CnpjMotorista = 'CNPJ_MOTORISTA',
  /** column name */
  CnpjTransportadora = 'CNPJ_TRANSPORTADORA',
  /** column name */
  DataBrm = 'DATA_BRM',
  /** column name */
  Lastnfe = 'LASTNFE',
  /** column name */
  LocalTransporte = 'LOCAL_TRANSPORTE',
  /** column name */
  Motorista = 'MOTORISTA',
  /** column name */
  PagadorFrete = 'PAGADOR_FRETE',
  /** column name */
  PesoBruto = 'PESO_BRUTO',
  /** column name */
  PesoDescarregado = 'PESO_DESCARREGADO',
  /** column name */
  Placa = 'PLACA',
  /** column name */
  PlacaCavalo = 'PLACA_CAVALO',
  /** column name */
  Tara = 'TARA',
  /** column name */
  Transporte = 'TRANSPORTE',
  /** column name */
  Valorcf = 'VALORCF',
  /** column name */
  Xmlnfe = 'XMLNFE',
  /** column name */
  BuscaNfeJobUuid = 'busca_nfe_job_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Edi_Busca_Nfe_Response_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Edi_Busca_Nfe_Response_Set_Input>;
  /** filter the rows which have to be updated */
  where: Edi_Busca_Nfe_Response_Bool_Exp;
};

/** columns and relationships of "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point = {
  __typename?: 'empty_tables_critical_segment_from_critical_point';
  end_percentage: Maybe<Scalars['float8']['output']>;
  end_point: Maybe<Scalars['String']['output']>;
  geojson: Maybe<Scalars['jsonb']['output']>;
  intersection_linestring: Maybe<Scalars['String']['output']>;
  length_meters: Maybe<Scalars['float8']['output']>;
  start_percentage: Maybe<Scalars['float8']['output']>;
  start_point: Maybe<Scalars['String']['output']>;
  way_osm_id: Maybe<Scalars['bigint']['output']>;
};


/** columns and relationships of "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_PointGeojsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_aggregate';
  aggregate: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate_Fields>;
  nodes: Array<Empty_Tables_Critical_Segment_From_Critical_Point>;
};

/** aggregate fields of "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_aggregate_fields';
  avg: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Max_Fields>;
  min: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Min_Fields>;
  stddev: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Stddev_Fields>;
  stddev_pop: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Stddev_Samp_Fields>;
  sum: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Sum_Fields>;
  var_pop: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Var_Pop_Fields>;
  var_samp: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Var_Samp_Fields>;
  variance: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Variance_Fields>;
};


/** aggregate fields of "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Append_Input = {
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Avg_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_avg_fields';
  end_percentage: Maybe<Scalars['Float']['output']>;
  length_meters: Maybe<Scalars['Float']['output']>;
  start_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "empty_tables.critical_segment_from_critical_point". All fields are combined with a logical 'AND'. */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp = {
  _and?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>>;
  _not?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
  _or?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>>;
  end_percentage?: InputMaybe<Float8_Comparison_Exp>;
  end_point?: InputMaybe<String_Comparison_Exp>;
  geojson?: InputMaybe<Jsonb_Comparison_Exp>;
  intersection_linestring?: InputMaybe<String_Comparison_Exp>;
  length_meters?: InputMaybe<Float8_Comparison_Exp>;
  start_percentage?: InputMaybe<Float8_Comparison_Exp>;
  start_point?: InputMaybe<String_Comparison_Exp>;
  way_osm_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Delete_At_Path_Input = {
  geojson?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Delete_Elem_Input = {
  geojson?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Delete_Key_Input = {
  geojson?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Inc_Input = {
  end_percentage?: InputMaybe<Scalars['float8']['input']>;
  length_meters?: InputMaybe<Scalars['float8']['input']>;
  start_percentage?: InputMaybe<Scalars['float8']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Insert_Input = {
  end_percentage?: InputMaybe<Scalars['float8']['input']>;
  end_point?: InputMaybe<Scalars['String']['input']>;
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
  intersection_linestring?: InputMaybe<Scalars['String']['input']>;
  length_meters?: InputMaybe<Scalars['float8']['input']>;
  start_percentage?: InputMaybe<Scalars['float8']['input']>;
  start_point?: InputMaybe<Scalars['String']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Max_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_max_fields';
  end_percentage: Maybe<Scalars['float8']['output']>;
  end_point: Maybe<Scalars['String']['output']>;
  intersection_linestring: Maybe<Scalars['String']['output']>;
  length_meters: Maybe<Scalars['float8']['output']>;
  start_percentage: Maybe<Scalars['float8']['output']>;
  start_point: Maybe<Scalars['String']['output']>;
  way_osm_id: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Min_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_min_fields';
  end_percentage: Maybe<Scalars['float8']['output']>;
  end_point: Maybe<Scalars['String']['output']>;
  intersection_linestring: Maybe<Scalars['String']['output']>;
  length_meters: Maybe<Scalars['float8']['output']>;
  start_percentage: Maybe<Scalars['float8']['output']>;
  start_point: Maybe<Scalars['String']['output']>;
  way_osm_id: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Mutation_Response = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Empty_Tables_Critical_Segment_From_Critical_Point>;
};

/** Ordering options when selecting data from "empty_tables.critical_segment_from_critical_point". */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Order_By = {
  end_percentage?: InputMaybe<Order_By>;
  end_point?: InputMaybe<Order_By>;
  geojson?: InputMaybe<Order_By>;
  intersection_linestring?: InputMaybe<Order_By>;
  length_meters?: InputMaybe<Order_By>;
  start_percentage?: InputMaybe<Order_By>;
  start_point?: InputMaybe<Order_By>;
  way_osm_id?: InputMaybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Prepend_Input = {
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "empty_tables.critical_segment_from_critical_point" */
export enum Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column {
  /** column name */
  EndPercentage = 'end_percentage',
  /** column name */
  EndPoint = 'end_point',
  /** column name */
  Geojson = 'geojson',
  /** column name */
  IntersectionLinestring = 'intersection_linestring',
  /** column name */
  LengthMeters = 'length_meters',
  /** column name */
  StartPercentage = 'start_percentage',
  /** column name */
  StartPoint = 'start_point',
  /** column name */
  WayOsmId = 'way_osm_id'
}

/** input type for updating data in table "empty_tables.critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Set_Input = {
  end_percentage?: InputMaybe<Scalars['float8']['input']>;
  end_point?: InputMaybe<Scalars['String']['input']>;
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
  intersection_linestring?: InputMaybe<Scalars['String']['input']>;
  length_meters?: InputMaybe<Scalars['float8']['input']>;
  start_percentage?: InputMaybe<Scalars['float8']['input']>;
  start_point?: InputMaybe<Scalars['String']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Stddev_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_stddev_fields';
  end_percentage: Maybe<Scalars['Float']['output']>;
  length_meters: Maybe<Scalars['Float']['output']>;
  start_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Stddev_Pop_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_stddev_pop_fields';
  end_percentage: Maybe<Scalars['Float']['output']>;
  length_meters: Maybe<Scalars['Float']['output']>;
  start_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Stddev_Samp_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_stddev_samp_fields';
  end_percentage: Maybe<Scalars['Float']['output']>;
  length_meters: Maybe<Scalars['Float']['output']>;
  start_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "empty_tables_critical_segment_from_critical_point" */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Empty_Tables_Critical_Segment_From_Critical_Point_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Stream_Cursor_Value_Input = {
  end_percentage?: InputMaybe<Scalars['float8']['input']>;
  end_point?: InputMaybe<Scalars['String']['input']>;
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
  intersection_linestring?: InputMaybe<Scalars['String']['input']>;
  length_meters?: InputMaybe<Scalars['float8']['input']>;
  start_percentage?: InputMaybe<Scalars['float8']['input']>;
  start_point?: InputMaybe<Scalars['String']['input']>;
  way_osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Sum_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_sum_fields';
  end_percentage: Maybe<Scalars['float8']['output']>;
  length_meters: Maybe<Scalars['float8']['output']>;
  start_percentage: Maybe<Scalars['float8']['output']>;
  way_osm_id: Maybe<Scalars['bigint']['output']>;
};

export type Empty_Tables_Critical_Segment_From_Critical_Point_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Set_Input>;
  /** filter the rows which have to be updated */
  where: Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Var_Pop_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_var_pop_fields';
  end_percentage: Maybe<Scalars['Float']['output']>;
  length_meters: Maybe<Scalars['Float']['output']>;
  start_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Var_Samp_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_var_samp_fields';
  end_percentage: Maybe<Scalars['Float']['output']>;
  length_meters: Maybe<Scalars['Float']['output']>;
  start_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Empty_Tables_Critical_Segment_From_Critical_Point_Variance_Fields = {
  __typename?: 'empty_tables_critical_segment_from_critical_point_variance_fields';
  end_percentage: Maybe<Scalars['Float']['output']>;
  length_meters: Maybe<Scalars['Float']['output']>;
  start_percentage: Maybe<Scalars['Float']['output']>;
  way_osm_id: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "empty_tables.driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data = {
  __typename?: 'empty_tables_driver_performance_data';
  avatar_url: Maybe<Scalars['String']['output']>;
  brake_use_avg: Maybe<Scalars['float8']['output']>;
  economic_range_avg: Maybe<Scalars['float8']['output']>;
  engine_load_avg: Maybe<Scalars['float8']['output']>;
  inertia_avg: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  note_avg: Maybe<Scalars['float8']['output']>;
  slow_running_avg: Maybe<Scalars['float8']['output']>;
  speed_control_avg: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Maybe<Scalars['bigint']['output']>;
  total_drivers: Maybe<Scalars['bigint']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_km_avg: Maybe<Scalars['float8']['output']>;
  total_periods: Maybe<Scalars['bigint']['output']>;
};

export type Empty_Tables_Driver_Performance_Data_Aggregate = {
  __typename?: 'empty_tables_driver_performance_data_aggregate';
  aggregate: Maybe<Empty_Tables_Driver_Performance_Data_Aggregate_Fields>;
  nodes: Array<Empty_Tables_Driver_Performance_Data>;
};

/** aggregate fields of "empty_tables.driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data_Aggregate_Fields = {
  __typename?: 'empty_tables_driver_performance_data_aggregate_fields';
  avg: Maybe<Empty_Tables_Driver_Performance_Data_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Empty_Tables_Driver_Performance_Data_Max_Fields>;
  min: Maybe<Empty_Tables_Driver_Performance_Data_Min_Fields>;
  stddev: Maybe<Empty_Tables_Driver_Performance_Data_Stddev_Fields>;
  stddev_pop: Maybe<Empty_Tables_Driver_Performance_Data_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Empty_Tables_Driver_Performance_Data_Stddev_Samp_Fields>;
  sum: Maybe<Empty_Tables_Driver_Performance_Data_Sum_Fields>;
  var_pop: Maybe<Empty_Tables_Driver_Performance_Data_Var_Pop_Fields>;
  var_samp: Maybe<Empty_Tables_Driver_Performance_Data_Var_Samp_Fields>;
  variance: Maybe<Empty_Tables_Driver_Performance_Data_Variance_Fields>;
};


/** aggregate fields of "empty_tables.driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Empty_Tables_Driver_Performance_Data_Avg_Fields = {
  __typename?: 'empty_tables_driver_performance_data_avg_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "empty_tables.driver_performance_data". All fields are combined with a logical 'AND'. */
export type Empty_Tables_Driver_Performance_Data_Bool_Exp = {
  _and?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Bool_Exp>>;
  _not?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
  _or?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Bool_Exp>>;
  avatar_url?: InputMaybe<String_Comparison_Exp>;
  brake_use_avg?: InputMaybe<Float8_Comparison_Exp>;
  economic_range_avg?: InputMaybe<Float8_Comparison_Exp>;
  engine_load_avg?: InputMaybe<Float8_Comparison_Exp>;
  inertia_avg?: InputMaybe<Float8_Comparison_Exp>;
  motorista_code?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  note_avg?: InputMaybe<Float8_Comparison_Exp>;
  slow_running_avg?: InputMaybe<Float8_Comparison_Exp>;
  speed_control_avg?: InputMaybe<Float8_Comparison_Exp>;
  total_consumed_fuel?: InputMaybe<Float8_Comparison_Exp>;
  total_consumed_fuel_avg?: InputMaybe<Float8_Comparison_Exp>;
  total_count?: InputMaybe<Bigint_Comparison_Exp>;
  total_drivers?: InputMaybe<Bigint_Comparison_Exp>;
  total_km?: InputMaybe<Float8_Comparison_Exp>;
  total_km_avg?: InputMaybe<Float8_Comparison_Exp>;
  total_periods?: InputMaybe<Bigint_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "empty_tables.driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data_Inc_Input = {
  brake_use_avg?: InputMaybe<Scalars['float8']['input']>;
  economic_range_avg?: InputMaybe<Scalars['float8']['input']>;
  engine_load_avg?: InputMaybe<Scalars['float8']['input']>;
  inertia_avg?: InputMaybe<Scalars['float8']['input']>;
  note_avg?: InputMaybe<Scalars['float8']['input']>;
  slow_running_avg?: InputMaybe<Scalars['float8']['input']>;
  speed_control_avg?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['bigint']['input']>;
  total_drivers?: InputMaybe<Scalars['bigint']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "empty_tables.driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data_Insert_Input = {
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  brake_use_avg?: InputMaybe<Scalars['float8']['input']>;
  economic_range_avg?: InputMaybe<Scalars['float8']['input']>;
  engine_load_avg?: InputMaybe<Scalars['float8']['input']>;
  inertia_avg?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note_avg?: InputMaybe<Scalars['float8']['input']>;
  slow_running_avg?: InputMaybe<Scalars['float8']['input']>;
  speed_control_avg?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['bigint']['input']>;
  total_drivers?: InputMaybe<Scalars['bigint']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Empty_Tables_Driver_Performance_Data_Max_Fields = {
  __typename?: 'empty_tables_driver_performance_data_max_fields';
  avatar_url: Maybe<Scalars['String']['output']>;
  brake_use_avg: Maybe<Scalars['float8']['output']>;
  economic_range_avg: Maybe<Scalars['float8']['output']>;
  engine_load_avg: Maybe<Scalars['float8']['output']>;
  inertia_avg: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  note_avg: Maybe<Scalars['float8']['output']>;
  slow_running_avg: Maybe<Scalars['float8']['output']>;
  speed_control_avg: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Maybe<Scalars['bigint']['output']>;
  total_drivers: Maybe<Scalars['bigint']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_km_avg: Maybe<Scalars['float8']['output']>;
  total_periods: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Empty_Tables_Driver_Performance_Data_Min_Fields = {
  __typename?: 'empty_tables_driver_performance_data_min_fields';
  avatar_url: Maybe<Scalars['String']['output']>;
  brake_use_avg: Maybe<Scalars['float8']['output']>;
  economic_range_avg: Maybe<Scalars['float8']['output']>;
  engine_load_avg: Maybe<Scalars['float8']['output']>;
  inertia_avg: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  note_avg: Maybe<Scalars['float8']['output']>;
  slow_running_avg: Maybe<Scalars['float8']['output']>;
  speed_control_avg: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Maybe<Scalars['bigint']['output']>;
  total_drivers: Maybe<Scalars['bigint']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_km_avg: Maybe<Scalars['float8']['output']>;
  total_periods: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "empty_tables.driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data_Mutation_Response = {
  __typename?: 'empty_tables_driver_performance_data_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Empty_Tables_Driver_Performance_Data>;
};

/** Ordering options when selecting data from "empty_tables.driver_performance_data". */
export type Empty_Tables_Driver_Performance_Data_Order_By = {
  avatar_url?: InputMaybe<Order_By>;
  brake_use_avg?: InputMaybe<Order_By>;
  economic_range_avg?: InputMaybe<Order_By>;
  engine_load_avg?: InputMaybe<Order_By>;
  inertia_avg?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  note_avg?: InputMaybe<Order_By>;
  slow_running_avg?: InputMaybe<Order_By>;
  speed_control_avg?: InputMaybe<Order_By>;
  total_consumed_fuel?: InputMaybe<Order_By>;
  total_consumed_fuel_avg?: InputMaybe<Order_By>;
  total_count?: InputMaybe<Order_By>;
  total_drivers?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_km_avg?: InputMaybe<Order_By>;
  total_periods?: InputMaybe<Order_By>;
};

/** select columns of table "empty_tables.driver_performance_data" */
export enum Empty_Tables_Driver_Performance_Data_Select_Column {
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  BrakeUseAvg = 'brake_use_avg',
  /** column name */
  EconomicRangeAvg = 'economic_range_avg',
  /** column name */
  EngineLoadAvg = 'engine_load_avg',
  /** column name */
  InertiaAvg = 'inertia_avg',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  Name = 'name',
  /** column name */
  NoteAvg = 'note_avg',
  /** column name */
  SlowRunningAvg = 'slow_running_avg',
  /** column name */
  SpeedControlAvg = 'speed_control_avg',
  /** column name */
  TotalConsumedFuel = 'total_consumed_fuel',
  /** column name */
  TotalConsumedFuelAvg = 'total_consumed_fuel_avg',
  /** column name */
  TotalCount = 'total_count',
  /** column name */
  TotalDrivers = 'total_drivers',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalKmAvg = 'total_km_avg',
  /** column name */
  TotalPeriods = 'total_periods'
}

/** input type for updating data in table "empty_tables.driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data_Set_Input = {
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  brake_use_avg?: InputMaybe<Scalars['float8']['input']>;
  economic_range_avg?: InputMaybe<Scalars['float8']['input']>;
  engine_load_avg?: InputMaybe<Scalars['float8']['input']>;
  inertia_avg?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note_avg?: InputMaybe<Scalars['float8']['input']>;
  slow_running_avg?: InputMaybe<Scalars['float8']['input']>;
  speed_control_avg?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['bigint']['input']>;
  total_drivers?: InputMaybe<Scalars['bigint']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Empty_Tables_Driver_Performance_Data_Stddev_Fields = {
  __typename?: 'empty_tables_driver_performance_data_stddev_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Empty_Tables_Driver_Performance_Data_Stddev_Pop_Fields = {
  __typename?: 'empty_tables_driver_performance_data_stddev_pop_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Empty_Tables_Driver_Performance_Data_Stddev_Samp_Fields = {
  __typename?: 'empty_tables_driver_performance_data_stddev_samp_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "empty_tables_driver_performance_data" */
export type Empty_Tables_Driver_Performance_Data_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Empty_Tables_Driver_Performance_Data_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Empty_Tables_Driver_Performance_Data_Stream_Cursor_Value_Input = {
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  brake_use_avg?: InputMaybe<Scalars['float8']['input']>;
  economic_range_avg?: InputMaybe<Scalars['float8']['input']>;
  engine_load_avg?: InputMaybe<Scalars['float8']['input']>;
  inertia_avg?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note_avg?: InputMaybe<Scalars['float8']['input']>;
  slow_running_avg?: InputMaybe<Scalars['float8']['input']>;
  speed_control_avg?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['bigint']['input']>;
  total_drivers?: InputMaybe<Scalars['bigint']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Empty_Tables_Driver_Performance_Data_Sum_Fields = {
  __typename?: 'empty_tables_driver_performance_data_sum_fields';
  brake_use_avg: Maybe<Scalars['float8']['output']>;
  economic_range_avg: Maybe<Scalars['float8']['output']>;
  engine_load_avg: Maybe<Scalars['float8']['output']>;
  inertia_avg: Maybe<Scalars['float8']['output']>;
  note_avg: Maybe<Scalars['float8']['output']>;
  slow_running_avg: Maybe<Scalars['float8']['output']>;
  speed_control_avg: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Maybe<Scalars['bigint']['output']>;
  total_drivers: Maybe<Scalars['bigint']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_km_avg: Maybe<Scalars['float8']['output']>;
  total_periods: Maybe<Scalars['bigint']['output']>;
};

export type Empty_Tables_Driver_Performance_Data_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Empty_Tables_Driver_Performance_Data_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Empty_Tables_Driver_Performance_Data_Set_Input>;
  /** filter the rows which have to be updated */
  where: Empty_Tables_Driver_Performance_Data_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Empty_Tables_Driver_Performance_Data_Var_Pop_Fields = {
  __typename?: 'empty_tables_driver_performance_data_var_pop_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Empty_Tables_Driver_Performance_Data_Var_Samp_Fields = {
  __typename?: 'empty_tables_driver_performance_data_var_samp_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Empty_Tables_Driver_Performance_Data_Variance_Fields = {
  __typename?: 'empty_tables_driver_performance_data_variance_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data = {
  __typename?: 'empty_tables_fleet_performance_data';
  brake_use_avg: Scalars['Int']['output'];
  economic_range_avg: Scalars['Int']['output'];
  engine_load_avg: Scalars['Int']['output'];
  inertia_avg: Scalars['Int']['output'];
  note_avg: Scalars['Int']['output'];
  slow_running_avg: Scalars['Int']['output'];
  speed_control_avg: Scalars['Int']['output'];
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Scalars['Int']['output'];
  total_drivers: Scalars['Int']['output'];
  total_km: Scalars['float8']['output'];
  total_km_avg: Scalars['float8']['output'];
  total_periods: Scalars['Int']['output'];
};

/** aggregated selection of "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Aggregate = {
  __typename?: 'empty_tables_fleet_performance_data_aggregate';
  aggregate: Maybe<Empty_Tables_Fleet_Performance_Data_Aggregate_Fields>;
  nodes: Array<Empty_Tables_Fleet_Performance_Data>;
};

/** aggregate fields of "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Aggregate_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_aggregate_fields';
  avg: Maybe<Empty_Tables_Fleet_Performance_Data_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Empty_Tables_Fleet_Performance_Data_Max_Fields>;
  min: Maybe<Empty_Tables_Fleet_Performance_Data_Min_Fields>;
  stddev: Maybe<Empty_Tables_Fleet_Performance_Data_Stddev_Fields>;
  stddev_pop: Maybe<Empty_Tables_Fleet_Performance_Data_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Empty_Tables_Fleet_Performance_Data_Stddev_Samp_Fields>;
  sum: Maybe<Empty_Tables_Fleet_Performance_Data_Sum_Fields>;
  var_pop: Maybe<Empty_Tables_Fleet_Performance_Data_Var_Pop_Fields>;
  var_samp: Maybe<Empty_Tables_Fleet_Performance_Data_Var_Samp_Fields>;
  variance: Maybe<Empty_Tables_Fleet_Performance_Data_Variance_Fields>;
};


/** aggregate fields of "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Empty_Tables_Fleet_Performance_Data_Avg_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_avg_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "empty_tables.fleet_performance_data". All fields are combined with a logical 'AND'. */
export type Empty_Tables_Fleet_Performance_Data_Bool_Exp = {
  _and?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Bool_Exp>>;
  _not?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
  _or?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Bool_Exp>>;
  brake_use_avg?: InputMaybe<Int_Comparison_Exp>;
  economic_range_avg?: InputMaybe<Int_Comparison_Exp>;
  engine_load_avg?: InputMaybe<Int_Comparison_Exp>;
  inertia_avg?: InputMaybe<Int_Comparison_Exp>;
  note_avg?: InputMaybe<Int_Comparison_Exp>;
  slow_running_avg?: InputMaybe<Int_Comparison_Exp>;
  speed_control_avg?: InputMaybe<Int_Comparison_Exp>;
  total_consumed_fuel?: InputMaybe<Float8_Comparison_Exp>;
  total_consumed_fuel_avg?: InputMaybe<Float8_Comparison_Exp>;
  total_count?: InputMaybe<Int_Comparison_Exp>;
  total_drivers?: InputMaybe<Int_Comparison_Exp>;
  total_km?: InputMaybe<Float8_Comparison_Exp>;
  total_km_avg?: InputMaybe<Float8_Comparison_Exp>;
  total_periods?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "empty_tables.fleet_performance_data" */
export enum Empty_Tables_Fleet_Performance_Data_Constraint {
  /** unique or primary key constraint on columns "note_avg", "total_km", "total_drivers", "total_km_avg", "total_periods", "slow_running_avg", "brake_use_avg", "inertia_avg", "total_count", "engine_load_avg", "speed_control_avg", "economic_range_avg" */
  FleetPerformanceDataPkey = 'fleet_performance_data_pkey'
}

/** input type for incrementing numeric columns in table "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Inc_Input = {
  brake_use_avg?: InputMaybe<Scalars['Int']['input']>;
  economic_range_avg?: InputMaybe<Scalars['Int']['input']>;
  engine_load_avg?: InputMaybe<Scalars['Int']['input']>;
  inertia_avg?: InputMaybe<Scalars['Int']['input']>;
  note_avg?: InputMaybe<Scalars['Int']['input']>;
  slow_running_avg?: InputMaybe<Scalars['Int']['input']>;
  speed_control_avg?: InputMaybe<Scalars['Int']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['Int']['input']>;
  total_drivers?: InputMaybe<Scalars['Int']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Insert_Input = {
  brake_use_avg?: InputMaybe<Scalars['Int']['input']>;
  economic_range_avg?: InputMaybe<Scalars['Int']['input']>;
  engine_load_avg?: InputMaybe<Scalars['Int']['input']>;
  inertia_avg?: InputMaybe<Scalars['Int']['input']>;
  note_avg?: InputMaybe<Scalars['Int']['input']>;
  slow_running_avg?: InputMaybe<Scalars['Int']['input']>;
  speed_control_avg?: InputMaybe<Scalars['Int']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['Int']['input']>;
  total_drivers?: InputMaybe<Scalars['Int']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Empty_Tables_Fleet_Performance_Data_Max_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_max_fields';
  brake_use_avg: Maybe<Scalars['Int']['output']>;
  economic_range_avg: Maybe<Scalars['Int']['output']>;
  engine_load_avg: Maybe<Scalars['Int']['output']>;
  inertia_avg: Maybe<Scalars['Int']['output']>;
  note_avg: Maybe<Scalars['Int']['output']>;
  slow_running_avg: Maybe<Scalars['Int']['output']>;
  speed_control_avg: Maybe<Scalars['Int']['output']>;
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Maybe<Scalars['Int']['output']>;
  total_drivers: Maybe<Scalars['Int']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_km_avg: Maybe<Scalars['float8']['output']>;
  total_periods: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Empty_Tables_Fleet_Performance_Data_Min_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_min_fields';
  brake_use_avg: Maybe<Scalars['Int']['output']>;
  economic_range_avg: Maybe<Scalars['Int']['output']>;
  engine_load_avg: Maybe<Scalars['Int']['output']>;
  inertia_avg: Maybe<Scalars['Int']['output']>;
  note_avg: Maybe<Scalars['Int']['output']>;
  slow_running_avg: Maybe<Scalars['Int']['output']>;
  speed_control_avg: Maybe<Scalars['Int']['output']>;
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Maybe<Scalars['Int']['output']>;
  total_drivers: Maybe<Scalars['Int']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_km_avg: Maybe<Scalars['float8']['output']>;
  total_periods: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Mutation_Response = {
  __typename?: 'empty_tables_fleet_performance_data_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Empty_Tables_Fleet_Performance_Data>;
};

/** on_conflict condition type for table "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_On_Conflict = {
  constraint: Empty_Tables_Fleet_Performance_Data_Constraint;
  update_columns?: Array<Empty_Tables_Fleet_Performance_Data_Update_Column>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};

/** Ordering options when selecting data from "empty_tables.fleet_performance_data". */
export type Empty_Tables_Fleet_Performance_Data_Order_By = {
  brake_use_avg?: InputMaybe<Order_By>;
  economic_range_avg?: InputMaybe<Order_By>;
  engine_load_avg?: InputMaybe<Order_By>;
  inertia_avg?: InputMaybe<Order_By>;
  note_avg?: InputMaybe<Order_By>;
  slow_running_avg?: InputMaybe<Order_By>;
  speed_control_avg?: InputMaybe<Order_By>;
  total_consumed_fuel?: InputMaybe<Order_By>;
  total_consumed_fuel_avg?: InputMaybe<Order_By>;
  total_count?: InputMaybe<Order_By>;
  total_drivers?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_km_avg?: InputMaybe<Order_By>;
  total_periods?: InputMaybe<Order_By>;
};

/** primary key columns input for table: empty_tables.fleet_performance_data */
export type Empty_Tables_Fleet_Performance_Data_Pk_Columns_Input = {
  brake_use_avg: Scalars['Int']['input'];
  economic_range_avg: Scalars['Int']['input'];
  engine_load_avg: Scalars['Int']['input'];
  inertia_avg: Scalars['Int']['input'];
  note_avg: Scalars['Int']['input'];
  slow_running_avg: Scalars['Int']['input'];
  speed_control_avg: Scalars['Int']['input'];
  total_count: Scalars['Int']['input'];
  total_drivers: Scalars['Int']['input'];
  total_km: Scalars['float8']['input'];
  total_km_avg: Scalars['float8']['input'];
  total_periods: Scalars['Int']['input'];
};

/** select columns of table "empty_tables.fleet_performance_data" */
export enum Empty_Tables_Fleet_Performance_Data_Select_Column {
  /** column name */
  BrakeUseAvg = 'brake_use_avg',
  /** column name */
  EconomicRangeAvg = 'economic_range_avg',
  /** column name */
  EngineLoadAvg = 'engine_load_avg',
  /** column name */
  InertiaAvg = 'inertia_avg',
  /** column name */
  NoteAvg = 'note_avg',
  /** column name */
  SlowRunningAvg = 'slow_running_avg',
  /** column name */
  SpeedControlAvg = 'speed_control_avg',
  /** column name */
  TotalConsumedFuel = 'total_consumed_fuel',
  /** column name */
  TotalConsumedFuelAvg = 'total_consumed_fuel_avg',
  /** column name */
  TotalCount = 'total_count',
  /** column name */
  TotalDrivers = 'total_drivers',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalKmAvg = 'total_km_avg',
  /** column name */
  TotalPeriods = 'total_periods'
}

/** input type for updating data in table "empty_tables.fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Set_Input = {
  brake_use_avg?: InputMaybe<Scalars['Int']['input']>;
  economic_range_avg?: InputMaybe<Scalars['Int']['input']>;
  engine_load_avg?: InputMaybe<Scalars['Int']['input']>;
  inertia_avg?: InputMaybe<Scalars['Int']['input']>;
  note_avg?: InputMaybe<Scalars['Int']['input']>;
  slow_running_avg?: InputMaybe<Scalars['Int']['input']>;
  speed_control_avg?: InputMaybe<Scalars['Int']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['Int']['input']>;
  total_drivers?: InputMaybe<Scalars['Int']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Empty_Tables_Fleet_Performance_Data_Stddev_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_stddev_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Empty_Tables_Fleet_Performance_Data_Stddev_Pop_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_stddev_pop_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Empty_Tables_Fleet_Performance_Data_Stddev_Samp_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_stddev_samp_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "empty_tables_fleet_performance_data" */
export type Empty_Tables_Fleet_Performance_Data_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Empty_Tables_Fleet_Performance_Data_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Empty_Tables_Fleet_Performance_Data_Stream_Cursor_Value_Input = {
  brake_use_avg?: InputMaybe<Scalars['Int']['input']>;
  economic_range_avg?: InputMaybe<Scalars['Int']['input']>;
  engine_load_avg?: InputMaybe<Scalars['Int']['input']>;
  inertia_avg?: InputMaybe<Scalars['Int']['input']>;
  note_avg?: InputMaybe<Scalars['Int']['input']>;
  slow_running_avg?: InputMaybe<Scalars['Int']['input']>;
  speed_control_avg?: InputMaybe<Scalars['Int']['input']>;
  total_consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  total_consumed_fuel_avg?: InputMaybe<Scalars['float8']['input']>;
  total_count?: InputMaybe<Scalars['Int']['input']>;
  total_drivers?: InputMaybe<Scalars['Int']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_km_avg?: InputMaybe<Scalars['float8']['input']>;
  total_periods?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Empty_Tables_Fleet_Performance_Data_Sum_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_sum_fields';
  brake_use_avg: Maybe<Scalars['Int']['output']>;
  economic_range_avg: Maybe<Scalars['Int']['output']>;
  engine_load_avg: Maybe<Scalars['Int']['output']>;
  inertia_avg: Maybe<Scalars['Int']['output']>;
  note_avg: Maybe<Scalars['Int']['output']>;
  slow_running_avg: Maybe<Scalars['Int']['output']>;
  speed_control_avg: Maybe<Scalars['Int']['output']>;
  total_consumed_fuel: Maybe<Scalars['float8']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['float8']['output']>;
  total_count: Maybe<Scalars['Int']['output']>;
  total_drivers: Maybe<Scalars['Int']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_km_avg: Maybe<Scalars['float8']['output']>;
  total_periods: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "empty_tables.fleet_performance_data" */
export enum Empty_Tables_Fleet_Performance_Data_Update_Column {
  /** column name */
  BrakeUseAvg = 'brake_use_avg',
  /** column name */
  EconomicRangeAvg = 'economic_range_avg',
  /** column name */
  EngineLoadAvg = 'engine_load_avg',
  /** column name */
  InertiaAvg = 'inertia_avg',
  /** column name */
  NoteAvg = 'note_avg',
  /** column name */
  SlowRunningAvg = 'slow_running_avg',
  /** column name */
  SpeedControlAvg = 'speed_control_avg',
  /** column name */
  TotalConsumedFuel = 'total_consumed_fuel',
  /** column name */
  TotalConsumedFuelAvg = 'total_consumed_fuel_avg',
  /** column name */
  TotalCount = 'total_count',
  /** column name */
  TotalDrivers = 'total_drivers',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalKmAvg = 'total_km_avg',
  /** column name */
  TotalPeriods = 'total_periods'
}

export type Empty_Tables_Fleet_Performance_Data_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Set_Input>;
  /** filter the rows which have to be updated */
  where: Empty_Tables_Fleet_Performance_Data_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Empty_Tables_Fleet_Performance_Data_Var_Pop_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_var_pop_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Empty_Tables_Fleet_Performance_Data_Var_Samp_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_var_samp_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Empty_Tables_Fleet_Performance_Data_Variance_Fields = {
  __typename?: 'empty_tables_fleet_performance_data_variance_fields';
  brake_use_avg: Maybe<Scalars['Float']['output']>;
  economic_range_avg: Maybe<Scalars['Float']['output']>;
  engine_load_avg: Maybe<Scalars['Float']['output']>;
  inertia_avg: Maybe<Scalars['Float']['output']>;
  note_avg: Maybe<Scalars['Float']['output']>;
  slow_running_avg: Maybe<Scalars['Float']['output']>;
  speed_control_avg: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel: Maybe<Scalars['Float']['output']>;
  total_consumed_fuel_avg: Maybe<Scalars['Float']['output']>;
  total_count: Maybe<Scalars['Float']['output']>;
  total_drivers: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_km_avg: Maybe<Scalars['Float']['output']>;
  total_periods: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip = {
  __typename?: 'empty_tables_geojson_trip';
  geojson: Scalars['jsonb']['output'];
  trip_id: Scalars['Int']['output'];
};


/** columns and relationships of "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_TripGeojsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_Aggregate = {
  __typename?: 'empty_tables_geojson_trip_aggregate';
  aggregate: Maybe<Empty_Tables_Geojson_Trip_Aggregate_Fields>;
  nodes: Array<Empty_Tables_Geojson_Trip>;
};

/** aggregate fields of "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_Aggregate_Fields = {
  __typename?: 'empty_tables_geojson_trip_aggregate_fields';
  avg: Maybe<Empty_Tables_Geojson_Trip_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Empty_Tables_Geojson_Trip_Max_Fields>;
  min: Maybe<Empty_Tables_Geojson_Trip_Min_Fields>;
  stddev: Maybe<Empty_Tables_Geojson_Trip_Stddev_Fields>;
  stddev_pop: Maybe<Empty_Tables_Geojson_Trip_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Empty_Tables_Geojson_Trip_Stddev_Samp_Fields>;
  sum: Maybe<Empty_Tables_Geojson_Trip_Sum_Fields>;
  var_pop: Maybe<Empty_Tables_Geojson_Trip_Var_Pop_Fields>;
  var_samp: Maybe<Empty_Tables_Geojson_Trip_Var_Samp_Fields>;
  variance: Maybe<Empty_Tables_Geojson_Trip_Variance_Fields>;
};


/** aggregate fields of "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Empty_Tables_Geojson_Trip_Append_Input = {
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Empty_Tables_Geojson_Trip_Avg_Fields = {
  __typename?: 'empty_tables_geojson_trip_avg_fields';
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "empty_tables.geojson_trip". All fields are combined with a logical 'AND'. */
export type Empty_Tables_Geojson_Trip_Bool_Exp = {
  _and?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Bool_Exp>>;
  _not?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
  _or?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Bool_Exp>>;
  geojson?: InputMaybe<Jsonb_Comparison_Exp>;
  trip_id?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "empty_tables.geojson_trip" */
export enum Empty_Tables_Geojson_Trip_Constraint {
  /** unique or primary key constraint on columns "trip_id" */
  GeojsonTripPkey = 'geojson_trip_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Empty_Tables_Geojson_Trip_Delete_At_Path_Input = {
  geojson?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Empty_Tables_Geojson_Trip_Delete_Elem_Input = {
  geojson?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Empty_Tables_Geojson_Trip_Delete_Key_Input = {
  geojson?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_Inc_Input = {
  trip_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_Insert_Input = {
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Empty_Tables_Geojson_Trip_Max_Fields = {
  __typename?: 'empty_tables_geojson_trip_max_fields';
  trip_id: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Empty_Tables_Geojson_Trip_Min_Fields = {
  __typename?: 'empty_tables_geojson_trip_min_fields';
  trip_id: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_Mutation_Response = {
  __typename?: 'empty_tables_geojson_trip_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Empty_Tables_Geojson_Trip>;
};

/** on_conflict condition type for table "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_On_Conflict = {
  constraint: Empty_Tables_Geojson_Trip_Constraint;
  update_columns?: Array<Empty_Tables_Geojson_Trip_Update_Column>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};

/** Ordering options when selecting data from "empty_tables.geojson_trip". */
export type Empty_Tables_Geojson_Trip_Order_By = {
  geojson?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: empty_tables.geojson_trip */
export type Empty_Tables_Geojson_Trip_Pk_Columns_Input = {
  trip_id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Empty_Tables_Geojson_Trip_Prepend_Input = {
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "empty_tables.geojson_trip" */
export enum Empty_Tables_Geojson_Trip_Select_Column {
  /** column name */
  Geojson = 'geojson',
  /** column name */
  TripId = 'trip_id'
}

/** input type for updating data in table "empty_tables.geojson_trip" */
export type Empty_Tables_Geojson_Trip_Set_Input = {
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Empty_Tables_Geojson_Trip_Stddev_Fields = {
  __typename?: 'empty_tables_geojson_trip_stddev_fields';
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Empty_Tables_Geojson_Trip_Stddev_Pop_Fields = {
  __typename?: 'empty_tables_geojson_trip_stddev_pop_fields';
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Empty_Tables_Geojson_Trip_Stddev_Samp_Fields = {
  __typename?: 'empty_tables_geojson_trip_stddev_samp_fields';
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "empty_tables_geojson_trip" */
export type Empty_Tables_Geojson_Trip_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Empty_Tables_Geojson_Trip_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Empty_Tables_Geojson_Trip_Stream_Cursor_Value_Input = {
  geojson?: InputMaybe<Scalars['jsonb']['input']>;
  trip_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Empty_Tables_Geojson_Trip_Sum_Fields = {
  __typename?: 'empty_tables_geojson_trip_sum_fields';
  trip_id: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "empty_tables.geojson_trip" */
export enum Empty_Tables_Geojson_Trip_Update_Column {
  /** column name */
  Geojson = 'geojson',
  /** column name */
  TripId = 'trip_id'
}

export type Empty_Tables_Geojson_Trip_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Empty_Tables_Geojson_Trip_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Empty_Tables_Geojson_Trip_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Empty_Tables_Geojson_Trip_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Empty_Tables_Geojson_Trip_Set_Input>;
  /** filter the rows which have to be updated */
  where: Empty_Tables_Geojson_Trip_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Empty_Tables_Geojson_Trip_Var_Pop_Fields = {
  __typename?: 'empty_tables_geojson_trip_var_pop_fields';
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Empty_Tables_Geojson_Trip_Var_Samp_Fields = {
  __typename?: 'empty_tables_geojson_trip_var_samp_fields';
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Empty_Tables_Geojson_Trip_Variance_Fields = {
  __typename?: 'empty_tables_geojson_trip_variance_fields';
  trip_id: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History = {
  __typename?: 'empty_tables_instructor_drivers_performance_history';
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  note: Scalars['float8']['output'];
  score_type: Maybe<Scalars['String']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  start_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Aggregate = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_aggregate';
  aggregate: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Aggregate_Fields>;
  nodes: Array<Empty_Tables_Instructor_Drivers_Performance_History>;
};

/** aggregate fields of "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Aggregate_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_aggregate_fields';
  avg: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Max_Fields>;
  min: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Min_Fields>;
  stddev: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Stddev_Fields>;
  stddev_pop: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Stddev_Samp_Fields>;
  sum: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Sum_Fields>;
  var_pop: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Var_Pop_Fields>;
  var_samp: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Var_Samp_Fields>;
  variance: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Variance_Fields>;
};


/** aggregate fields of "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Avg_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_avg_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "empty_tables.instructor_drivers_performance_history". All fields are combined with a logical 'AND'. */
export type Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp = {
  _and?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>>;
  _not?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
  _or?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>>;
  brake_use?: InputMaybe<Float8_Comparison_Exp>;
  economic_range?: InputMaybe<Float8_Comparison_Exp>;
  engine_load?: InputMaybe<Float8_Comparison_Exp>;
  inertia?: InputMaybe<Float8_Comparison_Exp>;
  motorista_code?: InputMaybe<String_Comparison_Exp>;
  note?: InputMaybe<Float8_Comparison_Exp>;
  score_type?: InputMaybe<String_Comparison_Exp>;
  slow_running?: InputMaybe<Float8_Comparison_Exp>;
  speed_control?: InputMaybe<Float8_Comparison_Exp>;
  start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Inc_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Insert_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  score_type?: InputMaybe<Scalars['String']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Max_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_max_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  score_type: Maybe<Scalars['String']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  start_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Min_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_min_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  score_type: Maybe<Scalars['String']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  start_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Mutation_Response = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Empty_Tables_Instructor_Drivers_Performance_History>;
};

/** Ordering options when selecting data from "empty_tables.instructor_drivers_performance_history". */
export type Empty_Tables_Instructor_Drivers_Performance_History_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  score_type?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** select columns of table "empty_tables.instructor_drivers_performance_history" */
export enum Empty_Tables_Instructor_Drivers_Performance_History_Select_Column {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  Note = 'note',
  /** column name */
  ScoreType = 'score_type',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid'
}

/** input type for updating data in table "empty_tables.instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Set_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  score_type?: InputMaybe<Scalars['String']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Stddev_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_stddev_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Stddev_Pop_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_stddev_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Stddev_Samp_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_stddev_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "empty_tables_instructor_drivers_performance_history" */
export type Empty_Tables_Instructor_Drivers_Performance_History_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Empty_Tables_Instructor_Drivers_Performance_History_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Empty_Tables_Instructor_Drivers_Performance_History_Stream_Cursor_Value_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  score_type?: InputMaybe<Scalars['String']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Sum_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_sum_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
};

export type Empty_Tables_Instructor_Drivers_Performance_History_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Set_Input>;
  /** filter the rows which have to be updated */
  where: Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Var_Pop_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_var_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Var_Samp_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_var_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Empty_Tables_Instructor_Drivers_Performance_History_Variance_Fields = {
  __typename?: 'empty_tables_instructor_drivers_performance_history_variance_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "fidelity_range_points" */
export type Fidelity_Range_Points = {
  __typename?: 'fidelity_range_points';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Scalars['timestamptz']['output'];
  disabled_at: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['Int']['output'];
  month_range_max: Scalars['Int']['output'];
  month_range_min: Scalars['Int']['output'];
  points: Scalars['Int']['output'];
};

/** aggregated selection of "fidelity_range_points" */
export type Fidelity_Range_Points_Aggregate = {
  __typename?: 'fidelity_range_points_aggregate';
  aggregate: Maybe<Fidelity_Range_Points_Aggregate_Fields>;
  nodes: Array<Fidelity_Range_Points>;
};

/** aggregate fields of "fidelity_range_points" */
export type Fidelity_Range_Points_Aggregate_Fields = {
  __typename?: 'fidelity_range_points_aggregate_fields';
  avg: Maybe<Fidelity_Range_Points_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Fidelity_Range_Points_Max_Fields>;
  min: Maybe<Fidelity_Range_Points_Min_Fields>;
  stddev: Maybe<Fidelity_Range_Points_Stddev_Fields>;
  stddev_pop: Maybe<Fidelity_Range_Points_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Fidelity_Range_Points_Stddev_Samp_Fields>;
  sum: Maybe<Fidelity_Range_Points_Sum_Fields>;
  var_pop: Maybe<Fidelity_Range_Points_Var_Pop_Fields>;
  var_samp: Maybe<Fidelity_Range_Points_Var_Samp_Fields>;
  variance: Maybe<Fidelity_Range_Points_Variance_Fields>;
};


/** aggregate fields of "fidelity_range_points" */
export type Fidelity_Range_Points_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Fidelity_Range_Points_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Fidelity_Range_Points_Avg_Fields = {
  __typename?: 'fidelity_range_points_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
  month_range_max: Maybe<Scalars['Float']['output']>;
  month_range_min: Maybe<Scalars['Float']['output']>;
  points: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "fidelity_range_points". All fields are combined with a logical 'AND'. */
export type Fidelity_Range_Points_Bool_Exp = {
  _and?: InputMaybe<Array<Fidelity_Range_Points_Bool_Exp>>;
  _not?: InputMaybe<Fidelity_Range_Points_Bool_Exp>;
  _or?: InputMaybe<Array<Fidelity_Range_Points_Bool_Exp>>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  disabled_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  month_range_max?: InputMaybe<Int_Comparison_Exp>;
  month_range_min?: InputMaybe<Int_Comparison_Exp>;
  points?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "fidelity_range_points" */
export enum Fidelity_Range_Points_Constraint {
  /** unique or primary key constraint on columns "id" */
  FidelityRangePointsPkey = 'fidelity_range_points_pkey'
}

/** input type for incrementing numeric columns in table "fidelity_range_points" */
export type Fidelity_Range_Points_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  month_range_max?: InputMaybe<Scalars['Int']['input']>;
  month_range_min?: InputMaybe<Scalars['Int']['input']>;
  points?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fidelity_range_points" */
export type Fidelity_Range_Points_Insert_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  disabled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  month_range_max?: InputMaybe<Scalars['Int']['input']>;
  month_range_min?: InputMaybe<Scalars['Int']['input']>;
  points?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Fidelity_Range_Points_Max_Fields = {
  __typename?: 'fidelity_range_points_max_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  disabled_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  month_range_max: Maybe<Scalars['Int']['output']>;
  month_range_min: Maybe<Scalars['Int']['output']>;
  points: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Fidelity_Range_Points_Min_Fields = {
  __typename?: 'fidelity_range_points_min_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  disabled_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['Int']['output']>;
  month_range_max: Maybe<Scalars['Int']['output']>;
  month_range_min: Maybe<Scalars['Int']['output']>;
  points: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "fidelity_range_points" */
export type Fidelity_Range_Points_Mutation_Response = {
  __typename?: 'fidelity_range_points_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Fidelity_Range_Points>;
};

/** on_conflict condition type for table "fidelity_range_points" */
export type Fidelity_Range_Points_On_Conflict = {
  constraint: Fidelity_Range_Points_Constraint;
  update_columns?: Array<Fidelity_Range_Points_Update_Column>;
  where?: InputMaybe<Fidelity_Range_Points_Bool_Exp>;
};

/** Ordering options when selecting data from "fidelity_range_points". */
export type Fidelity_Range_Points_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  disabled_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  month_range_max?: InputMaybe<Order_By>;
  month_range_min?: InputMaybe<Order_By>;
  points?: InputMaybe<Order_By>;
};

/** primary key columns input for table: fidelity_range_points */
export type Fidelity_Range_Points_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "fidelity_range_points" */
export enum Fidelity_Range_Points_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisabledAt = 'disabled_at',
  /** column name */
  Id = 'id',
  /** column name */
  MonthRangeMax = 'month_range_max',
  /** column name */
  MonthRangeMin = 'month_range_min',
  /** column name */
  Points = 'points'
}

/** input type for updating data in table "fidelity_range_points" */
export type Fidelity_Range_Points_Set_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  disabled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  month_range_max?: InputMaybe<Scalars['Int']['input']>;
  month_range_min?: InputMaybe<Scalars['Int']['input']>;
  points?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Fidelity_Range_Points_Stddev_Fields = {
  __typename?: 'fidelity_range_points_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
  month_range_max: Maybe<Scalars['Float']['output']>;
  month_range_min: Maybe<Scalars['Float']['output']>;
  points: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Fidelity_Range_Points_Stddev_Pop_Fields = {
  __typename?: 'fidelity_range_points_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  month_range_max: Maybe<Scalars['Float']['output']>;
  month_range_min: Maybe<Scalars['Float']['output']>;
  points: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Fidelity_Range_Points_Stddev_Samp_Fields = {
  __typename?: 'fidelity_range_points_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  month_range_max: Maybe<Scalars['Float']['output']>;
  month_range_min: Maybe<Scalars['Float']['output']>;
  points: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "fidelity_range_points" */
export type Fidelity_Range_Points_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fidelity_Range_Points_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fidelity_Range_Points_Stream_Cursor_Value_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  disabled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  month_range_max?: InputMaybe<Scalars['Int']['input']>;
  month_range_min?: InputMaybe<Scalars['Int']['input']>;
  points?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Fidelity_Range_Points_Sum_Fields = {
  __typename?: 'fidelity_range_points_sum_fields';
  id: Maybe<Scalars['Int']['output']>;
  month_range_max: Maybe<Scalars['Int']['output']>;
  month_range_min: Maybe<Scalars['Int']['output']>;
  points: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "fidelity_range_points" */
export enum Fidelity_Range_Points_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisabledAt = 'disabled_at',
  /** column name */
  Id = 'id',
  /** column name */
  MonthRangeMax = 'month_range_max',
  /** column name */
  MonthRangeMin = 'month_range_min',
  /** column name */
  Points = 'points'
}

export type Fidelity_Range_Points_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Fidelity_Range_Points_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Fidelity_Range_Points_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fidelity_Range_Points_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fidelity_Range_Points_Var_Pop_Fields = {
  __typename?: 'fidelity_range_points_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
  month_range_max: Maybe<Scalars['Float']['output']>;
  month_range_min: Maybe<Scalars['Float']['output']>;
  points: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Fidelity_Range_Points_Var_Samp_Fields = {
  __typename?: 'fidelity_range_points_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
  month_range_max: Maybe<Scalars['Float']['output']>;
  month_range_min: Maybe<Scalars['Float']['output']>;
  points: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Fidelity_Range_Points_Variance_Fields = {
  __typename?: 'fidelity_range_points_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
  month_range_max: Maybe<Scalars['Float']['output']>;
  month_range_min: Maybe<Scalars['Float']['output']>;
  points: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "fipe.price" */
export type Fipe_Price = {
  __typename?: 'fipe_price';
  created_at: Scalars['timestamptz']['output'];
  price: Scalars['float8']['output'];
  price_formatted: Scalars['String']['output'];
  /** An object relationship */
  reference_table: Fipe_Reference_Month;
  reference_table_date: Scalars['date']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  vehicle: Maybe<Fipe_Vehicle>;
  vehicle_fipe_code: Scalars['String']['output'];
  vehicle_model_year: Scalars['Int']['output'];
};

/** aggregated selection of "fipe.price" */
export type Fipe_Price_Aggregate = {
  __typename?: 'fipe_price_aggregate';
  aggregate: Maybe<Fipe_Price_Aggregate_Fields>;
  nodes: Array<Fipe_Price>;
};

export type Fipe_Price_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp_Var_Samp>;
};

export type Fipe_Price_Aggregate_Bool_Exp_Avg = {
  arguments: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Corr = {
  arguments: Fipe_Price_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Fipe_Price_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Fipe_Price_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Fipe_Price_Aggregate_Bool_Exp_Max = {
  arguments: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Min = {
  arguments: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Sum = {
  arguments: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Fipe_Price_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Price_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "fipe.price" */
export type Fipe_Price_Aggregate_Fields = {
  __typename?: 'fipe_price_aggregate_fields';
  avg: Maybe<Fipe_Price_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Fipe_Price_Max_Fields>;
  min: Maybe<Fipe_Price_Min_Fields>;
  stddev: Maybe<Fipe_Price_Stddev_Fields>;
  stddev_pop: Maybe<Fipe_Price_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Fipe_Price_Stddev_Samp_Fields>;
  sum: Maybe<Fipe_Price_Sum_Fields>;
  var_pop: Maybe<Fipe_Price_Var_Pop_Fields>;
  var_samp: Maybe<Fipe_Price_Var_Samp_Fields>;
  variance: Maybe<Fipe_Price_Variance_Fields>;
};


/** aggregate fields of "fipe.price" */
export type Fipe_Price_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fipe.price" */
export type Fipe_Price_Aggregate_Order_By = {
  avg?: InputMaybe<Fipe_Price_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Fipe_Price_Max_Order_By>;
  min?: InputMaybe<Fipe_Price_Min_Order_By>;
  stddev?: InputMaybe<Fipe_Price_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Fipe_Price_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Fipe_Price_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Fipe_Price_Sum_Order_By>;
  var_pop?: InputMaybe<Fipe_Price_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Fipe_Price_Var_Samp_Order_By>;
  variance?: InputMaybe<Fipe_Price_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "fipe.price" */
export type Fipe_Price_Arr_Rel_Insert_Input = {
  data: Array<Fipe_Price_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Fipe_Price_On_Conflict>;
};

/** aggregate avg on columns */
export type Fipe_Price_Avg_Fields = {
  __typename?: 'fipe_price_avg_fields';
  price: Maybe<Scalars['Float']['output']>;
  vehicle_model_year: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fipe.price" */
export type Fipe_Price_Avg_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "fipe.price". All fields are combined with a logical 'AND'. */
export type Fipe_Price_Bool_Exp = {
  _and?: InputMaybe<Array<Fipe_Price_Bool_Exp>>;
  _not?: InputMaybe<Fipe_Price_Bool_Exp>;
  _or?: InputMaybe<Array<Fipe_Price_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  price?: InputMaybe<Float8_Comparison_Exp>;
  price_formatted?: InputMaybe<String_Comparison_Exp>;
  reference_table?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
  reference_table_date?: InputMaybe<Date_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vehicle?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
  vehicle_fipe_code?: InputMaybe<String_Comparison_Exp>;
  vehicle_model_year?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "fipe.price" */
export enum Fipe_Price_Constraint {
  /** unique or primary key constraint on columns "vehicle_model_year", "vehicle_fipe_code", "reference_table_date" */
  PriceIdx = 'price_idx',
  /** unique or primary key constraint on columns "vehicle_model_year", "vehicle_fipe_code", "reference_table_date" */
  PricePkey = 'price_pkey'
}

/** input type for incrementing numeric columns in table "fipe.price" */
export type Fipe_Price_Inc_Input = {
  price?: InputMaybe<Scalars['float8']['input']>;
  vehicle_model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fipe.price" */
export type Fipe_Price_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  price?: InputMaybe<Scalars['float8']['input']>;
  price_formatted?: InputMaybe<Scalars['String']['input']>;
  reference_table?: InputMaybe<Fipe_Reference_Month_Obj_Rel_Insert_Input>;
  reference_table_date?: InputMaybe<Scalars['date']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle?: InputMaybe<Fipe_Vehicle_Obj_Rel_Insert_Input>;
  vehicle_fipe_code?: InputMaybe<Scalars['String']['input']>;
  vehicle_model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Fipe_Price_Max_Fields = {
  __typename?: 'fipe_price_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  price: Maybe<Scalars['float8']['output']>;
  price_formatted: Maybe<Scalars['String']['output']>;
  reference_table_date: Maybe<Scalars['date']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_fipe_code: Maybe<Scalars['String']['output']>;
  vehicle_model_year: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "fipe.price" */
export type Fipe_Price_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  price_formatted?: InputMaybe<Order_By>;
  reference_table_date?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vehicle_fipe_code?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Fipe_Price_Min_Fields = {
  __typename?: 'fipe_price_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  price: Maybe<Scalars['float8']['output']>;
  price_formatted: Maybe<Scalars['String']['output']>;
  reference_table_date: Maybe<Scalars['date']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_fipe_code: Maybe<Scalars['String']['output']>;
  vehicle_model_year: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "fipe.price" */
export type Fipe_Price_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  price_formatted?: InputMaybe<Order_By>;
  reference_table_date?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vehicle_fipe_code?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "fipe.price" */
export type Fipe_Price_Mutation_Response = {
  __typename?: 'fipe_price_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Fipe_Price>;
};

/** on_conflict condition type for table "fipe.price" */
export type Fipe_Price_On_Conflict = {
  constraint: Fipe_Price_Constraint;
  update_columns?: Array<Fipe_Price_Update_Column>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};

/** Ordering options when selecting data from "fipe.price". */
export type Fipe_Price_Order_By = {
  created_at?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  price_formatted?: InputMaybe<Order_By>;
  reference_table?: InputMaybe<Fipe_Reference_Month_Order_By>;
  reference_table_date?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vehicle?: InputMaybe<Fipe_Vehicle_Order_By>;
  vehicle_fipe_code?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** primary key columns input for table: fipe.price */
export type Fipe_Price_Pk_Columns_Input = {
  reference_table_date: Scalars['date']['input'];
  vehicle_fipe_code: Scalars['String']['input'];
  vehicle_model_year: Scalars['Int']['input'];
};

/** select columns of table "fipe.price" */
export enum Fipe_Price_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Price = 'price',
  /** column name */
  PriceFormatted = 'price_formatted',
  /** column name */
  ReferenceTableDate = 'reference_table_date',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VehicleFipeCode = 'vehicle_fipe_code',
  /** column name */
  VehicleModelYear = 'vehicle_model_year'
}

/** select "fipe_price_aggregate_bool_exp_avg_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** select "fipe_price_aggregate_bool_exp_corr_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** select "fipe_price_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** select "fipe_price_aggregate_bool_exp_max_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** select "fipe_price_aggregate_bool_exp_min_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** select "fipe_price_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** select "fipe_price_aggregate_bool_exp_sum_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** select "fipe_price_aggregate_bool_exp_var_samp_arguments_columns" columns of table "fipe.price" */
export enum Fipe_Price_Select_Column_Fipe_Price_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  Price = 'price'
}

/** input type for updating data in table "fipe.price" */
export type Fipe_Price_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  price?: InputMaybe<Scalars['float8']['input']>;
  price_formatted?: InputMaybe<Scalars['String']['input']>;
  reference_table_date?: InputMaybe<Scalars['date']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_fipe_code?: InputMaybe<Scalars['String']['input']>;
  vehicle_model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Fipe_Price_Stddev_Fields = {
  __typename?: 'fipe_price_stddev_fields';
  price: Maybe<Scalars['Float']['output']>;
  vehicle_model_year: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fipe.price" */
export type Fipe_Price_Stddev_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Fipe_Price_Stddev_Pop_Fields = {
  __typename?: 'fipe_price_stddev_pop_fields';
  price: Maybe<Scalars['Float']['output']>;
  vehicle_model_year: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fipe.price" */
export type Fipe_Price_Stddev_Pop_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Fipe_Price_Stddev_Samp_Fields = {
  __typename?: 'fipe_price_stddev_samp_fields';
  price: Maybe<Scalars['Float']['output']>;
  vehicle_model_year: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fipe.price" */
export type Fipe_Price_Stddev_Samp_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "fipe_price" */
export type Fipe_Price_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fipe_Price_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fipe_Price_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  price?: InputMaybe<Scalars['float8']['input']>;
  price_formatted?: InputMaybe<Scalars['String']['input']>;
  reference_table_date?: InputMaybe<Scalars['date']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_fipe_code?: InputMaybe<Scalars['String']['input']>;
  vehicle_model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Fipe_Price_Sum_Fields = {
  __typename?: 'fipe_price_sum_fields';
  price: Maybe<Scalars['float8']['output']>;
  vehicle_model_year: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "fipe.price" */
export type Fipe_Price_Sum_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** update columns of table "fipe.price" */
export enum Fipe_Price_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Price = 'price',
  /** column name */
  PriceFormatted = 'price_formatted',
  /** column name */
  ReferenceTableDate = 'reference_table_date',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VehicleFipeCode = 'vehicle_fipe_code',
  /** column name */
  VehicleModelYear = 'vehicle_model_year'
}

export type Fipe_Price_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Fipe_Price_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Fipe_Price_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fipe_Price_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fipe_Price_Var_Pop_Fields = {
  __typename?: 'fipe_price_var_pop_fields';
  price: Maybe<Scalars['Float']['output']>;
  vehicle_model_year: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fipe.price" */
export type Fipe_Price_Var_Pop_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Fipe_Price_Var_Samp_Fields = {
  __typename?: 'fipe_price_var_samp_fields';
  price: Maybe<Scalars['Float']['output']>;
  vehicle_model_year: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fipe.price" */
export type Fipe_Price_Var_Samp_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Fipe_Price_Variance_Fields = {
  __typename?: 'fipe_price_variance_fields';
  price: Maybe<Scalars['Float']['output']>;
  vehicle_model_year: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fipe.price" */
export type Fipe_Price_Variance_Order_By = {
  price?: InputMaybe<Order_By>;
  vehicle_model_year?: InputMaybe<Order_By>;
};

/** columns and relationships of "fipe.reference_month" */
export type Fipe_Reference_Month = {
  __typename?: 'fipe_reference_month';
  code: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  prices: Array<Fipe_Price>;
  /** An aggregate relationship */
  prices_aggregate: Fipe_Price_Aggregate;
  reference_date: Scalars['date']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "fipe.reference_month" */
export type Fipe_Reference_MonthPricesArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


/** columns and relationships of "fipe.reference_month" */
export type Fipe_Reference_MonthPrices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};

/** aggregated selection of "fipe.reference_month" */
export type Fipe_Reference_Month_Aggregate = {
  __typename?: 'fipe_reference_month_aggregate';
  aggregate: Maybe<Fipe_Reference_Month_Aggregate_Fields>;
  nodes: Array<Fipe_Reference_Month>;
};

/** aggregate fields of "fipe.reference_month" */
export type Fipe_Reference_Month_Aggregate_Fields = {
  __typename?: 'fipe_reference_month_aggregate_fields';
  avg: Maybe<Fipe_Reference_Month_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Fipe_Reference_Month_Max_Fields>;
  min: Maybe<Fipe_Reference_Month_Min_Fields>;
  stddev: Maybe<Fipe_Reference_Month_Stddev_Fields>;
  stddev_pop: Maybe<Fipe_Reference_Month_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Fipe_Reference_Month_Stddev_Samp_Fields>;
  sum: Maybe<Fipe_Reference_Month_Sum_Fields>;
  var_pop: Maybe<Fipe_Reference_Month_Var_Pop_Fields>;
  var_samp: Maybe<Fipe_Reference_Month_Var_Samp_Fields>;
  variance: Maybe<Fipe_Reference_Month_Variance_Fields>;
};


/** aggregate fields of "fipe.reference_month" */
export type Fipe_Reference_Month_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Fipe_Reference_Month_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Fipe_Reference_Month_Avg_Fields = {
  __typename?: 'fipe_reference_month_avg_fields';
  code: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "fipe.reference_month". All fields are combined with a logical 'AND'. */
export type Fipe_Reference_Month_Bool_Exp = {
  _and?: InputMaybe<Array<Fipe_Reference_Month_Bool_Exp>>;
  _not?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
  _or?: InputMaybe<Array<Fipe_Reference_Month_Bool_Exp>>;
  code?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  prices?: InputMaybe<Fipe_Price_Bool_Exp>;
  prices_aggregate?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp>;
  reference_date?: InputMaybe<Date_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "fipe.reference_month" */
export enum Fipe_Reference_Month_Constraint {
  /** unique or primary key constraint on columns "code" */
  ReferenceTablePkey = 'reference_table_pkey',
  /** unique or primary key constraint on columns "reference_date" */
  ReferenceTableReferenceDateKey = 'reference_table_reference_date_key'
}

/** input type for incrementing numeric columns in table "fipe.reference_month" */
export type Fipe_Reference_Month_Inc_Input = {
  code?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fipe.reference_month" */
export type Fipe_Reference_Month_Insert_Input = {
  code?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  prices?: InputMaybe<Fipe_Price_Arr_Rel_Insert_Input>;
  reference_date?: InputMaybe<Scalars['date']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Fipe_Reference_Month_Max_Fields = {
  __typename?: 'fipe_reference_month_max_fields';
  code: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  name: Maybe<Scalars['String']['output']>;
  reference_date: Maybe<Scalars['date']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Fipe_Reference_Month_Min_Fields = {
  __typename?: 'fipe_reference_month_min_fields';
  code: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  name: Maybe<Scalars['String']['output']>;
  reference_date: Maybe<Scalars['date']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "fipe.reference_month" */
export type Fipe_Reference_Month_Mutation_Response = {
  __typename?: 'fipe_reference_month_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Fipe_Reference_Month>;
};

/** input type for inserting object relation for remote table "fipe.reference_month" */
export type Fipe_Reference_Month_Obj_Rel_Insert_Input = {
  data: Fipe_Reference_Month_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Fipe_Reference_Month_On_Conflict>;
};

/** on_conflict condition type for table "fipe.reference_month" */
export type Fipe_Reference_Month_On_Conflict = {
  constraint: Fipe_Reference_Month_Constraint;
  update_columns?: Array<Fipe_Reference_Month_Update_Column>;
  where?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
};

/** Ordering options when selecting data from "fipe.reference_month". */
export type Fipe_Reference_Month_Order_By = {
  code?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  prices_aggregate?: InputMaybe<Fipe_Price_Aggregate_Order_By>;
  reference_date?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: fipe.reference_month */
export type Fipe_Reference_Month_Pk_Columns_Input = {
  code: Scalars['Int']['input'];
};

/** select columns of table "fipe.reference_month" */
export enum Fipe_Reference_Month_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  ReferenceDate = 'reference_date',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "fipe.reference_month" */
export type Fipe_Reference_Month_Set_Input = {
  code?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  reference_date?: InputMaybe<Scalars['date']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Fipe_Reference_Month_Stddev_Fields = {
  __typename?: 'fipe_reference_month_stddev_fields';
  code: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Fipe_Reference_Month_Stddev_Pop_Fields = {
  __typename?: 'fipe_reference_month_stddev_pop_fields';
  code: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Fipe_Reference_Month_Stddev_Samp_Fields = {
  __typename?: 'fipe_reference_month_stddev_samp_fields';
  code: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "fipe_reference_month" */
export type Fipe_Reference_Month_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fipe_Reference_Month_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fipe_Reference_Month_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  reference_date?: InputMaybe<Scalars['date']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Fipe_Reference_Month_Sum_Fields = {
  __typename?: 'fipe_reference_month_sum_fields';
  code: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "fipe.reference_month" */
export enum Fipe_Reference_Month_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  ReferenceDate = 'reference_date',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Fipe_Reference_Month_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Fipe_Reference_Month_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Fipe_Reference_Month_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fipe_Reference_Month_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fipe_Reference_Month_Var_Pop_Fields = {
  __typename?: 'fipe_reference_month_var_pop_fields';
  code: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Fipe_Reference_Month_Var_Samp_Fields = {
  __typename?: 'fipe_reference_month_var_samp_fields';
  code: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Fipe_Reference_Month_Variance_Fields = {
  __typename?: 'fipe_reference_month_variance_fields';
  code: Maybe<Scalars['Float']['output']>;
};

export type Fipe_Search_Fipe_Vehicle_Args = {
  search?: InputMaybe<Scalars['String']['input']>;
  vehicle_type_filter?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle = {
  __typename?: 'fipe_selected_vehicle';
  created_at: Scalars['timestamptz']['output'];
  finished_min_reference_date_sync: Maybe<Scalars['Boolean']['output']>;
  fipe_code: Scalars['String']['output'];
  last_sync_at: Maybe<Scalars['timestamptz']['output']>;
  max_sync_reference_date: Maybe<Scalars['date']['output']>;
  min_sync_reference_date: Maybe<Scalars['date']['output']>;
  model_year: Scalars['Int']['output'];
  /** An array relationship */
  prices: Array<Fipe_Price>;
  /** An aggregate relationship */
  prices_aggregate: Fipe_Price_Aggregate;
  /** An object relationship */
  vehicle: Maybe<Fipe_Vehicle>;
};


/** columns and relationships of "fipe.selected_vehicle" */
export type Fipe_Selected_VehiclePricesArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


/** columns and relationships of "fipe.selected_vehicle" */
export type Fipe_Selected_VehiclePrices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};

/** aggregated selection of "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Aggregate = {
  __typename?: 'fipe_selected_vehicle_aggregate';
  aggregate: Maybe<Fipe_Selected_Vehicle_Aggregate_Fields>;
  nodes: Array<Fipe_Selected_Vehicle>;
};

export type Fipe_Selected_Vehicle_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Count>;
};

export type Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_And = {
  arguments: Fipe_Selected_Vehicle_Select_Column_Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Fipe_Selected_Vehicle_Select_Column_Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Aggregate_Fields = {
  __typename?: 'fipe_selected_vehicle_aggregate_fields';
  avg: Maybe<Fipe_Selected_Vehicle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Fipe_Selected_Vehicle_Max_Fields>;
  min: Maybe<Fipe_Selected_Vehicle_Min_Fields>;
  stddev: Maybe<Fipe_Selected_Vehicle_Stddev_Fields>;
  stddev_pop: Maybe<Fipe_Selected_Vehicle_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Fipe_Selected_Vehicle_Stddev_Samp_Fields>;
  sum: Maybe<Fipe_Selected_Vehicle_Sum_Fields>;
  var_pop: Maybe<Fipe_Selected_Vehicle_Var_Pop_Fields>;
  var_samp: Maybe<Fipe_Selected_Vehicle_Var_Samp_Fields>;
  variance: Maybe<Fipe_Selected_Vehicle_Variance_Fields>;
};


/** aggregate fields of "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Aggregate_Order_By = {
  avg?: InputMaybe<Fipe_Selected_Vehicle_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Fipe_Selected_Vehicle_Max_Order_By>;
  min?: InputMaybe<Fipe_Selected_Vehicle_Min_Order_By>;
  stddev?: InputMaybe<Fipe_Selected_Vehicle_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Fipe_Selected_Vehicle_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Fipe_Selected_Vehicle_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Fipe_Selected_Vehicle_Sum_Order_By>;
  var_pop?: InputMaybe<Fipe_Selected_Vehicle_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Fipe_Selected_Vehicle_Var_Samp_Order_By>;
  variance?: InputMaybe<Fipe_Selected_Vehicle_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Arr_Rel_Insert_Input = {
  data: Array<Fipe_Selected_Vehicle_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Fipe_Selected_Vehicle_On_Conflict>;
};

/** aggregate avg on columns */
export type Fipe_Selected_Vehicle_Avg_Fields = {
  __typename?: 'fipe_selected_vehicle_avg_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Avg_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "fipe.selected_vehicle". All fields are combined with a logical 'AND'. */
export type Fipe_Selected_Vehicle_Bool_Exp = {
  _and?: InputMaybe<Array<Fipe_Selected_Vehicle_Bool_Exp>>;
  _not?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
  _or?: InputMaybe<Array<Fipe_Selected_Vehicle_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  finished_min_reference_date_sync?: InputMaybe<Boolean_Comparison_Exp>;
  fipe_code?: InputMaybe<String_Comparison_Exp>;
  last_sync_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  max_sync_reference_date?: InputMaybe<Date_Comparison_Exp>;
  min_sync_reference_date?: InputMaybe<Date_Comparison_Exp>;
  model_year?: InputMaybe<Int_Comparison_Exp>;
  prices?: InputMaybe<Fipe_Price_Bool_Exp>;
  prices_aggregate?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp>;
  vehicle?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};

/** unique or primary key constraints on table "fipe.selected_vehicle" */
export enum Fipe_Selected_Vehicle_Constraint {
  /** unique or primary key constraint on columns "fipe_code", "model_year" */
  SelectedVehiclePkey = 'selected_vehicle_pkey'
}

/** input type for incrementing numeric columns in table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Inc_Input = {
  model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  fipe_code?: InputMaybe<Scalars['String']['input']>;
  last_sync_at?: InputMaybe<Scalars['timestamptz']['input']>;
  max_sync_reference_date?: InputMaybe<Scalars['date']['input']>;
  min_sync_reference_date?: InputMaybe<Scalars['date']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
  prices?: InputMaybe<Fipe_Price_Arr_Rel_Insert_Input>;
  vehicle?: InputMaybe<Fipe_Vehicle_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Fipe_Selected_Vehicle_Max_Fields = {
  __typename?: 'fipe_selected_vehicle_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  fipe_code: Maybe<Scalars['String']['output']>;
  last_sync_at: Maybe<Scalars['timestamptz']['output']>;
  max_sync_reference_date: Maybe<Scalars['date']['output']>;
  min_sync_reference_date: Maybe<Scalars['date']['output']>;
  model_year: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  fipe_code?: InputMaybe<Order_By>;
  last_sync_at?: InputMaybe<Order_By>;
  max_sync_reference_date?: InputMaybe<Order_By>;
  min_sync_reference_date?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Fipe_Selected_Vehicle_Min_Fields = {
  __typename?: 'fipe_selected_vehicle_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  fipe_code: Maybe<Scalars['String']['output']>;
  last_sync_at: Maybe<Scalars['timestamptz']['output']>;
  max_sync_reference_date: Maybe<Scalars['date']['output']>;
  min_sync_reference_date: Maybe<Scalars['date']['output']>;
  model_year: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  fipe_code?: InputMaybe<Order_By>;
  last_sync_at?: InputMaybe<Order_By>;
  max_sync_reference_date?: InputMaybe<Order_By>;
  min_sync_reference_date?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Mutation_Response = {
  __typename?: 'fipe_selected_vehicle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Fipe_Selected_Vehicle>;
};

/** input type for inserting object relation for remote table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Obj_Rel_Insert_Input = {
  data: Fipe_Selected_Vehicle_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Fipe_Selected_Vehicle_On_Conflict>;
};

/** on_conflict condition type for table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_On_Conflict = {
  constraint: Fipe_Selected_Vehicle_Constraint;
  update_columns?: Array<Fipe_Selected_Vehicle_Update_Column>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};

/** Ordering options when selecting data from "fipe.selected_vehicle". */
export type Fipe_Selected_Vehicle_Order_By = {
  created_at?: InputMaybe<Order_By>;
  finished_min_reference_date_sync?: InputMaybe<Order_By>;
  fipe_code?: InputMaybe<Order_By>;
  last_sync_at?: InputMaybe<Order_By>;
  max_sync_reference_date?: InputMaybe<Order_By>;
  min_sync_reference_date?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
  prices_aggregate?: InputMaybe<Fipe_Price_Aggregate_Order_By>;
  vehicle?: InputMaybe<Fipe_Vehicle_Order_By>;
};

/** primary key columns input for table: fipe.selected_vehicle */
export type Fipe_Selected_Vehicle_Pk_Columns_Input = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};

/** select columns of table "fipe.selected_vehicle" */
export enum Fipe_Selected_Vehicle_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FinishedMinReferenceDateSync = 'finished_min_reference_date_sync',
  /** column name */
  FipeCode = 'fipe_code',
  /** column name */
  LastSyncAt = 'last_sync_at',
  /** column name */
  MaxSyncReferenceDate = 'max_sync_reference_date',
  /** column name */
  MinSyncReferenceDate = 'min_sync_reference_date',
  /** column name */
  ModelYear = 'model_year'
}

/** select "fipe_selected_vehicle_aggregate_bool_exp_bool_and_arguments_columns" columns of table "fipe.selected_vehicle" */
export enum Fipe_Selected_Vehicle_Select_Column_Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  FinishedMinReferenceDateSync = 'finished_min_reference_date_sync'
}

/** select "fipe_selected_vehicle_aggregate_bool_exp_bool_or_arguments_columns" columns of table "fipe.selected_vehicle" */
export enum Fipe_Selected_Vehicle_Select_Column_Fipe_Selected_Vehicle_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  FinishedMinReferenceDateSync = 'finished_min_reference_date_sync'
}

/** input type for updating data in table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  fipe_code?: InputMaybe<Scalars['String']['input']>;
  last_sync_at?: InputMaybe<Scalars['timestamptz']['input']>;
  max_sync_reference_date?: InputMaybe<Scalars['date']['input']>;
  min_sync_reference_date?: InputMaybe<Scalars['date']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Fipe_Selected_Vehicle_Stddev_Fields = {
  __typename?: 'fipe_selected_vehicle_stddev_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Stddev_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Fipe_Selected_Vehicle_Stddev_Pop_Fields = {
  __typename?: 'fipe_selected_vehicle_stddev_pop_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Stddev_Pop_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Fipe_Selected_Vehicle_Stddev_Samp_Fields = {
  __typename?: 'fipe_selected_vehicle_stddev_samp_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Stddev_Samp_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "fipe_selected_vehicle" */
export type Fipe_Selected_Vehicle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fipe_Selected_Vehicle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fipe_Selected_Vehicle_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  finished_min_reference_date_sync?: InputMaybe<Scalars['Boolean']['input']>;
  fipe_code?: InputMaybe<Scalars['String']['input']>;
  last_sync_at?: InputMaybe<Scalars['timestamptz']['input']>;
  max_sync_reference_date?: InputMaybe<Scalars['date']['input']>;
  min_sync_reference_date?: InputMaybe<Scalars['date']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Fipe_Selected_Vehicle_Sum_Fields = {
  __typename?: 'fipe_selected_vehicle_sum_fields';
  model_year: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Sum_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** update columns of table "fipe.selected_vehicle" */
export enum Fipe_Selected_Vehicle_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FipeCode = 'fipe_code',
  /** column name */
  LastSyncAt = 'last_sync_at',
  /** column name */
  MaxSyncReferenceDate = 'max_sync_reference_date',
  /** column name */
  MinSyncReferenceDate = 'min_sync_reference_date',
  /** column name */
  ModelYear = 'model_year'
}

export type Fipe_Selected_Vehicle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Fipe_Selected_Vehicle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Fipe_Selected_Vehicle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fipe_Selected_Vehicle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fipe_Selected_Vehicle_Var_Pop_Fields = {
  __typename?: 'fipe_selected_vehicle_var_pop_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Var_Pop_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Fipe_Selected_Vehicle_Var_Samp_Fields = {
  __typename?: 'fipe_selected_vehicle_var_samp_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Var_Samp_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Fipe_Selected_Vehicle_Variance_Fields = {
  __typename?: 'fipe_selected_vehicle_variance_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fipe.selected_vehicle" */
export type Fipe_Selected_Vehicle_Variance_Order_By = {
  model_year?: InputMaybe<Order_By>;
};

/** columns and relationships of "fipe.vehicle" */
export type Fipe_Vehicle = {
  __typename?: 'fipe_vehicle';
  brand: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  fipe_code: Scalars['String']['output'];
  fuel: Scalars['String']['output'];
  fuel_acronym: Scalars['bpchar']['output'];
  model: Scalars['String']['output'];
  model_year: Scalars['Int']['output'];
  /** An array relationship */
  prices: Array<Fipe_Price>;
  /** An aggregate relationship */
  prices_aggregate: Fipe_Price_Aggregate;
  /** An object relationship */
  selected_vehicle: Maybe<Fipe_Selected_Vehicle>;
  /** An array relationship */
  selected_vehicles: Array<Fipe_Selected_Vehicle>;
  /** An aggregate relationship */
  selected_vehicles_aggregate: Fipe_Selected_Vehicle_Aggregate;
  text_description: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  vehicle_type: Scalars['String']['output'];
};


/** columns and relationships of "fipe.vehicle" */
export type Fipe_VehiclePricesArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


/** columns and relationships of "fipe.vehicle" */
export type Fipe_VehiclePrices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


/** columns and relationships of "fipe.vehicle" */
export type Fipe_VehicleSelected_VehiclesArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Selected_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};


/** columns and relationships of "fipe.vehicle" */
export type Fipe_VehicleSelected_Vehicles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Selected_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};

export type Fipe_Vehicle_Aggregate = {
  __typename?: 'fipe_vehicle_aggregate';
  aggregate: Maybe<Fipe_Vehicle_Aggregate_Fields>;
  nodes: Array<Fipe_Vehicle>;
};

/** aggregate fields of "fipe.vehicle" */
export type Fipe_Vehicle_Aggregate_Fields = {
  __typename?: 'fipe_vehicle_aggregate_fields';
  avg: Maybe<Fipe_Vehicle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Fipe_Vehicle_Max_Fields>;
  min: Maybe<Fipe_Vehicle_Min_Fields>;
  stddev: Maybe<Fipe_Vehicle_Stddev_Fields>;
  stddev_pop: Maybe<Fipe_Vehicle_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Fipe_Vehicle_Stddev_Samp_Fields>;
  sum: Maybe<Fipe_Vehicle_Sum_Fields>;
  var_pop: Maybe<Fipe_Vehicle_Var_Pop_Fields>;
  var_samp: Maybe<Fipe_Vehicle_Var_Samp_Fields>;
  variance: Maybe<Fipe_Vehicle_Variance_Fields>;
};


/** aggregate fields of "fipe.vehicle" */
export type Fipe_Vehicle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Fipe_Vehicle_Avg_Fields = {
  __typename?: 'fipe_vehicle_avg_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "fipe.vehicle". All fields are combined with a logical 'AND'. */
export type Fipe_Vehicle_Bool_Exp = {
  _and?: InputMaybe<Array<Fipe_Vehicle_Bool_Exp>>;
  _not?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
  _or?: InputMaybe<Array<Fipe_Vehicle_Bool_Exp>>;
  brand?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  fipe_code?: InputMaybe<String_Comparison_Exp>;
  fuel?: InputMaybe<String_Comparison_Exp>;
  fuel_acronym?: InputMaybe<Bpchar_Comparison_Exp>;
  model?: InputMaybe<String_Comparison_Exp>;
  model_year?: InputMaybe<Int_Comparison_Exp>;
  prices?: InputMaybe<Fipe_Price_Bool_Exp>;
  prices_aggregate?: InputMaybe<Fipe_Price_Aggregate_Bool_Exp>;
  selected_vehicle?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
  selected_vehicles?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
  selected_vehicles_aggregate?: InputMaybe<Fipe_Selected_Vehicle_Aggregate_Bool_Exp>;
  text_description?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vehicle_type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "fipe.vehicle" */
export enum Fipe_Vehicle_Constraint {
  /** unique or primary key constraint on columns "fipe_code", "model_year" */
  VehicleFipeCodeModelYearKey = 'vehicle_fipe_code_model_year_key',
  /** unique or primary key constraint on columns "fipe_code", "model_year" */
  VehiclePkey = 'vehicle_pkey'
}

/** input type for incrementing numeric columns in table "fipe.vehicle" */
export type Fipe_Vehicle_Inc_Input = {
  model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fipe.vehicle" */
export type Fipe_Vehicle_Insert_Input = {
  brand?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  fipe_code?: InputMaybe<Scalars['String']['input']>;
  fuel?: InputMaybe<Scalars['String']['input']>;
  fuel_acronym?: InputMaybe<Scalars['bpchar']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
  prices?: InputMaybe<Fipe_Price_Arr_Rel_Insert_Input>;
  selected_vehicle?: InputMaybe<Fipe_Selected_Vehicle_Obj_Rel_Insert_Input>;
  selected_vehicles?: InputMaybe<Fipe_Selected_Vehicle_Arr_Rel_Insert_Input>;
  text_description?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Fipe_Vehicle_Max_Fields = {
  __typename?: 'fipe_vehicle_max_fields';
  brand: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  fipe_code: Maybe<Scalars['String']['output']>;
  fuel: Maybe<Scalars['String']['output']>;
  fuel_acronym: Maybe<Scalars['bpchar']['output']>;
  model: Maybe<Scalars['String']['output']>;
  model_year: Maybe<Scalars['Int']['output']>;
  text_description: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_type: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Fipe_Vehicle_Min_Fields = {
  __typename?: 'fipe_vehicle_min_fields';
  brand: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  fipe_code: Maybe<Scalars['String']['output']>;
  fuel: Maybe<Scalars['String']['output']>;
  fuel_acronym: Maybe<Scalars['bpchar']['output']>;
  model: Maybe<Scalars['String']['output']>;
  model_year: Maybe<Scalars['Int']['output']>;
  text_description: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_type: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "fipe.vehicle" */
export type Fipe_Vehicle_Mutation_Response = {
  __typename?: 'fipe_vehicle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Fipe_Vehicle>;
};

/** input type for inserting object relation for remote table "fipe.vehicle" */
export type Fipe_Vehicle_Obj_Rel_Insert_Input = {
  data: Fipe_Vehicle_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Fipe_Vehicle_On_Conflict>;
};

/** on_conflict condition type for table "fipe.vehicle" */
export type Fipe_Vehicle_On_Conflict = {
  constraint: Fipe_Vehicle_Constraint;
  update_columns?: Array<Fipe_Vehicle_Update_Column>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};

/** Ordering options when selecting data from "fipe.vehicle". */
export type Fipe_Vehicle_Order_By = {
  brand?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  fipe_code?: InputMaybe<Order_By>;
  fuel?: InputMaybe<Order_By>;
  fuel_acronym?: InputMaybe<Order_By>;
  model?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
  prices_aggregate?: InputMaybe<Fipe_Price_Aggregate_Order_By>;
  selected_vehicle?: InputMaybe<Fipe_Selected_Vehicle_Order_By>;
  selected_vehicles_aggregate?: InputMaybe<Fipe_Selected_Vehicle_Aggregate_Order_By>;
  text_description?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vehicle_type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: fipe.vehicle */
export type Fipe_Vehicle_Pk_Columns_Input = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};

/** select columns of table "fipe.vehicle" */
export enum Fipe_Vehicle_Select_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FipeCode = 'fipe_code',
  /** column name */
  Fuel = 'fuel',
  /** column name */
  FuelAcronym = 'fuel_acronym',
  /** column name */
  Model = 'model',
  /** column name */
  ModelYear = 'model_year',
  /** column name */
  TextDescription = 'text_description',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VehicleType = 'vehicle_type'
}

/** input type for updating data in table "fipe.vehicle" */
export type Fipe_Vehicle_Set_Input = {
  brand?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  fipe_code?: InputMaybe<Scalars['String']['input']>;
  fuel?: InputMaybe<Scalars['String']['input']>;
  fuel_acronym?: InputMaybe<Scalars['bpchar']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
  text_description?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Fipe_Vehicle_Stddev_Fields = {
  __typename?: 'fipe_vehicle_stddev_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Fipe_Vehicle_Stddev_Pop_Fields = {
  __typename?: 'fipe_vehicle_stddev_pop_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Fipe_Vehicle_Stddev_Samp_Fields = {
  __typename?: 'fipe_vehicle_stddev_samp_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "fipe_vehicle" */
export type Fipe_Vehicle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fipe_Vehicle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fipe_Vehicle_Stream_Cursor_Value_Input = {
  brand?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  fipe_code?: InputMaybe<Scalars['String']['input']>;
  fuel?: InputMaybe<Scalars['String']['input']>;
  fuel_acronym?: InputMaybe<Scalars['bpchar']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
  text_description?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Fipe_Vehicle_Sum_Fields = {
  __typename?: 'fipe_vehicle_sum_fields';
  model_year: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "fipe.vehicle" */
export enum Fipe_Vehicle_Update_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FipeCode = 'fipe_code',
  /** column name */
  Fuel = 'fuel',
  /** column name */
  FuelAcronym = 'fuel_acronym',
  /** column name */
  Model = 'model',
  /** column name */
  ModelYear = 'model_year',
  /** column name */
  TextDescription = 'text_description',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VehicleType = 'vehicle_type'
}

export type Fipe_Vehicle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Fipe_Vehicle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Fipe_Vehicle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fipe_Vehicle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fipe_Vehicle_Var_Pop_Fields = {
  __typename?: 'fipe_vehicle_var_pop_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Fipe_Vehicle_Var_Samp_Fields = {
  __typename?: 'fipe_vehicle_var_samp_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Fipe_Vehicle_Variance_Fields = {
  __typename?: 'fipe_vehicle_variance_fields';
  model_year: Maybe<Scalars['Float']['output']>;
};

export type Fleet_Performance_Data_Args = {
  exclusive_end_date?: InputMaybe<Scalars['date']['input']>;
  inclusive_start_date?: InputMaybe<Scalars['date']['input']>;
  score_type?: InputMaybe<Scalars['String']['input']>;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['float8']['input']>;
  _gt?: InputMaybe<Scalars['float8']['input']>;
  _gte?: InputMaybe<Scalars['float8']['input']>;
  _in?: InputMaybe<Array<Scalars['float8']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['float8']['input']>;
  _lte?: InputMaybe<Scalars['float8']['input']>;
  _neq?: InputMaybe<Scalars['float8']['input']>;
  _nin?: InputMaybe<Array<Scalars['float8']['input']>>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type Geography_Mssql_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['geography']['input']>;
  _gt?: InputMaybe<Scalars['geography']['input']>;
  _gte?: InputMaybe<Scalars['geography']['input']>;
  _in?: InputMaybe<Array<Scalars['geography']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['geography']['input']>;
  _lte?: InputMaybe<Scalars['geography']['input']>;
  _neq?: InputMaybe<Scalars['geography']['input']>;
  _nin?: InputMaybe<Array<Scalars['geography']['input']>>;
  /** does the column contain the given value */
  _st_contains?: InputMaybe<Scalars['geography']['input']>;
  /** is the column equal to given value (directionality is ignored) */
  _st_equals?: InputMaybe<Scalars['geography']['input']>;
  /** does the column spatially intersect the given value */
  _st_intersects?: InputMaybe<Scalars['geography']['input']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given value */
  _st_overlaps?: InputMaybe<Scalars['geography']['input']>;
  /** is the column contained in the given value */
  _st_within?: InputMaybe<Scalars['geography']['input']>;
};

export type Geography_Cast_Exp = {
  geometry?: InputMaybe<Geometry_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type Geography_Comparison_Exp = {
  _cast?: InputMaybe<Geography_Cast_Exp>;
  _eq?: InputMaybe<Scalars['geography']['input']>;
  _gt?: InputMaybe<Scalars['geography']['input']>;
  _gte?: InputMaybe<Scalars['geography']['input']>;
  _in?: InputMaybe<Array<Scalars['geography']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['geography']['input']>;
  _lte?: InputMaybe<Scalars['geography']['input']>;
  _neq?: InputMaybe<Scalars['geography']['input']>;
  _nin?: InputMaybe<Array<Scalars['geography']['input']>>;
  /** is the column within a given distance from the given geography value */
  _st_d_within?: InputMaybe<St_D_Within_Geography_Input>;
  /** does the column spatially intersect the given geography value */
  _st_intersects?: InputMaybe<Scalars['geography']['input']>;
};

export type Geometry_Cast_Exp = {
  geography?: InputMaybe<Geography_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'. */
export type Geometry_Comparison_Exp = {
  _cast?: InputMaybe<Geometry_Cast_Exp>;
  _eq?: InputMaybe<Scalars['geometry']['input']>;
  _gt?: InputMaybe<Scalars['geometry']['input']>;
  _gte?: InputMaybe<Scalars['geometry']['input']>;
  _in?: InputMaybe<Array<Scalars['geometry']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['geometry']['input']>;
  _lte?: InputMaybe<Scalars['geometry']['input']>;
  _neq?: InputMaybe<Scalars['geometry']['input']>;
  _nin?: InputMaybe<Array<Scalars['geometry']['input']>>;
  /** is the column within a given 3D distance from the given geometry value */
  _st_3d_d_within?: InputMaybe<St_D_Within_Input>;
  /** does the column spatially intersect the given geometry value in 3D */
  _st_3d_intersects?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column contain the given geometry value */
  _st_contains?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column cross the given geometry value */
  _st_crosses?: InputMaybe<Scalars['geometry']['input']>;
  /** is the column within a given distance from the given geometry value */
  _st_d_within?: InputMaybe<St_D_Within_Input>;
  /** is the column equal to given geometry value (directionality is ignored) */
  _st_equals?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column spatially intersect the given geometry value */
  _st_intersects?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given geometry value */
  _st_overlaps?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column have atleast one point in common with the given geometry value */
  _st_touches?: InputMaybe<Scalars['geometry']['input']>;
  /** is the column contained in the given geometry value */
  _st_within?: InputMaybe<Scalars['geometry']['input']>;
};

export type Get_Critical_Segments_From_Critical_Point_Args = {
  latitude?: InputMaybe<Scalars['float8']['input']>;
  longitude?: InputMaybe<Scalars['float8']['input']>;
  radius_meters?: InputMaybe<Scalars['float8']['input']>;
  road_types?: InputMaybe<Scalars['_text']['input']>;
};

export type Get_Driver_Warning_Geojson_Args = {
  p_driver_warning_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

export type Get_Route_Geojson_By_Score_Processed_Args = {
  p_codmoto?: InputMaybe<Scalars['String']['input']>;
  p_score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

export type Get_Trips_Geojson_Args = {
  trip_ids?: InputMaybe<Scalars['_int4']['input']>;
};

/** Boolean expression to compare columns of type "hstore". All fields are combined with logical 'AND'. */
export type Hstore_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['hstore']['input']>;
  _gt?: InputMaybe<Scalars['hstore']['input']>;
  _gte?: InputMaybe<Scalars['hstore']['input']>;
  _in?: InputMaybe<Array<Scalars['hstore']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['hstore']['input']>;
  _lte?: InputMaybe<Scalars['hstore']['input']>;
  _neq?: InputMaybe<Scalars['hstore']['input']>;
  _nin?: InputMaybe<Array<Scalars['hstore']['input']>>;
};

/** columns and relationships of "inspection" */
export type Inspection = {
  __typename?: 'inspection';
  created_at: Scalars['timestamptz']['output'];
  end_at: Scalars['timestamptz']['output'];
  exported: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['String']['output'];
  /** An array relationship */
  inspection_fk_tires: Array<Inspection_Fk_Tire>;
  /** An aggregate relationship */
  inspection_fk_tires_aggregate: Inspection_Fk_Tire_Aggregate;
  /** An array relationship */
  notes: Array<Note>;
  /** An aggregate relationship */
  notes_aggregate: Note_Aggregate;
  only_null_tire_pressure: Maybe<Scalars['Boolean']['output']>;
  service_type: Scalars['String']['output'];
  started_at: Scalars['timestamptz']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  vehicle: Vehicle;
  vehicle_plate: Scalars['String']['output'];
};


/** columns and relationships of "inspection" */
export type InspectionInspection_Fk_TiresArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


/** columns and relationships of "inspection" */
export type InspectionInspection_Fk_Tires_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


/** columns and relationships of "inspection" */
export type InspectionNotesArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};


/** columns and relationships of "inspection" */
export type InspectionNotes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};

/** aggregated selection of "inspection" */
export type Inspection_Aggregate = {
  __typename?: 'inspection_aggregate';
  aggregate: Maybe<Inspection_Aggregate_Fields>;
  nodes: Array<Inspection>;
};

export type Inspection_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Inspection_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Inspection_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Inspection_Aggregate_Bool_Exp_Count>;
};

export type Inspection_Aggregate_Bool_Exp_Bool_And = {
  arguments: Inspection_Select_Column_Inspection_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Inspection_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Inspection_Select_Column_Inspection_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Inspection_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Inspection_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "inspection" */
export type Inspection_Aggregate_Fields = {
  __typename?: 'inspection_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Inspection_Max_Fields>;
  min: Maybe<Inspection_Min_Fields>;
};


/** aggregate fields of "inspection" */
export type Inspection_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Inspection_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "inspection" */
export type Inspection_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Inspection_Max_Order_By>;
  min?: InputMaybe<Inspection_Min_Order_By>;
};

/** columns and relationships of "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter = {
  __typename?: 'inspection_analysis_parameter';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  value: Scalars['float8']['output'];
};

/** aggregated selection of "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Aggregate = {
  __typename?: 'inspection_analysis_parameter_aggregate';
  aggregate: Maybe<Inspection_Analysis_Parameter_Aggregate_Fields>;
  nodes: Array<Inspection_Analysis_Parameter>;
};

/** aggregate fields of "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Aggregate_Fields = {
  __typename?: 'inspection_analysis_parameter_aggregate_fields';
  avg: Maybe<Inspection_Analysis_Parameter_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Inspection_Analysis_Parameter_Max_Fields>;
  min: Maybe<Inspection_Analysis_Parameter_Min_Fields>;
  stddev: Maybe<Inspection_Analysis_Parameter_Stddev_Fields>;
  stddev_pop: Maybe<Inspection_Analysis_Parameter_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Inspection_Analysis_Parameter_Stddev_Samp_Fields>;
  sum: Maybe<Inspection_Analysis_Parameter_Sum_Fields>;
  var_pop: Maybe<Inspection_Analysis_Parameter_Var_Pop_Fields>;
  var_samp: Maybe<Inspection_Analysis_Parameter_Var_Samp_Fields>;
  variance: Maybe<Inspection_Analysis_Parameter_Variance_Fields>;
};


/** aggregate fields of "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Inspection_Analysis_Parameter_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Inspection_Analysis_Parameter_Avg_Fields = {
  __typename?: 'inspection_analysis_parameter_avg_fields';
  value: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "inspection_analysis_parameter". All fields are combined with a logical 'AND'. */
export type Inspection_Analysis_Parameter_Bool_Exp = {
  _and?: InputMaybe<Array<Inspection_Analysis_Parameter_Bool_Exp>>;
  _not?: InputMaybe<Inspection_Analysis_Parameter_Bool_Exp>;
  _or?: InputMaybe<Array<Inspection_Analysis_Parameter_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  value?: InputMaybe<Float8_Comparison_Exp>;
};

/** unique or primary key constraints on table "inspection_analysis_parameter" */
export enum Inspection_Analysis_Parameter_Constraint {
  /** unique or primary key constraint on columns "name" */
  InspectionAnalysisParameterPkey = 'inspection_analysis_parameter_pkey'
}

/** input type for incrementing numeric columns in table "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Inc_Input = {
  value?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate max on columns */
export type Inspection_Analysis_Parameter_Max_Fields = {
  __typename?: 'inspection_analysis_parameter_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  value: Maybe<Scalars['float8']['output']>;
};

/** aggregate min on columns */
export type Inspection_Analysis_Parameter_Min_Fields = {
  __typename?: 'inspection_analysis_parameter_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  value: Maybe<Scalars['float8']['output']>;
};

/** response of any mutation on the table "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Mutation_Response = {
  __typename?: 'inspection_analysis_parameter_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Inspection_Analysis_Parameter>;
};

/** on_conflict condition type for table "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_On_Conflict = {
  constraint: Inspection_Analysis_Parameter_Constraint;
  update_columns?: Array<Inspection_Analysis_Parameter_Update_Column>;
  where?: InputMaybe<Inspection_Analysis_Parameter_Bool_Exp>;
};

/** Ordering options when selecting data from "inspection_analysis_parameter". */
export type Inspection_Analysis_Parameter_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: inspection_analysis_parameter */
export type Inspection_Analysis_Parameter_Pk_Columns_Input = {
  name: Scalars['String']['input'];
};

/** select columns of table "inspection_analysis_parameter" */
export enum Inspection_Analysis_Parameter_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate stddev on columns */
export type Inspection_Analysis_Parameter_Stddev_Fields = {
  __typename?: 'inspection_analysis_parameter_stddev_fields';
  value: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Inspection_Analysis_Parameter_Stddev_Pop_Fields = {
  __typename?: 'inspection_analysis_parameter_stddev_pop_fields';
  value: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Inspection_Analysis_Parameter_Stddev_Samp_Fields = {
  __typename?: 'inspection_analysis_parameter_stddev_samp_fields';
  value: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "inspection_analysis_parameter" */
export type Inspection_Analysis_Parameter_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inspection_Analysis_Parameter_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inspection_Analysis_Parameter_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate sum on columns */
export type Inspection_Analysis_Parameter_Sum_Fields = {
  __typename?: 'inspection_analysis_parameter_sum_fields';
  value: Maybe<Scalars['float8']['output']>;
};

/** update columns of table "inspection_analysis_parameter" */
export enum Inspection_Analysis_Parameter_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

export type Inspection_Analysis_Parameter_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Inspection_Analysis_Parameter_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Inspection_Analysis_Parameter_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inspection_Analysis_Parameter_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Inspection_Analysis_Parameter_Var_Pop_Fields = {
  __typename?: 'inspection_analysis_parameter_var_pop_fields';
  value: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Inspection_Analysis_Parameter_Var_Samp_Fields = {
  __typename?: 'inspection_analysis_parameter_var_samp_fields';
  value: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Inspection_Analysis_Parameter_Variance_Fields = {
  __typename?: 'inspection_analysis_parameter_variance_fields';
  value: Maybe<Scalars['Float']['output']>;
};

/** input type for inserting array relation for remote table "inspection" */
export type Inspection_Arr_Rel_Insert_Input = {
  data: Array<Inspection_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Inspection_On_Conflict>;
};

/** Boolean expression to filter rows from the table "inspection". All fields are combined with a logical 'AND'. */
export type Inspection_Bool_Exp = {
  _and?: InputMaybe<Array<Inspection_Bool_Exp>>;
  _not?: InputMaybe<Inspection_Bool_Exp>;
  _or?: InputMaybe<Array<Inspection_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  end_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  exported?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  inspection_fk_tires?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  inspection_fk_tires_aggregate?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp>;
  notes?: InputMaybe<Note_Bool_Exp>;
  notes_aggregate?: InputMaybe<Note_Aggregate_Bool_Exp>;
  only_null_tire_pressure?: InputMaybe<Boolean_Comparison_Exp>;
  service_type?: InputMaybe<String_Comparison_Exp>;
  started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vehicle?: InputMaybe<Vehicle_Bool_Exp>;
  vehicle_plate?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "inspection" */
export enum Inspection_Constraint {
  /** unique or primary key constraint on columns "id" */
  InspectionPkey = 'inspection_pkey'
}

/** columns and relationships of "inspection_fk_tire" */
export type Inspection_Fk_Tire = {
  __typename?: 'inspection_fk_tire';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Int']['output']>;
  created_at: Scalars['timestamptz']['output'];
  groove: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  inspection: Inspection;
  inspection_id: Scalars['String']['output'];
  life: Maybe<Scalars['String']['output']>;
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  /** The position which the tire is located (external/internal - E/I) */
  position: Maybe<Scalars['bpchar']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
  /** The side which the tire is located (left/right - E/D) */
  side: Maybe<Scalars['bpchar']['output']>;
  /** An object relationship */
  tire: Tire;
  tire_id: Scalars['String']['output'];
  tire_identifier: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "inspection_fk_tire" */
export type Inspection_Fk_Tire_Aggregate = {
  __typename?: 'inspection_fk_tire_aggregate';
  aggregate: Maybe<Inspection_Fk_Tire_Aggregate_Fields>;
  nodes: Array<Inspection_Fk_Tire>;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp>;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg = {
  arguments: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr = {
  arguments: Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Max = {
  arguments: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Min = {
  arguments: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum = {
  arguments: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "inspection_fk_tire" */
export type Inspection_Fk_Tire_Aggregate_Fields = {
  __typename?: 'inspection_fk_tire_aggregate_fields';
  avg: Maybe<Inspection_Fk_Tire_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Inspection_Fk_Tire_Max_Fields>;
  min: Maybe<Inspection_Fk_Tire_Min_Fields>;
  stddev: Maybe<Inspection_Fk_Tire_Stddev_Fields>;
  stddev_pop: Maybe<Inspection_Fk_Tire_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Inspection_Fk_Tire_Stddev_Samp_Fields>;
  sum: Maybe<Inspection_Fk_Tire_Sum_Fields>;
  var_pop: Maybe<Inspection_Fk_Tire_Var_Pop_Fields>;
  var_samp: Maybe<Inspection_Fk_Tire_Var_Samp_Fields>;
  variance: Maybe<Inspection_Fk_Tire_Variance_Fields>;
};


/** aggregate fields of "inspection_fk_tire" */
export type Inspection_Fk_Tire_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Aggregate_Order_By = {
  avg?: InputMaybe<Inspection_Fk_Tire_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Inspection_Fk_Tire_Max_Order_By>;
  min?: InputMaybe<Inspection_Fk_Tire_Min_Order_By>;
  stddev?: InputMaybe<Inspection_Fk_Tire_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Inspection_Fk_Tire_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Inspection_Fk_Tire_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Inspection_Fk_Tire_Sum_Order_By>;
  var_pop?: InputMaybe<Inspection_Fk_Tire_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Inspection_Fk_Tire_Var_Samp_Order_By>;
  variance?: InputMaybe<Inspection_Fk_Tire_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Arr_Rel_Insert_Input = {
  data: Array<Inspection_Fk_Tire_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Inspection_Fk_Tire_On_Conflict>;
};

/** aggregate avg on columns */
export type Inspection_Fk_Tire_Avg_Fields = {
  __typename?: 'inspection_fk_tire_avg_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  groove: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Avg_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "inspection_fk_tire". All fields are combined with a logical 'AND'. */
export type Inspection_Fk_Tire_Bool_Exp = {
  _and?: InputMaybe<Array<Inspection_Fk_Tire_Bool_Exp>>;
  _not?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  _or?: InputMaybe<Array<Inspection_Fk_Tire_Bool_Exp>>;
  axis?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  groove?: InputMaybe<Int_Comparison_Exp>;
  inspection?: InputMaybe<Inspection_Bool_Exp>;
  inspection_id?: InputMaybe<String_Comparison_Exp>;
  life?: InputMaybe<String_Comparison_Exp>;
  maximum_depth?: InputMaybe<Float8_Comparison_Exp>;
  minimum_depth?: InputMaybe<Float8_Comparison_Exp>;
  position?: InputMaybe<Bpchar_Comparison_Exp>;
  pressure?: InputMaybe<Int_Comparison_Exp>;
  side?: InputMaybe<Bpchar_Comparison_Exp>;
  tire?: InputMaybe<Tire_Bool_Exp>;
  tire_id?: InputMaybe<String_Comparison_Exp>;
  tire_identifier?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Constraint {
  /** unique or primary key constraint on columns "tire_id", "inspection_id" */
  InspectionFkTirePkey = 'inspection_fk_tire_pkey'
}

/** input type for incrementing numeric columns in table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Inc_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['Int']['input']>;
  groove?: InputMaybe<Scalars['Int']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Insert_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  groove?: InputMaybe<Scalars['Int']['input']>;
  inspection?: InputMaybe<Inspection_Obj_Rel_Insert_Input>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  life?: InputMaybe<Scalars['String']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Scalars['bpchar']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Scalars['bpchar']['input']>;
  tire?: InputMaybe<Tire_Obj_Rel_Insert_Input>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Inspection_Fk_Tire_Max_Fields = {
  __typename?: 'inspection_fk_tire_max_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  groove: Maybe<Scalars['Int']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  life: Maybe<Scalars['String']['output']>;
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  /** The position which the tire is located (external/internal - E/I) */
  position: Maybe<Scalars['bpchar']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
  /** The side which the tire is located (left/right - E/D) */
  side: Maybe<Scalars['bpchar']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Max_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  life?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Inspection_Fk_Tire_Min_Fields = {
  __typename?: 'inspection_fk_tire_min_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  groove: Maybe<Scalars['Int']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  life: Maybe<Scalars['String']['output']>;
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  /** The position which the tire is located (external/internal - E/I) */
  position: Maybe<Scalars['bpchar']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
  /** The side which the tire is located (left/right - E/D) */
  side: Maybe<Scalars['bpchar']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Min_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  life?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Mutation_Response = {
  __typename?: 'inspection_fk_tire_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Inspection_Fk_Tire>;
};

/** on_conflict condition type for table "inspection_fk_tire" */
export type Inspection_Fk_Tire_On_Conflict = {
  constraint: Inspection_Fk_Tire_Constraint;
  update_columns?: Array<Inspection_Fk_Tire_Update_Column>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};

/** Ordering options when selecting data from "inspection_fk_tire". */
export type Inspection_Fk_Tire_Order_By = {
  axis?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  inspection?: InputMaybe<Inspection_Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  life?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
  side?: InputMaybe<Order_By>;
  tire?: InputMaybe<Tire_Order_By>;
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
};

/** primary key columns input for table: inspection_fk_tire */
export type Inspection_Fk_Tire_Pk_Columns_Input = {
  inspection_id: Scalars['String']['input'];
  tire_id: Scalars['String']['input'];
};

/** select columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column {
  /** column name */
  Axis = 'axis',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Groove = 'groove',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  Life = 'life',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth',
  /** column name */
  Position = 'position',
  /** column name */
  Pressure = 'pressure',
  /** column name */
  Side = 'side',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier'
}

/** select "inspection_fk_tire_aggregate_bool_exp_avg_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "inspection_fk_tire_aggregate_bool_exp_corr_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "inspection_fk_tire_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "inspection_fk_tire_aggregate_bool_exp_max_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "inspection_fk_tire_aggregate_bool_exp_min_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "inspection_fk_tire_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "inspection_fk_tire_aggregate_bool_exp_sum_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "inspection_fk_tire_aggregate_bool_exp_var_samp_arguments_columns" columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Select_Column_Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** input type for updating data in table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Set_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  groove?: InputMaybe<Scalars['Int']['input']>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  life?: InputMaybe<Scalars['String']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Scalars['bpchar']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Scalars['bpchar']['input']>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Inspection_Fk_Tire_Stddev_Fields = {
  __typename?: 'inspection_fk_tire_stddev_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  groove: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Stddev_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Inspection_Fk_Tire_Stddev_Pop_Fields = {
  __typename?: 'inspection_fk_tire_stddev_pop_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  groove: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Stddev_Pop_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Inspection_Fk_Tire_Stddev_Samp_Fields = {
  __typename?: 'inspection_fk_tire_stddev_samp_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  groove: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Stddev_Samp_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inspection_Fk_Tire_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inspection_Fk_Tire_Stream_Cursor_Value_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  groove?: InputMaybe<Scalars['Int']['input']>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  life?: InputMaybe<Scalars['String']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Scalars['bpchar']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Scalars['bpchar']['input']>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Inspection_Fk_Tire_Sum_Fields = {
  __typename?: 'inspection_fk_tire_sum_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Int']['output']>;
  groove: Maybe<Scalars['Int']['output']>;
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Sum_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** update columns of table "inspection_fk_tire" */
export enum Inspection_Fk_Tire_Update_Column {
  /** column name */
  Axis = 'axis',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Groove = 'groove',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  Life = 'life',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth',
  /** column name */
  Position = 'position',
  /** column name */
  Pressure = 'pressure',
  /** column name */
  Side = 'side',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier'
}

export type Inspection_Fk_Tire_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Inspection_Fk_Tire_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Inspection_Fk_Tire_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inspection_Fk_Tire_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Inspection_Fk_Tire_Var_Pop_Fields = {
  __typename?: 'inspection_fk_tire_var_pop_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  groove: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Var_Pop_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Inspection_Fk_Tire_Var_Samp_Fields = {
  __typename?: 'inspection_fk_tire_var_samp_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  groove: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Var_Samp_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Inspection_Fk_Tire_Variance_Fields = {
  __typename?: 'inspection_fk_tire_variance_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  groove: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "inspection_fk_tire" */
export type Inspection_Fk_Tire_Variance_Order_By = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Order_By>;
  groove?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** input type for inserting data into table "inspection" */
export type Inspection_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  exported?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inspection_fk_tires?: InputMaybe<Inspection_Fk_Tire_Arr_Rel_Insert_Input>;
  notes?: InputMaybe<Note_Arr_Rel_Insert_Input>;
  only_null_tire_pressure?: InputMaybe<Scalars['Boolean']['input']>;
  service_type?: InputMaybe<Scalars['String']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle?: InputMaybe<Vehicle_Obj_Rel_Insert_Input>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Inspection_Max_Fields = {
  __typename?: 'inspection_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  end_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['String']['output']>;
  service_type: Maybe<Scalars['String']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "inspection" */
export type Inspection_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  end_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  service_type?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Inspection_Min_Fields = {
  __typename?: 'inspection_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  end_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['String']['output']>;
  service_type: Maybe<Scalars['String']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "inspection" */
export type Inspection_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  end_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  service_type?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "inspection" */
export type Inspection_Mutation_Response = {
  __typename?: 'inspection_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Inspection>;
};

/** input type for inserting object relation for remote table "inspection" */
export type Inspection_Obj_Rel_Insert_Input = {
  data: Inspection_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Inspection_On_Conflict>;
};

/** on_conflict condition type for table "inspection" */
export type Inspection_On_Conflict = {
  constraint: Inspection_Constraint;
  update_columns?: Array<Inspection_Update_Column>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};

/** Ordering options when selecting data from "inspection". */
export type Inspection_Order_By = {
  created_at?: InputMaybe<Order_By>;
  end_at?: InputMaybe<Order_By>;
  exported?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inspection_fk_tires_aggregate?: InputMaybe<Inspection_Fk_Tire_Aggregate_Order_By>;
  notes_aggregate?: InputMaybe<Note_Aggregate_Order_By>;
  only_null_tire_pressure?: InputMaybe<Order_By>;
  service_type?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vehicle?: InputMaybe<Vehicle_Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** primary key columns input for table: inspection */
export type Inspection_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "inspection" */
export enum Inspection_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  Exported = 'exported',
  /** column name */
  Id = 'id',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure',
  /** column name */
  ServiceType = 'service_type',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

/** select "inspection_aggregate_bool_exp_bool_and_arguments_columns" columns of table "inspection" */
export enum Inspection_Select_Column_Inspection_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Exported = 'exported',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure'
}

/** select "inspection_aggregate_bool_exp_bool_or_arguments_columns" columns of table "inspection" */
export enum Inspection_Select_Column_Inspection_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Exported = 'exported',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure'
}

/** input type for updating data in table "inspection" */
export type Inspection_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  exported?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  only_null_tire_pressure?: InputMaybe<Scalars['Boolean']['input']>;
  service_type?: InputMaybe<Scalars['String']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "inspection" */
export type Inspection_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inspection_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inspection_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  exported?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  only_null_tire_pressure?: InputMaybe<Scalars['Boolean']['input']>;
  service_type?: InputMaybe<Scalars['String']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

export type Inspection_Tire_By_Vehicle = {
  __typename?: 'inspection_tire_by_vehicle';
  axis: Scalars['Int']['output'];
  band: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  dimension: Maybe<Scalars['String']['output']>;
  inspection_id: Scalars['String']['output'];
  position: Scalars['String']['output'];
  side: Scalars['String']['output'];
  started_at: Scalars['timestamptz']['output'];
  tire_id: Scalars['String']['output'];
  tire_identifier: Maybe<Scalars['String']['output']>;
  vehicle_plate: Scalars['String']['output'];
};

/** Boolean expression to filter rows from the logical model for "inspection_tire_by_vehicle". All fields are combined with a logical 'AND'. */
export type Inspection_Tire_By_Vehicle_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<Inspection_Tire_By_Vehicle_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<Inspection_Tire_By_Vehicle_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<Inspection_Tire_By_Vehicle_Bool_Exp_Bool_Exp>>;
  axis?: InputMaybe<Int_Comparison_Exp>;
  band?: InputMaybe<String_Comparison_Exp>;
  brand_name?: InputMaybe<String_Comparison_Exp>;
  dimension?: InputMaybe<String_Comparison_Exp>;
  inspection_id?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<String_Comparison_Exp>;
  side?: InputMaybe<String_Comparison_Exp>;
  started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  tire_id?: InputMaybe<String_Comparison_Exp>;
  tire_identifier?: InputMaybe<String_Comparison_Exp>;
  vehicle_plate?: InputMaybe<String_Comparison_Exp>;
};

export enum Inspection_Tire_By_Vehicle_Enum_Name {
  /** column name */
  Axis = 'axis',
  /** column name */
  Band = 'band',
  /** column name */
  BrandName = 'brand_name',
  /** column name */
  Dimension = 'dimension',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  Position = 'position',
  /** column name */
  Side = 'side',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

/** Ordering options when selecting data from "inspection_tire_by_vehicle". */
export type Inspection_Tire_By_Vehicle_Order_By = {
  axis?: InputMaybe<Order_By>;
  band?: InputMaybe<Order_By>;
  brand_name?: InputMaybe<Order_By>;
  dimension?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  side?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** update columns of table "inspection" */
export enum Inspection_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  Exported = 'exported',
  /** column name */
  Id = 'id',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure',
  /** column name */
  ServiceType = 'service_type',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

export type Inspection_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Inspection_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inspection_Bool_Exp;
};

/** inspections_exportNative Query Arguments */
export type Inspections_Export_Arguments = {
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  sync_date: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_excessive_high_pressureNative Query Arguments */
export type Inspections_That_Reported_Excessive_High_Pressure_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_excessive_low_pressureNative Query Arguments */
export type Inspections_That_Reported_Excessive_Low_Pressure_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_high_pressureNative Query Arguments */
export type Inspections_That_Reported_High_Pressure_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_high_twin_tires_minimum_depth_differenceNative Query Arguments */
export type Inspections_That_Reported_High_Twin_Tires_Minimum_Depth_Difference_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_low_pressureNative Query Arguments */
export type Inspections_That_Reported_Low_Pressure_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_low_tire_depthNative Query Arguments */
export type Inspections_That_Reported_Low_Tire_Depth_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_open_servicesNative Query Arguments */
export type Inspections_That_Reported_Open_Services_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_wear_irregularNative Query Arguments */
export type Inspections_That_Reported_Wear_Irregular_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_wear_severeNative Query Arguments */
export type Inspections_That_Reported_Wear_Severe_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_wear_severe_cavalo_mecanicoNative Query Arguments */
export type Inspections_That_Reported_Wear_Severe_Cavalo_Mecanico_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

/** inspections_that_reported_wear_severe_semi_reboqueNative Query Arguments */
export type Inspections_That_Reported_Wear_Severe_Semi_Reboque_Arguments = {
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};

export type Instructor_Drivers_Performance_History_Args = {
  lastupdatedatbyuser?: InputMaybe<Scalars['json']['input']>;
};

/** columns and relationships of "instructor_supervision" */
export type Instructor_Supervision = {
  __typename?: 'instructor_supervision';
  /** An object relationship */
  admin: Admin;
  /** An object relationship */
  adminByInstructorUuid: Admin;
  /** The admin that created this supervision */
  admin_uuid: Scalars['uuid']['output'];
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['float8']['output']>;
  /** When the supervision was cancelled */
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason: Maybe<Scalars['String']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['float8']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** A description of why this supervision will occur */
  description: Scalars['String']['output'];
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['float8']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['float8']['output']>;
  /** When the supervision was finished by the instructor */
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['float8']['output']>;
  /** An array relationship */
  instructor_supervision_observations: Array<Instructor_Supervision_Observation>;
  /** An aggregate relationship */
  instructor_supervision_observations_aggregate: Instructor_Supervision_Observation_Aggregate;
  /** The instructor that will supervise this */
  instructor_uuid: Scalars['uuid']['output'];
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** If this instructor supervision needs to be processed, to update new upcoming data about the driver notes */
  need_to_be_processed: Maybe<Scalars['Boolean']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['float8']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['float8']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['float8']['output']>;
  /** When the supervision was started */
  started_at: Maybe<Scalars['timestamptz']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['float8']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: User;
  /** The driver that will be followed in this supervision */
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "instructor_supervision" */
export type Instructor_SupervisionInstructor_Supervision_ObservationsArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};


/** columns and relationships of "instructor_supervision" */
export type Instructor_SupervisionInstructor_Supervision_Observations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};

/** aggregated selection of "instructor_supervision" */
export type Instructor_Supervision_Aggregate = {
  __typename?: 'instructor_supervision_aggregate';
  aggregate: Maybe<Instructor_Supervision_Aggregate_Fields>;
  nodes: Array<Instructor_Supervision>;
};

export type Instructor_Supervision_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp_Var_Samp>;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Avg = {
  arguments: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Corr = {
  arguments: Instructor_Supervision_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Instructor_Supervision_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Max = {
  arguments: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Min = {
  arguments: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Sum = {
  arguments: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Instructor_Supervision_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "instructor_supervision" */
export type Instructor_Supervision_Aggregate_Fields = {
  __typename?: 'instructor_supervision_aggregate_fields';
  avg: Maybe<Instructor_Supervision_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Instructor_Supervision_Max_Fields>;
  min: Maybe<Instructor_Supervision_Min_Fields>;
  stddev: Maybe<Instructor_Supervision_Stddev_Fields>;
  stddev_pop: Maybe<Instructor_Supervision_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Instructor_Supervision_Stddev_Samp_Fields>;
  sum: Maybe<Instructor_Supervision_Sum_Fields>;
  var_pop: Maybe<Instructor_Supervision_Var_Pop_Fields>;
  var_samp: Maybe<Instructor_Supervision_Var_Samp_Fields>;
  variance: Maybe<Instructor_Supervision_Variance_Fields>;
};


/** aggregate fields of "instructor_supervision" */
export type Instructor_Supervision_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "instructor_supervision" */
export type Instructor_Supervision_Aggregate_Order_By = {
  avg?: InputMaybe<Instructor_Supervision_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Instructor_Supervision_Max_Order_By>;
  min?: InputMaybe<Instructor_Supervision_Min_Order_By>;
  stddev?: InputMaybe<Instructor_Supervision_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Instructor_Supervision_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Instructor_Supervision_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Instructor_Supervision_Sum_Order_By>;
  var_pop?: InputMaybe<Instructor_Supervision_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Instructor_Supervision_Var_Samp_Order_By>;
  variance?: InputMaybe<Instructor_Supervision_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "instructor_supervision" */
export type Instructor_Supervision_Arr_Rel_Insert_Input = {
  data: Array<Instructor_Supervision_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Instructor_Supervision_On_Conflict>;
};

/** aggregate avg on columns */
export type Instructor_Supervision_Avg_Fields = {
  __typename?: 'instructor_supervision_avg_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['Float']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['Float']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['Float']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['Float']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['Float']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['Float']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['Float']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Avg_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "instructor_supervision". All fields are combined with a logical 'AND'. */
export type Instructor_Supervision_Bool_Exp = {
  _and?: InputMaybe<Array<Instructor_Supervision_Bool_Exp>>;
  _not?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  _or?: InputMaybe<Array<Instructor_Supervision_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  adminByInstructorUuid?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  brake_use?: InputMaybe<Float8_Comparison_Exp>;
  cancelled_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  cancelled_reason?: InputMaybe<String_Comparison_Exp>;
  consumed_fuel?: InputMaybe<Float8_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  economic_range?: InputMaybe<Float8_Comparison_Exp>;
  engine_load?: InputMaybe<Float8_Comparison_Exp>;
  finished_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  inertia?: InputMaybe<Float8_Comparison_Exp>;
  instructor_supervision_observations?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
  instructor_supervision_observations_aggregate?: InputMaybe<Instructor_Supervision_Observation_Aggregate_Bool_Exp>;
  instructor_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  last_processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  need_to_be_processed?: InputMaybe<Boolean_Comparison_Exp>;
  note?: InputMaybe<Float8_Comparison_Exp>;
  slow_running?: InputMaybe<Float8_Comparison_Exp>;
  speed_control?: InputMaybe<Float8_Comparison_Exp>;
  started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  total_km?: InputMaybe<Float8_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  vehicle_plate_scanned?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "instructor_supervision" */
export enum Instructor_Supervision_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  InstructorSupervisionPkey = 'instructor_supervision_pkey'
}

/** input type for incrementing numeric columns in table "instructor_supervision" */
export type Instructor_Supervision_Inc_Input = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Scalars['float8']['input']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Scalars['float8']['input']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "instructor_supervision" */
export type Instructor_Supervision_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  adminByInstructorUuid?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  /** The admin that created this supervision */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was cancelled */
  cancelled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason?: InputMaybe<Scalars['String']['input']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A description of why this supervision will occur */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was finished by the instructor */
  finished_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Scalars['float8']['input']>;
  instructor_supervision_observations?: InputMaybe<Instructor_Supervision_Observation_Arr_Rel_Insert_Input>;
  /** The instructor that will supervise this */
  instructor_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Scalars['float8']['input']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was started */
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  /** The driver that will be followed in this supervision */
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Instructor_Supervision_Max_Fields = {
  __typename?: 'instructor_supervision_max_fields';
  /** The admin that created this supervision */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['float8']['output']>;
  /** When the supervision was cancelled */
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason: Maybe<Scalars['String']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['float8']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A description of why this supervision will occur */
  description: Maybe<Scalars['String']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['float8']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['float8']['output']>;
  /** When the supervision was finished by the instructor */
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['float8']['output']>;
  /** The instructor that will supervise this */
  instructor_uuid: Maybe<Scalars['uuid']['output']>;
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['float8']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['float8']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['float8']['output']>;
  /** When the supervision was started */
  started_at: Maybe<Scalars['timestamptz']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** The driver that will be followed in this supervision */
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Max_Order_By = {
  /** The admin that created this supervision */
  admin_uuid?: InputMaybe<Order_By>;
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** When the supervision was cancelled */
  cancelled_at?: InputMaybe<Order_By>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** A description of why this supervision will occur */
  description?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** When the supervision was finished by the instructor */
  finished_at?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The instructor that will supervise this */
  instructor_uuid?: InputMaybe<Order_By>;
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** When the supervision was started */
  started_at?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** The driver that will be followed in this supervision */
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Instructor_Supervision_Min_Fields = {
  __typename?: 'instructor_supervision_min_fields';
  /** The admin that created this supervision */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['float8']['output']>;
  /** When the supervision was cancelled */
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason: Maybe<Scalars['String']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['float8']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A description of why this supervision will occur */
  description: Maybe<Scalars['String']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['float8']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['float8']['output']>;
  /** When the supervision was finished by the instructor */
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['float8']['output']>;
  /** The instructor that will supervise this */
  instructor_uuid: Maybe<Scalars['uuid']['output']>;
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['float8']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['float8']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['float8']['output']>;
  /** When the supervision was started */
  started_at: Maybe<Scalars['timestamptz']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** The driver that will be followed in this supervision */
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Min_Order_By = {
  /** The admin that created this supervision */
  admin_uuid?: InputMaybe<Order_By>;
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** When the supervision was cancelled */
  cancelled_at?: InputMaybe<Order_By>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** A description of why this supervision will occur */
  description?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** When the supervision was finished by the instructor */
  finished_at?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The instructor that will supervise this */
  instructor_uuid?: InputMaybe<Order_By>;
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** When the supervision was started */
  started_at?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** The driver that will be followed in this supervision */
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "instructor_supervision" */
export type Instructor_Supervision_Mutation_Response = {
  __typename?: 'instructor_supervision_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Instructor_Supervision>;
};

/** input type for inserting object relation for remote table "instructor_supervision" */
export type Instructor_Supervision_Obj_Rel_Insert_Input = {
  data: Instructor_Supervision_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Instructor_Supervision_On_Conflict>;
};

/** columns and relationships of "instructor_supervision_observation" */
export type Instructor_Supervision_Observation = {
  __typename?: 'instructor_supervision_observation';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  instructor_supervision: Instructor_Supervision;
  instructor_supervision_uuid: Scalars['uuid']['output'];
  observation: Scalars['String']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Aggregate = {
  __typename?: 'instructor_supervision_observation_aggregate';
  aggregate: Maybe<Instructor_Supervision_Observation_Aggregate_Fields>;
  nodes: Array<Instructor_Supervision_Observation>;
};

export type Instructor_Supervision_Observation_Aggregate_Bool_Exp = {
  count?: InputMaybe<Instructor_Supervision_Observation_Aggregate_Bool_Exp_Count>;
};

export type Instructor_Supervision_Observation_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Aggregate_Fields = {
  __typename?: 'instructor_supervision_observation_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Instructor_Supervision_Observation_Max_Fields>;
  min: Maybe<Instructor_Supervision_Observation_Min_Fields>;
};


/** aggregate fields of "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Instructor_Supervision_Observation_Max_Order_By>;
  min?: InputMaybe<Instructor_Supervision_Observation_Min_Order_By>;
};

/** input type for inserting array relation for remote table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Arr_Rel_Insert_Input = {
  data: Array<Instructor_Supervision_Observation_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Instructor_Supervision_Observation_On_Conflict>;
};

/** Boolean expression to filter rows from the table "instructor_supervision_observation". All fields are combined with a logical 'AND'. */
export type Instructor_Supervision_Observation_Bool_Exp = {
  _and?: InputMaybe<Array<Instructor_Supervision_Observation_Bool_Exp>>;
  _not?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
  _or?: InputMaybe<Array<Instructor_Supervision_Observation_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  instructor_supervision?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  instructor_supervision_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  observation?: InputMaybe<String_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "instructor_supervision_observation" */
export enum Instructor_Supervision_Observation_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  InstructorSupervisionObservationPkey = 'instructor_supervision_observation_pkey'
}

/** input type for inserting data into table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  instructor_supervision?: InputMaybe<Instructor_Supervision_Obj_Rel_Insert_Input>;
  instructor_supervision_uuid?: InputMaybe<Scalars['uuid']['input']>;
  observation?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Instructor_Supervision_Observation_Max_Fields = {
  __typename?: 'instructor_supervision_observation_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  instructor_supervision_uuid: Maybe<Scalars['uuid']['output']>;
  observation: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  instructor_supervision_uuid?: InputMaybe<Order_By>;
  observation?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Instructor_Supervision_Observation_Min_Fields = {
  __typename?: 'instructor_supervision_observation_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  instructor_supervision_uuid: Maybe<Scalars['uuid']['output']>;
  observation: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  instructor_supervision_uuid?: InputMaybe<Order_By>;
  observation?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Mutation_Response = {
  __typename?: 'instructor_supervision_observation_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Instructor_Supervision_Observation>;
};

/** on_conflict condition type for table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_On_Conflict = {
  constraint: Instructor_Supervision_Observation_Constraint;
  update_columns?: Array<Instructor_Supervision_Observation_Update_Column>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};

/** Ordering options when selecting data from "instructor_supervision_observation". */
export type Instructor_Supervision_Observation_Order_By = {
  created_at?: InputMaybe<Order_By>;
  instructor_supervision?: InputMaybe<Instructor_Supervision_Order_By>;
  instructor_supervision_uuid?: InputMaybe<Order_By>;
  observation?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: instructor_supervision_observation */
export type Instructor_Supervision_Observation_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "instructor_supervision_observation" */
export enum Instructor_Supervision_Observation_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InstructorSupervisionUuid = 'instructor_supervision_uuid',
  /** column name */
  Observation = 'observation',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  instructor_supervision_uuid?: InputMaybe<Scalars['uuid']['input']>;
  observation?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "instructor_supervision_observation" */
export type Instructor_Supervision_Observation_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Instructor_Supervision_Observation_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Instructor_Supervision_Observation_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  instructor_supervision_uuid?: InputMaybe<Scalars['uuid']['input']>;
  observation?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "instructor_supervision_observation" */
export enum Instructor_Supervision_Observation_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InstructorSupervisionUuid = 'instructor_supervision_uuid',
  /** column name */
  Observation = 'observation',
  /** column name */
  Uuid = 'uuid'
}

export type Instructor_Supervision_Observation_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Instructor_Supervision_Observation_Set_Input>;
  /** filter the rows which have to be updated */
  where: Instructor_Supervision_Observation_Bool_Exp;
};

/** on_conflict condition type for table "instructor_supervision" */
export type Instructor_Supervision_On_Conflict = {
  constraint: Instructor_Supervision_Constraint;
  update_columns?: Array<Instructor_Supervision_Update_Column>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};

/** Ordering options when selecting data from "instructor_supervision". */
export type Instructor_Supervision_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  adminByInstructorUuid?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  brake_use?: InputMaybe<Order_By>;
  cancelled_at?: InputMaybe<Order_By>;
  cancelled_reason?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  finished_at?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  instructor_supervision_observations_aggregate?: InputMaybe<Instructor_Supervision_Observation_Aggregate_Order_By>;
  instructor_uuid?: InputMaybe<Order_By>;
  last_processed_at?: InputMaybe<Order_By>;
  need_to_be_processed?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  vehicle_plate_scanned?: InputMaybe<Order_By>;
};

/** primary key columns input for table: instructor_supervision */
export type Instructor_Supervision_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  CancelledAt = 'cancelled_at',
  /** column name */
  CancelledReason = 'cancelled_reason',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  FinishedAt = 'finished_at',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  InstructorUuid = 'instructor_uuid',
  /** column name */
  LastProcessedAt = 'last_processed_at',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VehiclePlateScanned = 'vehicle_plate_scanned'
}

/** select "instructor_supervision_aggregate_bool_exp_avg_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "instructor_supervision_aggregate_bool_exp_corr_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "instructor_supervision_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "instructor_supervision_aggregate_bool_exp_max_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "instructor_supervision_aggregate_bool_exp_min_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "instructor_supervision_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "instructor_supervision_aggregate_bool_exp_sum_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "instructor_supervision_aggregate_bool_exp_var_samp_arguments_columns" columns of table "instructor_supervision" */
export enum Instructor_Supervision_Select_Column_Instructor_Supervision_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** input type for updating data in table "instructor_supervision" */
export type Instructor_Supervision_Set_Input = {
  /** The admin that created this supervision */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was cancelled */
  cancelled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason?: InputMaybe<Scalars['String']['input']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A description of why this supervision will occur */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was finished by the instructor */
  finished_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Scalars['float8']['input']>;
  /** The instructor that will supervise this */
  instructor_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Scalars['float8']['input']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was started */
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The driver that will be followed in this supervision */
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Instructor_Supervision_Stddev_Fields = {
  __typename?: 'instructor_supervision_stddev_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['Float']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['Float']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['Float']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['Float']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['Float']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['Float']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['Float']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Stddev_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Instructor_Supervision_Stddev_Pop_Fields = {
  __typename?: 'instructor_supervision_stddev_pop_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['Float']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['Float']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['Float']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['Float']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['Float']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['Float']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['Float']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Stddev_Pop_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Instructor_Supervision_Stddev_Samp_Fields = {
  __typename?: 'instructor_supervision_stddev_samp_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['Float']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['Float']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['Float']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['Float']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['Float']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['Float']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['Float']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Stddev_Samp_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "instructor_supervision" */
export type Instructor_Supervision_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Instructor_Supervision_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Instructor_Supervision_Stream_Cursor_Value_Input = {
  /** The admin that created this supervision */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was cancelled */
  cancelled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The reason of why the supervision was cancelled */
  cancelled_reason?: InputMaybe<Scalars['String']['input']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A description of why this supervision will occur */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was finished by the instructor */
  finished_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Scalars['float8']['input']>;
  /** The instructor that will supervise this */
  instructor_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The last time the notes of the current supervision was processed. If started_at is null then this is also null. It will process until 3 hours after the finished_at */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Scalars['float8']['input']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  /** When the supervision was started */
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The driver that will be followed in this supervision */
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle plate scanned by the instructor using the scanner. It's here for checking and history purposes */
  vehicle_plate_scanned?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Instructor_Supervision_Sum_Fields = {
  __typename?: 'instructor_supervision_sum_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['float8']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['float8']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['float8']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['float8']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['float8']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['float8']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['float8']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['float8']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Sum_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** update columns of table "instructor_supervision" */
export enum Instructor_Supervision_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  CancelledAt = 'cancelled_at',
  /** column name */
  CancelledReason = 'cancelled_reason',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  FinishedAt = 'finished_at',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  InstructorUuid = 'instructor_uuid',
  /** column name */
  LastProcessedAt = 'last_processed_at',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VehiclePlateScanned = 'vehicle_plate_scanned'
}

export type Instructor_Supervision_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Instructor_Supervision_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Instructor_Supervision_Set_Input>;
  /** filter the rows which have to be updated */
  where: Instructor_Supervision_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Instructor_Supervision_Var_Pop_Fields = {
  __typename?: 'instructor_supervision_var_pop_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['Float']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['Float']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['Float']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['Float']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['Float']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['Float']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['Float']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Var_Pop_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Instructor_Supervision_Var_Samp_Fields = {
  __typename?: 'instructor_supervision_var_samp_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['Float']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['Float']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['Float']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['Float']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['Float']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['Float']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['Float']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Var_Samp_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Instructor_Supervision_Variance_Fields = {
  __typename?: 'instructor_supervision_variance_fields';
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use: Maybe<Scalars['Float']['output']>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range: Maybe<Scalars['Float']['output']>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load: Maybe<Scalars['Float']['output']>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia: Maybe<Scalars['Float']['output']>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note: Maybe<Scalars['Float']['output']>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running: Maybe<Scalars['Float']['output']>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control: Maybe<Scalars['Float']['output']>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "instructor_supervision" */
export type Instructor_Supervision_Variance_Order_By = {
  /** The final brake_use note of the driver during the supervision period. Is calculated only when the supervision finishes */
  brake_use?: InputMaybe<Order_By>;
  /** The quantity of fuel consumed during the supervision period. Is calculated only when the supervision finishes */
  consumed_fuel?: InputMaybe<Order_By>;
  /** The final economic_range note of the driver during the supervision period. Is calculated only when the supervision finishes */
  economic_range?: InputMaybe<Order_By>;
  /** The final engine_load note of the driver during the supervision period. Is calculated only when the supervision finishes */
  engine_load?: InputMaybe<Order_By>;
  /** The final inertia note of the driver during the supervision period. Is calculated only when the supervision finishes */
  inertia?: InputMaybe<Order_By>;
  /** The final note of the driver during the supervision period. Is calculated only when the supervision finishes */
  note?: InputMaybe<Order_By>;
  /** The final slow_running note of the driver during the supervision period. Is calculated only when the supervision finishes */
  slow_running?: InputMaybe<Order_By>;
  /** The final speed_control note of the driver during the supervision period. Is calculated only when the supervision finishes */
  speed_control?: InputMaybe<Order_By>;
  /** The total km traveled during the supervision period. Is calculated only when the supervision finishes */
  total_km?: InputMaybe<Order_By>;
};

/** columns and relationships of "instructor_supervision_with_user" */
export type Instructor_Supervision_With_User = {
  __typename?: 'instructor_supervision_with_user';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  brake_use: Maybe<Scalars['float8']['output']>;
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  cancelled_reason: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  driver_avatar_url: Maybe<Scalars['String']['output']>;
  driver_license_plate: Maybe<Scalars['String']['output']>;
  driver_name: Maybe<Scalars['String']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  /** An array relationship */
  instructor_supervision_observations: Array<Instructor_Supervision_Observation>;
  /** An aggregate relationship */
  instructor_supervision_observations_aggregate: Instructor_Supervision_Observation_Aggregate;
  instructor_uuid: Maybe<Scalars['uuid']['output']>;
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  vehicle_plate_scanned: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "instructor_supervision_with_user" */
export type Instructor_Supervision_With_UserInstructor_Supervision_ObservationsArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};


/** columns and relationships of "instructor_supervision_with_user" */
export type Instructor_Supervision_With_UserInstructor_Supervision_Observations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};

/** aggregated selection of "instructor_supervision_with_user" */
export type Instructor_Supervision_With_User_Aggregate = {
  __typename?: 'instructor_supervision_with_user_aggregate';
  aggregate: Maybe<Instructor_Supervision_With_User_Aggregate_Fields>;
  nodes: Array<Instructor_Supervision_With_User>;
};

/** aggregate fields of "instructor_supervision_with_user" */
export type Instructor_Supervision_With_User_Aggregate_Fields = {
  __typename?: 'instructor_supervision_with_user_aggregate_fields';
  avg: Maybe<Instructor_Supervision_With_User_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Instructor_Supervision_With_User_Max_Fields>;
  min: Maybe<Instructor_Supervision_With_User_Min_Fields>;
  stddev: Maybe<Instructor_Supervision_With_User_Stddev_Fields>;
  stddev_pop: Maybe<Instructor_Supervision_With_User_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Instructor_Supervision_With_User_Stddev_Samp_Fields>;
  sum: Maybe<Instructor_Supervision_With_User_Sum_Fields>;
  var_pop: Maybe<Instructor_Supervision_With_User_Var_Pop_Fields>;
  var_samp: Maybe<Instructor_Supervision_With_User_Var_Samp_Fields>;
  variance: Maybe<Instructor_Supervision_With_User_Variance_Fields>;
};


/** aggregate fields of "instructor_supervision_with_user" */
export type Instructor_Supervision_With_User_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Instructor_Supervision_With_User_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Instructor_Supervision_With_User_Avg_Fields = {
  __typename?: 'instructor_supervision_with_user_avg_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "instructor_supervision_with_user". All fields are combined with a logical 'AND'. */
export type Instructor_Supervision_With_User_Bool_Exp = {
  _and?: InputMaybe<Array<Instructor_Supervision_With_User_Bool_Exp>>;
  _not?: InputMaybe<Instructor_Supervision_With_User_Bool_Exp>;
  _or?: InputMaybe<Array<Instructor_Supervision_With_User_Bool_Exp>>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  brake_use?: InputMaybe<Float8_Comparison_Exp>;
  cancelled_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  cancelled_reason?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  driver_avatar_url?: InputMaybe<String_Comparison_Exp>;
  driver_license_plate?: InputMaybe<String_Comparison_Exp>;
  driver_name?: InputMaybe<String_Comparison_Exp>;
  economic_range?: InputMaybe<Float8_Comparison_Exp>;
  engine_load?: InputMaybe<Float8_Comparison_Exp>;
  finished_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  inertia?: InputMaybe<Float8_Comparison_Exp>;
  instructor_supervision_observations?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
  instructor_supervision_observations_aggregate?: InputMaybe<Instructor_Supervision_Observation_Aggregate_Bool_Exp>;
  instructor_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  last_processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  note?: InputMaybe<Float8_Comparison_Exp>;
  slow_running?: InputMaybe<Float8_Comparison_Exp>;
  speed_control?: InputMaybe<Float8_Comparison_Exp>;
  started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  vehicle_plate_scanned?: InputMaybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Instructor_Supervision_With_User_Max_Fields = {
  __typename?: 'instructor_supervision_with_user_max_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  brake_use: Maybe<Scalars['float8']['output']>;
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  cancelled_reason: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  driver_avatar_url: Maybe<Scalars['String']['output']>;
  driver_license_plate: Maybe<Scalars['String']['output']>;
  driver_name: Maybe<Scalars['String']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  instructor_uuid: Maybe<Scalars['uuid']['output']>;
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  vehicle_plate_scanned: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Instructor_Supervision_With_User_Min_Fields = {
  __typename?: 'instructor_supervision_with_user_min_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  brake_use: Maybe<Scalars['float8']['output']>;
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  cancelled_reason: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  driver_avatar_url: Maybe<Scalars['String']['output']>;
  driver_license_plate: Maybe<Scalars['String']['output']>;
  driver_name: Maybe<Scalars['String']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  instructor_uuid: Maybe<Scalars['uuid']['output']>;
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  vehicle_plate_scanned: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "instructor_supervision_with_user". */
export type Instructor_Supervision_With_User_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  brake_use?: InputMaybe<Order_By>;
  cancelled_at?: InputMaybe<Order_By>;
  cancelled_reason?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  driver_avatar_url?: InputMaybe<Order_By>;
  driver_license_plate?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  finished_at?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  instructor_supervision_observations_aggregate?: InputMaybe<Instructor_Supervision_Observation_Aggregate_Order_By>;
  instructor_uuid?: InputMaybe<Order_By>;
  last_processed_at?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  vehicle_plate_scanned?: InputMaybe<Order_By>;
};

/** select columns of table "instructor_supervision_with_user" */
export enum Instructor_Supervision_With_User_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  CancelledAt = 'cancelled_at',
  /** column name */
  CancelledReason = 'cancelled_reason',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  DriverAvatarUrl = 'driver_avatar_url',
  /** column name */
  DriverLicensePlate = 'driver_license_plate',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  FinishedAt = 'finished_at',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  InstructorUuid = 'instructor_uuid',
  /** column name */
  LastProcessedAt = 'last_processed_at',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VehiclePlateScanned = 'vehicle_plate_scanned'
}

/** aggregate stddev on columns */
export type Instructor_Supervision_With_User_Stddev_Fields = {
  __typename?: 'instructor_supervision_with_user_stddev_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Instructor_Supervision_With_User_Stddev_Pop_Fields = {
  __typename?: 'instructor_supervision_with_user_stddev_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Instructor_Supervision_With_User_Stddev_Samp_Fields = {
  __typename?: 'instructor_supervision_with_user_stddev_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "instructor_supervision_with_user" */
export type Instructor_Supervision_With_User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Instructor_Supervision_With_User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Instructor_Supervision_With_User_Stream_Cursor_Value_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  cancelled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cancelled_reason?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  driver_avatar_url?: InputMaybe<Scalars['String']['input']>;
  driver_license_plate?: InputMaybe<Scalars['String']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  finished_at?: InputMaybe<Scalars['timestamptz']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  instructor_uuid?: InputMaybe<Scalars['uuid']['input']>;
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  vehicle_plate_scanned?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Instructor_Supervision_With_User_Sum_Fields = {
  __typename?: 'instructor_supervision_with_user_sum_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
};

/** aggregate var_pop on columns */
export type Instructor_Supervision_With_User_Var_Pop_Fields = {
  __typename?: 'instructor_supervision_with_user_var_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Instructor_Supervision_With_User_Var_Samp_Fields = {
  __typename?: 'instructor_supervision_with_user_var_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Instructor_Supervision_With_User_Variance_Fields = {
  __typename?: 'instructor_supervision_with_user_variance_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "int4range". All fields are combined with logical 'AND'. */
export type Int4range_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['int4range']['input']>;
  _gt?: InputMaybe<Scalars['int4range']['input']>;
  _gte?: InputMaybe<Scalars['int4range']['input']>;
  _in?: InputMaybe<Array<Scalars['int4range']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['int4range']['input']>;
  _lte?: InputMaybe<Scalars['int4range']['input']>;
  _neq?: InputMaybe<Scalars['int4range']['input']>;
  _nin?: InputMaybe<Array<Scalars['int4range']['input']>>;
};

/** Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'. */
export type Interval_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['interval']['input']>;
  _gt?: InputMaybe<Scalars['interval']['input']>;
  _gte?: InputMaybe<Scalars['interval']['input']>;
  _in?: InputMaybe<Array<Scalars['interval']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['interval']['input']>;
  _lte?: InputMaybe<Scalars['interval']['input']>;
  _neq?: InputMaybe<Scalars['interval']['input']>;
  _nin?: InputMaybe<Array<Scalars['interval']['input']>>;
};

/** Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'. */
export type Json_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['json']['input']>;
  _gt?: InputMaybe<Scalars['json']['input']>;
  _gte?: InputMaybe<Scalars['json']['input']>;
  _in?: InputMaybe<Array<Scalars['json']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['json']['input']>;
  _lte?: InputMaybe<Scalars['json']['input']>;
  _neq?: InputMaybe<Scalars['json']['input']>;
  _nin?: InputMaybe<Array<Scalars['json']['input']>>;
};

export type Jsonb_Cast_Exp = {
  String?: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']['input']>;
  _eq?: InputMaybe<Scalars['jsonb']['input']>;
  _gt?: InputMaybe<Scalars['jsonb']['input']>;
  _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['jsonb']['input']>;
  _lte?: InputMaybe<Scalars['jsonb']['input']>;
  _neq?: InputMaybe<Scalars['jsonb']['input']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;
};

/** columns and relationships of "last_inspection_tire_by_vehicle" */
export type Last_Inspection_Tire_By_Vehicle = {
  __typename?: 'last_inspection_tire_by_vehicle';
  axis: Maybe<Scalars['Int']['output']>;
  band: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  dimension: Maybe<Scalars['String']['output']>;
  ibor_tire: Maybe<CurrentTiresByVehicle>;
  inspection_id: Maybe<Scalars['String']['output']>;
  position: Maybe<Scalars['bpchar']['output']>;
  side: Maybe<Scalars['bpchar']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "last_inspection_tire_by_vehicle" */
export type Last_Inspection_Tire_By_Vehicle_Aggregate = {
  __typename?: 'last_inspection_tire_by_vehicle_aggregate';
  aggregate: Maybe<Last_Inspection_Tire_By_Vehicle_Aggregate_Fields>;
  nodes: Array<Last_Inspection_Tire_By_Vehicle>;
};

/** aggregate fields of "last_inspection_tire_by_vehicle" */
export type Last_Inspection_Tire_By_Vehicle_Aggregate_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_aggregate_fields';
  avg: Maybe<Last_Inspection_Tire_By_Vehicle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Last_Inspection_Tire_By_Vehicle_Max_Fields>;
  min: Maybe<Last_Inspection_Tire_By_Vehicle_Min_Fields>;
  stddev: Maybe<Last_Inspection_Tire_By_Vehicle_Stddev_Fields>;
  stddev_pop: Maybe<Last_Inspection_Tire_By_Vehicle_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Last_Inspection_Tire_By_Vehicle_Stddev_Samp_Fields>;
  sum: Maybe<Last_Inspection_Tire_By_Vehicle_Sum_Fields>;
  var_pop: Maybe<Last_Inspection_Tire_By_Vehicle_Var_Pop_Fields>;
  var_samp: Maybe<Last_Inspection_Tire_By_Vehicle_Var_Samp_Fields>;
  variance: Maybe<Last_Inspection_Tire_By_Vehicle_Variance_Fields>;
};


/** aggregate fields of "last_inspection_tire_by_vehicle" */
export type Last_Inspection_Tire_By_Vehicle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Last_Inspection_Tire_By_Vehicle_Avg_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_avg_fields';
  axis: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "last_inspection_tire_by_vehicle". All fields are combined with a logical 'AND'. */
export type Last_Inspection_Tire_By_Vehicle_Bool_Exp = {
  _and?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Bool_Exp>>;
  _not?: InputMaybe<Last_Inspection_Tire_By_Vehicle_Bool_Exp>;
  _or?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Bool_Exp>>;
  axis?: InputMaybe<Int_Comparison_Exp>;
  band?: InputMaybe<String_Comparison_Exp>;
  brand_name?: InputMaybe<String_Comparison_Exp>;
  dimension?: InputMaybe<String_Comparison_Exp>;
  inspection_id?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Bpchar_Comparison_Exp>;
  side?: InputMaybe<Bpchar_Comparison_Exp>;
  started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  tire_id?: InputMaybe<String_Comparison_Exp>;
  tire_identifier?: InputMaybe<String_Comparison_Exp>;
  vehicle_plate?: InputMaybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Last_Inspection_Tire_By_Vehicle_Max_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_max_fields';
  axis: Maybe<Scalars['Int']['output']>;
  band: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  dimension: Maybe<Scalars['String']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  position: Maybe<Scalars['bpchar']['output']>;
  side: Maybe<Scalars['bpchar']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Last_Inspection_Tire_By_Vehicle_Min_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_min_fields';
  axis: Maybe<Scalars['Int']['output']>;
  band: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  dimension: Maybe<Scalars['String']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  position: Maybe<Scalars['bpchar']['output']>;
  side: Maybe<Scalars['bpchar']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "last_inspection_tire_by_vehicle". */
export type Last_Inspection_Tire_By_Vehicle_Order_By = {
  axis?: InputMaybe<Order_By>;
  band?: InputMaybe<Order_By>;
  brand_name?: InputMaybe<Order_By>;
  dimension?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  side?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** last_inspection_tire_by_vehicle_plateNative Query Arguments */
export type Last_Inspection_Tire_By_Vehicle_Plate_Arguments = {
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** select columns of table "last_inspection_tire_by_vehicle" */
export enum Last_Inspection_Tire_By_Vehicle_Select_Column {
  /** column name */
  Axis = 'axis',
  /** column name */
  Band = 'band',
  /** column name */
  BrandName = 'brand_name',
  /** column name */
  Dimension = 'dimension',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  Position = 'position',
  /** column name */
  Side = 'side',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

/** aggregate stddev on columns */
export type Last_Inspection_Tire_By_Vehicle_Stddev_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_stddev_fields';
  axis: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Last_Inspection_Tire_By_Vehicle_Stddev_Pop_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_stddev_pop_fields';
  axis: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Last_Inspection_Tire_By_Vehicle_Stddev_Samp_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_stddev_samp_fields';
  axis: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "last_inspection_tire_by_vehicle" */
export type Last_Inspection_Tire_By_Vehicle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Last_Inspection_Tire_By_Vehicle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Last_Inspection_Tire_By_Vehicle_Stream_Cursor_Value_Input = {
  axis?: InputMaybe<Scalars['Int']['input']>;
  band?: InputMaybe<Scalars['String']['input']>;
  brand_name?: InputMaybe<Scalars['String']['input']>;
  dimension?: InputMaybe<Scalars['String']['input']>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['bpchar']['input']>;
  side?: InputMaybe<Scalars['bpchar']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Last_Inspection_Tire_By_Vehicle_Sum_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_sum_fields';
  axis: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Last_Inspection_Tire_By_Vehicle_Var_Pop_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_var_pop_fields';
  axis: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Last_Inspection_Tire_By_Vehicle_Var_Samp_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_var_samp_fields';
  axis: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Last_Inspection_Tire_By_Vehicle_Variance_Fields = {
  __typename?: 'last_inspection_tire_by_vehicle_variance_fields';
  axis: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "level" */
export type Level = {
  __typename?: 'level';
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  level_options: Array<Level_Option>;
  /** An aggregate relationship */
  level_options_aggregate: Level_Option_Aggregate;
  /** Name used in the UI when showing this level */
  name: Scalars['String']['output'];
  /** Number related to this level */
  number: Scalars['Int']['output'];
  /** An array relationship */
  user_fk_levels: Array<User_Fk_Level>;
  /** An aggregate relationship */
  user_fk_levels_aggregate: User_Fk_Level_Aggregate;
};


/** columns and relationships of "level" */
export type LevelLevel_OptionsArgs = {
  distinct_on?: InputMaybe<Array<Level_Option_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Option_Order_By>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


/** columns and relationships of "level" */
export type LevelLevel_Options_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Level_Option_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Option_Order_By>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


/** columns and relationships of "level" */
export type LevelUser_Fk_LevelsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


/** columns and relationships of "level" */
export type LevelUser_Fk_Levels_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};

/** aggregated selection of "level" */
export type Level_Aggregate = {
  __typename?: 'level_aggregate';
  aggregate: Maybe<Level_Aggregate_Fields>;
  nodes: Array<Level>;
};

/** aggregate fields of "level" */
export type Level_Aggregate_Fields = {
  __typename?: 'level_aggregate_fields';
  avg: Maybe<Level_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Level_Max_Fields>;
  min: Maybe<Level_Min_Fields>;
  stddev: Maybe<Level_Stddev_Fields>;
  stddev_pop: Maybe<Level_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Level_Stddev_Samp_Fields>;
  sum: Maybe<Level_Sum_Fields>;
  var_pop: Maybe<Level_Var_Pop_Fields>;
  var_samp: Maybe<Level_Var_Samp_Fields>;
  variance: Maybe<Level_Variance_Fields>;
};


/** aggregate fields of "level" */
export type Level_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Level_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Level_Avg_Fields = {
  __typename?: 'level_avg_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "level". All fields are combined with a logical 'AND'. */
export type Level_Bool_Exp = {
  _and?: InputMaybe<Array<Level_Bool_Exp>>;
  _not?: InputMaybe<Level_Bool_Exp>;
  _or?: InputMaybe<Array<Level_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  level_options?: InputMaybe<Level_Option_Bool_Exp>;
  level_options_aggregate?: InputMaybe<Level_Option_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  number?: InputMaybe<Int_Comparison_Exp>;
  user_fk_levels?: InputMaybe<User_Fk_Level_Bool_Exp>;
  user_fk_levels_aggregate?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "level" */
export enum Level_Constraint {
  /** unique or primary key constraint on columns "name" */
  LevelNameKey = 'level_name_key',
  /** unique or primary key constraint on columns "number" */
  LevelPkey = 'level_pkey'
}

/** input type for incrementing numeric columns in table "level" */
export type Level_Inc_Input = {
  /** Number related to this level */
  number?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "level" */
export type Level_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  level_options?: InputMaybe<Level_Option_Arr_Rel_Insert_Input>;
  /** Name used in the UI when showing this level */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Number related to this level */
  number?: InputMaybe<Scalars['Int']['input']>;
  user_fk_levels?: InputMaybe<User_Fk_Level_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Level_Max_Fields = {
  __typename?: 'level_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Name used in the UI when showing this level */
  name: Maybe<Scalars['String']['output']>;
  /** Number related to this level */
  number: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Level_Min_Fields = {
  __typename?: 'level_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** Name used in the UI when showing this level */
  name: Maybe<Scalars['String']['output']>;
  /** Number related to this level */
  number: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "level" */
export type Level_Mutation_Response = {
  __typename?: 'level_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Level>;
};

/** input type for inserting object relation for remote table "level" */
export type Level_Obj_Rel_Insert_Input = {
  data: Level_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Level_On_Conflict>;
};

/** on_conflict condition type for table "level" */
export type Level_On_Conflict = {
  constraint: Level_Constraint;
  update_columns?: Array<Level_Update_Column>;
  where?: InputMaybe<Level_Bool_Exp>;
};

/** columns and relationships of "level_option" */
export type Level_Option = {
  __typename?: 'level_option';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  level: Level;
  /** The number related to this option */
  level_number: Scalars['Int']['output'];
  max: Scalars['float8']['output'];
  min: Scalars['float8']['output'];
  multiplier: Scalars['float8']['output'];
  start_at: Scalars['timestamptz']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  user_fk_levels: Array<User_Fk_Level>;
  /** An aggregate relationship */
  user_fk_levels_aggregate: User_Fk_Level_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "level_option" */
export type Level_OptionUser_Fk_LevelsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


/** columns and relationships of "level_option" */
export type Level_OptionUser_Fk_Levels_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};

/** aggregated selection of "level_option" */
export type Level_Option_Aggregate = {
  __typename?: 'level_option_aggregate';
  aggregate: Maybe<Level_Option_Aggregate_Fields>;
  nodes: Array<Level_Option>;
};

export type Level_Option_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Level_Option_Aggregate_Bool_Exp_Var_Samp>;
};

export type Level_Option_Aggregate_Bool_Exp_Avg = {
  arguments: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Corr = {
  arguments: Level_Option_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Level_Option_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Level_Option_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Level_Option_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Level_Option_Aggregate_Bool_Exp_Max = {
  arguments: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Min = {
  arguments: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Sum = {
  arguments: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Level_Option_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Level_Option_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "level_option" */
export type Level_Option_Aggregate_Fields = {
  __typename?: 'level_option_aggregate_fields';
  avg: Maybe<Level_Option_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Level_Option_Max_Fields>;
  min: Maybe<Level_Option_Min_Fields>;
  stddev: Maybe<Level_Option_Stddev_Fields>;
  stddev_pop: Maybe<Level_Option_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Level_Option_Stddev_Samp_Fields>;
  sum: Maybe<Level_Option_Sum_Fields>;
  var_pop: Maybe<Level_Option_Var_Pop_Fields>;
  var_samp: Maybe<Level_Option_Var_Samp_Fields>;
  variance: Maybe<Level_Option_Variance_Fields>;
};


/** aggregate fields of "level_option" */
export type Level_Option_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Level_Option_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "level_option" */
export type Level_Option_Aggregate_Order_By = {
  avg?: InputMaybe<Level_Option_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Level_Option_Max_Order_By>;
  min?: InputMaybe<Level_Option_Min_Order_By>;
  stddev?: InputMaybe<Level_Option_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Level_Option_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Level_Option_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Level_Option_Sum_Order_By>;
  var_pop?: InputMaybe<Level_Option_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Level_Option_Var_Samp_Order_By>;
  variance?: InputMaybe<Level_Option_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "level_option" */
export type Level_Option_Arr_Rel_Insert_Input = {
  data: Array<Level_Option_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Level_Option_On_Conflict>;
};

/** aggregate avg on columns */
export type Level_Option_Avg_Fields = {
  __typename?: 'level_option_avg_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Float']['output']>;
  max: Maybe<Scalars['Float']['output']>;
  min: Maybe<Scalars['Float']['output']>;
  multiplier: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "level_option" */
export type Level_Option_Avg_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "level_option". All fields are combined with a logical 'AND'. */
export type Level_Option_Bool_Exp = {
  _and?: InputMaybe<Array<Level_Option_Bool_Exp>>;
  _not?: InputMaybe<Level_Option_Bool_Exp>;
  _or?: InputMaybe<Array<Level_Option_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  level?: InputMaybe<Level_Bool_Exp>;
  level_number?: InputMaybe<Int_Comparison_Exp>;
  max?: InputMaybe<Float8_Comparison_Exp>;
  min?: InputMaybe<Float8_Comparison_Exp>;
  multiplier?: InputMaybe<Float8_Comparison_Exp>;
  start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_fk_levels?: InputMaybe<User_Fk_Level_Bool_Exp>;
  user_fk_levels_aggregate?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "level_option" */
export enum Level_Option_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  LevelOptionsPkey = 'level_options_pkey'
}

/** input type for incrementing numeric columns in table "level_option" */
export type Level_Option_Inc_Input = {
  /** The number related to this option */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  max?: InputMaybe<Scalars['float8']['input']>;
  min?: InputMaybe<Scalars['float8']['input']>;
  multiplier?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "level_option" */
export type Level_Option_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  level?: InputMaybe<Level_Obj_Rel_Insert_Input>;
  /** The number related to this option */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  max?: InputMaybe<Scalars['float8']['input']>;
  min?: InputMaybe<Scalars['float8']['input']>;
  multiplier?: InputMaybe<Scalars['float8']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_fk_levels?: InputMaybe<User_Fk_Level_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Level_Option_Max_Fields = {
  __typename?: 'level_option_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The number related to this option */
  level_number: Maybe<Scalars['Int']['output']>;
  max: Maybe<Scalars['float8']['output']>;
  min: Maybe<Scalars['float8']['output']>;
  multiplier: Maybe<Scalars['float8']['output']>;
  start_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "level_option" */
export type Level_Option_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Level_Option_Min_Fields = {
  __typename?: 'level_option_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The number related to this option */
  level_number: Maybe<Scalars['Int']['output']>;
  max: Maybe<Scalars['float8']['output']>;
  min: Maybe<Scalars['float8']['output']>;
  multiplier: Maybe<Scalars['float8']['output']>;
  start_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "level_option" */
export type Level_Option_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "level_option" */
export type Level_Option_Mutation_Response = {
  __typename?: 'level_option_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Level_Option>;
};

/** input type for inserting object relation for remote table "level_option" */
export type Level_Option_Obj_Rel_Insert_Input = {
  data: Level_Option_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Level_Option_On_Conflict>;
};

/** on_conflict condition type for table "level_option" */
export type Level_Option_On_Conflict = {
  constraint: Level_Option_Constraint;
  update_columns?: Array<Level_Option_Update_Column>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};

/** Ordering options when selecting data from "level_option". */
export type Level_Option_Order_By = {
  created_at?: InputMaybe<Order_By>;
  level?: InputMaybe<Level_Order_By>;
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_fk_levels_aggregate?: InputMaybe<User_Fk_Level_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: level_option */
export type Level_Option_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "level_option" */
export enum Level_Option_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  LevelNumber = 'level_number',
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** select "level_option_aggregate_bool_exp_avg_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** select "level_option_aggregate_bool_exp_corr_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** select "level_option_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** select "level_option_aggregate_bool_exp_max_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** select "level_option_aggregate_bool_exp_min_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** select "level_option_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** select "level_option_aggregate_bool_exp_sum_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** select "level_option_aggregate_bool_exp_var_samp_arguments_columns" columns of table "level_option" */
export enum Level_Option_Select_Column_Level_Option_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier'
}

/** input type for updating data in table "level_option" */
export type Level_Option_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The number related to this option */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  max?: InputMaybe<Scalars['float8']['input']>;
  min?: InputMaybe<Scalars['float8']['input']>;
  multiplier?: InputMaybe<Scalars['float8']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Level_Option_Stddev_Fields = {
  __typename?: 'level_option_stddev_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Float']['output']>;
  max: Maybe<Scalars['Float']['output']>;
  min: Maybe<Scalars['Float']['output']>;
  multiplier: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "level_option" */
export type Level_Option_Stddev_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Level_Option_Stddev_Pop_Fields = {
  __typename?: 'level_option_stddev_pop_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Float']['output']>;
  max: Maybe<Scalars['Float']['output']>;
  min: Maybe<Scalars['Float']['output']>;
  multiplier: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "level_option" */
export type Level_Option_Stddev_Pop_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Level_Option_Stddev_Samp_Fields = {
  __typename?: 'level_option_stddev_samp_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Float']['output']>;
  max: Maybe<Scalars['Float']['output']>;
  min: Maybe<Scalars['Float']['output']>;
  multiplier: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "level_option" */
export type Level_Option_Stddev_Samp_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "level_option" */
export type Level_Option_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Level_Option_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Level_Option_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The number related to this option */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  max?: InputMaybe<Scalars['float8']['input']>;
  min?: InputMaybe<Scalars['float8']['input']>;
  multiplier?: InputMaybe<Scalars['float8']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Level_Option_Sum_Fields = {
  __typename?: 'level_option_sum_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Int']['output']>;
  max: Maybe<Scalars['float8']['output']>;
  min: Maybe<Scalars['float8']['output']>;
  multiplier: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "level_option" */
export type Level_Option_Sum_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** update columns of table "level_option" */
export enum Level_Option_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  LevelNumber = 'level_number',
  /** column name */
  Max = 'max',
  /** column name */
  Min = 'min',
  /** column name */
  Multiplier = 'multiplier',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Level_Option_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Level_Option_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Level_Option_Set_Input>;
  /** filter the rows which have to be updated */
  where: Level_Option_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Level_Option_Var_Pop_Fields = {
  __typename?: 'level_option_var_pop_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Float']['output']>;
  max: Maybe<Scalars['Float']['output']>;
  min: Maybe<Scalars['Float']['output']>;
  multiplier: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "level_option" */
export type Level_Option_Var_Pop_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Level_Option_Var_Samp_Fields = {
  __typename?: 'level_option_var_samp_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Float']['output']>;
  max: Maybe<Scalars['Float']['output']>;
  min: Maybe<Scalars['Float']['output']>;
  multiplier: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "level_option" */
export type Level_Option_Var_Samp_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Level_Option_Variance_Fields = {
  __typename?: 'level_option_variance_fields';
  /** The number related to this option */
  level_number: Maybe<Scalars['Float']['output']>;
  max: Maybe<Scalars['Float']['output']>;
  min: Maybe<Scalars['Float']['output']>;
  multiplier: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "level_option" */
export type Level_Option_Variance_Order_By = {
  /** The number related to this option */
  level_number?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_By>;
  min?: InputMaybe<Order_By>;
  multiplier?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "level". */
export type Level_Order_By = {
  created_at?: InputMaybe<Order_By>;
  level_options_aggregate?: InputMaybe<Level_Option_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  number?: InputMaybe<Order_By>;
  user_fk_levels_aggregate?: InputMaybe<User_Fk_Level_Aggregate_Order_By>;
};

/** primary key columns input for table: level */
export type Level_Pk_Columns_Input = {
  /** Number related to this level */
  number: Scalars['Int']['input'];
};

/** select columns of table "level" */
export enum Level_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  Number = 'number'
}

/** input type for updating data in table "level" */
export type Level_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Name used in the UI when showing this level */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Number related to this level */
  number?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Level_Stddev_Fields = {
  __typename?: 'level_stddev_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Level_Stddev_Pop_Fields = {
  __typename?: 'level_stddev_pop_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Level_Stddev_Samp_Fields = {
  __typename?: 'level_stddev_samp_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "level" */
export type Level_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Level_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Level_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Name used in the UI when showing this level */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Number related to this level */
  number?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Level_Sum_Fields = {
  __typename?: 'level_sum_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "level" */
export enum Level_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  Number = 'number'
}

export type Level_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Level_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Level_Set_Input>;
  /** filter the rows which have to be updated */
  where: Level_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Level_Var_Pop_Fields = {
  __typename?: 'level_var_pop_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Level_Var_Samp_Fields = {
  __typename?: 'level_var_samp_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Level_Variance_Fields = {
  __typename?: 'level_variance_fields';
  /** Number related to this level */
  number: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "module" */
export type Module = {
  __typename?: 'module';
  /** An array relationship */
  admin_permissions: Array<Admin_Permission>;
  /** An aggregate relationship */
  admin_permissions_aggregate: Admin_Permission_Aggregate;
  description: Scalars['String']['output'];
  /** An array relationship */
  module_permissions: Array<Module_Permission>;
  /** An aggregate relationship */
  module_permissions_aggregate: Module_Permission_Aggregate;
  name: Scalars['String']['output'];
};


/** columns and relationships of "module" */
export type ModuleAdmin_PermissionsArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


/** columns and relationships of "module" */
export type ModuleAdmin_Permissions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


/** columns and relationships of "module" */
export type ModuleModule_PermissionsArgs = {
  distinct_on?: InputMaybe<Array<Module_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Permission_Order_By>>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};


/** columns and relationships of "module" */
export type ModuleModule_Permissions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Permission_Order_By>>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};

/** aggregated selection of "module" */
export type Module_Aggregate = {
  __typename?: 'module_aggregate';
  aggregate: Maybe<Module_Aggregate_Fields>;
  nodes: Array<Module>;
};

/** aggregate fields of "module" */
export type Module_Aggregate_Fields = {
  __typename?: 'module_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Module_Max_Fields>;
  min: Maybe<Module_Min_Fields>;
};


/** aggregate fields of "module" */
export type Module_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Module_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "module". All fields are combined with a logical 'AND'. */
export type Module_Bool_Exp = {
  _and?: InputMaybe<Array<Module_Bool_Exp>>;
  _not?: InputMaybe<Module_Bool_Exp>;
  _or?: InputMaybe<Array<Module_Bool_Exp>>;
  admin_permissions?: InputMaybe<Admin_Permission_Bool_Exp>;
  admin_permissions_aggregate?: InputMaybe<Admin_Permission_Aggregate_Bool_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  module_permissions?: InputMaybe<Module_Permission_Bool_Exp>;
  module_permissions_aggregate?: InputMaybe<Module_Permission_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "module" */
export enum Module_Constraint {
  /** unique or primary key constraint on columns "name" */
  ModulePkey = 'module_pkey'
}

/** input type for inserting data into table "module" */
export type Module_Insert_Input = {
  admin_permissions?: InputMaybe<Admin_Permission_Arr_Rel_Insert_Input>;
  description?: InputMaybe<Scalars['String']['input']>;
  module_permissions?: InputMaybe<Module_Permission_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Module_Max_Fields = {
  __typename?: 'module_max_fields';
  description: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Module_Min_Fields = {
  __typename?: 'module_min_fields';
  description: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "module" */
export type Module_Mutation_Response = {
  __typename?: 'module_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Module>;
};

/** input type for inserting object relation for remote table "module" */
export type Module_Obj_Rel_Insert_Input = {
  data: Module_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Module_On_Conflict>;
};

/** on_conflict condition type for table "module" */
export type Module_On_Conflict = {
  constraint: Module_Constraint;
  update_columns?: Array<Module_Update_Column>;
  where?: InputMaybe<Module_Bool_Exp>;
};

/** Ordering options when selecting data from "module". */
export type Module_Order_By = {
  admin_permissions_aggregate?: InputMaybe<Admin_Permission_Aggregate_Order_By>;
  description?: InputMaybe<Order_By>;
  module_permissions_aggregate?: InputMaybe<Module_Permission_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
};

/** columns and relationships of "module_permission" */
export type Module_Permission = {
  __typename?: 'module_permission';
  action: Scalars['String']['output'];
  description: Scalars['String']['output'];
  /** An object relationship */
  module: Module;
  module_name: Scalars['String']['output'];
  /** An array relationship */
  profile_permissions: Array<Profile_Permission>;
  /** An aggregate relationship */
  profile_permissions_aggregate: Profile_Permission_Aggregate;
};


/** columns and relationships of "module_permission" */
export type Module_PermissionProfile_PermissionsArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};


/** columns and relationships of "module_permission" */
export type Module_PermissionProfile_Permissions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};

/** aggregated selection of "module_permission" */
export type Module_Permission_Aggregate = {
  __typename?: 'module_permission_aggregate';
  aggregate: Maybe<Module_Permission_Aggregate_Fields>;
  nodes: Array<Module_Permission>;
};

export type Module_Permission_Aggregate_Bool_Exp = {
  count?: InputMaybe<Module_Permission_Aggregate_Bool_Exp_Count>;
};

export type Module_Permission_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Module_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Module_Permission_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "module_permission" */
export type Module_Permission_Aggregate_Fields = {
  __typename?: 'module_permission_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Module_Permission_Max_Fields>;
  min: Maybe<Module_Permission_Min_Fields>;
};


/** aggregate fields of "module_permission" */
export type Module_Permission_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Module_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "module_permission" */
export type Module_Permission_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Module_Permission_Max_Order_By>;
  min?: InputMaybe<Module_Permission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "module_permission" */
export type Module_Permission_Arr_Rel_Insert_Input = {
  data: Array<Module_Permission_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Module_Permission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "module_permission". All fields are combined with a logical 'AND'. */
export type Module_Permission_Bool_Exp = {
  _and?: InputMaybe<Array<Module_Permission_Bool_Exp>>;
  _not?: InputMaybe<Module_Permission_Bool_Exp>;
  _or?: InputMaybe<Array<Module_Permission_Bool_Exp>>;
  action?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  module?: InputMaybe<Module_Bool_Exp>;
  module_name?: InputMaybe<String_Comparison_Exp>;
  profile_permissions?: InputMaybe<Profile_Permission_Bool_Exp>;
  profile_permissions_aggregate?: InputMaybe<Profile_Permission_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "module_permission" */
export enum Module_Permission_Constraint {
  /** unique or primary key constraint on columns "action" */
  ModulePermissionPkey = 'module_permission_pkey'
}

/** input type for inserting data into table "module_permission" */
export type Module_Permission_Insert_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  module?: InputMaybe<Module_Obj_Rel_Insert_Input>;
  module_name?: InputMaybe<Scalars['String']['input']>;
  profile_permissions?: InputMaybe<Profile_Permission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Module_Permission_Max_Fields = {
  __typename?: 'module_permission_max_fields';
  action: Maybe<Scalars['String']['output']>;
  description: Maybe<Scalars['String']['output']>;
  module_name: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "module_permission" */
export type Module_Permission_Max_Order_By = {
  action?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  module_name?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Module_Permission_Min_Fields = {
  __typename?: 'module_permission_min_fields';
  action: Maybe<Scalars['String']['output']>;
  description: Maybe<Scalars['String']['output']>;
  module_name: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "module_permission" */
export type Module_Permission_Min_Order_By = {
  action?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  module_name?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "module_permission" */
export type Module_Permission_Mutation_Response = {
  __typename?: 'module_permission_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Module_Permission>;
};

/** input type for inserting object relation for remote table "module_permission" */
export type Module_Permission_Obj_Rel_Insert_Input = {
  data: Module_Permission_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Module_Permission_On_Conflict>;
};

/** on_conflict condition type for table "module_permission" */
export type Module_Permission_On_Conflict = {
  constraint: Module_Permission_Constraint;
  update_columns?: Array<Module_Permission_Update_Column>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};

/** Ordering options when selecting data from "module_permission". */
export type Module_Permission_Order_By = {
  action?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  module?: InputMaybe<Module_Order_By>;
  module_name?: InputMaybe<Order_By>;
  profile_permissions_aggregate?: InputMaybe<Profile_Permission_Aggregate_Order_By>;
};

/** primary key columns input for table: module_permission */
export type Module_Permission_Pk_Columns_Input = {
  action: Scalars['String']['input'];
};

/** select columns of table "module_permission" */
export enum Module_Permission_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  Description = 'description',
  /** column name */
  ModuleName = 'module_name'
}

/** input type for updating data in table "module_permission" */
export type Module_Permission_Set_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  module_name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "module_permission" */
export type Module_Permission_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Module_Permission_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Module_Permission_Stream_Cursor_Value_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  module_name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "module_permission" */
export enum Module_Permission_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  Description = 'description',
  /** column name */
  ModuleName = 'module_name'
}

export type Module_Permission_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Module_Permission_Set_Input>;
  /** filter the rows which have to be updated */
  where: Module_Permission_Bool_Exp;
};

/** primary key columns input for table: module */
export type Module_Pk_Columns_Input = {
  name: Scalars['String']['input'];
};

/** select columns of table "module" */
export enum Module_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "module" */
export type Module_Set_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "module" */
export type Module_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Module_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Module_Stream_Cursor_Value_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "module" */
export enum Module_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

export type Module_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Module_Set_Input>;
  /** filter the rows which have to be updated */
  where: Module_Bool_Exp;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** execute VOLATILE function "buy_product" which returns "product_request" */
  buy_product: Maybe<Product_Request>;
  /** execute VOLATILE function "cancel_product_request" which returns "product_request" */
  cancel_product_request: Maybe<Product_Request>;
  /** execute VOLATILE function "change_admin_enabled" which returns "admin" */
  change_admin_enabled: Maybe<Admin>;
  change_admin_password: Maybe<ChangeAdminPasswordOutput>;
  /** execute VOLATILE function "change_driver_enabled" which returns "user" */
  change_driver_enabled: Maybe<User>;
  change_driver_password: Maybe<ChangeDriverPasswordOutput>;
  /** execute VOLATILE function "consume_whatsapp_event" which returns "whatsapp_event" */
  consume_whatsapp_event: Maybe<Whatsapp_Event>;
  /** delete data from the table: "CurrentTiresByVehicle" */
  delete_CurrentTiresByVehicle: Maybe<CurrentTiresByVehicle_Mutation_Response>;
  /** delete data from the table: "ParametroAlertaConducao" */
  delete_ParametroAlertaConducao: Maybe<ParametroAlertaConducao_Mutation_Response>;
  /** delete single row from the table: "ParametroAlertaConducao" */
  delete_ParametroAlertaConducao_by_pk: Maybe<ParametroAlertaConducao>;
  /** delete data from the table: "PerformanceParameter" */
  delete_PerformanceParameter: Maybe<PerformanceParameter_Mutation_Response>;
  /** delete single row from the table: "PerformanceParameter" */
  delete_PerformanceParameter_by_pk: Maybe<PerformanceParameter>;
  /** delete data from the table: "PontosRastro" */
  delete_PontosRastro: Maybe<PontosRastro_Mutation_Response>;
  /** delete single row from the table: "PontosRastro" */
  delete_PontosRastro_by_pk: Maybe<PontosRastro>;
  /** delete data from the table: "ScoreParameter" */
  delete_ScoreParameter: Maybe<ScoreParameter_Mutation_Response>;
  /** delete single row from the table: "ScoreParameter" */
  delete_ScoreParameter_by_pk: Maybe<ScoreParameter>;
  /** delete data from the table: "ScoreType" */
  delete_ScoreType: Maybe<ScoreType_Mutation_Response>;
  /** delete single row from the table: "ScoreType" */
  delete_ScoreType_by_pk: Maybe<ScoreType>;
  /** delete data from the table: "SuntechEquipamento" */
  delete_SuntechEquipamento: Maybe<SuntechEquipamento_Mutation_Response>;
  /** delete data from the table: "SuntechTrackerBatchCommand" */
  delete_SuntechTrackerBatchCommand: Maybe<SuntechTrackerBatchCommand_Mutation_Response>;
  /** delete data from the table: "SuntechTrackerBatchCommandDevice" */
  delete_SuntechTrackerBatchCommandDevice: Maybe<SuntechTrackerBatchCommandDevice_Mutation_Response>;
  /** delete single row from the table: "SuntechTrackerBatchCommandDevice" */
  delete_SuntechTrackerBatchCommandDevice_by_pk: Maybe<SuntechTrackerBatchCommandDevice>;
  /** delete data from the table: "SuntechTrackerBatchCommandPreset" */
  delete_SuntechTrackerBatchCommandPreset: Maybe<SuntechTrackerBatchCommandPreset_Mutation_Response>;
  /** delete single row from the table: "SuntechTrackerBatchCommandPreset" */
  delete_SuntechTrackerBatchCommandPreset_by_pk: Maybe<SuntechTrackerBatchCommandPreset>;
  /** delete single row from the table: "SuntechTrackerBatchCommand" */
  delete_SuntechTrackerBatchCommand_by_pk: Maybe<SuntechTrackerBatchCommand>;
  /** delete data from the table: "SuntechTrackerCommand" */
  delete_SuntechTrackerCommand: Maybe<SuntechTrackerCommand_Mutation_Response>;
  /** delete single row from the table: "SuntechTrackerCommand" */
  delete_SuntechTrackerCommand_by_pk: Maybe<SuntechTrackerCommand>;
  /** delete data from the table: "VirlocTrackerBatchCommand" */
  delete_VirlocTrackerBatchCommand: Maybe<VirlocTrackerBatchCommand_Mutation_Response>;
  /** delete data from the table: "VirlocTrackerBatchCommandDevice" */
  delete_VirlocTrackerBatchCommandDevice: Maybe<VirlocTrackerBatchCommandDevice_Mutation_Response>;
  /** delete single row from the table: "VirlocTrackerBatchCommandDevice" */
  delete_VirlocTrackerBatchCommandDevice_by_pk: Maybe<VirlocTrackerBatchCommandDevice>;
  /** delete data from the table: "VirlocTrackerBatchCommandPreset" */
  delete_VirlocTrackerBatchCommandPreset: Maybe<VirlocTrackerBatchCommandPreset_Mutation_Response>;
  /** delete single row from the table: "VirlocTrackerBatchCommandPreset" */
  delete_VirlocTrackerBatchCommandPreset_by_pk: Maybe<VirlocTrackerBatchCommandPreset>;
  /** delete single row from the table: "VirlocTrackerBatchCommand" */
  delete_VirlocTrackerBatchCommand_by_pk: Maybe<VirlocTrackerBatchCommand>;
  /** delete data from the table: "VirlocTrackerCommand" */
  delete_VirlocTrackerCommand: Maybe<VirlocTrackerCommand_Mutation_Response>;
  /** delete single row from the table: "VirlocTrackerCommand" */
  delete_VirlocTrackerCommand_by_pk: Maybe<VirlocTrackerCommand>;
  /** delete data from the table: "VirlocTrackerDevice" */
  delete_VirlocTrackerDevice: Maybe<VirlocTrackerDevice_Mutation_Response>;
  /** delete single row from the table: "VirlocTrackerDevice" */
  delete_VirlocTrackerDevice_by_pk: Maybe<VirlocTrackerDevice>;
  /** delete data from the table: "achievement" */
  delete_achievement: Maybe<Achievement_Mutation_Response>;
  /** delete single row from the table: "achievement" */
  delete_achievement_by_pk: Maybe<Achievement>;
  /** delete data from the table: "admin" */
  delete_admin: Maybe<Admin_Mutation_Response>;
  /** delete single row from the table: "admin" */
  delete_admin_by_pk: Maybe<Admin>;
  /** delete data from the table: "admin_fk_notifications" */
  delete_admin_fk_notifications: Maybe<Admin_Fk_Notifications_Mutation_Response>;
  /** delete single row from the table: "admin_fk_notifications" */
  delete_admin_fk_notifications_by_pk: Maybe<Admin_Fk_Notifications>;
  /** delete data from the table: "admin_fk_profile" */
  delete_admin_fk_profile: Maybe<Admin_Fk_Profile_Mutation_Response>;
  /** delete single row from the table: "admin_fk_profile" */
  delete_admin_fk_profile_by_pk: Maybe<Admin_Fk_Profile>;
  /** delete data from the table: "admin_permission" */
  delete_admin_permission: Maybe<Admin_Permission_Mutation_Response>;
  /** delete single row from the table: "admin_permission" */
  delete_admin_permission_by_pk: Maybe<Admin_Permission>;
  /** delete data from the table: "auto" */
  delete_auto: Maybe<Auto_Mutation_Response>;
  /** delete single row from the table: "auto" */
  delete_auto_by_pk: Maybe<Auto>;
  /** delete data from the table: "bi.dashboard" */
  delete_bi_dashboard: Maybe<Bi_Dashboard_Mutation_Response>;
  /** delete single row from the table: "bi.dashboard" */
  delete_bi_dashboard_by_pk: Maybe<Bi_Dashboard>;
  /** delete data from the table: "bi.dashboard_item" */
  delete_bi_dashboard_item: Maybe<Bi_Dashboard_Item_Mutation_Response>;
  /** delete single row from the table: "bi.dashboard_item" */
  delete_bi_dashboard_item_by_pk: Maybe<Bi_Dashboard_Item>;
  /** delete data from the table: "bi.dashboard_item_type" */
  delete_bi_dashboard_item_type: Maybe<Bi_Dashboard_Item_Type_Mutation_Response>;
  /** delete single row from the table: "bi.dashboard_item_type" */
  delete_bi_dashboard_item_type_by_pk: Maybe<Bi_Dashboard_Item_Type>;
  /** delete data from the table: "bi.datasource" */
  delete_bi_datasource: Maybe<Bi_Datasource_Mutation_Response>;
  /** delete single row from the table: "bi.datasource" */
  delete_bi_datasource_by_pk: Maybe<Bi_Datasource>;
  /** delete data from the table: "bi.datasource_type" */
  delete_bi_datasource_type: Maybe<Bi_Datasource_Type_Mutation_Response>;
  /** delete single row from the table: "bi.datasource_type" */
  delete_bi_datasource_type_by_pk: Maybe<Bi_Datasource_Type>;
  /** delete data from the table: "bi.permission" */
  delete_bi_permission: Maybe<Bi_Permission_Mutation_Response>;
  /** delete single row from the table: "bi.permission" */
  delete_bi_permission_by_pk: Maybe<Bi_Permission>;
  /** delete data from the table: "bi.permission_module" */
  delete_bi_permission_module: Maybe<Bi_Permission_Module_Mutation_Response>;
  /** delete single row from the table: "bi.permission_module" */
  delete_bi_permission_module_by_pk: Maybe<Bi_Permission_Module>;
  /** delete data from the table: "bi.public_link" */
  delete_bi_public_link: Maybe<Bi_Public_Link_Mutation_Response>;
  /** delete single row from the table: "bi.public_link" */
  delete_bi_public_link_by_pk: Maybe<Bi_Public_Link>;
  /** delete data from the table: "bi.query" */
  delete_bi_query: Maybe<Bi_Query_Mutation_Response>;
  /** delete data from the table: "bi.query_analytics" */
  delete_bi_query_analytics: Maybe<Bi_Query_Analytics_Mutation_Response>;
  /** delete single row from the table: "bi.query_analytics" */
  delete_bi_query_analytics_by_pk: Maybe<Bi_Query_Analytics>;
  /** delete single row from the table: "bi.query" */
  delete_bi_query_by_pk: Maybe<Bi_Query>;
  /** delete data from the table: "bi.query_cache" */
  delete_bi_query_cache: Maybe<Bi_Query_Cache_Mutation_Response>;
  /** delete single row from the table: "bi.query_cache" */
  delete_bi_query_cache_by_pk: Maybe<Bi_Query_Cache>;
  /** delete data from the table: "bi.subquery" */
  delete_bi_subquery: Maybe<Bi_Subquery_Mutation_Response>;
  /** delete single row from the table: "bi.subquery" */
  delete_bi_subquery_by_pk: Maybe<Bi_Subquery>;
  /** delete data from the table: "bi.user_permission" */
  delete_bi_user_permission: Maybe<Bi_User_Permission_Mutation_Response>;
  /** delete single row from the table: "bi.user_permission" */
  delete_bi_user_permission_by_pk: Maybe<Bi_User_Permission>;
  /** delete data from the table: "challenge" */
  delete_challenge: Maybe<Challenge_Mutation_Response>;
  /** delete single row from the table: "challenge" */
  delete_challenge_by_pk: Maybe<Challenge>;
  /** delete data from the table: "challenge_type" */
  delete_challenge_type: Maybe<Challenge_Type_Mutation_Response>;
  /** delete single row from the table: "challenge_type" */
  delete_challenge_type_by_pk: Maybe<Challenge_Type>;
  /** delete data from the table: "config" */
  delete_config: Maybe<Config_Mutation_Response>;
  /** delete single row from the table: "config" */
  delete_config_by_pk: Maybe<Config>;
  /** delete data from the table: "critical_point" */
  delete_critical_point: Maybe<Critical_Point_Mutation_Response>;
  /** delete single row from the table: "critical_point" */
  delete_critical_point_by_pk: Maybe<Critical_Point>;
  /** delete data from the table: "critical_segment" */
  delete_critical_segment: Maybe<Critical_Segment_Mutation_Response>;
  /** delete single row from the table: "critical_segment" */
  delete_critical_segment_by_pk: Maybe<Critical_Segment>;
  /** delete data from the table: "cte.nf_lock" */
  delete_cte_nf_lock: Maybe<Cte_Nf_Lock_Mutation_Response>;
  /** delete single row from the table: "cte.nf_lock" */
  delete_cte_nf_lock_by_pk: Maybe<Cte_Nf_Lock>;
  /** delete data from the table: "deleted_row" */
  delete_deleted_row: Maybe<Deleted_Row_Mutation_Response>;
  /** delete single row from the table: "deleted_row" */
  delete_deleted_row_by_pk: Maybe<Deleted_Row>;
  /** delete data from the table: "delivery" */
  delete_delivery: Maybe<Delivery_Mutation_Response>;
  /** delete single row from the table: "delivery" */
  delete_delivery_by_pk: Maybe<Delivery>;
  /** delete data from the table: "driver_warning" */
  delete_driver_warning: Maybe<Driver_Warning_Mutation_Response>;
  /** delete single row from the table: "driver_warning" */
  delete_driver_warning_by_pk: Maybe<Driver_Warning>;
  /** delete data from the table: "driver_warning_comment" */
  delete_driver_warning_comment: Maybe<Driver_Warning_Comment_Mutation_Response>;
  /** delete single row from the table: "driver_warning_comment" */
  delete_driver_warning_comment_by_pk: Maybe<Driver_Warning_Comment>;
  /** delete data from the table: "driver_warning_fk_whatsapp_message" */
  delete_driver_warning_fk_whatsapp_message: Maybe<Driver_Warning_Fk_Whatsapp_Message_Mutation_Response>;
  /** delete single row from the table: "driver_warning_fk_whatsapp_message" */
  delete_driver_warning_fk_whatsapp_message_by_pk: Maybe<Driver_Warning_Fk_Whatsapp_Message>;
  /** delete data from the table: "driver_warning_risk_level" */
  delete_driver_warning_risk_level: Maybe<Driver_Warning_Risk_Level_Mutation_Response>;
  /** delete single row from the table: "driver_warning_risk_level" */
  delete_driver_warning_risk_level_by_pk: Maybe<Driver_Warning_Risk_Level>;
  /** delete data from the table: "driver_warning_trip" */
  delete_driver_warning_trip: Maybe<Driver_Warning_Trip_Mutation_Response>;
  /** delete single row from the table: "driver_warning_trip" */
  delete_driver_warning_trip_by_pk: Maybe<Driver_Warning_Trip>;
  /** delete data from the table: "driver_warning_trip_point" */
  delete_driver_warning_trip_point: Maybe<Driver_Warning_Trip_Point_Mutation_Response>;
  /** delete single row from the table: "driver_warning_trip_point" */
  delete_driver_warning_trip_point_by_pk: Maybe<Driver_Warning_Trip_Point>;
  /** delete data from the table: "driver_warning_trip_severity" */
  delete_driver_warning_trip_severity: Maybe<Driver_Warning_Trip_Severity_Mutation_Response>;
  /** delete single row from the table: "driver_warning_trip_severity" */
  delete_driver_warning_trip_severity_by_pk: Maybe<Driver_Warning_Trip_Severity>;
  /** delete data from the table: "edi.busca_nfe_job" */
  delete_edi_busca_nfe_job: Maybe<Edi_Busca_Nfe_Job_Mutation_Response>;
  /** delete single row from the table: "edi.busca_nfe_job" */
  delete_edi_busca_nfe_job_by_pk: Maybe<Edi_Busca_Nfe_Job>;
  /** delete data from the table: "edi.busca_nfe_response" */
  delete_edi_busca_nfe_response: Maybe<Edi_Busca_Nfe_Response_Mutation_Response>;
  /** delete single row from the table: "edi.busca_nfe_response" */
  delete_edi_busca_nfe_response_by_pk: Maybe<Edi_Busca_Nfe_Response>;
  /** delete data from the table: "empty_tables.critical_segment_from_critical_point" */
  delete_empty_tables_critical_segment_from_critical_point: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Mutation_Response>;
  /** delete data from the table: "empty_tables.driver_performance_data" */
  delete_empty_tables_driver_performance_data: Maybe<Empty_Tables_Driver_Performance_Data_Mutation_Response>;
  /** delete data from the table: "empty_tables.fleet_performance_data" */
  delete_empty_tables_fleet_performance_data: Maybe<Empty_Tables_Fleet_Performance_Data_Mutation_Response>;
  /** delete single row from the table: "empty_tables.fleet_performance_data" */
  delete_empty_tables_fleet_performance_data_by_pk: Maybe<Empty_Tables_Fleet_Performance_Data>;
  /** delete data from the table: "empty_tables.geojson_trip" */
  delete_empty_tables_geojson_trip: Maybe<Empty_Tables_Geojson_Trip_Mutation_Response>;
  /** delete single row from the table: "empty_tables.geojson_trip" */
  delete_empty_tables_geojson_trip_by_pk: Maybe<Empty_Tables_Geojson_Trip>;
  /** delete data from the table: "empty_tables.instructor_drivers_performance_history" */
  delete_empty_tables_instructor_drivers_performance_history: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Mutation_Response>;
  /** delete data from the table: "fidelity_range_points" */
  delete_fidelity_range_points: Maybe<Fidelity_Range_Points_Mutation_Response>;
  /** delete single row from the table: "fidelity_range_points" */
  delete_fidelity_range_points_by_pk: Maybe<Fidelity_Range_Points>;
  /** delete data from the table: "fipe.price" */
  delete_fipe_price: Maybe<Fipe_Price_Mutation_Response>;
  /** delete single row from the table: "fipe.price" */
  delete_fipe_price_by_pk: Maybe<Fipe_Price>;
  /** delete data from the table: "fipe.reference_month" */
  delete_fipe_reference_month: Maybe<Fipe_Reference_Month_Mutation_Response>;
  /** delete single row from the table: "fipe.reference_month" */
  delete_fipe_reference_month_by_pk: Maybe<Fipe_Reference_Month>;
  /** delete data from the table: "fipe.selected_vehicle" */
  delete_fipe_selected_vehicle: Maybe<Fipe_Selected_Vehicle_Mutation_Response>;
  /** delete single row from the table: "fipe.selected_vehicle" */
  delete_fipe_selected_vehicle_by_pk: Maybe<Fipe_Selected_Vehicle>;
  /** delete data from the table: "fipe.vehicle" */
  delete_fipe_vehicle: Maybe<Fipe_Vehicle_Mutation_Response>;
  /** delete single row from the table: "fipe.vehicle" */
  delete_fipe_vehicle_by_pk: Maybe<Fipe_Vehicle>;
  /** delete data from the table: "inspection" */
  delete_inspection: Maybe<Inspection_Mutation_Response>;
  /** delete data from the table: "inspection_analysis_parameter" */
  delete_inspection_analysis_parameter: Maybe<Inspection_Analysis_Parameter_Mutation_Response>;
  /** delete single row from the table: "inspection_analysis_parameter" */
  delete_inspection_analysis_parameter_by_pk: Maybe<Inspection_Analysis_Parameter>;
  /** delete single row from the table: "inspection" */
  delete_inspection_by_pk: Maybe<Inspection>;
  /** delete data from the table: "inspection_fk_tire" */
  delete_inspection_fk_tire: Maybe<Inspection_Fk_Tire_Mutation_Response>;
  /** delete single row from the table: "inspection_fk_tire" */
  delete_inspection_fk_tire_by_pk: Maybe<Inspection_Fk_Tire>;
  /** delete data from the table: "instructor_supervision" */
  delete_instructor_supervision: Maybe<Instructor_Supervision_Mutation_Response>;
  /** delete single row from the table: "instructor_supervision" */
  delete_instructor_supervision_by_pk: Maybe<Instructor_Supervision>;
  /** delete data from the table: "instructor_supervision_observation" */
  delete_instructor_supervision_observation: Maybe<Instructor_Supervision_Observation_Mutation_Response>;
  /** delete single row from the table: "instructor_supervision_observation" */
  delete_instructor_supervision_observation_by_pk: Maybe<Instructor_Supervision_Observation>;
  /** delete data from the table: "level" */
  delete_level: Maybe<Level_Mutation_Response>;
  /** delete single row from the table: "level" */
  delete_level_by_pk: Maybe<Level>;
  /** delete data from the table: "level_option" */
  delete_level_option: Maybe<Level_Option_Mutation_Response>;
  /** delete single row from the table: "level_option" */
  delete_level_option_by_pk: Maybe<Level_Option>;
  /** delete data from the table: "module" */
  delete_module: Maybe<Module_Mutation_Response>;
  /** delete single row from the table: "module" */
  delete_module_by_pk: Maybe<Module>;
  /** delete data from the table: "module_permission" */
  delete_module_permission: Maybe<Module_Permission_Mutation_Response>;
  /** delete single row from the table: "module_permission" */
  delete_module_permission_by_pk: Maybe<Module_Permission>;
  /** delete data from the table: "note" */
  delete_note: Maybe<Note_Mutation_Response>;
  /** delete single row from the table: "note" */
  delete_note_by_pk: Maybe<Note>;
  /** delete data from the table: "notification" */
  delete_notification: Maybe<Notification_Mutation_Response>;
  /** delete single row from the table: "notification" */
  delete_notification_by_pk: Maybe<Notification>;
  /** delete data from the table: "planet_osm_line" */
  delete_planet_osm_line: Maybe<Planet_Osm_Line_Mutation_Response>;
  /** delete data from the table: "product" */
  delete_product: Maybe<Product_Mutation_Response>;
  /** delete single row from the table: "product" */
  delete_product_by_pk: Maybe<Product>;
  /** delete data from the table: "product_price" */
  delete_product_price: Maybe<Product_Price_Mutation_Response>;
  /** delete single row from the table: "product_price" */
  delete_product_price_by_pk: Maybe<Product_Price>;
  /** delete data from the table: "product_request" */
  delete_product_request: Maybe<Product_Request_Mutation_Response>;
  /** delete single row from the table: "product_request" */
  delete_product_request_by_pk: Maybe<Product_Request>;
  /** delete data from the table: "profile" */
  delete_profile: Maybe<Profile_Mutation_Response>;
  /** delete single row from the table: "profile" */
  delete_profile_by_pk: Maybe<Profile>;
  /** delete data from the table: "profile_permission" */
  delete_profile_permission: Maybe<Profile_Permission_Mutation_Response>;
  /** delete single row from the table: "profile_permission" */
  delete_profile_permission_by_pk: Maybe<Profile_Permission>;
  /** delete data from the table: "refresh_token" */
  delete_refresh_token: Maybe<Refresh_Token_Mutation_Response>;
  /** delete single row from the table: "refresh_token" */
  delete_refresh_token_by_pk: Maybe<Refresh_Token>;
  /** delete data from the table: "score_processed" */
  delete_score_processed: Maybe<Score_Processed_Mutation_Response>;
  /** delete single row from the table: "score_processed" */
  delete_score_processed_by_pk: Maybe<Score_Processed>;
  /** delete data from the table: "score_type" */
  delete_score_type: Maybe<Score_Type_Mutation_Response>;
  /** delete single row from the table: "score_type" */
  delete_score_type_by_pk: Maybe<Score_Type>;
  /** delete data from the table: "status_truck_hardware" */
  delete_status_truck_hardware: Maybe<Status_Truck_Hardware_Mutation_Response>;
  /** delete single row from the table: "status_truck_hardware" */
  delete_status_truck_hardware_by_pk: Maybe<Status_Truck_Hardware>;
  /** delete data from the table: "tire" */
  delete_tire: Maybe<Tire_Mutation_Response>;
  /** delete single row from the table: "tire" */
  delete_tire_by_pk: Maybe<Tire>;
  /** delete data from the table: "tire.inspection" */
  delete_tire_inspection: Maybe<Tire_Inspection_Mutation_Response>;
  /** delete single row from the table: "tire.inspection" */
  delete_tire_inspection_by_pk: Maybe<Tire_Inspection>;
  /** delete data from the table: "tire.inspection_fk_tire" */
  delete_tire_inspection_fk_tire: Maybe<Tire_Inspection_Fk_Tire_Mutation_Response>;
  /** delete single row from the table: "tire.inspection_fk_tire" */
  delete_tire_inspection_fk_tire_by_pk: Maybe<Tire_Inspection_Fk_Tire>;
  /** delete data from the table: "tire.inspection_note" */
  delete_tire_inspection_note: Maybe<Tire_Inspection_Note_Mutation_Response>;
  /** delete data from the table: "tire.inspection_note_attachment" */
  delete_tire_inspection_note_attachment: Maybe<Tire_Inspection_Note_Attachment_Mutation_Response>;
  /** delete single row from the table: "tire.inspection_note_attachment" */
  delete_tire_inspection_note_attachment_by_pk: Maybe<Tire_Inspection_Note_Attachment>;
  /** delete single row from the table: "tire.inspection_note" */
  delete_tire_inspection_note_by_pk: Maybe<Tire_Inspection_Note>;
  /** delete data from the table: "tire.inspection_origin" */
  delete_tire_inspection_origin: Maybe<Tire_Inspection_Origin_Mutation_Response>;
  /** delete single row from the table: "tire.inspection_origin" */
  delete_tire_inspection_origin_by_pk: Maybe<Tire_Inspection_Origin>;
  /** delete data from the table: "tire.note_type" */
  delete_tire_note_type: Maybe<Tire_Note_Type_Mutation_Response>;
  /** delete single row from the table: "tire.note_type" */
  delete_tire_note_type_by_pk: Maybe<Tire_Note_Type>;
  /** delete data from the table: "tire.parameter" */
  delete_tire_parameter: Maybe<Tire_Parameter_Mutation_Response>;
  /** delete single row from the table: "tire.parameter" */
  delete_tire_parameter_by_pk: Maybe<Tire_Parameter>;
  /** delete data from the table: "tire_processing_history" */
  delete_tire_processing_history: Maybe<Tire_Processing_History_Mutation_Response>;
  /** delete single row from the table: "tire_processing_history" */
  delete_tire_processing_history_by_pk: Maybe<Tire_Processing_History>;
  /** delete data from the table: "tirecheck_inconsistency" */
  delete_tirecheck_inconsistency: Maybe<Tirecheck_Inconsistency_Mutation_Response>;
  /** delete single row from the table: "tirecheck_inconsistency" */
  delete_tirecheck_inconsistency_by_pk: Maybe<Tirecheck_Inconsistency>;
  /** delete data from the table: "training" */
  delete_training: Maybe<Training_Mutation_Response>;
  /** delete single row from the table: "training" */
  delete_training_by_pk: Maybe<Training>;
  /** delete data from the table: "training_document" */
  delete_training_document: Maybe<Training_Document_Mutation_Response>;
  /** delete single row from the table: "training_document" */
  delete_training_document_by_pk: Maybe<Training_Document>;
  /** delete data from the table: "training_document_view" */
  delete_training_document_view: Maybe<Training_Document_View_Mutation_Response>;
  /** delete single row from the table: "training_document_view" */
  delete_training_document_view_by_pk: Maybe<Training_Document_View>;
  /** delete data from the table: "user" */
  delete_user: Maybe<User_Mutation_Response>;
  /** delete single row from the table: "user" */
  delete_user_by_pk: Maybe<User>;
  /** delete data from the table: "user_fk_achievement" */
  delete_user_fk_achievement: Maybe<User_Fk_Achievement_Mutation_Response>;
  /** delete single row from the table: "user_fk_achievement" */
  delete_user_fk_achievement_by_pk: Maybe<User_Fk_Achievement>;
  /** delete data from the table: "user_fk_challenge" */
  delete_user_fk_challenge: Maybe<User_Fk_Challenge_Mutation_Response>;
  /** delete single row from the table: "user_fk_challenge" */
  delete_user_fk_challenge_by_pk: Maybe<User_Fk_Challenge>;
  /** delete data from the table: "user_fk_level" */
  delete_user_fk_level: Maybe<User_Fk_Level_Mutation_Response>;
  /** delete single row from the table: "user_fk_level" */
  delete_user_fk_level_by_pk: Maybe<User_Fk_Level>;
  /** delete data from the table: "user_fk_notification" */
  delete_user_fk_notification: Maybe<User_Fk_Notification_Mutation_Response>;
  /** delete single row from the table: "user_fk_notification" */
  delete_user_fk_notification_by_pk: Maybe<User_Fk_Notification>;
  /** delete data from the table: "user_fk_privacy_policy" */
  delete_user_fk_privacy_policy: Maybe<User_Fk_Privacy_Policy_Mutation_Response>;
  /** delete single row from the table: "user_fk_privacy_policy" */
  delete_user_fk_privacy_policy_by_pk: Maybe<User_Fk_Privacy_Policy>;
  /** delete data from the table: "user_km_points_approval" */
  delete_user_km_points_approval: Maybe<User_Km_Points_Approval_Mutation_Response>;
  /** delete single row from the table: "user_km_points_approval" */
  delete_user_km_points_approval_by_pk: Maybe<User_Km_Points_Approval>;
  /** delete data from the table: "user_kmps" */
  delete_user_kmps: Maybe<User_Kmps_Mutation_Response>;
  /** delete single row from the table: "user_kmps" */
  delete_user_kmps_by_pk: Maybe<User_Kmps>;
  /** delete data from the table: "user_score" */
  delete_user_score: Maybe<User_Score_Mutation_Response>;
  /** delete single row from the table: "user_score" */
  delete_user_score_by_pk: Maybe<User_Score>;
  /** delete data from the table: "user_training" */
  delete_user_training: Maybe<User_Training_Mutation_Response>;
  /** delete single row from the table: "user_training" */
  delete_user_training_by_pk: Maybe<User_Training>;
  /** delete data from the table: "vehicle" */
  delete_vehicle: Maybe<Vehicle_Mutation_Response>;
  /** delete single row from the table: "vehicle" */
  delete_vehicle_by_pk: Maybe<Vehicle>;
  /** delete data from the table: "whatsapp_event" */
  delete_whatsapp_event: Maybe<Whatsapp_Event_Mutation_Response>;
  /** delete single row from the table: "whatsapp_event" */
  delete_whatsapp_event_by_pk: Maybe<Whatsapp_Event>;
  /** delete data from the table: "whatsapp_message" */
  delete_whatsapp_message: Maybe<Whatsapp_Message_Mutation_Response>;
  /** delete single row from the table: "whatsapp_message" */
  delete_whatsapp_message_by_pk: Maybe<Whatsapp_Message>;
  /** delete data from the table: "whatsapp_message_history" */
  delete_whatsapp_message_history: Maybe<Whatsapp_Message_History_Mutation_Response>;
  /** delete single row from the table: "whatsapp_message_history" */
  delete_whatsapp_message_history_by_pk: Maybe<Whatsapp_Message_History>;
  /** delete data from the table: "whatsapp_trigger" */
  delete_whatsapp_trigger: Maybe<Whatsapp_Trigger_Mutation_Response>;
  /** delete single row from the table: "whatsapp_trigger" */
  delete_whatsapp_trigger_by_pk: Maybe<Whatsapp_Trigger>;
  edi_api_busca_nfe: Maybe<EdiApiNFeOutput>;
  edi_api_request_end_of_busca_nfe: Maybe<EdiApiNFeOutput>;
  /** execute VOLATILE function "generate_missing_score_processed" which returns "score_processed" */
  generate_missing_score_processed: Array<Score_Processed>;
  /** insert data into the table: "CurrentTiresByVehicle" */
  insert_CurrentTiresByVehicle: Maybe<CurrentTiresByVehicle_Mutation_Response>;
  /** insert a single row into the table: "CurrentTiresByVehicle" */
  insert_CurrentTiresByVehicle_one: Maybe<CurrentTiresByVehicle>;
  /** insert data into the table: "ParametroAlertaConducao" */
  insert_ParametroAlertaConducao: Maybe<ParametroAlertaConducao_Mutation_Response>;
  /** insert a single row into the table: "ParametroAlertaConducao" */
  insert_ParametroAlertaConducao_one: Maybe<ParametroAlertaConducao>;
  /** insert data into the table: "PerformanceParameter" */
  insert_PerformanceParameter: Maybe<PerformanceParameter_Mutation_Response>;
  /** insert a single row into the table: "PerformanceParameter" */
  insert_PerformanceParameter_one: Maybe<PerformanceParameter>;
  /** insert data into the table: "PontosRastro" */
  insert_PontosRastro: Maybe<PontosRastro_Mutation_Response>;
  /** insert a single row into the table: "PontosRastro" */
  insert_PontosRastro_one: Maybe<PontosRastro>;
  /** insert data into the table: "ScoreParameter" */
  insert_ScoreParameter: Maybe<ScoreParameter_Mutation_Response>;
  /** insert a single row into the table: "ScoreParameter" */
  insert_ScoreParameter_one: Maybe<ScoreParameter>;
  /** insert data into the table: "ScoreType" */
  insert_ScoreType: Maybe<ScoreType_Mutation_Response>;
  /** insert a single row into the table: "ScoreType" */
  insert_ScoreType_one: Maybe<ScoreType>;
  /** insert data into the table: "SuntechEquipamento" */
  insert_SuntechEquipamento: Maybe<SuntechEquipamento_Mutation_Response>;
  /** insert a single row into the table: "SuntechEquipamento" */
  insert_SuntechEquipamento_one: Maybe<SuntechEquipamento>;
  /** insert data into the table: "SuntechTrackerBatchCommand" */
  insert_SuntechTrackerBatchCommand: Maybe<SuntechTrackerBatchCommand_Mutation_Response>;
  /** insert data into the table: "SuntechTrackerBatchCommandDevice" */
  insert_SuntechTrackerBatchCommandDevice: Maybe<SuntechTrackerBatchCommandDevice_Mutation_Response>;
  /** insert a single row into the table: "SuntechTrackerBatchCommandDevice" */
  insert_SuntechTrackerBatchCommandDevice_one: Maybe<SuntechTrackerBatchCommandDevice>;
  /** insert data into the table: "SuntechTrackerBatchCommandPreset" */
  insert_SuntechTrackerBatchCommandPreset: Maybe<SuntechTrackerBatchCommandPreset_Mutation_Response>;
  /** insert a single row into the table: "SuntechTrackerBatchCommandPreset" */
  insert_SuntechTrackerBatchCommandPreset_one: Maybe<SuntechTrackerBatchCommandPreset>;
  /** insert a single row into the table: "SuntechTrackerBatchCommand" */
  insert_SuntechTrackerBatchCommand_one: Maybe<SuntechTrackerBatchCommand>;
  /** insert data into the table: "SuntechTrackerCommand" */
  insert_SuntechTrackerCommand: Maybe<SuntechTrackerCommand_Mutation_Response>;
  /** insert a single row into the table: "SuntechTrackerCommand" */
  insert_SuntechTrackerCommand_one: Maybe<SuntechTrackerCommand>;
  /** insert data into the table: "VirlocTrackerBatchCommand" */
  insert_VirlocTrackerBatchCommand: Maybe<VirlocTrackerBatchCommand_Mutation_Response>;
  /** insert data into the table: "VirlocTrackerBatchCommandDevice" */
  insert_VirlocTrackerBatchCommandDevice: Maybe<VirlocTrackerBatchCommandDevice_Mutation_Response>;
  /** insert a single row into the table: "VirlocTrackerBatchCommandDevice" */
  insert_VirlocTrackerBatchCommandDevice_one: Maybe<VirlocTrackerBatchCommandDevice>;
  /** insert data into the table: "VirlocTrackerBatchCommandPreset" */
  insert_VirlocTrackerBatchCommandPreset: Maybe<VirlocTrackerBatchCommandPreset_Mutation_Response>;
  /** insert a single row into the table: "VirlocTrackerBatchCommandPreset" */
  insert_VirlocTrackerBatchCommandPreset_one: Maybe<VirlocTrackerBatchCommandPreset>;
  /** insert a single row into the table: "VirlocTrackerBatchCommand" */
  insert_VirlocTrackerBatchCommand_one: Maybe<VirlocTrackerBatchCommand>;
  /** insert data into the table: "VirlocTrackerCommand" */
  insert_VirlocTrackerCommand: Maybe<VirlocTrackerCommand_Mutation_Response>;
  /** insert a single row into the table: "VirlocTrackerCommand" */
  insert_VirlocTrackerCommand_one: Maybe<VirlocTrackerCommand>;
  /** insert data into the table: "VirlocTrackerDevice" */
  insert_VirlocTrackerDevice: Maybe<VirlocTrackerDevice_Mutation_Response>;
  /** insert a single row into the table: "VirlocTrackerDevice" */
  insert_VirlocTrackerDevice_one: Maybe<VirlocTrackerDevice>;
  /** insert data into the table: "achievement" */
  insert_achievement: Maybe<Achievement_Mutation_Response>;
  /** insert a single row into the table: "achievement" */
  insert_achievement_one: Maybe<Achievement>;
  /** insert data into the table: "admin" */
  insert_admin: Maybe<Admin_Mutation_Response>;
  /** insert data into the table: "admin_fk_notifications" */
  insert_admin_fk_notifications: Maybe<Admin_Fk_Notifications_Mutation_Response>;
  /** insert a single row into the table: "admin_fk_notifications" */
  insert_admin_fk_notifications_one: Maybe<Admin_Fk_Notifications>;
  /** insert data into the table: "admin_fk_profile" */
  insert_admin_fk_profile: Maybe<Admin_Fk_Profile_Mutation_Response>;
  /** insert a single row into the table: "admin_fk_profile" */
  insert_admin_fk_profile_one: Maybe<Admin_Fk_Profile>;
  /** insert a single row into the table: "admin" */
  insert_admin_one: Maybe<Admin>;
  /** insert data into the table: "admin_permission" */
  insert_admin_permission: Maybe<Admin_Permission_Mutation_Response>;
  /** insert a single row into the table: "admin_permission" */
  insert_admin_permission_one: Maybe<Admin_Permission>;
  /** insert data into the table: "auto" */
  insert_auto: Maybe<Auto_Mutation_Response>;
  /** insert a single row into the table: "auto" */
  insert_auto_one: Maybe<Auto>;
  /** insert data into the table: "bi.dashboard" */
  insert_bi_dashboard: Maybe<Bi_Dashboard_Mutation_Response>;
  /** insert data into the table: "bi.dashboard_item" */
  insert_bi_dashboard_item: Maybe<Bi_Dashboard_Item_Mutation_Response>;
  /** insert a single row into the table: "bi.dashboard_item" */
  insert_bi_dashboard_item_one: Maybe<Bi_Dashboard_Item>;
  /** insert data into the table: "bi.dashboard_item_type" */
  insert_bi_dashboard_item_type: Maybe<Bi_Dashboard_Item_Type_Mutation_Response>;
  /** insert a single row into the table: "bi.dashboard_item_type" */
  insert_bi_dashboard_item_type_one: Maybe<Bi_Dashboard_Item_Type>;
  /** insert a single row into the table: "bi.dashboard" */
  insert_bi_dashboard_one: Maybe<Bi_Dashboard>;
  /** insert data into the table: "bi.datasource" */
  insert_bi_datasource: Maybe<Bi_Datasource_Mutation_Response>;
  /** insert a single row into the table: "bi.datasource" */
  insert_bi_datasource_one: Maybe<Bi_Datasource>;
  /** insert data into the table: "bi.datasource_type" */
  insert_bi_datasource_type: Maybe<Bi_Datasource_Type_Mutation_Response>;
  /** insert a single row into the table: "bi.datasource_type" */
  insert_bi_datasource_type_one: Maybe<Bi_Datasource_Type>;
  /** insert data into the table: "bi.permission" */
  insert_bi_permission: Maybe<Bi_Permission_Mutation_Response>;
  /** insert data into the table: "bi.permission_module" */
  insert_bi_permission_module: Maybe<Bi_Permission_Module_Mutation_Response>;
  /** insert a single row into the table: "bi.permission_module" */
  insert_bi_permission_module_one: Maybe<Bi_Permission_Module>;
  /** insert a single row into the table: "bi.permission" */
  insert_bi_permission_one: Maybe<Bi_Permission>;
  /** insert data into the table: "bi.public_link" */
  insert_bi_public_link: Maybe<Bi_Public_Link_Mutation_Response>;
  /** insert a single row into the table: "bi.public_link" */
  insert_bi_public_link_one: Maybe<Bi_Public_Link>;
  /** insert data into the table: "bi.query" */
  insert_bi_query: Maybe<Bi_Query_Mutation_Response>;
  /** insert data into the table: "bi.query_analytics" */
  insert_bi_query_analytics: Maybe<Bi_Query_Analytics_Mutation_Response>;
  /** insert a single row into the table: "bi.query_analytics" */
  insert_bi_query_analytics_one: Maybe<Bi_Query_Analytics>;
  /** insert data into the table: "bi.query_cache" */
  insert_bi_query_cache: Maybe<Bi_Query_Cache_Mutation_Response>;
  /** insert a single row into the table: "bi.query_cache" */
  insert_bi_query_cache_one: Maybe<Bi_Query_Cache>;
  /** insert a single row into the table: "bi.query" */
  insert_bi_query_one: Maybe<Bi_Query>;
  /** insert data into the table: "bi.subquery" */
  insert_bi_subquery: Maybe<Bi_Subquery_Mutation_Response>;
  /** insert a single row into the table: "bi.subquery" */
  insert_bi_subquery_one: Maybe<Bi_Subquery>;
  /** insert data into the table: "bi.user_permission" */
  insert_bi_user_permission: Maybe<Bi_User_Permission_Mutation_Response>;
  /** insert a single row into the table: "bi.user_permission" */
  insert_bi_user_permission_one: Maybe<Bi_User_Permission>;
  /** insert data into the table: "challenge" */
  insert_challenge: Maybe<Challenge_Mutation_Response>;
  /** insert a single row into the table: "challenge" */
  insert_challenge_one: Maybe<Challenge>;
  /** insert data into the table: "challenge_type" */
  insert_challenge_type: Maybe<Challenge_Type_Mutation_Response>;
  /** insert a single row into the table: "challenge_type" */
  insert_challenge_type_one: Maybe<Challenge_Type>;
  /** insert data into the table: "config" */
  insert_config: Maybe<Config_Mutation_Response>;
  /** insert a single row into the table: "config" */
  insert_config_one: Maybe<Config>;
  /** insert data into the table: "critical_point" */
  insert_critical_point: Maybe<Critical_Point_Mutation_Response>;
  /** insert a single row into the table: "critical_point" */
  insert_critical_point_one: Maybe<Critical_Point>;
  /** insert data into the table: "critical_segment" */
  insert_critical_segment: Maybe<Critical_Segment_Mutation_Response>;
  /** insert a single row into the table: "critical_segment" */
  insert_critical_segment_one: Maybe<Critical_Segment>;
  /** insert data into the table: "cte.nf_lock" */
  insert_cte_nf_lock: Maybe<Cte_Nf_Lock_Mutation_Response>;
  /** insert a single row into the table: "cte.nf_lock" */
  insert_cte_nf_lock_one: Maybe<Cte_Nf_Lock>;
  /** insert data into the table: "deleted_row" */
  insert_deleted_row: Maybe<Deleted_Row_Mutation_Response>;
  /** insert a single row into the table: "deleted_row" */
  insert_deleted_row_one: Maybe<Deleted_Row>;
  /** insert data into the table: "delivery" */
  insert_delivery: Maybe<Delivery_Mutation_Response>;
  /** insert a single row into the table: "delivery" */
  insert_delivery_one: Maybe<Delivery>;
  /** insert data into the table: "driver_warning" */
  insert_driver_warning: Maybe<Driver_Warning_Mutation_Response>;
  /** insert data into the table: "driver_warning_comment" */
  insert_driver_warning_comment: Maybe<Driver_Warning_Comment_Mutation_Response>;
  /** insert a single row into the table: "driver_warning_comment" */
  insert_driver_warning_comment_one: Maybe<Driver_Warning_Comment>;
  /** insert data into the table: "driver_warning_fk_whatsapp_message" */
  insert_driver_warning_fk_whatsapp_message: Maybe<Driver_Warning_Fk_Whatsapp_Message_Mutation_Response>;
  /** insert a single row into the table: "driver_warning_fk_whatsapp_message" */
  insert_driver_warning_fk_whatsapp_message_one: Maybe<Driver_Warning_Fk_Whatsapp_Message>;
  /** insert a single row into the table: "driver_warning" */
  insert_driver_warning_one: Maybe<Driver_Warning>;
  /** insert data into the table: "driver_warning_risk_level" */
  insert_driver_warning_risk_level: Maybe<Driver_Warning_Risk_Level_Mutation_Response>;
  /** insert a single row into the table: "driver_warning_risk_level" */
  insert_driver_warning_risk_level_one: Maybe<Driver_Warning_Risk_Level>;
  /** insert data into the table: "driver_warning_trip" */
  insert_driver_warning_trip: Maybe<Driver_Warning_Trip_Mutation_Response>;
  /** insert a single row into the table: "driver_warning_trip" */
  insert_driver_warning_trip_one: Maybe<Driver_Warning_Trip>;
  /** insert data into the table: "driver_warning_trip_point" */
  insert_driver_warning_trip_point: Maybe<Driver_Warning_Trip_Point_Mutation_Response>;
  /** insert a single row into the table: "driver_warning_trip_point" */
  insert_driver_warning_trip_point_one: Maybe<Driver_Warning_Trip_Point>;
  /** insert data into the table: "driver_warning_trip_severity" */
  insert_driver_warning_trip_severity: Maybe<Driver_Warning_Trip_Severity_Mutation_Response>;
  /** insert a single row into the table: "driver_warning_trip_severity" */
  insert_driver_warning_trip_severity_one: Maybe<Driver_Warning_Trip_Severity>;
  /** insert data into the table: "edi.busca_nfe_job" */
  insert_edi_busca_nfe_job: Maybe<Edi_Busca_Nfe_Job_Mutation_Response>;
  /** insert a single row into the table: "edi.busca_nfe_job" */
  insert_edi_busca_nfe_job_one: Maybe<Edi_Busca_Nfe_Job>;
  /** insert data into the table: "edi.busca_nfe_response" */
  insert_edi_busca_nfe_response: Maybe<Edi_Busca_Nfe_Response_Mutation_Response>;
  /** insert a single row into the table: "edi.busca_nfe_response" */
  insert_edi_busca_nfe_response_one: Maybe<Edi_Busca_Nfe_Response>;
  /** insert data into the table: "empty_tables.critical_segment_from_critical_point" */
  insert_empty_tables_critical_segment_from_critical_point: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Mutation_Response>;
  /** insert a single row into the table: "empty_tables.critical_segment_from_critical_point" */
  insert_empty_tables_critical_segment_from_critical_point_one: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point>;
  /** insert data into the table: "empty_tables.driver_performance_data" */
  insert_empty_tables_driver_performance_data: Maybe<Empty_Tables_Driver_Performance_Data_Mutation_Response>;
  /** insert a single row into the table: "empty_tables.driver_performance_data" */
  insert_empty_tables_driver_performance_data_one: Maybe<Empty_Tables_Driver_Performance_Data>;
  /** insert data into the table: "empty_tables.fleet_performance_data" */
  insert_empty_tables_fleet_performance_data: Maybe<Empty_Tables_Fleet_Performance_Data_Mutation_Response>;
  /** insert a single row into the table: "empty_tables.fleet_performance_data" */
  insert_empty_tables_fleet_performance_data_one: Maybe<Empty_Tables_Fleet_Performance_Data>;
  /** insert data into the table: "empty_tables.geojson_trip" */
  insert_empty_tables_geojson_trip: Maybe<Empty_Tables_Geojson_Trip_Mutation_Response>;
  /** insert a single row into the table: "empty_tables.geojson_trip" */
  insert_empty_tables_geojson_trip_one: Maybe<Empty_Tables_Geojson_Trip>;
  /** insert data into the table: "empty_tables.instructor_drivers_performance_history" */
  insert_empty_tables_instructor_drivers_performance_history: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Mutation_Response>;
  /** insert a single row into the table: "empty_tables.instructor_drivers_performance_history" */
  insert_empty_tables_instructor_drivers_performance_history_one: Maybe<Empty_Tables_Instructor_Drivers_Performance_History>;
  /** insert data into the table: "fidelity_range_points" */
  insert_fidelity_range_points: Maybe<Fidelity_Range_Points_Mutation_Response>;
  /** insert a single row into the table: "fidelity_range_points" */
  insert_fidelity_range_points_one: Maybe<Fidelity_Range_Points>;
  /** insert data into the table: "fipe.price" */
  insert_fipe_price: Maybe<Fipe_Price_Mutation_Response>;
  /** insert a single row into the table: "fipe.price" */
  insert_fipe_price_one: Maybe<Fipe_Price>;
  /** insert data into the table: "fipe.reference_month" */
  insert_fipe_reference_month: Maybe<Fipe_Reference_Month_Mutation_Response>;
  /** insert a single row into the table: "fipe.reference_month" */
  insert_fipe_reference_month_one: Maybe<Fipe_Reference_Month>;
  /** insert data into the table: "fipe.selected_vehicle" */
  insert_fipe_selected_vehicle: Maybe<Fipe_Selected_Vehicle_Mutation_Response>;
  /** insert a single row into the table: "fipe.selected_vehicle" */
  insert_fipe_selected_vehicle_one: Maybe<Fipe_Selected_Vehicle>;
  /** insert data into the table: "fipe.vehicle" */
  insert_fipe_vehicle: Maybe<Fipe_Vehicle_Mutation_Response>;
  /** insert a single row into the table: "fipe.vehicle" */
  insert_fipe_vehicle_one: Maybe<Fipe_Vehicle>;
  /** insert data into the table: "inspection" */
  insert_inspection: Maybe<Inspection_Mutation_Response>;
  /** insert data into the table: "inspection_analysis_parameter" */
  insert_inspection_analysis_parameter: Maybe<Inspection_Analysis_Parameter_Mutation_Response>;
  /** insert a single row into the table: "inspection_analysis_parameter" */
  insert_inspection_analysis_parameter_one: Maybe<Inspection_Analysis_Parameter>;
  /** insert data into the table: "inspection_fk_tire" */
  insert_inspection_fk_tire: Maybe<Inspection_Fk_Tire_Mutation_Response>;
  /** insert a single row into the table: "inspection_fk_tire" */
  insert_inspection_fk_tire_one: Maybe<Inspection_Fk_Tire>;
  /** insert a single row into the table: "inspection" */
  insert_inspection_one: Maybe<Inspection>;
  /** insert data into the table: "instructor_supervision" */
  insert_instructor_supervision: Maybe<Instructor_Supervision_Mutation_Response>;
  /** insert data into the table: "instructor_supervision_observation" */
  insert_instructor_supervision_observation: Maybe<Instructor_Supervision_Observation_Mutation_Response>;
  /** insert a single row into the table: "instructor_supervision_observation" */
  insert_instructor_supervision_observation_one: Maybe<Instructor_Supervision_Observation>;
  /** insert a single row into the table: "instructor_supervision" */
  insert_instructor_supervision_one: Maybe<Instructor_Supervision>;
  /** insert data into the table: "level" */
  insert_level: Maybe<Level_Mutation_Response>;
  /** insert a single row into the table: "level" */
  insert_level_one: Maybe<Level>;
  /** insert data into the table: "level_option" */
  insert_level_option: Maybe<Level_Option_Mutation_Response>;
  /** insert a single row into the table: "level_option" */
  insert_level_option_one: Maybe<Level_Option>;
  /** insert data into the table: "module" */
  insert_module: Maybe<Module_Mutation_Response>;
  /** insert a single row into the table: "module" */
  insert_module_one: Maybe<Module>;
  /** insert data into the table: "module_permission" */
  insert_module_permission: Maybe<Module_Permission_Mutation_Response>;
  /** insert a single row into the table: "module_permission" */
  insert_module_permission_one: Maybe<Module_Permission>;
  /** insert data into the table: "note" */
  insert_note: Maybe<Note_Mutation_Response>;
  /** insert a single row into the table: "note" */
  insert_note_one: Maybe<Note>;
  /** insert data into the table: "notification" */
  insert_notification: Maybe<Notification_Mutation_Response>;
  /** insert a single row into the table: "notification" */
  insert_notification_one: Maybe<Notification>;
  /** insert data into the table: "planet_osm_line" */
  insert_planet_osm_line: Maybe<Planet_Osm_Line_Mutation_Response>;
  /** insert a single row into the table: "planet_osm_line" */
  insert_planet_osm_line_one: Maybe<Planet_Osm_Line>;
  /** insert data into the table: "product" */
  insert_product: Maybe<Product_Mutation_Response>;
  /** insert a single row into the table: "product" */
  insert_product_one: Maybe<Product>;
  /** insert data into the table: "product_price" */
  insert_product_price: Maybe<Product_Price_Mutation_Response>;
  /** insert a single row into the table: "product_price" */
  insert_product_price_one: Maybe<Product_Price>;
  /** insert data into the table: "product_request" */
  insert_product_request: Maybe<Product_Request_Mutation_Response>;
  /** insert a single row into the table: "product_request" */
  insert_product_request_one: Maybe<Product_Request>;
  /** insert data into the table: "profile" */
  insert_profile: Maybe<Profile_Mutation_Response>;
  /** insert a single row into the table: "profile" */
  insert_profile_one: Maybe<Profile>;
  /** insert data into the table: "profile_permission" */
  insert_profile_permission: Maybe<Profile_Permission_Mutation_Response>;
  /** insert a single row into the table: "profile_permission" */
  insert_profile_permission_one: Maybe<Profile_Permission>;
  /** insert data into the table: "refresh_token" */
  insert_refresh_token: Maybe<Refresh_Token_Mutation_Response>;
  /** insert a single row into the table: "refresh_token" */
  insert_refresh_token_one: Maybe<Refresh_Token>;
  /** insert data into the table: "score_processed" */
  insert_score_processed: Maybe<Score_Processed_Mutation_Response>;
  /** insert a single row into the table: "score_processed" */
  insert_score_processed_one: Maybe<Score_Processed>;
  /** insert data into the table: "score_type" */
  insert_score_type: Maybe<Score_Type_Mutation_Response>;
  /** insert a single row into the table: "score_type" */
  insert_score_type_one: Maybe<Score_Type>;
  /** insert data into the table: "status_truck_hardware" */
  insert_status_truck_hardware: Maybe<Status_Truck_Hardware_Mutation_Response>;
  /** insert a single row into the table: "status_truck_hardware" */
  insert_status_truck_hardware_one: Maybe<Status_Truck_Hardware>;
  /** insert data into the table: "tire" */
  insert_tire: Maybe<Tire_Mutation_Response>;
  /** insert data into the table: "tire.inspection" */
  insert_tire_inspection: Maybe<Tire_Inspection_Mutation_Response>;
  /** insert data into the table: "tire.inspection_fk_tire" */
  insert_tire_inspection_fk_tire: Maybe<Tire_Inspection_Fk_Tire_Mutation_Response>;
  /** insert a single row into the table: "tire.inspection_fk_tire" */
  insert_tire_inspection_fk_tire_one: Maybe<Tire_Inspection_Fk_Tire>;
  /** insert data into the table: "tire.inspection_note" */
  insert_tire_inspection_note: Maybe<Tire_Inspection_Note_Mutation_Response>;
  /** insert data into the table: "tire.inspection_note_attachment" */
  insert_tire_inspection_note_attachment: Maybe<Tire_Inspection_Note_Attachment_Mutation_Response>;
  /** insert a single row into the table: "tire.inspection_note_attachment" */
  insert_tire_inspection_note_attachment_one: Maybe<Tire_Inspection_Note_Attachment>;
  /** insert a single row into the table: "tire.inspection_note" */
  insert_tire_inspection_note_one: Maybe<Tire_Inspection_Note>;
  /** insert a single row into the table: "tire.inspection" */
  insert_tire_inspection_one: Maybe<Tire_Inspection>;
  /** insert data into the table: "tire.inspection_origin" */
  insert_tire_inspection_origin: Maybe<Tire_Inspection_Origin_Mutation_Response>;
  /** insert a single row into the table: "tire.inspection_origin" */
  insert_tire_inspection_origin_one: Maybe<Tire_Inspection_Origin>;
  /** insert data into the table: "tire.note_type" */
  insert_tire_note_type: Maybe<Tire_Note_Type_Mutation_Response>;
  /** insert a single row into the table: "tire.note_type" */
  insert_tire_note_type_one: Maybe<Tire_Note_Type>;
  /** insert a single row into the table: "tire" */
  insert_tire_one: Maybe<Tire>;
  /** insert data into the table: "tire.parameter" */
  insert_tire_parameter: Maybe<Tire_Parameter_Mutation_Response>;
  /** insert a single row into the table: "tire.parameter" */
  insert_tire_parameter_one: Maybe<Tire_Parameter>;
  /** insert data into the table: "tire_processing_history" */
  insert_tire_processing_history: Maybe<Tire_Processing_History_Mutation_Response>;
  /** insert a single row into the table: "tire_processing_history" */
  insert_tire_processing_history_one: Maybe<Tire_Processing_History>;
  /** insert data into the table: "tirecheck_inconsistency" */
  insert_tirecheck_inconsistency: Maybe<Tirecheck_Inconsistency_Mutation_Response>;
  /** insert a single row into the table: "tirecheck_inconsistency" */
  insert_tirecheck_inconsistency_one: Maybe<Tirecheck_Inconsistency>;
  /** insert data into the table: "training" */
  insert_training: Maybe<Training_Mutation_Response>;
  /** insert data into the table: "training_document" */
  insert_training_document: Maybe<Training_Document_Mutation_Response>;
  /** insert a single row into the table: "training_document" */
  insert_training_document_one: Maybe<Training_Document>;
  /** insert data into the table: "training_document_view" */
  insert_training_document_view: Maybe<Training_Document_View_Mutation_Response>;
  /** insert a single row into the table: "training_document_view" */
  insert_training_document_view_one: Maybe<Training_Document_View>;
  /** insert a single row into the table: "training" */
  insert_training_one: Maybe<Training>;
  /** insert data into the table: "user" */
  insert_user: Maybe<User_Mutation_Response>;
  /** insert data into the table: "user_fk_achievement" */
  insert_user_fk_achievement: Maybe<User_Fk_Achievement_Mutation_Response>;
  /** insert a single row into the table: "user_fk_achievement" */
  insert_user_fk_achievement_one: Maybe<User_Fk_Achievement>;
  /** insert data into the table: "user_fk_challenge" */
  insert_user_fk_challenge: Maybe<User_Fk_Challenge_Mutation_Response>;
  /** insert a single row into the table: "user_fk_challenge" */
  insert_user_fk_challenge_one: Maybe<User_Fk_Challenge>;
  /** insert data into the table: "user_fk_level" */
  insert_user_fk_level: Maybe<User_Fk_Level_Mutation_Response>;
  /** insert a single row into the table: "user_fk_level" */
  insert_user_fk_level_one: Maybe<User_Fk_Level>;
  /** insert data into the table: "user_fk_notification" */
  insert_user_fk_notification: Maybe<User_Fk_Notification_Mutation_Response>;
  /** insert a single row into the table: "user_fk_notification" */
  insert_user_fk_notification_one: Maybe<User_Fk_Notification>;
  /** insert data into the table: "user_fk_privacy_policy" */
  insert_user_fk_privacy_policy: Maybe<User_Fk_Privacy_Policy_Mutation_Response>;
  /** insert a single row into the table: "user_fk_privacy_policy" */
  insert_user_fk_privacy_policy_one: Maybe<User_Fk_Privacy_Policy>;
  /** insert data into the table: "user_km_points_approval" */
  insert_user_km_points_approval: Maybe<User_Km_Points_Approval_Mutation_Response>;
  /** insert a single row into the table: "user_km_points_approval" */
  insert_user_km_points_approval_one: Maybe<User_Km_Points_Approval>;
  /** insert data into the table: "user_kmps" */
  insert_user_kmps: Maybe<User_Kmps_Mutation_Response>;
  /** insert a single row into the table: "user_kmps" */
  insert_user_kmps_one: Maybe<User_Kmps>;
  /** insert a single row into the table: "user" */
  insert_user_one: Maybe<User>;
  /** insert data into the table: "user_score" */
  insert_user_score: Maybe<User_Score_Mutation_Response>;
  /** insert a single row into the table: "user_score" */
  insert_user_score_one: Maybe<User_Score>;
  /** insert data into the table: "user_training" */
  insert_user_training: Maybe<User_Training_Mutation_Response>;
  /** insert a single row into the table: "user_training" */
  insert_user_training_one: Maybe<User_Training>;
  /** insert data into the table: "vehicle" */
  insert_vehicle: Maybe<Vehicle_Mutation_Response>;
  /** insert a single row into the table: "vehicle" */
  insert_vehicle_one: Maybe<Vehicle>;
  /** insert data into the table: "whatsapp_event" */
  insert_whatsapp_event: Maybe<Whatsapp_Event_Mutation_Response>;
  /** insert a single row into the table: "whatsapp_event" */
  insert_whatsapp_event_one: Maybe<Whatsapp_Event>;
  /** insert data into the table: "whatsapp_message" */
  insert_whatsapp_message: Maybe<Whatsapp_Message_Mutation_Response>;
  /** insert data into the table: "whatsapp_message_history" */
  insert_whatsapp_message_history: Maybe<Whatsapp_Message_History_Mutation_Response>;
  /** insert a single row into the table: "whatsapp_message_history" */
  insert_whatsapp_message_history_one: Maybe<Whatsapp_Message_History>;
  /** insert a single row into the table: "whatsapp_message" */
  insert_whatsapp_message_one: Maybe<Whatsapp_Message>;
  /** insert data into the table: "whatsapp_trigger" */
  insert_whatsapp_trigger: Maybe<Whatsapp_Trigger_Mutation_Response>;
  /** insert a single row into the table: "whatsapp_trigger" */
  insert_whatsapp_trigger_one: Maybe<Whatsapp_Trigger>;
  register_admin: Maybe<RegisterAdminOutput>;
  /** update data of the table: "CurrentTiresByVehicle" */
  update_CurrentTiresByVehicle: Maybe<CurrentTiresByVehicle_Mutation_Response>;
  /** update data of the table: "ParametroAlertaConducao" */
  update_ParametroAlertaConducao: Maybe<ParametroAlertaConducao_Mutation_Response>;
  /** update single row of the table: "ParametroAlertaConducao" */
  update_ParametroAlertaConducao_by_pk: Maybe<ParametroAlertaConducao>;
  /** update data of the table: "PerformanceParameter" */
  update_PerformanceParameter: Maybe<PerformanceParameter_Mutation_Response>;
  /** update single row of the table: "PerformanceParameter" */
  update_PerformanceParameter_by_pk: Maybe<PerformanceParameter>;
  /** update data of the table: "PontosRastro" */
  update_PontosRastro: Maybe<PontosRastro_Mutation_Response>;
  /** update single row of the table: "PontosRastro" */
  update_PontosRastro_by_pk: Maybe<PontosRastro>;
  /** update data of the table: "ScoreParameter" */
  update_ScoreParameter: Maybe<ScoreParameter_Mutation_Response>;
  /** update single row of the table: "ScoreParameter" */
  update_ScoreParameter_by_pk: Maybe<ScoreParameter>;
  /** update data of the table: "ScoreType" */
  update_ScoreType: Maybe<ScoreType_Mutation_Response>;
  /** update single row of the table: "ScoreType" */
  update_ScoreType_by_pk: Maybe<ScoreType>;
  /** update data of the table: "SuntechEquipamento" */
  update_SuntechEquipamento: Maybe<SuntechEquipamento_Mutation_Response>;
  /** update data of the table: "SuntechTrackerBatchCommand" */
  update_SuntechTrackerBatchCommand: Maybe<SuntechTrackerBatchCommand_Mutation_Response>;
  /** update data of the table: "SuntechTrackerBatchCommandDevice" */
  update_SuntechTrackerBatchCommandDevice: Maybe<SuntechTrackerBatchCommandDevice_Mutation_Response>;
  /** update single row of the table: "SuntechTrackerBatchCommandDevice" */
  update_SuntechTrackerBatchCommandDevice_by_pk: Maybe<SuntechTrackerBatchCommandDevice>;
  /** update data of the table: "SuntechTrackerBatchCommandPreset" */
  update_SuntechTrackerBatchCommandPreset: Maybe<SuntechTrackerBatchCommandPreset_Mutation_Response>;
  /** update single row of the table: "SuntechTrackerBatchCommandPreset" */
  update_SuntechTrackerBatchCommandPreset_by_pk: Maybe<SuntechTrackerBatchCommandPreset>;
  /** update single row of the table: "SuntechTrackerBatchCommand" */
  update_SuntechTrackerBatchCommand_by_pk: Maybe<SuntechTrackerBatchCommand>;
  /** update data of the table: "SuntechTrackerCommand" */
  update_SuntechTrackerCommand: Maybe<SuntechTrackerCommand_Mutation_Response>;
  /** update single row of the table: "SuntechTrackerCommand" */
  update_SuntechTrackerCommand_by_pk: Maybe<SuntechTrackerCommand>;
  /** update data of the table: "VirlocTrackerBatchCommand" */
  update_VirlocTrackerBatchCommand: Maybe<VirlocTrackerBatchCommand_Mutation_Response>;
  /** update data of the table: "VirlocTrackerBatchCommandDevice" */
  update_VirlocTrackerBatchCommandDevice: Maybe<VirlocTrackerBatchCommandDevice_Mutation_Response>;
  /** update single row of the table: "VirlocTrackerBatchCommandDevice" */
  update_VirlocTrackerBatchCommandDevice_by_pk: Maybe<VirlocTrackerBatchCommandDevice>;
  /** update data of the table: "VirlocTrackerBatchCommandPreset" */
  update_VirlocTrackerBatchCommandPreset: Maybe<VirlocTrackerBatchCommandPreset_Mutation_Response>;
  /** update single row of the table: "VirlocTrackerBatchCommandPreset" */
  update_VirlocTrackerBatchCommandPreset_by_pk: Maybe<VirlocTrackerBatchCommandPreset>;
  /** update single row of the table: "VirlocTrackerBatchCommand" */
  update_VirlocTrackerBatchCommand_by_pk: Maybe<VirlocTrackerBatchCommand>;
  /** update data of the table: "VirlocTrackerCommand" */
  update_VirlocTrackerCommand: Maybe<VirlocTrackerCommand_Mutation_Response>;
  /** update single row of the table: "VirlocTrackerCommand" */
  update_VirlocTrackerCommand_by_pk: Maybe<VirlocTrackerCommand>;
  /** update data of the table: "VirlocTrackerDevice" */
  update_VirlocTrackerDevice: Maybe<VirlocTrackerDevice_Mutation_Response>;
  /** update single row of the table: "VirlocTrackerDevice" */
  update_VirlocTrackerDevice_by_pk: Maybe<VirlocTrackerDevice>;
  /** update data of the table: "achievement" */
  update_achievement: Maybe<Achievement_Mutation_Response>;
  /** update single row of the table: "achievement" */
  update_achievement_by_pk: Maybe<Achievement>;
  /** update multiples rows of table: "achievement" */
  update_achievement_many: Maybe<Array<Maybe<Achievement_Mutation_Response>>>;
  /** update data of the table: "admin" */
  update_admin: Maybe<Admin_Mutation_Response>;
  /** update single row of the table: "admin" */
  update_admin_by_pk: Maybe<Admin>;
  /** update data of the table: "admin_fk_notifications" */
  update_admin_fk_notifications: Maybe<Admin_Fk_Notifications_Mutation_Response>;
  /** update single row of the table: "admin_fk_notifications" */
  update_admin_fk_notifications_by_pk: Maybe<Admin_Fk_Notifications>;
  /** update multiples rows of table: "admin_fk_notifications" */
  update_admin_fk_notifications_many: Maybe<Array<Maybe<Admin_Fk_Notifications_Mutation_Response>>>;
  /** update data of the table: "admin_fk_profile" */
  update_admin_fk_profile: Maybe<Admin_Fk_Profile_Mutation_Response>;
  /** update single row of the table: "admin_fk_profile" */
  update_admin_fk_profile_by_pk: Maybe<Admin_Fk_Profile>;
  /** update multiples rows of table: "admin_fk_profile" */
  update_admin_fk_profile_many: Maybe<Array<Maybe<Admin_Fk_Profile_Mutation_Response>>>;
  /** update multiples rows of table: "admin" */
  update_admin_many: Maybe<Array<Maybe<Admin_Mutation_Response>>>;
  /** update data of the table: "admin_permission" */
  update_admin_permission: Maybe<Admin_Permission_Mutation_Response>;
  /** update single row of the table: "admin_permission" */
  update_admin_permission_by_pk: Maybe<Admin_Permission>;
  /** update multiples rows of table: "admin_permission" */
  update_admin_permission_many: Maybe<Array<Maybe<Admin_Permission_Mutation_Response>>>;
  /** update data of the table: "auto" */
  update_auto: Maybe<Auto_Mutation_Response>;
  /** update single row of the table: "auto" */
  update_auto_by_pk: Maybe<Auto>;
  /** update data of the table: "bi.dashboard" */
  update_bi_dashboard: Maybe<Bi_Dashboard_Mutation_Response>;
  /** update single row of the table: "bi.dashboard" */
  update_bi_dashboard_by_pk: Maybe<Bi_Dashboard>;
  /** update data of the table: "bi.dashboard_item" */
  update_bi_dashboard_item: Maybe<Bi_Dashboard_Item_Mutation_Response>;
  /** update single row of the table: "bi.dashboard_item" */
  update_bi_dashboard_item_by_pk: Maybe<Bi_Dashboard_Item>;
  /** update multiples rows of table: "bi.dashboard_item" */
  update_bi_dashboard_item_many: Maybe<Array<Maybe<Bi_Dashboard_Item_Mutation_Response>>>;
  /** update data of the table: "bi.dashboard_item_type" */
  update_bi_dashboard_item_type: Maybe<Bi_Dashboard_Item_Type_Mutation_Response>;
  /** update single row of the table: "bi.dashboard_item_type" */
  update_bi_dashboard_item_type_by_pk: Maybe<Bi_Dashboard_Item_Type>;
  /** update multiples rows of table: "bi.dashboard_item_type" */
  update_bi_dashboard_item_type_many: Maybe<Array<Maybe<Bi_Dashboard_Item_Type_Mutation_Response>>>;
  /** update multiples rows of table: "bi.dashboard" */
  update_bi_dashboard_many: Maybe<Array<Maybe<Bi_Dashboard_Mutation_Response>>>;
  /** update data of the table: "bi.datasource" */
  update_bi_datasource: Maybe<Bi_Datasource_Mutation_Response>;
  /** update single row of the table: "bi.datasource" */
  update_bi_datasource_by_pk: Maybe<Bi_Datasource>;
  /** update multiples rows of table: "bi.datasource" */
  update_bi_datasource_many: Maybe<Array<Maybe<Bi_Datasource_Mutation_Response>>>;
  /** update data of the table: "bi.datasource_type" */
  update_bi_datasource_type: Maybe<Bi_Datasource_Type_Mutation_Response>;
  /** update single row of the table: "bi.datasource_type" */
  update_bi_datasource_type_by_pk: Maybe<Bi_Datasource_Type>;
  /** update multiples rows of table: "bi.datasource_type" */
  update_bi_datasource_type_many: Maybe<Array<Maybe<Bi_Datasource_Type_Mutation_Response>>>;
  /** update data of the table: "bi.permission" */
  update_bi_permission: Maybe<Bi_Permission_Mutation_Response>;
  /** update single row of the table: "bi.permission" */
  update_bi_permission_by_pk: Maybe<Bi_Permission>;
  /** update multiples rows of table: "bi.permission" */
  update_bi_permission_many: Maybe<Array<Maybe<Bi_Permission_Mutation_Response>>>;
  /** update data of the table: "bi.permission_module" */
  update_bi_permission_module: Maybe<Bi_Permission_Module_Mutation_Response>;
  /** update single row of the table: "bi.permission_module" */
  update_bi_permission_module_by_pk: Maybe<Bi_Permission_Module>;
  /** update multiples rows of table: "bi.permission_module" */
  update_bi_permission_module_many: Maybe<Array<Maybe<Bi_Permission_Module_Mutation_Response>>>;
  /** update data of the table: "bi.public_link" */
  update_bi_public_link: Maybe<Bi_Public_Link_Mutation_Response>;
  /** update single row of the table: "bi.public_link" */
  update_bi_public_link_by_pk: Maybe<Bi_Public_Link>;
  /** update multiples rows of table: "bi.public_link" */
  update_bi_public_link_many: Maybe<Array<Maybe<Bi_Public_Link_Mutation_Response>>>;
  /** update data of the table: "bi.query" */
  update_bi_query: Maybe<Bi_Query_Mutation_Response>;
  /** update data of the table: "bi.query_analytics" */
  update_bi_query_analytics: Maybe<Bi_Query_Analytics_Mutation_Response>;
  /** update single row of the table: "bi.query_analytics" */
  update_bi_query_analytics_by_pk: Maybe<Bi_Query_Analytics>;
  /** update multiples rows of table: "bi.query_analytics" */
  update_bi_query_analytics_many: Maybe<Array<Maybe<Bi_Query_Analytics_Mutation_Response>>>;
  /** update single row of the table: "bi.query" */
  update_bi_query_by_pk: Maybe<Bi_Query>;
  /** update data of the table: "bi.query_cache" */
  update_bi_query_cache: Maybe<Bi_Query_Cache_Mutation_Response>;
  /** update single row of the table: "bi.query_cache" */
  update_bi_query_cache_by_pk: Maybe<Bi_Query_Cache>;
  /** update multiples rows of table: "bi.query_cache" */
  update_bi_query_cache_many: Maybe<Array<Maybe<Bi_Query_Cache_Mutation_Response>>>;
  /** update multiples rows of table: "bi.query" */
  update_bi_query_many: Maybe<Array<Maybe<Bi_Query_Mutation_Response>>>;
  /** update data of the table: "bi.subquery" */
  update_bi_subquery: Maybe<Bi_Subquery_Mutation_Response>;
  /** update single row of the table: "bi.subquery" */
  update_bi_subquery_by_pk: Maybe<Bi_Subquery>;
  /** update multiples rows of table: "bi.subquery" */
  update_bi_subquery_many: Maybe<Array<Maybe<Bi_Subquery_Mutation_Response>>>;
  /** update data of the table: "bi.user_permission" */
  update_bi_user_permission: Maybe<Bi_User_Permission_Mutation_Response>;
  /** update single row of the table: "bi.user_permission" */
  update_bi_user_permission_by_pk: Maybe<Bi_User_Permission>;
  /** update multiples rows of table: "bi.user_permission" */
  update_bi_user_permission_many: Maybe<Array<Maybe<Bi_User_Permission_Mutation_Response>>>;
  /** update data of the table: "challenge" */
  update_challenge: Maybe<Challenge_Mutation_Response>;
  /** update single row of the table: "challenge" */
  update_challenge_by_pk: Maybe<Challenge>;
  /** update multiples rows of table: "challenge" */
  update_challenge_many: Maybe<Array<Maybe<Challenge_Mutation_Response>>>;
  /** update data of the table: "challenge_type" */
  update_challenge_type: Maybe<Challenge_Type_Mutation_Response>;
  /** update single row of the table: "challenge_type" */
  update_challenge_type_by_pk: Maybe<Challenge_Type>;
  /** update multiples rows of table: "challenge_type" */
  update_challenge_type_many: Maybe<Array<Maybe<Challenge_Type_Mutation_Response>>>;
  /** update data of the table: "config" */
  update_config: Maybe<Config_Mutation_Response>;
  /** update single row of the table: "config" */
  update_config_by_pk: Maybe<Config>;
  /** update multiples rows of table: "config" */
  update_config_many: Maybe<Array<Maybe<Config_Mutation_Response>>>;
  /** update data of the table: "critical_point" */
  update_critical_point: Maybe<Critical_Point_Mutation_Response>;
  /** update single row of the table: "critical_point" */
  update_critical_point_by_pk: Maybe<Critical_Point>;
  /** update multiples rows of table: "critical_point" */
  update_critical_point_many: Maybe<Array<Maybe<Critical_Point_Mutation_Response>>>;
  /** update data of the table: "critical_segment" */
  update_critical_segment: Maybe<Critical_Segment_Mutation_Response>;
  /** update single row of the table: "critical_segment" */
  update_critical_segment_by_pk: Maybe<Critical_Segment>;
  /** update multiples rows of table: "critical_segment" */
  update_critical_segment_many: Maybe<Array<Maybe<Critical_Segment_Mutation_Response>>>;
  /** update data of the table: "cte.nf_lock" */
  update_cte_nf_lock: Maybe<Cte_Nf_Lock_Mutation_Response>;
  /** update single row of the table: "cte.nf_lock" */
  update_cte_nf_lock_by_pk: Maybe<Cte_Nf_Lock>;
  /** update multiples rows of table: "cte.nf_lock" */
  update_cte_nf_lock_many: Maybe<Array<Maybe<Cte_Nf_Lock_Mutation_Response>>>;
  /** update data of the table: "deleted_row" */
  update_deleted_row: Maybe<Deleted_Row_Mutation_Response>;
  /** update single row of the table: "deleted_row" */
  update_deleted_row_by_pk: Maybe<Deleted_Row>;
  /** update multiples rows of table: "deleted_row" */
  update_deleted_row_many: Maybe<Array<Maybe<Deleted_Row_Mutation_Response>>>;
  /** update data of the table: "delivery" */
  update_delivery: Maybe<Delivery_Mutation_Response>;
  /** update single row of the table: "delivery" */
  update_delivery_by_pk: Maybe<Delivery>;
  /** update multiples rows of table: "delivery" */
  update_delivery_many: Maybe<Array<Maybe<Delivery_Mutation_Response>>>;
  /** update data of the table: "driver_warning" */
  update_driver_warning: Maybe<Driver_Warning_Mutation_Response>;
  /** update single row of the table: "driver_warning" */
  update_driver_warning_by_pk: Maybe<Driver_Warning>;
  /** update data of the table: "driver_warning_comment" */
  update_driver_warning_comment: Maybe<Driver_Warning_Comment_Mutation_Response>;
  /** update single row of the table: "driver_warning_comment" */
  update_driver_warning_comment_by_pk: Maybe<Driver_Warning_Comment>;
  /** update multiples rows of table: "driver_warning_comment" */
  update_driver_warning_comment_many: Maybe<Array<Maybe<Driver_Warning_Comment_Mutation_Response>>>;
  /** update data of the table: "driver_warning_fk_whatsapp_message" */
  update_driver_warning_fk_whatsapp_message: Maybe<Driver_Warning_Fk_Whatsapp_Message_Mutation_Response>;
  /** update single row of the table: "driver_warning_fk_whatsapp_message" */
  update_driver_warning_fk_whatsapp_message_by_pk: Maybe<Driver_Warning_Fk_Whatsapp_Message>;
  /** update multiples rows of table: "driver_warning_fk_whatsapp_message" */
  update_driver_warning_fk_whatsapp_message_many: Maybe<Array<Maybe<Driver_Warning_Fk_Whatsapp_Message_Mutation_Response>>>;
  /** update multiples rows of table: "driver_warning" */
  update_driver_warning_many: Maybe<Array<Maybe<Driver_Warning_Mutation_Response>>>;
  /** update data of the table: "driver_warning_risk_level" */
  update_driver_warning_risk_level: Maybe<Driver_Warning_Risk_Level_Mutation_Response>;
  /** update single row of the table: "driver_warning_risk_level" */
  update_driver_warning_risk_level_by_pk: Maybe<Driver_Warning_Risk_Level>;
  /** update multiples rows of table: "driver_warning_risk_level" */
  update_driver_warning_risk_level_many: Maybe<Array<Maybe<Driver_Warning_Risk_Level_Mutation_Response>>>;
  /** update data of the table: "driver_warning_trip" */
  update_driver_warning_trip: Maybe<Driver_Warning_Trip_Mutation_Response>;
  /** update single row of the table: "driver_warning_trip" */
  update_driver_warning_trip_by_pk: Maybe<Driver_Warning_Trip>;
  /** update multiples rows of table: "driver_warning_trip" */
  update_driver_warning_trip_many: Maybe<Array<Maybe<Driver_Warning_Trip_Mutation_Response>>>;
  /** update data of the table: "driver_warning_trip_point" */
  update_driver_warning_trip_point: Maybe<Driver_Warning_Trip_Point_Mutation_Response>;
  /** update single row of the table: "driver_warning_trip_point" */
  update_driver_warning_trip_point_by_pk: Maybe<Driver_Warning_Trip_Point>;
  /** update multiples rows of table: "driver_warning_trip_point" */
  update_driver_warning_trip_point_many: Maybe<Array<Maybe<Driver_Warning_Trip_Point_Mutation_Response>>>;
  /** update data of the table: "driver_warning_trip_severity" */
  update_driver_warning_trip_severity: Maybe<Driver_Warning_Trip_Severity_Mutation_Response>;
  /** update single row of the table: "driver_warning_trip_severity" */
  update_driver_warning_trip_severity_by_pk: Maybe<Driver_Warning_Trip_Severity>;
  /** update multiples rows of table: "driver_warning_trip_severity" */
  update_driver_warning_trip_severity_many: Maybe<Array<Maybe<Driver_Warning_Trip_Severity_Mutation_Response>>>;
  /** update data of the table: "edi.busca_nfe_job" */
  update_edi_busca_nfe_job: Maybe<Edi_Busca_Nfe_Job_Mutation_Response>;
  /** update single row of the table: "edi.busca_nfe_job" */
  update_edi_busca_nfe_job_by_pk: Maybe<Edi_Busca_Nfe_Job>;
  /** update multiples rows of table: "edi.busca_nfe_job" */
  update_edi_busca_nfe_job_many: Maybe<Array<Maybe<Edi_Busca_Nfe_Job_Mutation_Response>>>;
  /** update data of the table: "edi.busca_nfe_response" */
  update_edi_busca_nfe_response: Maybe<Edi_Busca_Nfe_Response_Mutation_Response>;
  /** update single row of the table: "edi.busca_nfe_response" */
  update_edi_busca_nfe_response_by_pk: Maybe<Edi_Busca_Nfe_Response>;
  /** update multiples rows of table: "edi.busca_nfe_response" */
  update_edi_busca_nfe_response_many: Maybe<Array<Maybe<Edi_Busca_Nfe_Response_Mutation_Response>>>;
  /** update data of the table: "empty_tables.critical_segment_from_critical_point" */
  update_empty_tables_critical_segment_from_critical_point: Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Mutation_Response>;
  /** update multiples rows of table: "empty_tables.critical_segment_from_critical_point" */
  update_empty_tables_critical_segment_from_critical_point_many: Maybe<Array<Maybe<Empty_Tables_Critical_Segment_From_Critical_Point_Mutation_Response>>>;
  /** update data of the table: "empty_tables.driver_performance_data" */
  update_empty_tables_driver_performance_data: Maybe<Empty_Tables_Driver_Performance_Data_Mutation_Response>;
  /** update multiples rows of table: "empty_tables.driver_performance_data" */
  update_empty_tables_driver_performance_data_many: Maybe<Array<Maybe<Empty_Tables_Driver_Performance_Data_Mutation_Response>>>;
  /** update data of the table: "empty_tables.fleet_performance_data" */
  update_empty_tables_fleet_performance_data: Maybe<Empty_Tables_Fleet_Performance_Data_Mutation_Response>;
  /** update single row of the table: "empty_tables.fleet_performance_data" */
  update_empty_tables_fleet_performance_data_by_pk: Maybe<Empty_Tables_Fleet_Performance_Data>;
  /** update multiples rows of table: "empty_tables.fleet_performance_data" */
  update_empty_tables_fleet_performance_data_many: Maybe<Array<Maybe<Empty_Tables_Fleet_Performance_Data_Mutation_Response>>>;
  /** update data of the table: "empty_tables.geojson_trip" */
  update_empty_tables_geojson_trip: Maybe<Empty_Tables_Geojson_Trip_Mutation_Response>;
  /** update single row of the table: "empty_tables.geojson_trip" */
  update_empty_tables_geojson_trip_by_pk: Maybe<Empty_Tables_Geojson_Trip>;
  /** update multiples rows of table: "empty_tables.geojson_trip" */
  update_empty_tables_geojson_trip_many: Maybe<Array<Maybe<Empty_Tables_Geojson_Trip_Mutation_Response>>>;
  /** update data of the table: "empty_tables.instructor_drivers_performance_history" */
  update_empty_tables_instructor_drivers_performance_history: Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Mutation_Response>;
  /** update multiples rows of table: "empty_tables.instructor_drivers_performance_history" */
  update_empty_tables_instructor_drivers_performance_history_many: Maybe<Array<Maybe<Empty_Tables_Instructor_Drivers_Performance_History_Mutation_Response>>>;
  /** update data of the table: "fidelity_range_points" */
  update_fidelity_range_points: Maybe<Fidelity_Range_Points_Mutation_Response>;
  /** update single row of the table: "fidelity_range_points" */
  update_fidelity_range_points_by_pk: Maybe<Fidelity_Range_Points>;
  /** update multiples rows of table: "fidelity_range_points" */
  update_fidelity_range_points_many: Maybe<Array<Maybe<Fidelity_Range_Points_Mutation_Response>>>;
  /** update data of the table: "fipe.price" */
  update_fipe_price: Maybe<Fipe_Price_Mutation_Response>;
  /** update single row of the table: "fipe.price" */
  update_fipe_price_by_pk: Maybe<Fipe_Price>;
  /** update multiples rows of table: "fipe.price" */
  update_fipe_price_many: Maybe<Array<Maybe<Fipe_Price_Mutation_Response>>>;
  /** update data of the table: "fipe.reference_month" */
  update_fipe_reference_month: Maybe<Fipe_Reference_Month_Mutation_Response>;
  /** update single row of the table: "fipe.reference_month" */
  update_fipe_reference_month_by_pk: Maybe<Fipe_Reference_Month>;
  /** update multiples rows of table: "fipe.reference_month" */
  update_fipe_reference_month_many: Maybe<Array<Maybe<Fipe_Reference_Month_Mutation_Response>>>;
  /** update data of the table: "fipe.selected_vehicle" */
  update_fipe_selected_vehicle: Maybe<Fipe_Selected_Vehicle_Mutation_Response>;
  /** update single row of the table: "fipe.selected_vehicle" */
  update_fipe_selected_vehicle_by_pk: Maybe<Fipe_Selected_Vehicle>;
  /** update multiples rows of table: "fipe.selected_vehicle" */
  update_fipe_selected_vehicle_many: Maybe<Array<Maybe<Fipe_Selected_Vehicle_Mutation_Response>>>;
  /** update data of the table: "fipe.vehicle" */
  update_fipe_vehicle: Maybe<Fipe_Vehicle_Mutation_Response>;
  /** update single row of the table: "fipe.vehicle" */
  update_fipe_vehicle_by_pk: Maybe<Fipe_Vehicle>;
  /** update multiples rows of table: "fipe.vehicle" */
  update_fipe_vehicle_many: Maybe<Array<Maybe<Fipe_Vehicle_Mutation_Response>>>;
  /** update data of the table: "inspection" */
  update_inspection: Maybe<Inspection_Mutation_Response>;
  /** update data of the table: "inspection_analysis_parameter" */
  update_inspection_analysis_parameter: Maybe<Inspection_Analysis_Parameter_Mutation_Response>;
  /** update single row of the table: "inspection_analysis_parameter" */
  update_inspection_analysis_parameter_by_pk: Maybe<Inspection_Analysis_Parameter>;
  /** update multiples rows of table: "inspection_analysis_parameter" */
  update_inspection_analysis_parameter_many: Maybe<Array<Maybe<Inspection_Analysis_Parameter_Mutation_Response>>>;
  /** update single row of the table: "inspection" */
  update_inspection_by_pk: Maybe<Inspection>;
  /** update data of the table: "inspection_fk_tire" */
  update_inspection_fk_tire: Maybe<Inspection_Fk_Tire_Mutation_Response>;
  /** update single row of the table: "inspection_fk_tire" */
  update_inspection_fk_tire_by_pk: Maybe<Inspection_Fk_Tire>;
  /** update multiples rows of table: "inspection_fk_tire" */
  update_inspection_fk_tire_many: Maybe<Array<Maybe<Inspection_Fk_Tire_Mutation_Response>>>;
  /** update multiples rows of table: "inspection" */
  update_inspection_many: Maybe<Array<Maybe<Inspection_Mutation_Response>>>;
  /** update data of the table: "instructor_supervision" */
  update_instructor_supervision: Maybe<Instructor_Supervision_Mutation_Response>;
  /** update single row of the table: "instructor_supervision" */
  update_instructor_supervision_by_pk: Maybe<Instructor_Supervision>;
  /** update multiples rows of table: "instructor_supervision" */
  update_instructor_supervision_many: Maybe<Array<Maybe<Instructor_Supervision_Mutation_Response>>>;
  /** update data of the table: "instructor_supervision_observation" */
  update_instructor_supervision_observation: Maybe<Instructor_Supervision_Observation_Mutation_Response>;
  /** update single row of the table: "instructor_supervision_observation" */
  update_instructor_supervision_observation_by_pk: Maybe<Instructor_Supervision_Observation>;
  /** update multiples rows of table: "instructor_supervision_observation" */
  update_instructor_supervision_observation_many: Maybe<Array<Maybe<Instructor_Supervision_Observation_Mutation_Response>>>;
  /** update data of the table: "level" */
  update_level: Maybe<Level_Mutation_Response>;
  /** update single row of the table: "level" */
  update_level_by_pk: Maybe<Level>;
  /** update multiples rows of table: "level" */
  update_level_many: Maybe<Array<Maybe<Level_Mutation_Response>>>;
  /** update data of the table: "level_option" */
  update_level_option: Maybe<Level_Option_Mutation_Response>;
  /** update single row of the table: "level_option" */
  update_level_option_by_pk: Maybe<Level_Option>;
  /** update multiples rows of table: "level_option" */
  update_level_option_many: Maybe<Array<Maybe<Level_Option_Mutation_Response>>>;
  /** update data of the table: "module" */
  update_module: Maybe<Module_Mutation_Response>;
  /** update single row of the table: "module" */
  update_module_by_pk: Maybe<Module>;
  /** update multiples rows of table: "module" */
  update_module_many: Maybe<Array<Maybe<Module_Mutation_Response>>>;
  /** update data of the table: "module_permission" */
  update_module_permission: Maybe<Module_Permission_Mutation_Response>;
  /** update single row of the table: "module_permission" */
  update_module_permission_by_pk: Maybe<Module_Permission>;
  /** update multiples rows of table: "module_permission" */
  update_module_permission_many: Maybe<Array<Maybe<Module_Permission_Mutation_Response>>>;
  /** update data of the table: "note" */
  update_note: Maybe<Note_Mutation_Response>;
  /** update single row of the table: "note" */
  update_note_by_pk: Maybe<Note>;
  /** update multiples rows of table: "note" */
  update_note_many: Maybe<Array<Maybe<Note_Mutation_Response>>>;
  /** update data of the table: "notification" */
  update_notification: Maybe<Notification_Mutation_Response>;
  /** update single row of the table: "notification" */
  update_notification_by_pk: Maybe<Notification>;
  /** update multiples rows of table: "notification" */
  update_notification_many: Maybe<Array<Maybe<Notification_Mutation_Response>>>;
  /** update data of the table: "planet_osm_line" */
  update_planet_osm_line: Maybe<Planet_Osm_Line_Mutation_Response>;
  /** update multiples rows of table: "planet_osm_line" */
  update_planet_osm_line_many: Maybe<Array<Maybe<Planet_Osm_Line_Mutation_Response>>>;
  /** update data of the table: "product" */
  update_product: Maybe<Product_Mutation_Response>;
  /** update single row of the table: "product" */
  update_product_by_pk: Maybe<Product>;
  /** update multiples rows of table: "product" */
  update_product_many: Maybe<Array<Maybe<Product_Mutation_Response>>>;
  /** update data of the table: "product_price" */
  update_product_price: Maybe<Product_Price_Mutation_Response>;
  /** update single row of the table: "product_price" */
  update_product_price_by_pk: Maybe<Product_Price>;
  /** update multiples rows of table: "product_price" */
  update_product_price_many: Maybe<Array<Maybe<Product_Price_Mutation_Response>>>;
  /** update data of the table: "product_request" */
  update_product_request: Maybe<Product_Request_Mutation_Response>;
  /** update single row of the table: "product_request" */
  update_product_request_by_pk: Maybe<Product_Request>;
  /** update multiples rows of table: "product_request" */
  update_product_request_many: Maybe<Array<Maybe<Product_Request_Mutation_Response>>>;
  /** update data of the table: "profile" */
  update_profile: Maybe<Profile_Mutation_Response>;
  /** update single row of the table: "profile" */
  update_profile_by_pk: Maybe<Profile>;
  /** update multiples rows of table: "profile" */
  update_profile_many: Maybe<Array<Maybe<Profile_Mutation_Response>>>;
  /** update data of the table: "profile_permission" */
  update_profile_permission: Maybe<Profile_Permission_Mutation_Response>;
  /** update single row of the table: "profile_permission" */
  update_profile_permission_by_pk: Maybe<Profile_Permission>;
  /** update multiples rows of table: "profile_permission" */
  update_profile_permission_many: Maybe<Array<Maybe<Profile_Permission_Mutation_Response>>>;
  /** update data of the table: "refresh_token" */
  update_refresh_token: Maybe<Refresh_Token_Mutation_Response>;
  /** update single row of the table: "refresh_token" */
  update_refresh_token_by_pk: Maybe<Refresh_Token>;
  /** update multiples rows of table: "refresh_token" */
  update_refresh_token_many: Maybe<Array<Maybe<Refresh_Token_Mutation_Response>>>;
  /** update data of the table: "score_processed" */
  update_score_processed: Maybe<Score_Processed_Mutation_Response>;
  /** update single row of the table: "score_processed" */
  update_score_processed_by_pk: Maybe<Score_Processed>;
  /** update multiples rows of table: "score_processed" */
  update_score_processed_many: Maybe<Array<Maybe<Score_Processed_Mutation_Response>>>;
  /** update data of the table: "score_type" */
  update_score_type: Maybe<Score_Type_Mutation_Response>;
  /** update single row of the table: "score_type" */
  update_score_type_by_pk: Maybe<Score_Type>;
  /** update multiples rows of table: "score_type" */
  update_score_type_many: Maybe<Array<Maybe<Score_Type_Mutation_Response>>>;
  /** update data of the table: "status_truck_hardware" */
  update_status_truck_hardware: Maybe<Status_Truck_Hardware_Mutation_Response>;
  /** update single row of the table: "status_truck_hardware" */
  update_status_truck_hardware_by_pk: Maybe<Status_Truck_Hardware>;
  /** execute VOLATILE function "update_status_truck_hardware_by_vehicle_plates" which returns "status_truck_hardware" */
  update_status_truck_hardware_by_vehicle_plates: Array<Status_Truck_Hardware>;
  /** update multiples rows of table: "status_truck_hardware" */
  update_status_truck_hardware_many: Maybe<Array<Maybe<Status_Truck_Hardware_Mutation_Response>>>;
  /** update data of the table: "tire" */
  update_tire: Maybe<Tire_Mutation_Response>;
  /** update single row of the table: "tire" */
  update_tire_by_pk: Maybe<Tire>;
  /** update data of the table: "tire.inspection" */
  update_tire_inspection: Maybe<Tire_Inspection_Mutation_Response>;
  /** update single row of the table: "tire.inspection" */
  update_tire_inspection_by_pk: Maybe<Tire_Inspection>;
  /** update data of the table: "tire.inspection_fk_tire" */
  update_tire_inspection_fk_tire: Maybe<Tire_Inspection_Fk_Tire_Mutation_Response>;
  /** update single row of the table: "tire.inspection_fk_tire" */
  update_tire_inspection_fk_tire_by_pk: Maybe<Tire_Inspection_Fk_Tire>;
  /** update multiples rows of table: "tire.inspection_fk_tire" */
  update_tire_inspection_fk_tire_many: Maybe<Array<Maybe<Tire_Inspection_Fk_Tire_Mutation_Response>>>;
  /** update multiples rows of table: "tire.inspection" */
  update_tire_inspection_many: Maybe<Array<Maybe<Tire_Inspection_Mutation_Response>>>;
  /** update data of the table: "tire.inspection_note" */
  update_tire_inspection_note: Maybe<Tire_Inspection_Note_Mutation_Response>;
  /** update data of the table: "tire.inspection_note_attachment" */
  update_tire_inspection_note_attachment: Maybe<Tire_Inspection_Note_Attachment_Mutation_Response>;
  /** update single row of the table: "tire.inspection_note_attachment" */
  update_tire_inspection_note_attachment_by_pk: Maybe<Tire_Inspection_Note_Attachment>;
  /** update multiples rows of table: "tire.inspection_note_attachment" */
  update_tire_inspection_note_attachment_many: Maybe<Array<Maybe<Tire_Inspection_Note_Attachment_Mutation_Response>>>;
  /** update single row of the table: "tire.inspection_note" */
  update_tire_inspection_note_by_pk: Maybe<Tire_Inspection_Note>;
  /** update multiples rows of table: "tire.inspection_note" */
  update_tire_inspection_note_many: Maybe<Array<Maybe<Tire_Inspection_Note_Mutation_Response>>>;
  /** update data of the table: "tire.inspection_origin" */
  update_tire_inspection_origin: Maybe<Tire_Inspection_Origin_Mutation_Response>;
  /** update single row of the table: "tire.inspection_origin" */
  update_tire_inspection_origin_by_pk: Maybe<Tire_Inspection_Origin>;
  /** update multiples rows of table: "tire.inspection_origin" */
  update_tire_inspection_origin_many: Maybe<Array<Maybe<Tire_Inspection_Origin_Mutation_Response>>>;
  /** update multiples rows of table: "tire" */
  update_tire_many: Maybe<Array<Maybe<Tire_Mutation_Response>>>;
  /** update data of the table: "tire.note_type" */
  update_tire_note_type: Maybe<Tire_Note_Type_Mutation_Response>;
  /** update single row of the table: "tire.note_type" */
  update_tire_note_type_by_pk: Maybe<Tire_Note_Type>;
  /** update multiples rows of table: "tire.note_type" */
  update_tire_note_type_many: Maybe<Array<Maybe<Tire_Note_Type_Mutation_Response>>>;
  /** update data of the table: "tire.parameter" */
  update_tire_parameter: Maybe<Tire_Parameter_Mutation_Response>;
  /** update single row of the table: "tire.parameter" */
  update_tire_parameter_by_pk: Maybe<Tire_Parameter>;
  /** update multiples rows of table: "tire.parameter" */
  update_tire_parameter_many: Maybe<Array<Maybe<Tire_Parameter_Mutation_Response>>>;
  /** update data of the table: "tire_processing_history" */
  update_tire_processing_history: Maybe<Tire_Processing_History_Mutation_Response>;
  /** update single row of the table: "tire_processing_history" */
  update_tire_processing_history_by_pk: Maybe<Tire_Processing_History>;
  /** update multiples rows of table: "tire_processing_history" */
  update_tire_processing_history_many: Maybe<Array<Maybe<Tire_Processing_History_Mutation_Response>>>;
  /** update data of the table: "tirecheck_inconsistency" */
  update_tirecheck_inconsistency: Maybe<Tirecheck_Inconsistency_Mutation_Response>;
  /** update single row of the table: "tirecheck_inconsistency" */
  update_tirecheck_inconsistency_by_pk: Maybe<Tirecheck_Inconsistency>;
  /** update multiples rows of table: "tirecheck_inconsistency" */
  update_tirecheck_inconsistency_many: Maybe<Array<Maybe<Tirecheck_Inconsistency_Mutation_Response>>>;
  /** update data of the table: "training" */
  update_training: Maybe<Training_Mutation_Response>;
  /** update single row of the table: "training" */
  update_training_by_pk: Maybe<Training>;
  /** update data of the table: "training_document" */
  update_training_document: Maybe<Training_Document_Mutation_Response>;
  /** update single row of the table: "training_document" */
  update_training_document_by_pk: Maybe<Training_Document>;
  /** update multiples rows of table: "training_document" */
  update_training_document_many: Maybe<Array<Maybe<Training_Document_Mutation_Response>>>;
  /** update data of the table: "training_document_view" */
  update_training_document_view: Maybe<Training_Document_View_Mutation_Response>;
  /** update single row of the table: "training_document_view" */
  update_training_document_view_by_pk: Maybe<Training_Document_View>;
  /** update multiples rows of table: "training_document_view" */
  update_training_document_view_many: Maybe<Array<Maybe<Training_Document_View_Mutation_Response>>>;
  /** update multiples rows of table: "training" */
  update_training_many: Maybe<Array<Maybe<Training_Mutation_Response>>>;
  /** update data of the table: "user" */
  update_user: Maybe<User_Mutation_Response>;
  /** update single row of the table: "user" */
  update_user_by_pk: Maybe<User>;
  /** update data of the table: "user_fk_achievement" */
  update_user_fk_achievement: Maybe<User_Fk_Achievement_Mutation_Response>;
  /** update single row of the table: "user_fk_achievement" */
  update_user_fk_achievement_by_pk: Maybe<User_Fk_Achievement>;
  /** update multiples rows of table: "user_fk_achievement" */
  update_user_fk_achievement_many: Maybe<Array<Maybe<User_Fk_Achievement_Mutation_Response>>>;
  /** update data of the table: "user_fk_challenge" */
  update_user_fk_challenge: Maybe<User_Fk_Challenge_Mutation_Response>;
  /** update single row of the table: "user_fk_challenge" */
  update_user_fk_challenge_by_pk: Maybe<User_Fk_Challenge>;
  /** update multiples rows of table: "user_fk_challenge" */
  update_user_fk_challenge_many: Maybe<Array<Maybe<User_Fk_Challenge_Mutation_Response>>>;
  /** update data of the table: "user_fk_level" */
  update_user_fk_level: Maybe<User_Fk_Level_Mutation_Response>;
  /** update single row of the table: "user_fk_level" */
  update_user_fk_level_by_pk: Maybe<User_Fk_Level>;
  /** update multiples rows of table: "user_fk_level" */
  update_user_fk_level_many: Maybe<Array<Maybe<User_Fk_Level_Mutation_Response>>>;
  /** update data of the table: "user_fk_notification" */
  update_user_fk_notification: Maybe<User_Fk_Notification_Mutation_Response>;
  /** update single row of the table: "user_fk_notification" */
  update_user_fk_notification_by_pk: Maybe<User_Fk_Notification>;
  /** update multiples rows of table: "user_fk_notification" */
  update_user_fk_notification_many: Maybe<Array<Maybe<User_Fk_Notification_Mutation_Response>>>;
  /** update data of the table: "user_fk_privacy_policy" */
  update_user_fk_privacy_policy: Maybe<User_Fk_Privacy_Policy_Mutation_Response>;
  /** update single row of the table: "user_fk_privacy_policy" */
  update_user_fk_privacy_policy_by_pk: Maybe<User_Fk_Privacy_Policy>;
  /** update multiples rows of table: "user_fk_privacy_policy" */
  update_user_fk_privacy_policy_many: Maybe<Array<Maybe<User_Fk_Privacy_Policy_Mutation_Response>>>;
  /** update data of the table: "user_km_points_approval" */
  update_user_km_points_approval: Maybe<User_Km_Points_Approval_Mutation_Response>;
  /** update single row of the table: "user_km_points_approval" */
  update_user_km_points_approval_by_pk: Maybe<User_Km_Points_Approval>;
  /** update multiples rows of table: "user_km_points_approval" */
  update_user_km_points_approval_many: Maybe<Array<Maybe<User_Km_Points_Approval_Mutation_Response>>>;
  /** update data of the table: "user_kmps" */
  update_user_kmps: Maybe<User_Kmps_Mutation_Response>;
  /** update single row of the table: "user_kmps" */
  update_user_kmps_by_pk: Maybe<User_Kmps>;
  /** update multiples rows of table: "user_kmps" */
  update_user_kmps_many: Maybe<Array<Maybe<User_Kmps_Mutation_Response>>>;
  /** update multiples rows of table: "user" */
  update_user_many: Maybe<Array<Maybe<User_Mutation_Response>>>;
  /** update data of the table: "user_score" */
  update_user_score: Maybe<User_Score_Mutation_Response>;
  /** update single row of the table: "user_score" */
  update_user_score_by_pk: Maybe<User_Score>;
  /** update multiples rows of table: "user_score" */
  update_user_score_many: Maybe<Array<Maybe<User_Score_Mutation_Response>>>;
  /** update data of the table: "user_training" */
  update_user_training: Maybe<User_Training_Mutation_Response>;
  /** update single row of the table: "user_training" */
  update_user_training_by_pk: Maybe<User_Training>;
  /** update multiples rows of table: "user_training" */
  update_user_training_many: Maybe<Array<Maybe<User_Training_Mutation_Response>>>;
  /** update data of the table: "vehicle" */
  update_vehicle: Maybe<Vehicle_Mutation_Response>;
  /** update single row of the table: "vehicle" */
  update_vehicle_by_pk: Maybe<Vehicle>;
  /** update multiples rows of table: "vehicle" */
  update_vehicle_many: Maybe<Array<Maybe<Vehicle_Mutation_Response>>>;
  /** update data of the table: "whatsapp_event" */
  update_whatsapp_event: Maybe<Whatsapp_Event_Mutation_Response>;
  /** update single row of the table: "whatsapp_event" */
  update_whatsapp_event_by_pk: Maybe<Whatsapp_Event>;
  /** update multiples rows of table: "whatsapp_event" */
  update_whatsapp_event_many: Maybe<Array<Maybe<Whatsapp_Event_Mutation_Response>>>;
  /** update data of the table: "whatsapp_message" */
  update_whatsapp_message: Maybe<Whatsapp_Message_Mutation_Response>;
  /** update single row of the table: "whatsapp_message" */
  update_whatsapp_message_by_pk: Maybe<Whatsapp_Message>;
  /** update data of the table: "whatsapp_message_history" */
  update_whatsapp_message_history: Maybe<Whatsapp_Message_History_Mutation_Response>;
  /** update single row of the table: "whatsapp_message_history" */
  update_whatsapp_message_history_by_pk: Maybe<Whatsapp_Message_History>;
  /** update multiples rows of table: "whatsapp_message_history" */
  update_whatsapp_message_history_many: Maybe<Array<Maybe<Whatsapp_Message_History_Mutation_Response>>>;
  /** update multiples rows of table: "whatsapp_message" */
  update_whatsapp_message_many: Maybe<Array<Maybe<Whatsapp_Message_Mutation_Response>>>;
  /** update data of the table: "whatsapp_trigger" */
  update_whatsapp_trigger: Maybe<Whatsapp_Trigger_Mutation_Response>;
  /** update single row of the table: "whatsapp_trigger" */
  update_whatsapp_trigger_by_pk: Maybe<Whatsapp_Trigger>;
  /** update multiples rows of table: "whatsapp_trigger" */
  update_whatsapp_trigger_many: Maybe<Array<Maybe<Whatsapp_Trigger_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootBuy_ProductArgs = {
  args: Buy_Product_Args;
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootCancel_Product_RequestArgs = {
  args: Cancel_Product_Request_Args;
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootChange_Admin_EnabledArgs = {
  args: Change_Admin_Enabled_Args;
  distinct_on?: InputMaybe<Array<Admin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Order_By>>;
  where?: InputMaybe<Admin_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootChange_Admin_PasswordArgs = {
  admin_uuid: Scalars['uuid']['input'];
  new_password: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootChange_Driver_EnabledArgs = {
  args: Change_Driver_Enabled_Args;
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootChange_Driver_PasswordArgs = {
  new_password: Scalars['String']['input'];
  user_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootConsume_Whatsapp_EventArgs = {
  args: Consume_Whatsapp_Event_Args;
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootDelete_CurrentTiresByVehicleArgs = {
  where: CurrentTiresByVehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ParametroAlertaConducaoArgs = {
  where: ParametroAlertaConducao_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ParametroAlertaConducao_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PerformanceParameterArgs = {
  where: PerformanceParameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PerformanceParameter_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PontosRastroArgs = {
  where: PontosRastro_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PontosRastro_By_PkArgs = {
  PontoRastroId: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ScoreParameterArgs = {
  where: ScoreParameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ScoreParameter_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ScoreTypeArgs = {
  where: ScoreType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ScoreType_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SuntechEquipamentoArgs = {
  where: SuntechEquipamento_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerBatchCommandArgs = {
  where: SuntechTrackerBatchCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerBatchCommandDeviceArgs = {
  where: SuntechTrackerBatchCommandDevice_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerBatchCommandDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerBatchCommandPresetArgs = {
  where: SuntechTrackerBatchCommandPreset_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerBatchCommandPreset_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerBatchCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerCommandArgs = {
  where: SuntechTrackerCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_SuntechTrackerCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerBatchCommandArgs = {
  where: VirlocTrackerBatchCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerBatchCommandDeviceArgs = {
  where: VirlocTrackerBatchCommandDevice_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerBatchCommandDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerBatchCommandPresetArgs = {
  where: VirlocTrackerBatchCommandPreset_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerBatchCommandPreset_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerBatchCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerCommandArgs = {
  where: VirlocTrackerCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerDeviceArgs = {
  where: VirlocTrackerDevice_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_VirlocTrackerDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AchievementArgs = {
  where: Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Achievement_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AdminArgs = {
  where: Admin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Admin_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Admin_Fk_NotificationsArgs = {
  where: Admin_Fk_Notifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Admin_Fk_Notifications_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  notification_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Admin_Fk_ProfileArgs = {
  where: Admin_Fk_Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Admin_Fk_Profile_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  created_at: Scalars['timestamptz']['input'];
  profile_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Admin_PermissionArgs = {
  where: Admin_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Admin_Permission_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AutoArgs = {
  where: Auto_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auto_By_PkArgs = {
  placa: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_DashboardArgs = {
  where: Bi_Dashboard_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Dashboard_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_Dashboard_ItemArgs = {
  where: Bi_Dashboard_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Dashboard_Item_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_Dashboard_Item_TypeArgs = {
  where: Bi_Dashboard_Item_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Dashboard_Item_Type_By_PkArgs = {
  type: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_DatasourceArgs = {
  where: Bi_Datasource_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Datasource_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_Datasource_TypeArgs = {
  where: Bi_Datasource_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Datasource_Type_By_PkArgs = {
  type: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_PermissionArgs = {
  where: Bi_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Permission_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_Permission_ModuleArgs = {
  where: Bi_Permission_Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Permission_Module_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_Public_LinkArgs = {
  where: Bi_Public_Link_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Public_Link_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_QueryArgs = {
  where: Bi_Query_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Query_AnalyticsArgs = {
  where: Bi_Query_Analytics_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Query_Analytics_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_Query_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_Query_CacheArgs = {
  where: Bi_Query_Cache_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Query_Cache_By_PkArgs = {
  dashboard_uuid: Scalars['uuid']['input'];
  params_hash: Scalars['String']['input'];
  query_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_SubqueryArgs = {
  where: Bi_Subquery_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_Subquery_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Bi_User_PermissionArgs = {
  where: Bi_User_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bi_User_Permission_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ChallengeArgs = {
  where: Challenge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Challenge_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Challenge_TypeArgs = {
  where: Challenge_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Challenge_Type_By_PkArgs = {
  name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ConfigArgs = {
  where: Config_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Config_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Critical_PointArgs = {
  where: Critical_Point_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Critical_Point_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Critical_SegmentArgs = {
  where: Critical_Segment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Critical_Segment_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Cte_Nf_LockArgs = {
  where: Cte_Nf_Lock_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Cte_Nf_Lock_By_PkArgs = {
  nf: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Deleted_RowArgs = {
  where: Deleted_Row_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Deleted_Row_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DeliveryArgs = {
  where: Delivery_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Delivery_By_PkArgs = {
  document_number: Scalars['String']['input'];
  invoice_number: Scalars['String']['input'];
  trip_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Driver_WarningArgs = {
  where: Driver_Warning_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_CommentArgs = {
  where: Driver_Warning_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Comment_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Fk_Whatsapp_MessageArgs = {
  where: Driver_Warning_Fk_Whatsapp_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Fk_Whatsapp_Message_By_PkArgs = {
  driver_warning_uuid: Scalars['uuid']['input'];
  whatsapp_message_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Risk_LevelArgs = {
  where: Driver_Warning_Risk_Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Risk_Level_By_PkArgs = {
  level_name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_TripArgs = {
  where: Driver_Warning_Trip_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Trip_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Trip_PointArgs = {
  where: Driver_Warning_Trip_Point_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Trip_Point_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Trip_SeverityArgs = {
  where: Driver_Warning_Trip_Severity_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driver_Warning_Trip_Severity_By_PkArgs = {
  severity_level: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Edi_Busca_Nfe_JobArgs = {
  where: Edi_Busca_Nfe_Job_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Edi_Busca_Nfe_Job_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Edi_Busca_Nfe_ResponseArgs = {
  where: Edi_Busca_Nfe_Response_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Edi_Busca_Nfe_Response_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Empty_Tables_Critical_Segment_From_Critical_PointArgs = {
  where: Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Empty_Tables_Driver_Performance_DataArgs = {
  where: Empty_Tables_Driver_Performance_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Empty_Tables_Fleet_Performance_DataArgs = {
  where: Empty_Tables_Fleet_Performance_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Empty_Tables_Fleet_Performance_Data_By_PkArgs = {
  brake_use_avg: Scalars['Int']['input'];
  economic_range_avg: Scalars['Int']['input'];
  engine_load_avg: Scalars['Int']['input'];
  inertia_avg: Scalars['Int']['input'];
  note_avg: Scalars['Int']['input'];
  slow_running_avg: Scalars['Int']['input'];
  speed_control_avg: Scalars['Int']['input'];
  total_count: Scalars['Int']['input'];
  total_drivers: Scalars['Int']['input'];
  total_km: Scalars['float8']['input'];
  total_km_avg: Scalars['float8']['input'];
  total_periods: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Empty_Tables_Geojson_TripArgs = {
  where: Empty_Tables_Geojson_Trip_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Empty_Tables_Geojson_Trip_By_PkArgs = {
  trip_id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Empty_Tables_Instructor_Drivers_Performance_HistoryArgs = {
  where: Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fidelity_Range_PointsArgs = {
  where: Fidelity_Range_Points_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fidelity_Range_Points_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Fipe_PriceArgs = {
  where: Fipe_Price_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fipe_Price_By_PkArgs = {
  reference_table_date: Scalars['date']['input'];
  vehicle_fipe_code: Scalars['String']['input'];
  vehicle_model_year: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Fipe_Reference_MonthArgs = {
  where: Fipe_Reference_Month_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fipe_Reference_Month_By_PkArgs = {
  code: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Fipe_Selected_VehicleArgs = {
  where: Fipe_Selected_Vehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fipe_Selected_Vehicle_By_PkArgs = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Fipe_VehicleArgs = {
  where: Fipe_Vehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fipe_Vehicle_By_PkArgs = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_InspectionArgs = {
  where: Inspection_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Inspection_Analysis_ParameterArgs = {
  where: Inspection_Analysis_Parameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Inspection_Analysis_Parameter_By_PkArgs = {
  name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Inspection_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Inspection_Fk_TireArgs = {
  where: Inspection_Fk_Tire_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Inspection_Fk_Tire_By_PkArgs = {
  inspection_id: Scalars['String']['input'];
  tire_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Instructor_SupervisionArgs = {
  where: Instructor_Supervision_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Instructor_Supervision_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Instructor_Supervision_ObservationArgs = {
  where: Instructor_Supervision_Observation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Instructor_Supervision_Observation_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_LevelArgs = {
  where: Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Level_By_PkArgs = {
  number: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Level_OptionArgs = {
  where: Level_Option_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Level_Option_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ModuleArgs = {
  where: Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Module_By_PkArgs = {
  name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Module_PermissionArgs = {
  where: Module_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Module_Permission_By_PkArgs = {
  action: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_NoteArgs = {
  where: Note_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Note_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_NotificationArgs = {
  where: Notification_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Notification_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Planet_Osm_LineArgs = {
  where: Planet_Osm_Line_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ProductArgs = {
  where: Product_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Product_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Product_PriceArgs = {
  where: Product_Price_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Product_Price_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Product_RequestArgs = {
  where: Product_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Product_Request_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ProfileArgs = {
  where: Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Profile_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Profile_PermissionArgs = {
  where: Profile_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Profile_Permission_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Refresh_TokenArgs = {
  where: Refresh_Token_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Refresh_Token_By_PkArgs = {
  refresh_token: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Score_ProcessedArgs = {
  where: Score_Processed_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Score_Processed_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Score_TypeArgs = {
  where: Score_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Score_Type_By_PkArgs = {
  name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Status_Truck_HardwareArgs = {
  where: Status_Truck_Hardware_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Status_Truck_Hardware_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_TireArgs = {
  where: Tire_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_InspectionArgs = {
  where: Tire_Inspection_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_Fk_TireArgs = {
  where: Tire_Inspection_Fk_Tire_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_Fk_Tire_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_NoteArgs = {
  where: Tire_Inspection_Note_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_Note_AttachmentArgs = {
  where: Tire_Inspection_Note_Attachment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_Note_Attachment_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_Note_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_OriginArgs = {
  where: Tire_Inspection_Origin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Inspection_Origin_By_PkArgs = {
  origin: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_Note_TypeArgs = {
  where: Tire_Note_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Note_Type_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_ParameterArgs = {
  where: Tire_Parameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Parameter_By_PkArgs = {
  name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tire_Processing_HistoryArgs = {
  where: Tire_Processing_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tire_Processing_History_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Tirecheck_InconsistencyArgs = {
  where: Tirecheck_Inconsistency_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tirecheck_Inconsistency_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_TrainingArgs = {
  where: Training_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Training_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Training_DocumentArgs = {
  where: Training_Document_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Training_Document_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Training_Document_ViewArgs = {
  where: Training_Document_View_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Training_Document_View_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UserArgs = {
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_AchievementArgs = {
  where: User_Fk_Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_Achievement_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_ChallengeArgs = {
  where: User_Fk_Challenge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_Challenge_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_LevelArgs = {
  where: User_Fk_Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_Level_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_NotificationArgs = {
  where: User_Fk_Notification_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_Notification_By_PkArgs = {
  notification_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_Privacy_PolicyArgs = {
  where: User_Fk_Privacy_Policy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Fk_Privacy_Policy_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Km_Points_ApprovalArgs = {
  where: User_Km_Points_Approval_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Km_Points_Approval_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_KmpsArgs = {
  where: User_Kmps_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Kmps_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_ScoreArgs = {
  where: User_Score_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Score_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_TrainingArgs = {
  where: User_Training_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Training_By_PkArgs = {
  training_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VehicleArgs = {
  where: Vehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Vehicle_By_PkArgs = {
  plate: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_EventArgs = {
  where: Whatsapp_Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_Event_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_MessageArgs = {
  where: Whatsapp_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_Message_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_Message_HistoryArgs = {
  where: Whatsapp_Message_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_Message_History_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_TriggerArgs = {
  where: Whatsapp_Trigger_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Whatsapp_Trigger_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootGenerate_Missing_Score_ProcessedArgs = {
  distinct_on?: InputMaybe<Array<Score_Processed_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Processed_Order_By>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootInsert_CurrentTiresByVehicleArgs = {
  if_matched?: InputMaybe<CurrentTiresByVehicle_If_Matched>;
  objects: Array<CurrentTiresByVehicle_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_CurrentTiresByVehicle_OneArgs = {
  if_matched?: InputMaybe<CurrentTiresByVehicle_If_Matched>;
  object: CurrentTiresByVehicle_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_ParametroAlertaConducaoArgs = {
  if_matched?: InputMaybe<ParametroAlertaConducao_If_Matched>;
  objects: Array<ParametroAlertaConducao_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_ParametroAlertaConducao_OneArgs = {
  if_matched?: InputMaybe<ParametroAlertaConducao_If_Matched>;
  object: ParametroAlertaConducao_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_PerformanceParameterArgs = {
  if_matched?: InputMaybe<PerformanceParameter_If_Matched>;
  objects: Array<PerformanceParameter_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_PerformanceParameter_OneArgs = {
  if_matched?: InputMaybe<PerformanceParameter_If_Matched>;
  object: PerformanceParameter_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_PontosRastroArgs = {
  if_matched?: InputMaybe<PontosRastro_If_Matched>;
  objects: Array<PontosRastro_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_PontosRastro_OneArgs = {
  if_matched?: InputMaybe<PontosRastro_If_Matched>;
  object: PontosRastro_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_ScoreParameterArgs = {
  if_matched?: InputMaybe<ScoreParameter_If_Matched>;
  objects: Array<ScoreParameter_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_ScoreParameter_OneArgs = {
  if_matched?: InputMaybe<ScoreParameter_If_Matched>;
  object: ScoreParameter_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_ScoreTypeArgs = {
  if_matched?: InputMaybe<ScoreType_If_Matched>;
  objects: Array<ScoreType_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_ScoreType_OneArgs = {
  if_matched?: InputMaybe<ScoreType_If_Matched>;
  object: ScoreType_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_SuntechEquipamentoArgs = {
  if_matched?: InputMaybe<SuntechEquipamento_If_Matched>;
  objects: Array<SuntechEquipamento_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_SuntechEquipamento_OneArgs = {
  if_matched?: InputMaybe<SuntechEquipamento_If_Matched>;
  object: SuntechEquipamento_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerBatchCommandArgs = {
  if_matched?: InputMaybe<SuntechTrackerBatchCommand_If_Matched>;
  objects: Array<SuntechTrackerBatchCommand_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerBatchCommandDeviceArgs = {
  if_matched?: InputMaybe<SuntechTrackerBatchCommandDevice_If_Matched>;
  objects: Array<SuntechTrackerBatchCommandDevice_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerBatchCommandDevice_OneArgs = {
  if_matched?: InputMaybe<SuntechTrackerBatchCommandDevice_If_Matched>;
  object: SuntechTrackerBatchCommandDevice_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerBatchCommandPresetArgs = {
  if_matched?: InputMaybe<SuntechTrackerBatchCommandPreset_If_Matched>;
  objects: Array<SuntechTrackerBatchCommandPreset_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerBatchCommandPreset_OneArgs = {
  if_matched?: InputMaybe<SuntechTrackerBatchCommandPreset_If_Matched>;
  object: SuntechTrackerBatchCommandPreset_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerBatchCommand_OneArgs = {
  if_matched?: InputMaybe<SuntechTrackerBatchCommand_If_Matched>;
  object: SuntechTrackerBatchCommand_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerCommandArgs = {
  if_matched?: InputMaybe<SuntechTrackerCommand_If_Matched>;
  objects: Array<SuntechTrackerCommand_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_SuntechTrackerCommand_OneArgs = {
  if_matched?: InputMaybe<SuntechTrackerCommand_If_Matched>;
  object: SuntechTrackerCommand_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerBatchCommandArgs = {
  if_matched?: InputMaybe<VirlocTrackerBatchCommand_If_Matched>;
  objects: Array<VirlocTrackerBatchCommand_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerBatchCommandDeviceArgs = {
  if_matched?: InputMaybe<VirlocTrackerBatchCommandDevice_If_Matched>;
  objects: Array<VirlocTrackerBatchCommandDevice_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerBatchCommandDevice_OneArgs = {
  if_matched?: InputMaybe<VirlocTrackerBatchCommandDevice_If_Matched>;
  object: VirlocTrackerBatchCommandDevice_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerBatchCommandPresetArgs = {
  if_matched?: InputMaybe<VirlocTrackerBatchCommandPreset_If_Matched>;
  objects: Array<VirlocTrackerBatchCommandPreset_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerBatchCommandPreset_OneArgs = {
  if_matched?: InputMaybe<VirlocTrackerBatchCommandPreset_If_Matched>;
  object: VirlocTrackerBatchCommandPreset_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerBatchCommand_OneArgs = {
  if_matched?: InputMaybe<VirlocTrackerBatchCommand_If_Matched>;
  object: VirlocTrackerBatchCommand_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerCommandArgs = {
  if_matched?: InputMaybe<VirlocTrackerCommand_If_Matched>;
  objects: Array<VirlocTrackerCommand_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerCommand_OneArgs = {
  if_matched?: InputMaybe<VirlocTrackerCommand_If_Matched>;
  object: VirlocTrackerCommand_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerDeviceArgs = {
  if_matched?: InputMaybe<VirlocTrackerDevice_If_Matched>;
  objects: Array<VirlocTrackerDevice_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_VirlocTrackerDevice_OneArgs = {
  if_matched?: InputMaybe<VirlocTrackerDevice_If_Matched>;
  object: VirlocTrackerDevice_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_AchievementArgs = {
  objects: Array<Achievement_Insert_Input>;
  on_conflict?: InputMaybe<Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Achievement_OneArgs = {
  object: Achievement_Insert_Input;
  on_conflict?: InputMaybe<Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AdminArgs = {
  objects: Array<Admin_Insert_Input>;
  on_conflict?: InputMaybe<Admin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Admin_Fk_NotificationsArgs = {
  objects: Array<Admin_Fk_Notifications_Insert_Input>;
  on_conflict?: InputMaybe<Admin_Fk_Notifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Admin_Fk_Notifications_OneArgs = {
  object: Admin_Fk_Notifications_Insert_Input;
  on_conflict?: InputMaybe<Admin_Fk_Notifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Admin_Fk_ProfileArgs = {
  objects: Array<Admin_Fk_Profile_Insert_Input>;
  on_conflict?: InputMaybe<Admin_Fk_Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Admin_Fk_Profile_OneArgs = {
  object: Admin_Fk_Profile_Insert_Input;
  on_conflict?: InputMaybe<Admin_Fk_Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Admin_OneArgs = {
  object: Admin_Insert_Input;
  on_conflict?: InputMaybe<Admin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Admin_PermissionArgs = {
  objects: Array<Admin_Permission_Insert_Input>;
  on_conflict?: InputMaybe<Admin_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Admin_Permission_OneArgs = {
  object: Admin_Permission_Insert_Input;
  on_conflict?: InputMaybe<Admin_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AutoArgs = {
  if_matched?: InputMaybe<Auto_If_Matched>;
  objects: Array<Auto_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Auto_OneArgs = {
  if_matched?: InputMaybe<Auto_If_Matched>;
  object: Auto_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Bi_DashboardArgs = {
  objects: Array<Bi_Dashboard_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Dashboard_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Dashboard_ItemArgs = {
  objects: Array<Bi_Dashboard_Item_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Dashboard_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Dashboard_Item_OneArgs = {
  object: Bi_Dashboard_Item_Insert_Input;
  on_conflict?: InputMaybe<Bi_Dashboard_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Dashboard_Item_TypeArgs = {
  objects: Array<Bi_Dashboard_Item_Type_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Dashboard_Item_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Dashboard_Item_Type_OneArgs = {
  object: Bi_Dashboard_Item_Type_Insert_Input;
  on_conflict?: InputMaybe<Bi_Dashboard_Item_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Dashboard_OneArgs = {
  object: Bi_Dashboard_Insert_Input;
  on_conflict?: InputMaybe<Bi_Dashboard_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_DatasourceArgs = {
  objects: Array<Bi_Datasource_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Datasource_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Datasource_OneArgs = {
  object: Bi_Datasource_Insert_Input;
  on_conflict?: InputMaybe<Bi_Datasource_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Datasource_TypeArgs = {
  objects: Array<Bi_Datasource_Type_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Datasource_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Datasource_Type_OneArgs = {
  object: Bi_Datasource_Type_Insert_Input;
  on_conflict?: InputMaybe<Bi_Datasource_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_PermissionArgs = {
  objects: Array<Bi_Permission_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Permission_ModuleArgs = {
  objects: Array<Bi_Permission_Module_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Permission_Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Permission_Module_OneArgs = {
  object: Bi_Permission_Module_Insert_Input;
  on_conflict?: InputMaybe<Bi_Permission_Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Permission_OneArgs = {
  object: Bi_Permission_Insert_Input;
  on_conflict?: InputMaybe<Bi_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Public_LinkArgs = {
  objects: Array<Bi_Public_Link_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Public_Link_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Public_Link_OneArgs = {
  object: Bi_Public_Link_Insert_Input;
  on_conflict?: InputMaybe<Bi_Public_Link_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_QueryArgs = {
  objects: Array<Bi_Query_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Query_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Query_AnalyticsArgs = {
  objects: Array<Bi_Query_Analytics_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Query_Analytics_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Query_Analytics_OneArgs = {
  object: Bi_Query_Analytics_Insert_Input;
  on_conflict?: InputMaybe<Bi_Query_Analytics_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Query_CacheArgs = {
  objects: Array<Bi_Query_Cache_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Query_Cache_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Query_Cache_OneArgs = {
  object: Bi_Query_Cache_Insert_Input;
  on_conflict?: InputMaybe<Bi_Query_Cache_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Query_OneArgs = {
  object: Bi_Query_Insert_Input;
  on_conflict?: InputMaybe<Bi_Query_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_SubqueryArgs = {
  objects: Array<Bi_Subquery_Insert_Input>;
  on_conflict?: InputMaybe<Bi_Subquery_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_Subquery_OneArgs = {
  object: Bi_Subquery_Insert_Input;
  on_conflict?: InputMaybe<Bi_Subquery_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_User_PermissionArgs = {
  objects: Array<Bi_User_Permission_Insert_Input>;
  on_conflict?: InputMaybe<Bi_User_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bi_User_Permission_OneArgs = {
  object: Bi_User_Permission_Insert_Input;
  on_conflict?: InputMaybe<Bi_User_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ChallengeArgs = {
  objects: Array<Challenge_Insert_Input>;
  on_conflict?: InputMaybe<Challenge_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Challenge_OneArgs = {
  object: Challenge_Insert_Input;
  on_conflict?: InputMaybe<Challenge_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Challenge_TypeArgs = {
  objects: Array<Challenge_Type_Insert_Input>;
  on_conflict?: InputMaybe<Challenge_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Challenge_Type_OneArgs = {
  object: Challenge_Type_Insert_Input;
  on_conflict?: InputMaybe<Challenge_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConfigArgs = {
  objects: Array<Config_Insert_Input>;
  on_conflict?: InputMaybe<Config_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Config_OneArgs = {
  object: Config_Insert_Input;
  on_conflict?: InputMaybe<Config_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Critical_PointArgs = {
  objects: Array<Critical_Point_Insert_Input>;
  on_conflict?: InputMaybe<Critical_Point_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Critical_Point_OneArgs = {
  object: Critical_Point_Insert_Input;
  on_conflict?: InputMaybe<Critical_Point_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Critical_SegmentArgs = {
  objects: Array<Critical_Segment_Insert_Input>;
  on_conflict?: InputMaybe<Critical_Segment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Critical_Segment_OneArgs = {
  object: Critical_Segment_Insert_Input;
  on_conflict?: InputMaybe<Critical_Segment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cte_Nf_LockArgs = {
  objects: Array<Cte_Nf_Lock_Insert_Input>;
  on_conflict?: InputMaybe<Cte_Nf_Lock_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cte_Nf_Lock_OneArgs = {
  object: Cte_Nf_Lock_Insert_Input;
  on_conflict?: InputMaybe<Cte_Nf_Lock_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Deleted_RowArgs = {
  objects: Array<Deleted_Row_Insert_Input>;
  on_conflict?: InputMaybe<Deleted_Row_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Deleted_Row_OneArgs = {
  object: Deleted_Row_Insert_Input;
  on_conflict?: InputMaybe<Deleted_Row_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DeliveryArgs = {
  objects: Array<Delivery_Insert_Input>;
  on_conflict?: InputMaybe<Delivery_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Delivery_OneArgs = {
  object: Delivery_Insert_Input;
  on_conflict?: InputMaybe<Delivery_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_WarningArgs = {
  objects: Array<Driver_Warning_Insert_Input>;
  on_conflict?: InputMaybe<Driver_Warning_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_CommentArgs = {
  objects: Array<Driver_Warning_Comment_Insert_Input>;
  on_conflict?: InputMaybe<Driver_Warning_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Comment_OneArgs = {
  object: Driver_Warning_Comment_Insert_Input;
  on_conflict?: InputMaybe<Driver_Warning_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Fk_Whatsapp_MessageArgs = {
  objects: Array<Driver_Warning_Fk_Whatsapp_Message_Insert_Input>;
  on_conflict?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Fk_Whatsapp_Message_OneArgs = {
  object: Driver_Warning_Fk_Whatsapp_Message_Insert_Input;
  on_conflict?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_OneArgs = {
  object: Driver_Warning_Insert_Input;
  on_conflict?: InputMaybe<Driver_Warning_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Risk_LevelArgs = {
  objects: Array<Driver_Warning_Risk_Level_Insert_Input>;
  on_conflict?: InputMaybe<Driver_Warning_Risk_Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Risk_Level_OneArgs = {
  object: Driver_Warning_Risk_Level_Insert_Input;
  on_conflict?: InputMaybe<Driver_Warning_Risk_Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_TripArgs = {
  objects: Array<Driver_Warning_Trip_Insert_Input>;
  on_conflict?: InputMaybe<Driver_Warning_Trip_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Trip_OneArgs = {
  object: Driver_Warning_Trip_Insert_Input;
  on_conflict?: InputMaybe<Driver_Warning_Trip_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Trip_PointArgs = {
  objects: Array<Driver_Warning_Trip_Point_Insert_Input>;
  on_conflict?: InputMaybe<Driver_Warning_Trip_Point_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Trip_Point_OneArgs = {
  object: Driver_Warning_Trip_Point_Insert_Input;
  on_conflict?: InputMaybe<Driver_Warning_Trip_Point_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Trip_SeverityArgs = {
  objects: Array<Driver_Warning_Trip_Severity_Insert_Input>;
  on_conflict?: InputMaybe<Driver_Warning_Trip_Severity_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driver_Warning_Trip_Severity_OneArgs = {
  object: Driver_Warning_Trip_Severity_Insert_Input;
  on_conflict?: InputMaybe<Driver_Warning_Trip_Severity_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Edi_Busca_Nfe_JobArgs = {
  objects: Array<Edi_Busca_Nfe_Job_Insert_Input>;
  on_conflict?: InputMaybe<Edi_Busca_Nfe_Job_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Edi_Busca_Nfe_Job_OneArgs = {
  object: Edi_Busca_Nfe_Job_Insert_Input;
  on_conflict?: InputMaybe<Edi_Busca_Nfe_Job_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Edi_Busca_Nfe_ResponseArgs = {
  objects: Array<Edi_Busca_Nfe_Response_Insert_Input>;
  on_conflict?: InputMaybe<Edi_Busca_Nfe_Response_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Edi_Busca_Nfe_Response_OneArgs = {
  object: Edi_Busca_Nfe_Response_Insert_Input;
  on_conflict?: InputMaybe<Edi_Busca_Nfe_Response_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Critical_Segment_From_Critical_PointArgs = {
  objects: Array<Empty_Tables_Critical_Segment_From_Critical_Point_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Critical_Segment_From_Critical_Point_OneArgs = {
  object: Empty_Tables_Critical_Segment_From_Critical_Point_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Driver_Performance_DataArgs = {
  objects: Array<Empty_Tables_Driver_Performance_Data_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Driver_Performance_Data_OneArgs = {
  object: Empty_Tables_Driver_Performance_Data_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Fleet_Performance_DataArgs = {
  objects: Array<Empty_Tables_Fleet_Performance_Data_Insert_Input>;
  on_conflict?: InputMaybe<Empty_Tables_Fleet_Performance_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Fleet_Performance_Data_OneArgs = {
  object: Empty_Tables_Fleet_Performance_Data_Insert_Input;
  on_conflict?: InputMaybe<Empty_Tables_Fleet_Performance_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Geojson_TripArgs = {
  objects: Array<Empty_Tables_Geojson_Trip_Insert_Input>;
  on_conflict?: InputMaybe<Empty_Tables_Geojson_Trip_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Geojson_Trip_OneArgs = {
  object: Empty_Tables_Geojson_Trip_Insert_Input;
  on_conflict?: InputMaybe<Empty_Tables_Geojson_Trip_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Instructor_Drivers_Performance_HistoryArgs = {
  objects: Array<Empty_Tables_Instructor_Drivers_Performance_History_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Empty_Tables_Instructor_Drivers_Performance_History_OneArgs = {
  object: Empty_Tables_Instructor_Drivers_Performance_History_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Fidelity_Range_PointsArgs = {
  objects: Array<Fidelity_Range_Points_Insert_Input>;
  on_conflict?: InputMaybe<Fidelity_Range_Points_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fidelity_Range_Points_OneArgs = {
  object: Fidelity_Range_Points_Insert_Input;
  on_conflict?: InputMaybe<Fidelity_Range_Points_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_PriceArgs = {
  objects: Array<Fipe_Price_Insert_Input>;
  on_conflict?: InputMaybe<Fipe_Price_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_Price_OneArgs = {
  object: Fipe_Price_Insert_Input;
  on_conflict?: InputMaybe<Fipe_Price_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_Reference_MonthArgs = {
  objects: Array<Fipe_Reference_Month_Insert_Input>;
  on_conflict?: InputMaybe<Fipe_Reference_Month_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_Reference_Month_OneArgs = {
  object: Fipe_Reference_Month_Insert_Input;
  on_conflict?: InputMaybe<Fipe_Reference_Month_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_Selected_VehicleArgs = {
  objects: Array<Fipe_Selected_Vehicle_Insert_Input>;
  on_conflict?: InputMaybe<Fipe_Selected_Vehicle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_Selected_Vehicle_OneArgs = {
  object: Fipe_Selected_Vehicle_Insert_Input;
  on_conflict?: InputMaybe<Fipe_Selected_Vehicle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_VehicleArgs = {
  objects: Array<Fipe_Vehicle_Insert_Input>;
  on_conflict?: InputMaybe<Fipe_Vehicle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fipe_Vehicle_OneArgs = {
  object: Fipe_Vehicle_Insert_Input;
  on_conflict?: InputMaybe<Fipe_Vehicle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InspectionArgs = {
  objects: Array<Inspection_Insert_Input>;
  on_conflict?: InputMaybe<Inspection_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inspection_Analysis_ParameterArgs = {
  objects: Array<Inspection_Analysis_Parameter_Insert_Input>;
  on_conflict?: InputMaybe<Inspection_Analysis_Parameter_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inspection_Analysis_Parameter_OneArgs = {
  object: Inspection_Analysis_Parameter_Insert_Input;
  on_conflict?: InputMaybe<Inspection_Analysis_Parameter_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inspection_Fk_TireArgs = {
  objects: Array<Inspection_Fk_Tire_Insert_Input>;
  on_conflict?: InputMaybe<Inspection_Fk_Tire_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inspection_Fk_Tire_OneArgs = {
  object: Inspection_Fk_Tire_Insert_Input;
  on_conflict?: InputMaybe<Inspection_Fk_Tire_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inspection_OneArgs = {
  object: Inspection_Insert_Input;
  on_conflict?: InputMaybe<Inspection_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Instructor_SupervisionArgs = {
  objects: Array<Instructor_Supervision_Insert_Input>;
  on_conflict?: InputMaybe<Instructor_Supervision_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Instructor_Supervision_ObservationArgs = {
  objects: Array<Instructor_Supervision_Observation_Insert_Input>;
  on_conflict?: InputMaybe<Instructor_Supervision_Observation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Instructor_Supervision_Observation_OneArgs = {
  object: Instructor_Supervision_Observation_Insert_Input;
  on_conflict?: InputMaybe<Instructor_Supervision_Observation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Instructor_Supervision_OneArgs = {
  object: Instructor_Supervision_Insert_Input;
  on_conflict?: InputMaybe<Instructor_Supervision_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LevelArgs = {
  objects: Array<Level_Insert_Input>;
  on_conflict?: InputMaybe<Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Level_OneArgs = {
  object: Level_Insert_Input;
  on_conflict?: InputMaybe<Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Level_OptionArgs = {
  objects: Array<Level_Option_Insert_Input>;
  on_conflict?: InputMaybe<Level_Option_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Level_Option_OneArgs = {
  object: Level_Option_Insert_Input;
  on_conflict?: InputMaybe<Level_Option_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ModuleArgs = {
  objects: Array<Module_Insert_Input>;
  on_conflict?: InputMaybe<Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_OneArgs = {
  object: Module_Insert_Input;
  on_conflict?: InputMaybe<Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_PermissionArgs = {
  objects: Array<Module_Permission_Insert_Input>;
  on_conflict?: InputMaybe<Module_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_Permission_OneArgs = {
  object: Module_Permission_Insert_Input;
  on_conflict?: InputMaybe<Module_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_NoteArgs = {
  objects: Array<Note_Insert_Input>;
  on_conflict?: InputMaybe<Note_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Note_OneArgs = {
  object: Note_Insert_Input;
  on_conflict?: InputMaybe<Note_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_NotificationArgs = {
  objects: Array<Notification_Insert_Input>;
  on_conflict?: InputMaybe<Notification_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Notification_OneArgs = {
  object: Notification_Insert_Input;
  on_conflict?: InputMaybe<Notification_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Planet_Osm_LineArgs = {
  objects: Array<Planet_Osm_Line_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Planet_Osm_Line_OneArgs = {
  object: Planet_Osm_Line_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_ProductArgs = {
  objects: Array<Product_Insert_Input>;
  on_conflict?: InputMaybe<Product_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Product_OneArgs = {
  object: Product_Insert_Input;
  on_conflict?: InputMaybe<Product_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Product_PriceArgs = {
  objects: Array<Product_Price_Insert_Input>;
  on_conflict?: InputMaybe<Product_Price_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Product_Price_OneArgs = {
  object: Product_Price_Insert_Input;
  on_conflict?: InputMaybe<Product_Price_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Product_RequestArgs = {
  objects: Array<Product_Request_Insert_Input>;
  on_conflict?: InputMaybe<Product_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Product_Request_OneArgs = {
  object: Product_Request_Insert_Input;
  on_conflict?: InputMaybe<Product_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ProfileArgs = {
  objects: Array<Profile_Insert_Input>;
  on_conflict?: InputMaybe<Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_OneArgs = {
  object: Profile_Insert_Input;
  on_conflict?: InputMaybe<Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_PermissionArgs = {
  objects: Array<Profile_Permission_Insert_Input>;
  on_conflict?: InputMaybe<Profile_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_Permission_OneArgs = {
  object: Profile_Permission_Insert_Input;
  on_conflict?: InputMaybe<Profile_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Refresh_TokenArgs = {
  objects: Array<Refresh_Token_Insert_Input>;
  on_conflict?: InputMaybe<Refresh_Token_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Refresh_Token_OneArgs = {
  object: Refresh_Token_Insert_Input;
  on_conflict?: InputMaybe<Refresh_Token_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Score_ProcessedArgs = {
  objects: Array<Score_Processed_Insert_Input>;
  on_conflict?: InputMaybe<Score_Processed_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Score_Processed_OneArgs = {
  object: Score_Processed_Insert_Input;
  on_conflict?: InputMaybe<Score_Processed_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Score_TypeArgs = {
  objects: Array<Score_Type_Insert_Input>;
  on_conflict?: InputMaybe<Score_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Score_Type_OneArgs = {
  object: Score_Type_Insert_Input;
  on_conflict?: InputMaybe<Score_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Status_Truck_HardwareArgs = {
  objects: Array<Status_Truck_Hardware_Insert_Input>;
  on_conflict?: InputMaybe<Status_Truck_Hardware_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Status_Truck_Hardware_OneArgs = {
  object: Status_Truck_Hardware_Insert_Input;
  on_conflict?: InputMaybe<Status_Truck_Hardware_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TireArgs = {
  objects: Array<Tire_Insert_Input>;
  on_conflict?: InputMaybe<Tire_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_InspectionArgs = {
  objects: Array<Tire_Inspection_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Inspection_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_Fk_TireArgs = {
  objects: Array<Tire_Inspection_Fk_Tire_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Inspection_Fk_Tire_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_Fk_Tire_OneArgs = {
  object: Tire_Inspection_Fk_Tire_Insert_Input;
  on_conflict?: InputMaybe<Tire_Inspection_Fk_Tire_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_NoteArgs = {
  objects: Array<Tire_Inspection_Note_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Inspection_Note_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_Note_AttachmentArgs = {
  objects: Array<Tire_Inspection_Note_Attachment_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Inspection_Note_Attachment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_Note_Attachment_OneArgs = {
  object: Tire_Inspection_Note_Attachment_Insert_Input;
  on_conflict?: InputMaybe<Tire_Inspection_Note_Attachment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_Note_OneArgs = {
  object: Tire_Inspection_Note_Insert_Input;
  on_conflict?: InputMaybe<Tire_Inspection_Note_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_OneArgs = {
  object: Tire_Inspection_Insert_Input;
  on_conflict?: InputMaybe<Tire_Inspection_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_OriginArgs = {
  objects: Array<Tire_Inspection_Origin_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Inspection_Origin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Inspection_Origin_OneArgs = {
  object: Tire_Inspection_Origin_Insert_Input;
  on_conflict?: InputMaybe<Tire_Inspection_Origin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Note_TypeArgs = {
  objects: Array<Tire_Note_Type_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Note_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Note_Type_OneArgs = {
  object: Tire_Note_Type_Insert_Input;
  on_conflict?: InputMaybe<Tire_Note_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_OneArgs = {
  object: Tire_Insert_Input;
  on_conflict?: InputMaybe<Tire_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_ParameterArgs = {
  objects: Array<Tire_Parameter_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Parameter_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Parameter_OneArgs = {
  object: Tire_Parameter_Insert_Input;
  on_conflict?: InputMaybe<Tire_Parameter_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Processing_HistoryArgs = {
  objects: Array<Tire_Processing_History_Insert_Input>;
  on_conflict?: InputMaybe<Tire_Processing_History_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tire_Processing_History_OneArgs = {
  object: Tire_Processing_History_Insert_Input;
  on_conflict?: InputMaybe<Tire_Processing_History_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tirecheck_InconsistencyArgs = {
  objects: Array<Tirecheck_Inconsistency_Insert_Input>;
  on_conflict?: InputMaybe<Tirecheck_Inconsistency_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tirecheck_Inconsistency_OneArgs = {
  object: Tirecheck_Inconsistency_Insert_Input;
  on_conflict?: InputMaybe<Tirecheck_Inconsistency_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TrainingArgs = {
  objects: Array<Training_Insert_Input>;
  on_conflict?: InputMaybe<Training_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Training_DocumentArgs = {
  objects: Array<Training_Document_Insert_Input>;
  on_conflict?: InputMaybe<Training_Document_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Training_Document_OneArgs = {
  object: Training_Document_Insert_Input;
  on_conflict?: InputMaybe<Training_Document_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Training_Document_ViewArgs = {
  objects: Array<Training_Document_View_Insert_Input>;
  on_conflict?: InputMaybe<Training_Document_View_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Training_Document_View_OneArgs = {
  object: Training_Document_View_Insert_Input;
  on_conflict?: InputMaybe<Training_Document_View_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Training_OneArgs = {
  object: Training_Insert_Input;
  on_conflict?: InputMaybe<Training_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserArgs = {
  objects: Array<User_Insert_Input>;
  on_conflict?: InputMaybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_AchievementArgs = {
  objects: Array<User_Fk_Achievement_Insert_Input>;
  on_conflict?: InputMaybe<User_Fk_Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_Achievement_OneArgs = {
  object: User_Fk_Achievement_Insert_Input;
  on_conflict?: InputMaybe<User_Fk_Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_ChallengeArgs = {
  objects: Array<User_Fk_Challenge_Insert_Input>;
  on_conflict?: InputMaybe<User_Fk_Challenge_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_Challenge_OneArgs = {
  object: User_Fk_Challenge_Insert_Input;
  on_conflict?: InputMaybe<User_Fk_Challenge_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_LevelArgs = {
  objects: Array<User_Fk_Level_Insert_Input>;
  on_conflict?: InputMaybe<User_Fk_Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_Level_OneArgs = {
  object: User_Fk_Level_Insert_Input;
  on_conflict?: InputMaybe<User_Fk_Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_NotificationArgs = {
  objects: Array<User_Fk_Notification_Insert_Input>;
  on_conflict?: InputMaybe<User_Fk_Notification_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_Notification_OneArgs = {
  object: User_Fk_Notification_Insert_Input;
  on_conflict?: InputMaybe<User_Fk_Notification_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_Privacy_PolicyArgs = {
  objects: Array<User_Fk_Privacy_Policy_Insert_Input>;
  on_conflict?: InputMaybe<User_Fk_Privacy_Policy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Fk_Privacy_Policy_OneArgs = {
  object: User_Fk_Privacy_Policy_Insert_Input;
  on_conflict?: InputMaybe<User_Fk_Privacy_Policy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Km_Points_ApprovalArgs = {
  objects: Array<User_Km_Points_Approval_Insert_Input>;
  on_conflict?: InputMaybe<User_Km_Points_Approval_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Km_Points_Approval_OneArgs = {
  object: User_Km_Points_Approval_Insert_Input;
  on_conflict?: InputMaybe<User_Km_Points_Approval_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_KmpsArgs = {
  objects: Array<User_Kmps_Insert_Input>;
  on_conflict?: InputMaybe<User_Kmps_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Kmps_OneArgs = {
  object: User_Kmps_Insert_Input;
  on_conflict?: InputMaybe<User_Kmps_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OneArgs = {
  object: User_Insert_Input;
  on_conflict?: InputMaybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_ScoreArgs = {
  objects: Array<User_Score_Insert_Input>;
  on_conflict?: InputMaybe<User_Score_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Score_OneArgs = {
  object: User_Score_Insert_Input;
  on_conflict?: InputMaybe<User_Score_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_TrainingArgs = {
  objects: Array<User_Training_Insert_Input>;
  on_conflict?: InputMaybe<User_Training_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Training_OneArgs = {
  object: User_Training_Insert_Input;
  on_conflict?: InputMaybe<User_Training_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VehicleArgs = {
  objects: Array<Vehicle_Insert_Input>;
  on_conflict?: InputMaybe<Vehicle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Vehicle_OneArgs = {
  object: Vehicle_Insert_Input;
  on_conflict?: InputMaybe<Vehicle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_EventArgs = {
  objects: Array<Whatsapp_Event_Insert_Input>;
  on_conflict?: InputMaybe<Whatsapp_Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_Event_OneArgs = {
  object: Whatsapp_Event_Insert_Input;
  on_conflict?: InputMaybe<Whatsapp_Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_MessageArgs = {
  objects: Array<Whatsapp_Message_Insert_Input>;
  on_conflict?: InputMaybe<Whatsapp_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_Message_HistoryArgs = {
  objects: Array<Whatsapp_Message_History_Insert_Input>;
  on_conflict?: InputMaybe<Whatsapp_Message_History_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_Message_History_OneArgs = {
  object: Whatsapp_Message_History_Insert_Input;
  on_conflict?: InputMaybe<Whatsapp_Message_History_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_Message_OneArgs = {
  object: Whatsapp_Message_Insert_Input;
  on_conflict?: InputMaybe<Whatsapp_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_TriggerArgs = {
  objects: Array<Whatsapp_Trigger_Insert_Input>;
  on_conflict?: InputMaybe<Whatsapp_Trigger_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Whatsapp_Trigger_OneArgs = {
  object: Whatsapp_Trigger_Insert_Input;
  on_conflict?: InputMaybe<Whatsapp_Trigger_On_Conflict>;
};


/** mutation root */
export type Mutation_RootRegister_AdminArgs = {
  cpf?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootUpdate_CurrentTiresByVehicleArgs = {
  _set?: InputMaybe<CurrentTiresByVehicle_Set_Input>;
  where: CurrentTiresByVehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ParametroAlertaConducaoArgs = {
  _inc?: InputMaybe<ParametroAlertaConducao_Inc_Input>;
  _set?: InputMaybe<ParametroAlertaConducao_Set_Input>;
  where: ParametroAlertaConducao_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ParametroAlertaConducao_By_PkArgs = {
  _inc?: InputMaybe<ParametroAlertaConducao_Inc_Input>;
  _set?: InputMaybe<ParametroAlertaConducao_Set_Input>;
  pk_columns: ParametroAlertaConducao_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PerformanceParameterArgs = {
  _set?: InputMaybe<PerformanceParameter_Set_Input>;
  where: PerformanceParameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_PerformanceParameter_By_PkArgs = {
  _set?: InputMaybe<PerformanceParameter_Set_Input>;
  pk_columns: PerformanceParameter_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PontosRastroArgs = {
  _inc?: InputMaybe<PontosRastro_Inc_Input>;
  _set?: InputMaybe<PontosRastro_Set_Input>;
  where: PontosRastro_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_PontosRastro_By_PkArgs = {
  _inc?: InputMaybe<PontosRastro_Inc_Input>;
  _set?: InputMaybe<PontosRastro_Set_Input>;
  pk_columns: PontosRastro_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ScoreParameterArgs = {
  _inc?: InputMaybe<ScoreParameter_Inc_Input>;
  _set?: InputMaybe<ScoreParameter_Set_Input>;
  where: ScoreParameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ScoreParameter_By_PkArgs = {
  _inc?: InputMaybe<ScoreParameter_Inc_Input>;
  _set?: InputMaybe<ScoreParameter_Set_Input>;
  pk_columns: ScoreParameter_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ScoreTypeArgs = {
  _set?: InputMaybe<ScoreType_Set_Input>;
  where: ScoreType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ScoreType_By_PkArgs = {
  _set?: InputMaybe<ScoreType_Set_Input>;
  pk_columns: ScoreType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechEquipamentoArgs = {
  _inc?: InputMaybe<SuntechEquipamento_Inc_Input>;
  _set?: InputMaybe<SuntechEquipamento_Set_Input>;
  where: SuntechEquipamento_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerBatchCommandArgs = {
  _set?: InputMaybe<SuntechTrackerBatchCommand_Set_Input>;
  where: SuntechTrackerBatchCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerBatchCommandDeviceArgs = {
  _inc?: InputMaybe<SuntechTrackerBatchCommandDevice_Inc_Input>;
  _set?: InputMaybe<SuntechTrackerBatchCommandDevice_Set_Input>;
  where: SuntechTrackerBatchCommandDevice_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerBatchCommandDevice_By_PkArgs = {
  _inc?: InputMaybe<SuntechTrackerBatchCommandDevice_Inc_Input>;
  _set?: InputMaybe<SuntechTrackerBatchCommandDevice_Set_Input>;
  pk_columns: SuntechTrackerBatchCommandDevice_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerBatchCommandPresetArgs = {
  _set?: InputMaybe<SuntechTrackerBatchCommandPreset_Set_Input>;
  where: SuntechTrackerBatchCommandPreset_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerBatchCommandPreset_By_PkArgs = {
  _set?: InputMaybe<SuntechTrackerBatchCommandPreset_Set_Input>;
  pk_columns: SuntechTrackerBatchCommandPreset_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerBatchCommand_By_PkArgs = {
  _set?: InputMaybe<SuntechTrackerBatchCommand_Set_Input>;
  pk_columns: SuntechTrackerBatchCommand_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerCommandArgs = {
  _inc?: InputMaybe<SuntechTrackerCommand_Inc_Input>;
  _set?: InputMaybe<SuntechTrackerCommand_Set_Input>;
  where: SuntechTrackerCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_SuntechTrackerCommand_By_PkArgs = {
  _inc?: InputMaybe<SuntechTrackerCommand_Inc_Input>;
  _set?: InputMaybe<SuntechTrackerCommand_Set_Input>;
  pk_columns: SuntechTrackerCommand_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerBatchCommandArgs = {
  _set?: InputMaybe<VirlocTrackerBatchCommand_Set_Input>;
  where: VirlocTrackerBatchCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerBatchCommandDeviceArgs = {
  _inc?: InputMaybe<VirlocTrackerBatchCommandDevice_Inc_Input>;
  _set?: InputMaybe<VirlocTrackerBatchCommandDevice_Set_Input>;
  where: VirlocTrackerBatchCommandDevice_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerBatchCommandDevice_By_PkArgs = {
  _inc?: InputMaybe<VirlocTrackerBatchCommandDevice_Inc_Input>;
  _set?: InputMaybe<VirlocTrackerBatchCommandDevice_Set_Input>;
  pk_columns: VirlocTrackerBatchCommandDevice_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerBatchCommandPresetArgs = {
  _set?: InputMaybe<VirlocTrackerBatchCommandPreset_Set_Input>;
  where: VirlocTrackerBatchCommandPreset_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerBatchCommandPreset_By_PkArgs = {
  _set?: InputMaybe<VirlocTrackerBatchCommandPreset_Set_Input>;
  pk_columns: VirlocTrackerBatchCommandPreset_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerBatchCommand_By_PkArgs = {
  _set?: InputMaybe<VirlocTrackerBatchCommand_Set_Input>;
  pk_columns: VirlocTrackerBatchCommand_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerCommandArgs = {
  _inc?: InputMaybe<VirlocTrackerCommand_Inc_Input>;
  _set?: InputMaybe<VirlocTrackerCommand_Set_Input>;
  where: VirlocTrackerCommand_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerCommand_By_PkArgs = {
  _inc?: InputMaybe<VirlocTrackerCommand_Inc_Input>;
  _set?: InputMaybe<VirlocTrackerCommand_Set_Input>;
  pk_columns: VirlocTrackerCommand_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerDeviceArgs = {
  _inc?: InputMaybe<VirlocTrackerDevice_Inc_Input>;
  _set?: InputMaybe<VirlocTrackerDevice_Set_Input>;
  where: VirlocTrackerDevice_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_VirlocTrackerDevice_By_PkArgs = {
  _inc?: InputMaybe<VirlocTrackerDevice_Inc_Input>;
  _set?: InputMaybe<VirlocTrackerDevice_Set_Input>;
  pk_columns: VirlocTrackerDevice_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_AchievementArgs = {
  _append?: InputMaybe<Achievement_Append_Input>;
  _delete_at_path?: InputMaybe<Achievement_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Achievement_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Achievement_Delete_Key_Input>;
  _inc?: InputMaybe<Achievement_Inc_Input>;
  _prepend?: InputMaybe<Achievement_Prepend_Input>;
  _set?: InputMaybe<Achievement_Set_Input>;
  where: Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Achievement_By_PkArgs = {
  _append?: InputMaybe<Achievement_Append_Input>;
  _delete_at_path?: InputMaybe<Achievement_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Achievement_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Achievement_Delete_Key_Input>;
  _inc?: InputMaybe<Achievement_Inc_Input>;
  _prepend?: InputMaybe<Achievement_Prepend_Input>;
  _set?: InputMaybe<Achievement_Set_Input>;
  pk_columns: Achievement_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Achievement_ManyArgs = {
  updates: Array<Achievement_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AdminArgs = {
  _set?: InputMaybe<Admin_Set_Input>;
  where: Admin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_By_PkArgs = {
  _set?: InputMaybe<Admin_Set_Input>;
  pk_columns: Admin_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Fk_NotificationsArgs = {
  _set?: InputMaybe<Admin_Fk_Notifications_Set_Input>;
  where: Admin_Fk_Notifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Fk_Notifications_By_PkArgs = {
  _set?: InputMaybe<Admin_Fk_Notifications_Set_Input>;
  pk_columns: Admin_Fk_Notifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Fk_Notifications_ManyArgs = {
  updates: Array<Admin_Fk_Notifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Fk_ProfileArgs = {
  _set?: InputMaybe<Admin_Fk_Profile_Set_Input>;
  where: Admin_Fk_Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Fk_Profile_By_PkArgs = {
  _set?: InputMaybe<Admin_Fk_Profile_Set_Input>;
  pk_columns: Admin_Fk_Profile_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Fk_Profile_ManyArgs = {
  updates: Array<Admin_Fk_Profile_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_ManyArgs = {
  updates: Array<Admin_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_PermissionArgs = {
  _set?: InputMaybe<Admin_Permission_Set_Input>;
  where: Admin_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Permission_By_PkArgs = {
  _set?: InputMaybe<Admin_Permission_Set_Input>;
  pk_columns: Admin_Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Admin_Permission_ManyArgs = {
  updates: Array<Admin_Permission_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AutoArgs = {
  _inc?: InputMaybe<Auto_Inc_Input>;
  _set?: InputMaybe<Auto_Set_Input>;
  where: Auto_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auto_By_PkArgs = {
  _inc?: InputMaybe<Auto_Inc_Input>;
  _set?: InputMaybe<Auto_Set_Input>;
  pk_columns: Auto_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_DashboardArgs = {
  _append?: InputMaybe<Bi_Dashboard_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Dashboard_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Dashboard_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Dashboard_Delete_Key_Input>;
  _inc?: InputMaybe<Bi_Dashboard_Inc_Input>;
  _prepend?: InputMaybe<Bi_Dashboard_Prepend_Input>;
  _set?: InputMaybe<Bi_Dashboard_Set_Input>;
  where: Bi_Dashboard_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_By_PkArgs = {
  _append?: InputMaybe<Bi_Dashboard_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Dashboard_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Dashboard_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Dashboard_Delete_Key_Input>;
  _inc?: InputMaybe<Bi_Dashboard_Inc_Input>;
  _prepend?: InputMaybe<Bi_Dashboard_Prepend_Input>;
  _set?: InputMaybe<Bi_Dashboard_Set_Input>;
  pk_columns: Bi_Dashboard_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_ItemArgs = {
  _append?: InputMaybe<Bi_Dashboard_Item_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Dashboard_Item_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Dashboard_Item_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Dashboard_Item_Delete_Key_Input>;
  _prepend?: InputMaybe<Bi_Dashboard_Item_Prepend_Input>;
  _set?: InputMaybe<Bi_Dashboard_Item_Set_Input>;
  where: Bi_Dashboard_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_Item_By_PkArgs = {
  _append?: InputMaybe<Bi_Dashboard_Item_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Dashboard_Item_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Dashboard_Item_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Dashboard_Item_Delete_Key_Input>;
  _prepend?: InputMaybe<Bi_Dashboard_Item_Prepend_Input>;
  _set?: InputMaybe<Bi_Dashboard_Item_Set_Input>;
  pk_columns: Bi_Dashboard_Item_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_Item_ManyArgs = {
  updates: Array<Bi_Dashboard_Item_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_Item_TypeArgs = {
  _set?: InputMaybe<Bi_Dashboard_Item_Type_Set_Input>;
  where: Bi_Dashboard_Item_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_Item_Type_By_PkArgs = {
  _set?: InputMaybe<Bi_Dashboard_Item_Type_Set_Input>;
  pk_columns: Bi_Dashboard_Item_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_Item_Type_ManyArgs = {
  updates: Array<Bi_Dashboard_Item_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Dashboard_ManyArgs = {
  updates: Array<Bi_Dashboard_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_DatasourceArgs = {
  _inc?: InputMaybe<Bi_Datasource_Inc_Input>;
  _set?: InputMaybe<Bi_Datasource_Set_Input>;
  where: Bi_Datasource_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Datasource_By_PkArgs = {
  _inc?: InputMaybe<Bi_Datasource_Inc_Input>;
  _set?: InputMaybe<Bi_Datasource_Set_Input>;
  pk_columns: Bi_Datasource_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Datasource_ManyArgs = {
  updates: Array<Bi_Datasource_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Datasource_TypeArgs = {
  _set?: InputMaybe<Bi_Datasource_Type_Set_Input>;
  where: Bi_Datasource_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Datasource_Type_By_PkArgs = {
  _set?: InputMaybe<Bi_Datasource_Type_Set_Input>;
  pk_columns: Bi_Datasource_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Datasource_Type_ManyArgs = {
  updates: Array<Bi_Datasource_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_PermissionArgs = {
  _inc?: InputMaybe<Bi_Permission_Inc_Input>;
  _set?: InputMaybe<Bi_Permission_Set_Input>;
  where: Bi_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Permission_By_PkArgs = {
  _inc?: InputMaybe<Bi_Permission_Inc_Input>;
  _set?: InputMaybe<Bi_Permission_Set_Input>;
  pk_columns: Bi_Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Permission_ManyArgs = {
  updates: Array<Bi_Permission_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Permission_ModuleArgs = {
  _inc?: InputMaybe<Bi_Permission_Module_Inc_Input>;
  _set?: InputMaybe<Bi_Permission_Module_Set_Input>;
  where: Bi_Permission_Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Permission_Module_By_PkArgs = {
  _inc?: InputMaybe<Bi_Permission_Module_Inc_Input>;
  _set?: InputMaybe<Bi_Permission_Module_Set_Input>;
  pk_columns: Bi_Permission_Module_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Permission_Module_ManyArgs = {
  updates: Array<Bi_Permission_Module_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Public_LinkArgs = {
  _set?: InputMaybe<Bi_Public_Link_Set_Input>;
  where: Bi_Public_Link_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Public_Link_By_PkArgs = {
  _set?: InputMaybe<Bi_Public_Link_Set_Input>;
  pk_columns: Bi_Public_Link_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Public_Link_ManyArgs = {
  updates: Array<Bi_Public_Link_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_QueryArgs = {
  _set?: InputMaybe<Bi_Query_Set_Input>;
  where: Bi_Query_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_AnalyticsArgs = {
  _append?: InputMaybe<Bi_Query_Analytics_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Query_Analytics_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Query_Analytics_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Query_Analytics_Delete_Key_Input>;
  _inc?: InputMaybe<Bi_Query_Analytics_Inc_Input>;
  _prepend?: InputMaybe<Bi_Query_Analytics_Prepend_Input>;
  _set?: InputMaybe<Bi_Query_Analytics_Set_Input>;
  where: Bi_Query_Analytics_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_Analytics_By_PkArgs = {
  _append?: InputMaybe<Bi_Query_Analytics_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Query_Analytics_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Query_Analytics_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Query_Analytics_Delete_Key_Input>;
  _inc?: InputMaybe<Bi_Query_Analytics_Inc_Input>;
  _prepend?: InputMaybe<Bi_Query_Analytics_Prepend_Input>;
  _set?: InputMaybe<Bi_Query_Analytics_Set_Input>;
  pk_columns: Bi_Query_Analytics_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_Analytics_ManyArgs = {
  updates: Array<Bi_Query_Analytics_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_By_PkArgs = {
  _set?: InputMaybe<Bi_Query_Set_Input>;
  pk_columns: Bi_Query_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_CacheArgs = {
  _append?: InputMaybe<Bi_Query_Cache_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Query_Cache_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Query_Cache_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Query_Cache_Delete_Key_Input>;
  _prepend?: InputMaybe<Bi_Query_Cache_Prepend_Input>;
  _set?: InputMaybe<Bi_Query_Cache_Set_Input>;
  where: Bi_Query_Cache_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_Cache_By_PkArgs = {
  _append?: InputMaybe<Bi_Query_Cache_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Query_Cache_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Query_Cache_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Query_Cache_Delete_Key_Input>;
  _prepend?: InputMaybe<Bi_Query_Cache_Prepend_Input>;
  _set?: InputMaybe<Bi_Query_Cache_Set_Input>;
  pk_columns: Bi_Query_Cache_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_Cache_ManyArgs = {
  updates: Array<Bi_Query_Cache_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Query_ManyArgs = {
  updates: Array<Bi_Query_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_SubqueryArgs = {
  _append?: InputMaybe<Bi_Subquery_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Subquery_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Subquery_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Subquery_Delete_Key_Input>;
  _prepend?: InputMaybe<Bi_Subquery_Prepend_Input>;
  _set?: InputMaybe<Bi_Subquery_Set_Input>;
  where: Bi_Subquery_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Subquery_By_PkArgs = {
  _append?: InputMaybe<Bi_Subquery_Append_Input>;
  _delete_at_path?: InputMaybe<Bi_Subquery_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bi_Subquery_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bi_Subquery_Delete_Key_Input>;
  _prepend?: InputMaybe<Bi_Subquery_Prepend_Input>;
  _set?: InputMaybe<Bi_Subquery_Set_Input>;
  pk_columns: Bi_Subquery_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_Subquery_ManyArgs = {
  updates: Array<Bi_Subquery_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_User_PermissionArgs = {
  _set?: InputMaybe<Bi_User_Permission_Set_Input>;
  where: Bi_User_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_User_Permission_By_PkArgs = {
  _set?: InputMaybe<Bi_User_Permission_Set_Input>;
  pk_columns: Bi_User_Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bi_User_Permission_ManyArgs = {
  updates: Array<Bi_User_Permission_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ChallengeArgs = {
  _inc?: InputMaybe<Challenge_Inc_Input>;
  _set?: InputMaybe<Challenge_Set_Input>;
  where: Challenge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Challenge_By_PkArgs = {
  _inc?: InputMaybe<Challenge_Inc_Input>;
  _set?: InputMaybe<Challenge_Set_Input>;
  pk_columns: Challenge_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Challenge_ManyArgs = {
  updates: Array<Challenge_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Challenge_TypeArgs = {
  _inc?: InputMaybe<Challenge_Type_Inc_Input>;
  _set?: InputMaybe<Challenge_Type_Set_Input>;
  where: Challenge_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Challenge_Type_By_PkArgs = {
  _inc?: InputMaybe<Challenge_Type_Inc_Input>;
  _set?: InputMaybe<Challenge_Type_Set_Input>;
  pk_columns: Challenge_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Challenge_Type_ManyArgs = {
  updates: Array<Challenge_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ConfigArgs = {
  _inc?: InputMaybe<Config_Inc_Input>;
  _set?: InputMaybe<Config_Set_Input>;
  where: Config_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Config_By_PkArgs = {
  _inc?: InputMaybe<Config_Inc_Input>;
  _set?: InputMaybe<Config_Set_Input>;
  pk_columns: Config_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Config_ManyArgs = {
  updates: Array<Config_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Critical_PointArgs = {
  _inc?: InputMaybe<Critical_Point_Inc_Input>;
  _set?: InputMaybe<Critical_Point_Set_Input>;
  where: Critical_Point_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Critical_Point_By_PkArgs = {
  _inc?: InputMaybe<Critical_Point_Inc_Input>;
  _set?: InputMaybe<Critical_Point_Set_Input>;
  pk_columns: Critical_Point_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Critical_Point_ManyArgs = {
  updates: Array<Critical_Point_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Critical_SegmentArgs = {
  _inc?: InputMaybe<Critical_Segment_Inc_Input>;
  _set?: InputMaybe<Critical_Segment_Set_Input>;
  where: Critical_Segment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Critical_Segment_By_PkArgs = {
  _inc?: InputMaybe<Critical_Segment_Inc_Input>;
  _set?: InputMaybe<Critical_Segment_Set_Input>;
  pk_columns: Critical_Segment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Critical_Segment_ManyArgs = {
  updates: Array<Critical_Segment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Cte_Nf_LockArgs = {
  _inc?: InputMaybe<Cte_Nf_Lock_Inc_Input>;
  _set?: InputMaybe<Cte_Nf_Lock_Set_Input>;
  where: Cte_Nf_Lock_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Cte_Nf_Lock_By_PkArgs = {
  _inc?: InputMaybe<Cte_Nf_Lock_Inc_Input>;
  _set?: InputMaybe<Cte_Nf_Lock_Set_Input>;
  pk_columns: Cte_Nf_Lock_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Cte_Nf_Lock_ManyArgs = {
  updates: Array<Cte_Nf_Lock_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Deleted_RowArgs = {
  _inc?: InputMaybe<Deleted_Row_Inc_Input>;
  _set?: InputMaybe<Deleted_Row_Set_Input>;
  where: Deleted_Row_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Deleted_Row_By_PkArgs = {
  _inc?: InputMaybe<Deleted_Row_Inc_Input>;
  _set?: InputMaybe<Deleted_Row_Set_Input>;
  pk_columns: Deleted_Row_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Deleted_Row_ManyArgs = {
  updates: Array<Deleted_Row_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DeliveryArgs = {
  _inc?: InputMaybe<Delivery_Inc_Input>;
  _set?: InputMaybe<Delivery_Set_Input>;
  where: Delivery_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Delivery_By_PkArgs = {
  _inc?: InputMaybe<Delivery_Inc_Input>;
  _set?: InputMaybe<Delivery_Set_Input>;
  pk_columns: Delivery_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Delivery_ManyArgs = {
  updates: Array<Delivery_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_WarningArgs = {
  _inc?: InputMaybe<Driver_Warning_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Set_Input>;
  where: Driver_Warning_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_By_PkArgs = {
  _inc?: InputMaybe<Driver_Warning_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Set_Input>;
  pk_columns: Driver_Warning_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_CommentArgs = {
  _set?: InputMaybe<Driver_Warning_Comment_Set_Input>;
  where: Driver_Warning_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Comment_By_PkArgs = {
  _set?: InputMaybe<Driver_Warning_Comment_Set_Input>;
  pk_columns: Driver_Warning_Comment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Comment_ManyArgs = {
  updates: Array<Driver_Warning_Comment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Fk_Whatsapp_MessageArgs = {
  _inc?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Set_Input>;
  where: Driver_Warning_Fk_Whatsapp_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Fk_Whatsapp_Message_By_PkArgs = {
  _inc?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Set_Input>;
  pk_columns: Driver_Warning_Fk_Whatsapp_Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Fk_Whatsapp_Message_ManyArgs = {
  updates: Array<Driver_Warning_Fk_Whatsapp_Message_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_ManyArgs = {
  updates: Array<Driver_Warning_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Risk_LevelArgs = {
  _set?: InputMaybe<Driver_Warning_Risk_Level_Set_Input>;
  where: Driver_Warning_Risk_Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Risk_Level_By_PkArgs = {
  _set?: InputMaybe<Driver_Warning_Risk_Level_Set_Input>;
  pk_columns: Driver_Warning_Risk_Level_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Risk_Level_ManyArgs = {
  updates: Array<Driver_Warning_Risk_Level_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_TripArgs = {
  _append?: InputMaybe<Driver_Warning_Trip_Append_Input>;
  _delete_at_path?: InputMaybe<Driver_Warning_Trip_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Driver_Warning_Trip_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Driver_Warning_Trip_Delete_Key_Input>;
  _inc?: InputMaybe<Driver_Warning_Trip_Inc_Input>;
  _prepend?: InputMaybe<Driver_Warning_Trip_Prepend_Input>;
  _set?: InputMaybe<Driver_Warning_Trip_Set_Input>;
  where: Driver_Warning_Trip_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_By_PkArgs = {
  _append?: InputMaybe<Driver_Warning_Trip_Append_Input>;
  _delete_at_path?: InputMaybe<Driver_Warning_Trip_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Driver_Warning_Trip_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Driver_Warning_Trip_Delete_Key_Input>;
  _inc?: InputMaybe<Driver_Warning_Trip_Inc_Input>;
  _prepend?: InputMaybe<Driver_Warning_Trip_Prepend_Input>;
  _set?: InputMaybe<Driver_Warning_Trip_Set_Input>;
  pk_columns: Driver_Warning_Trip_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_ManyArgs = {
  updates: Array<Driver_Warning_Trip_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_PointArgs = {
  _inc?: InputMaybe<Driver_Warning_Trip_Point_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Trip_Point_Set_Input>;
  where: Driver_Warning_Trip_Point_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_Point_By_PkArgs = {
  _inc?: InputMaybe<Driver_Warning_Trip_Point_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Trip_Point_Set_Input>;
  pk_columns: Driver_Warning_Trip_Point_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_Point_ManyArgs = {
  updates: Array<Driver_Warning_Trip_Point_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_SeverityArgs = {
  _inc?: InputMaybe<Driver_Warning_Trip_Severity_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Trip_Severity_Set_Input>;
  where: Driver_Warning_Trip_Severity_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_Severity_By_PkArgs = {
  _inc?: InputMaybe<Driver_Warning_Trip_Severity_Inc_Input>;
  _set?: InputMaybe<Driver_Warning_Trip_Severity_Set_Input>;
  pk_columns: Driver_Warning_Trip_Severity_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driver_Warning_Trip_Severity_ManyArgs = {
  updates: Array<Driver_Warning_Trip_Severity_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Edi_Busca_Nfe_JobArgs = {
  _append?: InputMaybe<Edi_Busca_Nfe_Job_Append_Input>;
  _delete_at_path?: InputMaybe<Edi_Busca_Nfe_Job_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Edi_Busca_Nfe_Job_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Edi_Busca_Nfe_Job_Delete_Key_Input>;
  _prepend?: InputMaybe<Edi_Busca_Nfe_Job_Prepend_Input>;
  _set?: InputMaybe<Edi_Busca_Nfe_Job_Set_Input>;
  where: Edi_Busca_Nfe_Job_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Edi_Busca_Nfe_Job_By_PkArgs = {
  _append?: InputMaybe<Edi_Busca_Nfe_Job_Append_Input>;
  _delete_at_path?: InputMaybe<Edi_Busca_Nfe_Job_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Edi_Busca_Nfe_Job_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Edi_Busca_Nfe_Job_Delete_Key_Input>;
  _prepend?: InputMaybe<Edi_Busca_Nfe_Job_Prepend_Input>;
  _set?: InputMaybe<Edi_Busca_Nfe_Job_Set_Input>;
  pk_columns: Edi_Busca_Nfe_Job_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Edi_Busca_Nfe_Job_ManyArgs = {
  updates: Array<Edi_Busca_Nfe_Job_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Edi_Busca_Nfe_ResponseArgs = {
  _set?: InputMaybe<Edi_Busca_Nfe_Response_Set_Input>;
  where: Edi_Busca_Nfe_Response_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Edi_Busca_Nfe_Response_By_PkArgs = {
  _set?: InputMaybe<Edi_Busca_Nfe_Response_Set_Input>;
  pk_columns: Edi_Busca_Nfe_Response_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Edi_Busca_Nfe_Response_ManyArgs = {
  updates: Array<Edi_Busca_Nfe_Response_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Critical_Segment_From_Critical_PointArgs = {
  _append?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Append_Input>;
  _delete_at_path?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Delete_Key_Input>;
  _inc?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Inc_Input>;
  _prepend?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Prepend_Input>;
  _set?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Set_Input>;
  where: Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Critical_Segment_From_Critical_Point_ManyArgs = {
  updates: Array<Empty_Tables_Critical_Segment_From_Critical_Point_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Driver_Performance_DataArgs = {
  _inc?: InputMaybe<Empty_Tables_Driver_Performance_Data_Inc_Input>;
  _set?: InputMaybe<Empty_Tables_Driver_Performance_Data_Set_Input>;
  where: Empty_Tables_Driver_Performance_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Driver_Performance_Data_ManyArgs = {
  updates: Array<Empty_Tables_Driver_Performance_Data_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Fleet_Performance_DataArgs = {
  _inc?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Inc_Input>;
  _set?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Set_Input>;
  where: Empty_Tables_Fleet_Performance_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Fleet_Performance_Data_By_PkArgs = {
  _inc?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Inc_Input>;
  _set?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Set_Input>;
  pk_columns: Empty_Tables_Fleet_Performance_Data_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Fleet_Performance_Data_ManyArgs = {
  updates: Array<Empty_Tables_Fleet_Performance_Data_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Geojson_TripArgs = {
  _append?: InputMaybe<Empty_Tables_Geojson_Trip_Append_Input>;
  _delete_at_path?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_Key_Input>;
  _inc?: InputMaybe<Empty_Tables_Geojson_Trip_Inc_Input>;
  _prepend?: InputMaybe<Empty_Tables_Geojson_Trip_Prepend_Input>;
  _set?: InputMaybe<Empty_Tables_Geojson_Trip_Set_Input>;
  where: Empty_Tables_Geojson_Trip_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Geojson_Trip_By_PkArgs = {
  _append?: InputMaybe<Empty_Tables_Geojson_Trip_Append_Input>;
  _delete_at_path?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Empty_Tables_Geojson_Trip_Delete_Key_Input>;
  _inc?: InputMaybe<Empty_Tables_Geojson_Trip_Inc_Input>;
  _prepend?: InputMaybe<Empty_Tables_Geojson_Trip_Prepend_Input>;
  _set?: InputMaybe<Empty_Tables_Geojson_Trip_Set_Input>;
  pk_columns: Empty_Tables_Geojson_Trip_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Geojson_Trip_ManyArgs = {
  updates: Array<Empty_Tables_Geojson_Trip_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Instructor_Drivers_Performance_HistoryArgs = {
  _inc?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Inc_Input>;
  _set?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Set_Input>;
  where: Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Empty_Tables_Instructor_Drivers_Performance_History_ManyArgs = {
  updates: Array<Empty_Tables_Instructor_Drivers_Performance_History_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fidelity_Range_PointsArgs = {
  _inc?: InputMaybe<Fidelity_Range_Points_Inc_Input>;
  _set?: InputMaybe<Fidelity_Range_Points_Set_Input>;
  where: Fidelity_Range_Points_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fidelity_Range_Points_By_PkArgs = {
  _inc?: InputMaybe<Fidelity_Range_Points_Inc_Input>;
  _set?: InputMaybe<Fidelity_Range_Points_Set_Input>;
  pk_columns: Fidelity_Range_Points_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fidelity_Range_Points_ManyArgs = {
  updates: Array<Fidelity_Range_Points_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_PriceArgs = {
  _inc?: InputMaybe<Fipe_Price_Inc_Input>;
  _set?: InputMaybe<Fipe_Price_Set_Input>;
  where: Fipe_Price_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Price_By_PkArgs = {
  _inc?: InputMaybe<Fipe_Price_Inc_Input>;
  _set?: InputMaybe<Fipe_Price_Set_Input>;
  pk_columns: Fipe_Price_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Price_ManyArgs = {
  updates: Array<Fipe_Price_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Reference_MonthArgs = {
  _inc?: InputMaybe<Fipe_Reference_Month_Inc_Input>;
  _set?: InputMaybe<Fipe_Reference_Month_Set_Input>;
  where: Fipe_Reference_Month_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Reference_Month_By_PkArgs = {
  _inc?: InputMaybe<Fipe_Reference_Month_Inc_Input>;
  _set?: InputMaybe<Fipe_Reference_Month_Set_Input>;
  pk_columns: Fipe_Reference_Month_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Reference_Month_ManyArgs = {
  updates: Array<Fipe_Reference_Month_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Selected_VehicleArgs = {
  _inc?: InputMaybe<Fipe_Selected_Vehicle_Inc_Input>;
  _set?: InputMaybe<Fipe_Selected_Vehicle_Set_Input>;
  where: Fipe_Selected_Vehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Selected_Vehicle_By_PkArgs = {
  _inc?: InputMaybe<Fipe_Selected_Vehicle_Inc_Input>;
  _set?: InputMaybe<Fipe_Selected_Vehicle_Set_Input>;
  pk_columns: Fipe_Selected_Vehicle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Selected_Vehicle_ManyArgs = {
  updates: Array<Fipe_Selected_Vehicle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_VehicleArgs = {
  _inc?: InputMaybe<Fipe_Vehicle_Inc_Input>;
  _set?: InputMaybe<Fipe_Vehicle_Set_Input>;
  where: Fipe_Vehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Vehicle_By_PkArgs = {
  _inc?: InputMaybe<Fipe_Vehicle_Inc_Input>;
  _set?: InputMaybe<Fipe_Vehicle_Set_Input>;
  pk_columns: Fipe_Vehicle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fipe_Vehicle_ManyArgs = {
  updates: Array<Fipe_Vehicle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_InspectionArgs = {
  _set?: InputMaybe<Inspection_Set_Input>;
  where: Inspection_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_Analysis_ParameterArgs = {
  _inc?: InputMaybe<Inspection_Analysis_Parameter_Inc_Input>;
  _set?: InputMaybe<Inspection_Analysis_Parameter_Set_Input>;
  where: Inspection_Analysis_Parameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_Analysis_Parameter_By_PkArgs = {
  _inc?: InputMaybe<Inspection_Analysis_Parameter_Inc_Input>;
  _set?: InputMaybe<Inspection_Analysis_Parameter_Set_Input>;
  pk_columns: Inspection_Analysis_Parameter_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_Analysis_Parameter_ManyArgs = {
  updates: Array<Inspection_Analysis_Parameter_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_By_PkArgs = {
  _set?: InputMaybe<Inspection_Set_Input>;
  pk_columns: Inspection_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_Fk_TireArgs = {
  _inc?: InputMaybe<Inspection_Fk_Tire_Inc_Input>;
  _set?: InputMaybe<Inspection_Fk_Tire_Set_Input>;
  where: Inspection_Fk_Tire_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_Fk_Tire_By_PkArgs = {
  _inc?: InputMaybe<Inspection_Fk_Tire_Inc_Input>;
  _set?: InputMaybe<Inspection_Fk_Tire_Set_Input>;
  pk_columns: Inspection_Fk_Tire_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_Fk_Tire_ManyArgs = {
  updates: Array<Inspection_Fk_Tire_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Inspection_ManyArgs = {
  updates: Array<Inspection_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Instructor_SupervisionArgs = {
  _inc?: InputMaybe<Instructor_Supervision_Inc_Input>;
  _set?: InputMaybe<Instructor_Supervision_Set_Input>;
  where: Instructor_Supervision_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Instructor_Supervision_By_PkArgs = {
  _inc?: InputMaybe<Instructor_Supervision_Inc_Input>;
  _set?: InputMaybe<Instructor_Supervision_Set_Input>;
  pk_columns: Instructor_Supervision_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Instructor_Supervision_ManyArgs = {
  updates: Array<Instructor_Supervision_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Instructor_Supervision_ObservationArgs = {
  _set?: InputMaybe<Instructor_Supervision_Observation_Set_Input>;
  where: Instructor_Supervision_Observation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Instructor_Supervision_Observation_By_PkArgs = {
  _set?: InputMaybe<Instructor_Supervision_Observation_Set_Input>;
  pk_columns: Instructor_Supervision_Observation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Instructor_Supervision_Observation_ManyArgs = {
  updates: Array<Instructor_Supervision_Observation_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LevelArgs = {
  _inc?: InputMaybe<Level_Inc_Input>;
  _set?: InputMaybe<Level_Set_Input>;
  where: Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Level_By_PkArgs = {
  _inc?: InputMaybe<Level_Inc_Input>;
  _set?: InputMaybe<Level_Set_Input>;
  pk_columns: Level_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Level_ManyArgs = {
  updates: Array<Level_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Level_OptionArgs = {
  _inc?: InputMaybe<Level_Option_Inc_Input>;
  _set?: InputMaybe<Level_Option_Set_Input>;
  where: Level_Option_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Level_Option_By_PkArgs = {
  _inc?: InputMaybe<Level_Option_Inc_Input>;
  _set?: InputMaybe<Level_Option_Set_Input>;
  pk_columns: Level_Option_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Level_Option_ManyArgs = {
  updates: Array<Level_Option_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ModuleArgs = {
  _set?: InputMaybe<Module_Set_Input>;
  where: Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Module_By_PkArgs = {
  _set?: InputMaybe<Module_Set_Input>;
  pk_columns: Module_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Module_ManyArgs = {
  updates: Array<Module_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Module_PermissionArgs = {
  _set?: InputMaybe<Module_Permission_Set_Input>;
  where: Module_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Module_Permission_By_PkArgs = {
  _set?: InputMaybe<Module_Permission_Set_Input>;
  pk_columns: Module_Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Module_Permission_ManyArgs = {
  updates: Array<Module_Permission_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_NoteArgs = {
  _set?: InputMaybe<Note_Set_Input>;
  where: Note_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Note_By_PkArgs = {
  _set?: InputMaybe<Note_Set_Input>;
  pk_columns: Note_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Note_ManyArgs = {
  updates: Array<Note_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_NotificationArgs = {
  _append?: InputMaybe<Notification_Append_Input>;
  _delete_at_path?: InputMaybe<Notification_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Notification_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Notification_Delete_Key_Input>;
  _prepend?: InputMaybe<Notification_Prepend_Input>;
  _set?: InputMaybe<Notification_Set_Input>;
  where: Notification_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Notification_By_PkArgs = {
  _append?: InputMaybe<Notification_Append_Input>;
  _delete_at_path?: InputMaybe<Notification_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Notification_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Notification_Delete_Key_Input>;
  _prepend?: InputMaybe<Notification_Prepend_Input>;
  _set?: InputMaybe<Notification_Set_Input>;
  pk_columns: Notification_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Notification_ManyArgs = {
  updates: Array<Notification_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Planet_Osm_LineArgs = {
  _inc?: InputMaybe<Planet_Osm_Line_Inc_Input>;
  _set?: InputMaybe<Planet_Osm_Line_Set_Input>;
  where: Planet_Osm_Line_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Planet_Osm_Line_ManyArgs = {
  updates: Array<Planet_Osm_Line_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ProductArgs = {
  _inc?: InputMaybe<Product_Inc_Input>;
  _set?: InputMaybe<Product_Set_Input>;
  where: Product_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Product_By_PkArgs = {
  _inc?: InputMaybe<Product_Inc_Input>;
  _set?: InputMaybe<Product_Set_Input>;
  pk_columns: Product_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Product_ManyArgs = {
  updates: Array<Product_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Product_PriceArgs = {
  _inc?: InputMaybe<Product_Price_Inc_Input>;
  _set?: InputMaybe<Product_Price_Set_Input>;
  where: Product_Price_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Product_Price_By_PkArgs = {
  _inc?: InputMaybe<Product_Price_Inc_Input>;
  _set?: InputMaybe<Product_Price_Set_Input>;
  pk_columns: Product_Price_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Product_Price_ManyArgs = {
  updates: Array<Product_Price_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Product_RequestArgs = {
  _set?: InputMaybe<Product_Request_Set_Input>;
  where: Product_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Product_Request_By_PkArgs = {
  _set?: InputMaybe<Product_Request_Set_Input>;
  pk_columns: Product_Request_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Product_Request_ManyArgs = {
  updates: Array<Product_Request_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ProfileArgs = {
  _set?: InputMaybe<Profile_Set_Input>;
  where: Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_By_PkArgs = {
  _set?: InputMaybe<Profile_Set_Input>;
  pk_columns: Profile_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_ManyArgs = {
  updates: Array<Profile_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_PermissionArgs = {
  _set?: InputMaybe<Profile_Permission_Set_Input>;
  where: Profile_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_Permission_By_PkArgs = {
  _set?: InputMaybe<Profile_Permission_Set_Input>;
  pk_columns: Profile_Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_Permission_ManyArgs = {
  updates: Array<Profile_Permission_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Refresh_TokenArgs = {
  _set?: InputMaybe<Refresh_Token_Set_Input>;
  where: Refresh_Token_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Refresh_Token_By_PkArgs = {
  _set?: InputMaybe<Refresh_Token_Set_Input>;
  pk_columns: Refresh_Token_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Refresh_Token_ManyArgs = {
  updates: Array<Refresh_Token_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Score_ProcessedArgs = {
  _set?: InputMaybe<Score_Processed_Set_Input>;
  where: Score_Processed_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Score_Processed_By_PkArgs = {
  _set?: InputMaybe<Score_Processed_Set_Input>;
  pk_columns: Score_Processed_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Score_Processed_ManyArgs = {
  updates: Array<Score_Processed_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Score_TypeArgs = {
  _set?: InputMaybe<Score_Type_Set_Input>;
  where: Score_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Score_Type_By_PkArgs = {
  _set?: InputMaybe<Score_Type_Set_Input>;
  pk_columns: Score_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Score_Type_ManyArgs = {
  updates: Array<Score_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Status_Truck_HardwareArgs = {
  _inc?: InputMaybe<Status_Truck_Hardware_Inc_Input>;
  _set?: InputMaybe<Status_Truck_Hardware_Set_Input>;
  where: Status_Truck_Hardware_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Status_Truck_Hardware_By_PkArgs = {
  _inc?: InputMaybe<Status_Truck_Hardware_Inc_Input>;
  _set?: InputMaybe<Status_Truck_Hardware_Set_Input>;
  pk_columns: Status_Truck_Hardware_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Status_Truck_Hardware_By_Vehicle_PlatesArgs = {
  args: Update_Status_Truck_Hardware_By_Vehicle_Plates_Args;
  distinct_on?: InputMaybe<Array<Status_Truck_Hardware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Status_Truck_Hardware_Order_By>>;
  where?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootUpdate_Status_Truck_Hardware_ManyArgs = {
  updates: Array<Status_Truck_Hardware_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TireArgs = {
  _inc?: InputMaybe<Tire_Inc_Input>;
  _set?: InputMaybe<Tire_Set_Input>;
  where: Tire_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_By_PkArgs = {
  _inc?: InputMaybe<Tire_Inc_Input>;
  _set?: InputMaybe<Tire_Set_Input>;
  pk_columns: Tire_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_InspectionArgs = {
  _inc?: InputMaybe<Tire_Inspection_Inc_Input>;
  _set?: InputMaybe<Tire_Inspection_Set_Input>;
  where: Tire_Inspection_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_By_PkArgs = {
  _inc?: InputMaybe<Tire_Inspection_Inc_Input>;
  _set?: InputMaybe<Tire_Inspection_Set_Input>;
  pk_columns: Tire_Inspection_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Fk_TireArgs = {
  _inc?: InputMaybe<Tire_Inspection_Fk_Tire_Inc_Input>;
  _set?: InputMaybe<Tire_Inspection_Fk_Tire_Set_Input>;
  where: Tire_Inspection_Fk_Tire_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Fk_Tire_By_PkArgs = {
  _inc?: InputMaybe<Tire_Inspection_Fk_Tire_Inc_Input>;
  _set?: InputMaybe<Tire_Inspection_Fk_Tire_Set_Input>;
  pk_columns: Tire_Inspection_Fk_Tire_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Fk_Tire_ManyArgs = {
  updates: Array<Tire_Inspection_Fk_Tire_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_ManyArgs = {
  updates: Array<Tire_Inspection_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_NoteArgs = {
  _set?: InputMaybe<Tire_Inspection_Note_Set_Input>;
  where: Tire_Inspection_Note_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Note_AttachmentArgs = {
  _set?: InputMaybe<Tire_Inspection_Note_Attachment_Set_Input>;
  where: Tire_Inspection_Note_Attachment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Note_Attachment_By_PkArgs = {
  _set?: InputMaybe<Tire_Inspection_Note_Attachment_Set_Input>;
  pk_columns: Tire_Inspection_Note_Attachment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Note_Attachment_ManyArgs = {
  updates: Array<Tire_Inspection_Note_Attachment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Note_By_PkArgs = {
  _set?: InputMaybe<Tire_Inspection_Note_Set_Input>;
  pk_columns: Tire_Inspection_Note_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Note_ManyArgs = {
  updates: Array<Tire_Inspection_Note_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_OriginArgs = {
  _set?: InputMaybe<Tire_Inspection_Origin_Set_Input>;
  where: Tire_Inspection_Origin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Origin_By_PkArgs = {
  _set?: InputMaybe<Tire_Inspection_Origin_Set_Input>;
  pk_columns: Tire_Inspection_Origin_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Inspection_Origin_ManyArgs = {
  updates: Array<Tire_Inspection_Origin_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_ManyArgs = {
  updates: Array<Tire_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Note_TypeArgs = {
  _set?: InputMaybe<Tire_Note_Type_Set_Input>;
  where: Tire_Note_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Note_Type_By_PkArgs = {
  _set?: InputMaybe<Tire_Note_Type_Set_Input>;
  pk_columns: Tire_Note_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Note_Type_ManyArgs = {
  updates: Array<Tire_Note_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_ParameterArgs = {
  _set?: InputMaybe<Tire_Parameter_Set_Input>;
  where: Tire_Parameter_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Parameter_By_PkArgs = {
  _set?: InputMaybe<Tire_Parameter_Set_Input>;
  pk_columns: Tire_Parameter_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Parameter_ManyArgs = {
  updates: Array<Tire_Parameter_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Processing_HistoryArgs = {
  _inc?: InputMaybe<Tire_Processing_History_Inc_Input>;
  _set?: InputMaybe<Tire_Processing_History_Set_Input>;
  where: Tire_Processing_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Processing_History_By_PkArgs = {
  _inc?: InputMaybe<Tire_Processing_History_Inc_Input>;
  _set?: InputMaybe<Tire_Processing_History_Set_Input>;
  pk_columns: Tire_Processing_History_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tire_Processing_History_ManyArgs = {
  updates: Array<Tire_Processing_History_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Tirecheck_InconsistencyArgs = {
  _set?: InputMaybe<Tirecheck_Inconsistency_Set_Input>;
  where: Tirecheck_Inconsistency_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tirecheck_Inconsistency_By_PkArgs = {
  _set?: InputMaybe<Tirecheck_Inconsistency_Set_Input>;
  pk_columns: Tirecheck_Inconsistency_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tirecheck_Inconsistency_ManyArgs = {
  updates: Array<Tirecheck_Inconsistency_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TrainingArgs = {
  _inc?: InputMaybe<Training_Inc_Input>;
  _set?: InputMaybe<Training_Set_Input>;
  where: Training_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Training_By_PkArgs = {
  _inc?: InputMaybe<Training_Inc_Input>;
  _set?: InputMaybe<Training_Set_Input>;
  pk_columns: Training_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Training_DocumentArgs = {
  _inc?: InputMaybe<Training_Document_Inc_Input>;
  _set?: InputMaybe<Training_Document_Set_Input>;
  where: Training_Document_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Training_Document_By_PkArgs = {
  _inc?: InputMaybe<Training_Document_Inc_Input>;
  _set?: InputMaybe<Training_Document_Set_Input>;
  pk_columns: Training_Document_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Training_Document_ManyArgs = {
  updates: Array<Training_Document_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Training_Document_ViewArgs = {
  _set?: InputMaybe<Training_Document_View_Set_Input>;
  where: Training_Document_View_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Training_Document_View_By_PkArgs = {
  _set?: InputMaybe<Training_Document_View_Set_Input>;
  pk_columns: Training_Document_View_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Training_Document_View_ManyArgs = {
  updates: Array<Training_Document_View_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Training_ManyArgs = {
  updates: Array<Training_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UserArgs = {
  _set?: InputMaybe<User_Set_Input>;
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_By_PkArgs = {
  _set?: InputMaybe<User_Set_Input>;
  pk_columns: User_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_AchievementArgs = {
  _set?: InputMaybe<User_Fk_Achievement_Set_Input>;
  where: User_Fk_Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Achievement_By_PkArgs = {
  _set?: InputMaybe<User_Fk_Achievement_Set_Input>;
  pk_columns: User_Fk_Achievement_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Achievement_ManyArgs = {
  updates: Array<User_Fk_Achievement_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_ChallengeArgs = {
  _inc?: InputMaybe<User_Fk_Challenge_Inc_Input>;
  _set?: InputMaybe<User_Fk_Challenge_Set_Input>;
  where: User_Fk_Challenge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Challenge_By_PkArgs = {
  _inc?: InputMaybe<User_Fk_Challenge_Inc_Input>;
  _set?: InputMaybe<User_Fk_Challenge_Set_Input>;
  pk_columns: User_Fk_Challenge_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Challenge_ManyArgs = {
  updates: Array<User_Fk_Challenge_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_LevelArgs = {
  _inc?: InputMaybe<User_Fk_Level_Inc_Input>;
  _set?: InputMaybe<User_Fk_Level_Set_Input>;
  where: User_Fk_Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Level_By_PkArgs = {
  _inc?: InputMaybe<User_Fk_Level_Inc_Input>;
  _set?: InputMaybe<User_Fk_Level_Set_Input>;
  pk_columns: User_Fk_Level_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Level_ManyArgs = {
  updates: Array<User_Fk_Level_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_NotificationArgs = {
  _set?: InputMaybe<User_Fk_Notification_Set_Input>;
  where: User_Fk_Notification_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Notification_By_PkArgs = {
  _set?: InputMaybe<User_Fk_Notification_Set_Input>;
  pk_columns: User_Fk_Notification_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Notification_ManyArgs = {
  updates: Array<User_Fk_Notification_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Privacy_PolicyArgs = {
  _set?: InputMaybe<User_Fk_Privacy_Policy_Set_Input>;
  where: User_Fk_Privacy_Policy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Privacy_Policy_By_PkArgs = {
  _set?: InputMaybe<User_Fk_Privacy_Policy_Set_Input>;
  pk_columns: User_Fk_Privacy_Policy_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Fk_Privacy_Policy_ManyArgs = {
  updates: Array<User_Fk_Privacy_Policy_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Km_Points_ApprovalArgs = {
  _inc?: InputMaybe<User_Km_Points_Approval_Inc_Input>;
  _set?: InputMaybe<User_Km_Points_Approval_Set_Input>;
  where: User_Km_Points_Approval_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Km_Points_Approval_By_PkArgs = {
  _inc?: InputMaybe<User_Km_Points_Approval_Inc_Input>;
  _set?: InputMaybe<User_Km_Points_Approval_Set_Input>;
  pk_columns: User_Km_Points_Approval_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Km_Points_Approval_ManyArgs = {
  updates: Array<User_Km_Points_Approval_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_KmpsArgs = {
  _inc?: InputMaybe<User_Kmps_Inc_Input>;
  _set?: InputMaybe<User_Kmps_Set_Input>;
  where: User_Kmps_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Kmps_By_PkArgs = {
  _inc?: InputMaybe<User_Kmps_Inc_Input>;
  _set?: InputMaybe<User_Kmps_Set_Input>;
  pk_columns: User_Kmps_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Kmps_ManyArgs = {
  updates: Array<User_Kmps_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_ManyArgs = {
  updates: Array<User_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_ScoreArgs = {
  _inc?: InputMaybe<User_Score_Inc_Input>;
  _set?: InputMaybe<User_Score_Set_Input>;
  where: User_Score_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Score_By_PkArgs = {
  _inc?: InputMaybe<User_Score_Inc_Input>;
  _set?: InputMaybe<User_Score_Set_Input>;
  pk_columns: User_Score_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Score_ManyArgs = {
  updates: Array<User_Score_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_TrainingArgs = {
  _set?: InputMaybe<User_Training_Set_Input>;
  where: User_Training_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Training_By_PkArgs = {
  _set?: InputMaybe<User_Training_Set_Input>;
  pk_columns: User_Training_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Training_ManyArgs = {
  updates: Array<User_Training_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_VehicleArgs = {
  _set?: InputMaybe<Vehicle_Set_Input>;
  where: Vehicle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Vehicle_By_PkArgs = {
  _set?: InputMaybe<Vehicle_Set_Input>;
  pk_columns: Vehicle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Vehicle_ManyArgs = {
  updates: Array<Vehicle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_EventArgs = {
  _append?: InputMaybe<Whatsapp_Event_Append_Input>;
  _delete_at_path?: InputMaybe<Whatsapp_Event_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Whatsapp_Event_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Whatsapp_Event_Delete_Key_Input>;
  _inc?: InputMaybe<Whatsapp_Event_Inc_Input>;
  _prepend?: InputMaybe<Whatsapp_Event_Prepend_Input>;
  _set?: InputMaybe<Whatsapp_Event_Set_Input>;
  where: Whatsapp_Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Event_By_PkArgs = {
  _append?: InputMaybe<Whatsapp_Event_Append_Input>;
  _delete_at_path?: InputMaybe<Whatsapp_Event_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Whatsapp_Event_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Whatsapp_Event_Delete_Key_Input>;
  _inc?: InputMaybe<Whatsapp_Event_Inc_Input>;
  _prepend?: InputMaybe<Whatsapp_Event_Prepend_Input>;
  _set?: InputMaybe<Whatsapp_Event_Set_Input>;
  pk_columns: Whatsapp_Event_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Event_ManyArgs = {
  updates: Array<Whatsapp_Event_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_MessageArgs = {
  _set?: InputMaybe<Whatsapp_Message_Set_Input>;
  where: Whatsapp_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Message_By_PkArgs = {
  _set?: InputMaybe<Whatsapp_Message_Set_Input>;
  pk_columns: Whatsapp_Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Message_HistoryArgs = {
  _set?: InputMaybe<Whatsapp_Message_History_Set_Input>;
  where: Whatsapp_Message_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Message_History_By_PkArgs = {
  _set?: InputMaybe<Whatsapp_Message_History_Set_Input>;
  pk_columns: Whatsapp_Message_History_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Message_History_ManyArgs = {
  updates: Array<Whatsapp_Message_History_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Message_ManyArgs = {
  updates: Array<Whatsapp_Message_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_TriggerArgs = {
  _inc?: InputMaybe<Whatsapp_Trigger_Inc_Input>;
  _set?: InputMaybe<Whatsapp_Trigger_Set_Input>;
  where: Whatsapp_Trigger_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Trigger_By_PkArgs = {
  _inc?: InputMaybe<Whatsapp_Trigger_Inc_Input>;
  _set?: InputMaybe<Whatsapp_Trigger_Set_Input>;
  pk_columns: Whatsapp_Trigger_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Whatsapp_Trigger_ManyArgs = {
  updates: Array<Whatsapp_Trigger_Updates>;
};

/** next_tire_processing_date_rangeNative Query Arguments */
export type Next_Tire_Processing_Date_Range_Arguments = {
  company_name: Scalars['String']['input'];
};

export type Next_Tire_Processing_Unit = {
  __typename?: 'next_tire_processing_unit';
  next_end_at: Scalars['timestamptz']['output'];
  next_start_at: Scalars['timestamptz']['output'];
};

/** Boolean expression to filter rows from the logical model for "next_tire_processing_unit". All fields are combined with a logical 'AND'. */
export type Next_Tire_Processing_Unit_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<Next_Tire_Processing_Unit_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<Next_Tire_Processing_Unit_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<Next_Tire_Processing_Unit_Bool_Exp_Bool_Exp>>;
  next_end_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  next_start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

export enum Next_Tire_Processing_Unit_Enum_Name {
  /** column name */
  NextEndAt = 'next_end_at',
  /** column name */
  NextStartAt = 'next_start_at'
}

/** Ordering options when selecting data from "next_tire_processing_unit". */
export type Next_Tire_Processing_Unit_Order_By = {
  next_end_at?: InputMaybe<Order_By>;
  next_start_at?: InputMaybe<Order_By>;
};

/** columns and relationships of "note" */
export type Note = {
  __typename?: 'note';
  action: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  description: Scalars['String']['output'];
  /** An object relationship */
  inspection: Inspection;
  inspection_id: Scalars['String']['output'];
  /** An object relationship */
  tire: Tire;
  tire_id: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "note" */
export type Note_Aggregate = {
  __typename?: 'note_aggregate';
  aggregate: Maybe<Note_Aggregate_Fields>;
  nodes: Array<Note>;
};

export type Note_Aggregate_Bool_Exp = {
  count?: InputMaybe<Note_Aggregate_Bool_Exp_Count>;
};

export type Note_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Note_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Note_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "note" */
export type Note_Aggregate_Fields = {
  __typename?: 'note_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Note_Max_Fields>;
  min: Maybe<Note_Min_Fields>;
};


/** aggregate fields of "note" */
export type Note_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Note_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "note" */
export type Note_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Note_Max_Order_By>;
  min?: InputMaybe<Note_Min_Order_By>;
};

/** input type for inserting array relation for remote table "note" */
export type Note_Arr_Rel_Insert_Input = {
  data: Array<Note_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Note_On_Conflict>;
};

/** Boolean expression to filter rows from the table "note". All fields are combined with a logical 'AND'. */
export type Note_Bool_Exp = {
  _and?: InputMaybe<Array<Note_Bool_Exp>>;
  _not?: InputMaybe<Note_Bool_Exp>;
  _or?: InputMaybe<Array<Note_Bool_Exp>>;
  action?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  inspection?: InputMaybe<Inspection_Bool_Exp>;
  inspection_id?: InputMaybe<String_Comparison_Exp>;
  tire?: InputMaybe<Tire_Bool_Exp>;
  tire_id?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "note" */
export enum Note_Constraint {
  /** unique or primary key constraint on columns "action", "tire_id", "description", "inspection_id" */
  NoteInspectionIdTireIdActionDescriptionKey = 'note_inspection_id_tire_id_action_description_key',
  /** unique or primary key constraint on columns "uuid" */
  NotePkey = 'note_pkey'
}

/** input type for inserting data into table "note" */
export type Note_Insert_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  inspection?: InputMaybe<Inspection_Obj_Rel_Insert_Input>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  tire?: InputMaybe<Tire_Obj_Rel_Insert_Input>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Note_Max_Fields = {
  __typename?: 'note_max_fields';
  action: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "note" */
export type Note_Max_Order_By = {
  action?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Note_Min_Fields = {
  __typename?: 'note_min_fields';
  action: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  tire_id: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "note" */
export type Note_Min_Order_By = {
  action?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "note" */
export type Note_Mutation_Response = {
  __typename?: 'note_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Note>;
};

/** on_conflict condition type for table "note" */
export type Note_On_Conflict = {
  constraint: Note_Constraint;
  update_columns?: Array<Note_Update_Column>;
  where?: InputMaybe<Note_Bool_Exp>;
};

/** Ordering options when selecting data from "note". */
export type Note_Order_By = {
  action?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  inspection?: InputMaybe<Inspection_Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  tire?: InputMaybe<Tire_Order_By>;
  tire_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: note */
export type Note_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "note" */
export enum Note_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "note" */
export type Note_Set_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "note" */
export type Note_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Note_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Note_Stream_Cursor_Value_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  tire_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "note" */
export enum Note_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Note_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Note_Set_Input>;
  /** filter the rows which have to be updated */
  where: Note_Bool_Exp;
};

/** Store notifications sended for specific users */
export type Notification = {
  __typename?: 'notification';
  /** An object relationship */
  admin: Maybe<Admin>;
  /** An array relationship */
  admin_fk_notifications: Array<Admin_Fk_Notifications>;
  /** An aggregate relationship */
  admin_fk_notifications_aggregate: Admin_Fk_Notifications_Aggregate;
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents: Scalars['jsonb']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings: Scalars['jsonb']['output'];
  /** An image that will be shown on the notification */
  large_icon: Maybe<Scalars['String']['output']>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id: Maybe<Scalars['String']['output']>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  /** When this notification was sent by OneSignal */
  sent_at: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  user_fk_notifications: Array<User_Fk_Notification>;
  /** An aggregate relationship */
  user_fk_notifications_aggregate: User_Fk_Notification_Aggregate;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid: Scalars['uuid']['output'];
};


/** Store notifications sended for specific users */
export type NotificationAdmin_Fk_NotificationsArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


/** Store notifications sended for specific users */
export type NotificationAdmin_Fk_Notifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


/** Store notifications sended for specific users */
export type NotificationContentsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Store notifications sended for specific users */
export type NotificationHeadingsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Store notifications sended for specific users */
export type NotificationUser_Fk_NotificationsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


/** Store notifications sended for specific users */
export type NotificationUser_Fk_Notifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};

/** aggregated selection of "notification" */
export type Notification_Aggregate = {
  __typename?: 'notification_aggregate';
  aggregate: Maybe<Notification_Aggregate_Fields>;
  nodes: Array<Notification>;
};

export type Notification_Aggregate_Bool_Exp = {
  count?: InputMaybe<Notification_Aggregate_Bool_Exp_Count>;
};

export type Notification_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Notification_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Notification_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "notification" */
export type Notification_Aggregate_Fields = {
  __typename?: 'notification_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Notification_Max_Fields>;
  min: Maybe<Notification_Min_Fields>;
};


/** aggregate fields of "notification" */
export type Notification_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Notification_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "notification" */
export type Notification_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Notification_Max_Order_By>;
  min?: InputMaybe<Notification_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Notification_Append_Input = {
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Scalars['jsonb']['input']>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "notification" */
export type Notification_Arr_Rel_Insert_Input = {
  data: Array<Notification_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Notification_On_Conflict>;
};

/** Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'. */
export type Notification_Bool_Exp = {
  _and?: InputMaybe<Array<Notification_Bool_Exp>>;
  _not?: InputMaybe<Notification_Bool_Exp>;
  _or?: InputMaybe<Array<Notification_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_fk_notifications?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
  admin_fk_notifications_aggregate?: InputMaybe<Admin_Fk_Notifications_Aggregate_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  contents?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  headings?: InputMaybe<Jsonb_Comparison_Exp>;
  large_icon?: InputMaybe<String_Comparison_Exp>;
  notification_id?: InputMaybe<String_Comparison_Exp>;
  score_processed_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  sent_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_fk_notifications?: InputMaybe<User_Fk_Notification_Bool_Exp>;
  user_fk_notifications_aggregate?: InputMaybe<User_Fk_Notification_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "notification" */
export enum Notification_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserNotificationPkey = 'user_notification_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Notification_Delete_At_Path_Input = {
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Notification_Delete_Elem_Input = {
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Scalars['Int']['input']>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Notification_Delete_Key_Input = {
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Scalars['String']['input']>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "notification" */
export type Notification_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  admin_fk_notifications?: InputMaybe<Admin_Fk_Notifications_Arr_Rel_Insert_Input>;
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Scalars['jsonb']['input']>;
  /** An image that will be shown on the notification */
  large_icon?: InputMaybe<Scalars['String']['input']>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id?: InputMaybe<Scalars['String']['input']>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** When this notification was sent by OneSignal */
  sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_fk_notifications?: InputMaybe<User_Fk_Notification_Arr_Rel_Insert_Input>;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Notification_Max_Fields = {
  __typename?: 'notification_max_fields';
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** An image that will be shown on the notification */
  large_icon: Maybe<Scalars['String']['output']>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id: Maybe<Scalars['String']['output']>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  /** When this notification was sent by OneSignal */
  sent_at: Maybe<Scalars['timestamptz']['output']>;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "notification" */
export type Notification_Max_Order_By = {
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** An image that will be shown on the notification */
  large_icon?: InputMaybe<Order_By>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id?: InputMaybe<Order_By>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid?: InputMaybe<Order_By>;
  /** When this notification was sent by OneSignal */
  sent_at?: InputMaybe<Order_By>;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Notification_Min_Fields = {
  __typename?: 'notification_min_fields';
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** An image that will be shown on the notification */
  large_icon: Maybe<Scalars['String']['output']>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id: Maybe<Scalars['String']['output']>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  /** When this notification was sent by OneSignal */
  sent_at: Maybe<Scalars['timestamptz']['output']>;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "notification" */
export type Notification_Min_Order_By = {
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** An image that will be shown on the notification */
  large_icon?: InputMaybe<Order_By>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id?: InputMaybe<Order_By>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid?: InputMaybe<Order_By>;
  /** When this notification was sent by OneSignal */
  sent_at?: InputMaybe<Order_By>;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "notification" */
export type Notification_Mutation_Response = {
  __typename?: 'notification_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Notification>;
};

/** input type for inserting object relation for remote table "notification" */
export type Notification_Obj_Rel_Insert_Input = {
  data: Notification_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Notification_On_Conflict>;
};

/** on_conflict condition type for table "notification" */
export type Notification_On_Conflict = {
  constraint: Notification_Constraint;
  update_columns?: Array<Notification_Update_Column>;
  where?: InputMaybe<Notification_Bool_Exp>;
};

/** Ordering options when selecting data from "notification". */
export type Notification_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_fk_notifications_aggregate?: InputMaybe<Admin_Fk_Notifications_Aggregate_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  contents?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  headings?: InputMaybe<Order_By>;
  large_icon?: InputMaybe<Order_By>;
  notification_id?: InputMaybe<Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  sent_at?: InputMaybe<Order_By>;
  user_fk_notifications_aggregate?: InputMaybe<User_Fk_Notification_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: notification */
export type Notification_Pk_Columns_Input = {
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Notification_Prepend_Input = {
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Scalars['jsonb']['input']>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "notification" */
export enum Notification_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  Contents = 'contents',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Headings = 'headings',
  /** column name */
  LargeIcon = 'large_icon',
  /** column name */
  NotificationId = 'notification_id',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  SentAt = 'sent_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "notification" */
export type Notification_Set_Input = {
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Scalars['jsonb']['input']>;
  /** An image that will be shown on the notification */
  large_icon?: InputMaybe<Scalars['String']['input']>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id?: InputMaybe<Scalars['String']['input']>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** When this notification was sent by OneSignal */
  sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "notification" */
export type Notification_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Notification_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Notification_Stream_Cursor_Value_Input = {
  /** The admin that created this notification. Can be null if was created by the system */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** This is the "title" of the push message. {"en": "English Title", "es": "Spanish Title"} */
  contents?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The notification's content (excluding the title), a map of language codes to text for each language. {"en": "English Message", "es": "Spanish Message"} */
  headings?: InputMaybe<Scalars['jsonb']['input']>;
  /** An image that will be shown on the notification */
  large_icon?: InputMaybe<Scalars['String']['input']>;
  /** The notification id provided by OneSignal after the notification was sent */
  notification_id?: InputMaybe<Scalars['String']['input']>;
  /** If this notification is about a ranking, this field is fullfilled with the corresponding score_processed */
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** When this notification was sent by OneSignal */
  sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The identifier of this notification. It is used as external_id on OneSignal, therefore if it was sended twice the user will get only one notification */
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "notification" */
export enum Notification_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  Contents = 'contents',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Headings = 'headings',
  /** column name */
  LargeIcon = 'large_icon',
  /** column name */
  NotificationId = 'notification_id',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  SentAt = 'sent_at',
  /** column name */
  Uuid = 'uuid'
}

export type Notification_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Notification_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Notification_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Notification_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Notification_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Notification_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Notification_Set_Input>;
  /** filter the rows which have to be updated */
  where: Notification_Bool_Exp;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['numeric']['input']>;
  _gt?: InputMaybe<Scalars['numeric']['input']>;
  _gte?: InputMaybe<Scalars['numeric']['input']>;
  _in?: InputMaybe<Array<Scalars['numeric']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['numeric']['input']>;
  _lte?: InputMaybe<Scalars['numeric']['input']>;
  _neq?: InputMaybe<Scalars['numeric']['input']>;
  _nin?: InputMaybe<Array<Scalars['numeric']['input']>>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls first */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls last */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "planet_osm_line" */
export type Planet_Osm_Line = {
  __typename?: 'planet_osm_line';
  highway: Maybe<Scalars['String']['output']>;
  maxheight: Maybe<Scalars['String']['output']>;
  maxspeed: Maybe<Scalars['String']['output']>;
  maxspeed_hgv: Maybe<Scalars['String']['output']>;
  maxweight: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  osm_id: Maybe<Scalars['bigint']['output']>;
  ref: Maybe<Scalars['String']['output']>;
  service: Maybe<Scalars['String']['output']>;
  tags: Maybe<Scalars['hstore']['output']>;
  toll: Maybe<Scalars['String']['output']>;
  way: Maybe<Scalars['geometry']['output']>;
};

/** aggregated selection of "planet_osm_line" */
export type Planet_Osm_Line_Aggregate = {
  __typename?: 'planet_osm_line_aggregate';
  aggregate: Maybe<Planet_Osm_Line_Aggregate_Fields>;
  nodes: Array<Planet_Osm_Line>;
};

/** aggregate fields of "planet_osm_line" */
export type Planet_Osm_Line_Aggregate_Fields = {
  __typename?: 'planet_osm_line_aggregate_fields';
  avg: Maybe<Planet_Osm_Line_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Planet_Osm_Line_Max_Fields>;
  min: Maybe<Planet_Osm_Line_Min_Fields>;
  stddev: Maybe<Planet_Osm_Line_Stddev_Fields>;
  stddev_pop: Maybe<Planet_Osm_Line_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Planet_Osm_Line_Stddev_Samp_Fields>;
  sum: Maybe<Planet_Osm_Line_Sum_Fields>;
  var_pop: Maybe<Planet_Osm_Line_Var_Pop_Fields>;
  var_samp: Maybe<Planet_Osm_Line_Var_Samp_Fields>;
  variance: Maybe<Planet_Osm_Line_Variance_Fields>;
};


/** aggregate fields of "planet_osm_line" */
export type Planet_Osm_Line_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Planet_Osm_Line_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Planet_Osm_Line_Avg_Fields = {
  __typename?: 'planet_osm_line_avg_fields';
  osm_id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "planet_osm_line". All fields are combined with a logical 'AND'. */
export type Planet_Osm_Line_Bool_Exp = {
  _and?: InputMaybe<Array<Planet_Osm_Line_Bool_Exp>>;
  _not?: InputMaybe<Planet_Osm_Line_Bool_Exp>;
  _or?: InputMaybe<Array<Planet_Osm_Line_Bool_Exp>>;
  highway?: InputMaybe<String_Comparison_Exp>;
  maxheight?: InputMaybe<String_Comparison_Exp>;
  maxspeed?: InputMaybe<String_Comparison_Exp>;
  maxspeed_hgv?: InputMaybe<String_Comparison_Exp>;
  maxweight?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  osm_id?: InputMaybe<Bigint_Comparison_Exp>;
  ref?: InputMaybe<String_Comparison_Exp>;
  service?: InputMaybe<String_Comparison_Exp>;
  tags?: InputMaybe<Hstore_Comparison_Exp>;
  toll?: InputMaybe<String_Comparison_Exp>;
  way?: InputMaybe<Geometry_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "planet_osm_line" */
export type Planet_Osm_Line_Inc_Input = {
  osm_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "planet_osm_line" */
export type Planet_Osm_Line_Insert_Input = {
  highway?: InputMaybe<Scalars['String']['input']>;
  maxheight?: InputMaybe<Scalars['String']['input']>;
  maxspeed?: InputMaybe<Scalars['String']['input']>;
  maxspeed_hgv?: InputMaybe<Scalars['String']['input']>;
  maxweight?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  osm_id?: InputMaybe<Scalars['bigint']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  service?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['hstore']['input']>;
  toll?: InputMaybe<Scalars['String']['input']>;
  way?: InputMaybe<Scalars['geometry']['input']>;
};

/** aggregate max on columns */
export type Planet_Osm_Line_Max_Fields = {
  __typename?: 'planet_osm_line_max_fields';
  highway: Maybe<Scalars['String']['output']>;
  maxheight: Maybe<Scalars['String']['output']>;
  maxspeed: Maybe<Scalars['String']['output']>;
  maxspeed_hgv: Maybe<Scalars['String']['output']>;
  maxweight: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  osm_id: Maybe<Scalars['bigint']['output']>;
  ref: Maybe<Scalars['String']['output']>;
  service: Maybe<Scalars['String']['output']>;
  toll: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Planet_Osm_Line_Min_Fields = {
  __typename?: 'planet_osm_line_min_fields';
  highway: Maybe<Scalars['String']['output']>;
  maxheight: Maybe<Scalars['String']['output']>;
  maxspeed: Maybe<Scalars['String']['output']>;
  maxspeed_hgv: Maybe<Scalars['String']['output']>;
  maxweight: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  osm_id: Maybe<Scalars['bigint']['output']>;
  ref: Maybe<Scalars['String']['output']>;
  service: Maybe<Scalars['String']['output']>;
  toll: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "planet_osm_line" */
export type Planet_Osm_Line_Mutation_Response = {
  __typename?: 'planet_osm_line_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Planet_Osm_Line>;
};

/** Ordering options when selecting data from "planet_osm_line". */
export type Planet_Osm_Line_Order_By = {
  highway?: InputMaybe<Order_By>;
  maxheight?: InputMaybe<Order_By>;
  maxspeed?: InputMaybe<Order_By>;
  maxspeed_hgv?: InputMaybe<Order_By>;
  maxweight?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  osm_id?: InputMaybe<Order_By>;
  ref?: InputMaybe<Order_By>;
  service?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  toll?: InputMaybe<Order_By>;
  way?: InputMaybe<Order_By>;
};

/** select columns of table "planet_osm_line" */
export enum Planet_Osm_Line_Select_Column {
  /** column name */
  Highway = 'highway',
  /** column name */
  Maxheight = 'maxheight',
  /** column name */
  Maxspeed = 'maxspeed',
  /** column name */
  MaxspeedHgv = 'maxspeed_hgv',
  /** column name */
  Maxweight = 'maxweight',
  /** column name */
  Name = 'name',
  /** column name */
  OsmId = 'osm_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Service = 'service',
  /** column name */
  Tags = 'tags',
  /** column name */
  Toll = 'toll',
  /** column name */
  Way = 'way'
}

/** input type for updating data in table "planet_osm_line" */
export type Planet_Osm_Line_Set_Input = {
  highway?: InputMaybe<Scalars['String']['input']>;
  maxheight?: InputMaybe<Scalars['String']['input']>;
  maxspeed?: InputMaybe<Scalars['String']['input']>;
  maxspeed_hgv?: InputMaybe<Scalars['String']['input']>;
  maxweight?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  osm_id?: InputMaybe<Scalars['bigint']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  service?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['hstore']['input']>;
  toll?: InputMaybe<Scalars['String']['input']>;
  way?: InputMaybe<Scalars['geometry']['input']>;
};

/** aggregate stddev on columns */
export type Planet_Osm_Line_Stddev_Fields = {
  __typename?: 'planet_osm_line_stddev_fields';
  osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Planet_Osm_Line_Stddev_Pop_Fields = {
  __typename?: 'planet_osm_line_stddev_pop_fields';
  osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Planet_Osm_Line_Stddev_Samp_Fields = {
  __typename?: 'planet_osm_line_stddev_samp_fields';
  osm_id: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "planet_osm_line" */
export type Planet_Osm_Line_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Planet_Osm_Line_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Planet_Osm_Line_Stream_Cursor_Value_Input = {
  highway?: InputMaybe<Scalars['String']['input']>;
  maxheight?: InputMaybe<Scalars['String']['input']>;
  maxspeed?: InputMaybe<Scalars['String']['input']>;
  maxspeed_hgv?: InputMaybe<Scalars['String']['input']>;
  maxweight?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  osm_id?: InputMaybe<Scalars['bigint']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  service?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['hstore']['input']>;
  toll?: InputMaybe<Scalars['String']['input']>;
  way?: InputMaybe<Scalars['geometry']['input']>;
};

/** aggregate sum on columns */
export type Planet_Osm_Line_Sum_Fields = {
  __typename?: 'planet_osm_line_sum_fields';
  osm_id: Maybe<Scalars['bigint']['output']>;
};

export type Planet_Osm_Line_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Planet_Osm_Line_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Planet_Osm_Line_Set_Input>;
  /** filter the rows which have to be updated */
  where: Planet_Osm_Line_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Planet_Osm_Line_Var_Pop_Fields = {
  __typename?: 'planet_osm_line_var_pop_fields';
  osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Planet_Osm_Line_Var_Samp_Fields = {
  __typename?: 'planet_osm_line_var_samp_fields';
  osm_id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Planet_Osm_Line_Variance_Fields = {
  __typename?: 'planet_osm_line_variance_fields';
  osm_id: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "product" */
export type Product = {
  __typename?: 'product';
  carrousel_order: Maybe<Scalars['Int']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "current_product_price" */
  current_product_price: Maybe<Array<Product_Price>>;
  enabled: Scalars['Boolean']['output'];
  image_url: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  product_prices: Array<Product_Price>;
  /** An aggregate relationship */
  product_prices_aggregate: Product_Price_Aggregate;
  quantity: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "product" */
export type ProductCurrent_Product_PriceArgs = {
  distinct_on?: InputMaybe<Array<Product_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Price_Order_By>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};


/** columns and relationships of "product" */
export type ProductProduct_PricesArgs = {
  distinct_on?: InputMaybe<Array<Product_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Price_Order_By>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};


/** columns and relationships of "product" */
export type ProductProduct_Prices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Price_Order_By>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};

/** aggregated selection of "product" */
export type Product_Aggregate = {
  __typename?: 'product_aggregate';
  aggregate: Maybe<Product_Aggregate_Fields>;
  nodes: Array<Product>;
};

/** aggregate fields of "product" */
export type Product_Aggregate_Fields = {
  __typename?: 'product_aggregate_fields';
  avg: Maybe<Product_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Product_Max_Fields>;
  min: Maybe<Product_Min_Fields>;
  stddev: Maybe<Product_Stddev_Fields>;
  stddev_pop: Maybe<Product_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Product_Stddev_Samp_Fields>;
  sum: Maybe<Product_Sum_Fields>;
  var_pop: Maybe<Product_Var_Pop_Fields>;
  var_samp: Maybe<Product_Var_Samp_Fields>;
  variance: Maybe<Product_Variance_Fields>;
};


/** aggregate fields of "product" */
export type Product_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Product_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Product_Avg_Fields = {
  __typename?: 'product_avg_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "product". All fields are combined with a logical 'AND'. */
export type Product_Bool_Exp = {
  _and?: InputMaybe<Array<Product_Bool_Exp>>;
  _not?: InputMaybe<Product_Bool_Exp>;
  _or?: InputMaybe<Array<Product_Bool_Exp>>;
  carrousel_order?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  current_price?: InputMaybe<Int_Comparison_Exp>;
  current_product_price?: InputMaybe<Product_Price_Bool_Exp>;
  enabled?: InputMaybe<Boolean_Comparison_Exp>;
  image_url?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  product_prices?: InputMaybe<Product_Price_Bool_Exp>;
  product_prices_aggregate?: InputMaybe<Product_Price_Aggregate_Bool_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "product" */
export enum Product_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  ProductPkey = 'product_pkey'
}

/** input type for incrementing numeric columns in table "product" */
export type Product_Inc_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "product" */
export type Product_Insert_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  product_prices?: InputMaybe<Product_Price_Arr_Rel_Insert_Input>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Product_Max_Fields = {
  __typename?: 'product_max_fields';
  carrousel_order: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  image_url: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  quantity: Maybe<Scalars['Int']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Product_Min_Fields = {
  __typename?: 'product_min_fields';
  carrousel_order: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  image_url: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  quantity: Maybe<Scalars['Int']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "product" */
export type Product_Mutation_Response = {
  __typename?: 'product_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Product>;
};

/** input type for inserting object relation for remote table "product" */
export type Product_Obj_Rel_Insert_Input = {
  data: Product_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Product_On_Conflict>;
};

/** on_conflict condition type for table "product" */
export type Product_On_Conflict = {
  constraint: Product_Constraint;
  update_columns?: Array<Product_Update_Column>;
  where?: InputMaybe<Product_Bool_Exp>;
};

/** Ordering options when selecting data from "product". */
export type Product_Order_By = {
  carrousel_order?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  current_price?: InputMaybe<Order_By>;
  current_product_price_aggregate?: InputMaybe<Product_Price_Aggregate_Order_By>;
  enabled?: InputMaybe<Order_By>;
  image_url?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  product_prices_aggregate?: InputMaybe<Product_Price_Aggregate_Order_By>;
  quantity?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: product */
export type Product_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "product_price" */
export type Product_Price = {
  __typename?: 'product_price';
  created_at: Scalars['timestamptz']['output'];
  is_discount: Scalars['Boolean']['output'];
  price: Scalars['Int']['output'];
  /** An object relationship */
  product: Product;
  /** An array relationship */
  product_requests: Array<Product_Request>;
  /** An aggregate relationship */
  product_requests_aggregate: Product_Request_Aggregate;
  product_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "product_price" */
export type Product_PriceProduct_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


/** columns and relationships of "product_price" */
export type Product_PriceProduct_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};

/** aggregated selection of "product_price" */
export type Product_Price_Aggregate = {
  __typename?: 'product_price_aggregate';
  aggregate: Maybe<Product_Price_Aggregate_Fields>;
  nodes: Array<Product_Price>;
};

export type Product_Price_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Product_Price_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Product_Price_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Product_Price_Aggregate_Bool_Exp_Count>;
};

export type Product_Price_Aggregate_Bool_Exp_Bool_And = {
  arguments: Product_Price_Select_Column_Product_Price_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Product_Price_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Product_Price_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Product_Price_Select_Column_Product_Price_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Product_Price_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Product_Price_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Product_Price_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Product_Price_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "product_price" */
export type Product_Price_Aggregate_Fields = {
  __typename?: 'product_price_aggregate_fields';
  avg: Maybe<Product_Price_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Product_Price_Max_Fields>;
  min: Maybe<Product_Price_Min_Fields>;
  stddev: Maybe<Product_Price_Stddev_Fields>;
  stddev_pop: Maybe<Product_Price_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Product_Price_Stddev_Samp_Fields>;
  sum: Maybe<Product_Price_Sum_Fields>;
  var_pop: Maybe<Product_Price_Var_Pop_Fields>;
  var_samp: Maybe<Product_Price_Var_Samp_Fields>;
  variance: Maybe<Product_Price_Variance_Fields>;
};


/** aggregate fields of "product_price" */
export type Product_Price_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Product_Price_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "product_price" */
export type Product_Price_Aggregate_Order_By = {
  avg?: InputMaybe<Product_Price_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Product_Price_Max_Order_By>;
  min?: InputMaybe<Product_Price_Min_Order_By>;
  stddev?: InputMaybe<Product_Price_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Product_Price_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Product_Price_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Product_Price_Sum_Order_By>;
  var_pop?: InputMaybe<Product_Price_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Product_Price_Var_Samp_Order_By>;
  variance?: InputMaybe<Product_Price_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "product_price" */
export type Product_Price_Arr_Rel_Insert_Input = {
  data: Array<Product_Price_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Product_Price_On_Conflict>;
};

/** aggregate avg on columns */
export type Product_Price_Avg_Fields = {
  __typename?: 'product_price_avg_fields';
  price: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "product_price" */
export type Product_Price_Avg_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "product_price". All fields are combined with a logical 'AND'. */
export type Product_Price_Bool_Exp = {
  _and?: InputMaybe<Array<Product_Price_Bool_Exp>>;
  _not?: InputMaybe<Product_Price_Bool_Exp>;
  _or?: InputMaybe<Array<Product_Price_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  is_discount?: InputMaybe<Boolean_Comparison_Exp>;
  price?: InputMaybe<Int_Comparison_Exp>;
  product?: InputMaybe<Product_Bool_Exp>;
  product_requests?: InputMaybe<Product_Request_Bool_Exp>;
  product_requests_aggregate?: InputMaybe<Product_Request_Aggregate_Bool_Exp>;
  product_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "product_price" */
export enum Product_Price_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  ProductPricePkey = 'product_price_pkey'
}

/** input type for incrementing numeric columns in table "product_price" */
export type Product_Price_Inc_Input = {
  price?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "product_price" */
export type Product_Price_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  is_discount?: InputMaybe<Scalars['Boolean']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  product?: InputMaybe<Product_Obj_Rel_Insert_Input>;
  product_requests?: InputMaybe<Product_Request_Arr_Rel_Insert_Input>;
  product_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Product_Price_Max_Fields = {
  __typename?: 'product_price_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  price: Maybe<Scalars['Int']['output']>;
  product_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "product_price" */
export type Product_Price_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  product_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Product_Price_Min_Fields = {
  __typename?: 'product_price_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  price: Maybe<Scalars['Int']['output']>;
  product_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "product_price" */
export type Product_Price_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  product_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "product_price" */
export type Product_Price_Mutation_Response = {
  __typename?: 'product_price_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Product_Price>;
};

/** input type for inserting object relation for remote table "product_price" */
export type Product_Price_Obj_Rel_Insert_Input = {
  data: Product_Price_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Product_Price_On_Conflict>;
};

/** on_conflict condition type for table "product_price" */
export type Product_Price_On_Conflict = {
  constraint: Product_Price_Constraint;
  update_columns?: Array<Product_Price_Update_Column>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};

/** Ordering options when selecting data from "product_price". */
export type Product_Price_Order_By = {
  created_at?: InputMaybe<Order_By>;
  is_discount?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  product?: InputMaybe<Product_Order_By>;
  product_requests_aggregate?: InputMaybe<Product_Request_Aggregate_Order_By>;
  product_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: product_price */
export type Product_Price_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "product_price" */
export enum Product_Price_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IsDiscount = 'is_discount',
  /** column name */
  Price = 'price',
  /** column name */
  ProductUuid = 'product_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** select "product_price_aggregate_bool_exp_bool_and_arguments_columns" columns of table "product_price" */
export enum Product_Price_Select_Column_Product_Price_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsDiscount = 'is_discount'
}

/** select "product_price_aggregate_bool_exp_bool_or_arguments_columns" columns of table "product_price" */
export enum Product_Price_Select_Column_Product_Price_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsDiscount = 'is_discount'
}

/** input type for updating data in table "product_price" */
export type Product_Price_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  is_discount?: InputMaybe<Scalars['Boolean']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  product_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Product_Price_Stddev_Fields = {
  __typename?: 'product_price_stddev_fields';
  price: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "product_price" */
export type Product_Price_Stddev_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Product_Price_Stddev_Pop_Fields = {
  __typename?: 'product_price_stddev_pop_fields';
  price: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "product_price" */
export type Product_Price_Stddev_Pop_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Product_Price_Stddev_Samp_Fields = {
  __typename?: 'product_price_stddev_samp_fields';
  price: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "product_price" */
export type Product_Price_Stddev_Samp_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "product_price" */
export type Product_Price_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Product_Price_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Product_Price_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  is_discount?: InputMaybe<Scalars['Boolean']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  product_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Product_Price_Sum_Fields = {
  __typename?: 'product_price_sum_fields';
  price: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "product_price" */
export type Product_Price_Sum_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** update columns of table "product_price" */
export enum Product_Price_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IsDiscount = 'is_discount',
  /** column name */
  Price = 'price',
  /** column name */
  ProductUuid = 'product_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Product_Price_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Product_Price_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Product_Price_Set_Input>;
  /** filter the rows which have to be updated */
  where: Product_Price_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Product_Price_Var_Pop_Fields = {
  __typename?: 'product_price_var_pop_fields';
  price: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "product_price" */
export type Product_Price_Var_Pop_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Product_Price_Var_Samp_Fields = {
  __typename?: 'product_price_var_samp_fields';
  price: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "product_price" */
export type Product_Price_Var_Samp_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Product_Price_Variance_Fields = {
  __typename?: 'product_price_variance_fields';
  price: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "product_price" */
export type Product_Price_Variance_Order_By = {
  price?: InputMaybe<Order_By>;
};

/** columns and relationships of "product_request" */
export type Product_Request = {
  __typename?: 'product_request';
  /** An object relationship */
  admin: Maybe<Admin>;
  /** The admin that changed the request status */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** The reason because the product request was cancelled */
  cancel_reason: Maybe<Scalars['String']['output']>;
  /** It's when the product request was cancelled */
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** It's when the product was finally delivered */
  delivered_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  product_price: Product_Price;
  /** The price that was used to buy this product and make this request */
  product_price_uuid: Scalars['uuid']['output'];
  /** It's when the product became ready for delivery */
  ready_for_delivery_at: Maybe<Scalars['timestamptz']['output']>;
  /** Status of the request. Can be one of these: requested, ready_for_delivery, delivered, cancelled */
  status: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: User;
  /** An array relationship */
  userKmpsByNewProductRequestUuid: Array<User_Kmps>;
  /** An aggregate relationship */
  userKmpsByNewProductRequestUuid_aggregate: User_Kmps_Aggregate;
  /** An array relationship */
  user_kmps: Array<User_Kmps>;
  /** An aggregate relationship */
  user_kmps_aggregate: User_Kmps_Aggregate;
  /** The user that made this request */
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "product_request" */
export type Product_RequestUserKmpsByNewProductRequestUuidArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


/** columns and relationships of "product_request" */
export type Product_RequestUserKmpsByNewProductRequestUuid_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


/** columns and relationships of "product_request" */
export type Product_RequestUser_KmpsArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


/** columns and relationships of "product_request" */
export type Product_RequestUser_Kmps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};

/** aggregated selection of "product_request" */
export type Product_Request_Aggregate = {
  __typename?: 'product_request_aggregate';
  aggregate: Maybe<Product_Request_Aggregate_Fields>;
  nodes: Array<Product_Request>;
};

export type Product_Request_Aggregate_Bool_Exp = {
  count?: InputMaybe<Product_Request_Aggregate_Bool_Exp_Count>;
};

export type Product_Request_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Product_Request_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Product_Request_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "product_request" */
export type Product_Request_Aggregate_Fields = {
  __typename?: 'product_request_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Product_Request_Max_Fields>;
  min: Maybe<Product_Request_Min_Fields>;
};


/** aggregate fields of "product_request" */
export type Product_Request_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Product_Request_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "product_request" */
export type Product_Request_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Product_Request_Max_Order_By>;
  min?: InputMaybe<Product_Request_Min_Order_By>;
};

/** input type for inserting array relation for remote table "product_request" */
export type Product_Request_Arr_Rel_Insert_Input = {
  data: Array<Product_Request_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Product_Request_On_Conflict>;
};

/** Boolean expression to filter rows from the table "product_request". All fields are combined with a logical 'AND'. */
export type Product_Request_Bool_Exp = {
  _and?: InputMaybe<Array<Product_Request_Bool_Exp>>;
  _not?: InputMaybe<Product_Request_Bool_Exp>;
  _or?: InputMaybe<Array<Product_Request_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  cancel_reason?: InputMaybe<String_Comparison_Exp>;
  cancelled_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivered_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  product_price?: InputMaybe<Product_Price_Bool_Exp>;
  product_price_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  ready_for_delivery_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  userKmpsByNewProductRequestUuid?: InputMaybe<User_Kmps_Bool_Exp>;
  userKmpsByNewProductRequestUuid_aggregate?: InputMaybe<User_Kmps_Aggregate_Bool_Exp>;
  user_kmps?: InputMaybe<User_Kmps_Bool_Exp>;
  user_kmps_aggregate?: InputMaybe<User_Kmps_Aggregate_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "product_request" */
export enum Product_Request_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  ProductRequestPkey = 'product_request_pkey'
}

/** input type for inserting data into table "product_request" */
export type Product_Request_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  /** The admin that changed the request status */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The reason because the product request was cancelled */
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  /** It's when the product request was cancelled */
  cancelled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** It's when the product was finally delivered */
  delivered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  product_price?: InputMaybe<Product_Price_Obj_Rel_Insert_Input>;
  /** The price that was used to buy this product and make this request */
  product_price_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** It's when the product became ready for delivery */
  ready_for_delivery_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  userKmpsByNewProductRequestUuid?: InputMaybe<User_Kmps_Arr_Rel_Insert_Input>;
  user_kmps?: InputMaybe<User_Kmps_Arr_Rel_Insert_Input>;
  /** The user that made this request */
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Product_Request_Max_Fields = {
  __typename?: 'product_request_max_fields';
  /** The admin that changed the request status */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** The reason because the product request was cancelled */
  cancel_reason: Maybe<Scalars['String']['output']>;
  /** It's when the product request was cancelled */
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** It's when the product was finally delivered */
  delivered_at: Maybe<Scalars['timestamptz']['output']>;
  /** The price that was used to buy this product and make this request */
  product_price_uuid: Maybe<Scalars['uuid']['output']>;
  /** It's when the product became ready for delivery */
  ready_for_delivery_at: Maybe<Scalars['timestamptz']['output']>;
  /** Status of the request. Can be one of these: requested, ready_for_delivery, delivered, cancelled */
  status: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** The user that made this request */
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "product_request" */
export type Product_Request_Max_Order_By = {
  /** The admin that changed the request status */
  admin_uuid?: InputMaybe<Order_By>;
  /** The reason because the product request was cancelled */
  cancel_reason?: InputMaybe<Order_By>;
  /** It's when the product request was cancelled */
  cancelled_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** It's when the product was finally delivered */
  delivered_at?: InputMaybe<Order_By>;
  /** The price that was used to buy this product and make this request */
  product_price_uuid?: InputMaybe<Order_By>;
  /** It's when the product became ready for delivery */
  ready_for_delivery_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** The user that made this request */
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Product_Request_Min_Fields = {
  __typename?: 'product_request_min_fields';
  /** The admin that changed the request status */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** The reason because the product request was cancelled */
  cancel_reason: Maybe<Scalars['String']['output']>;
  /** It's when the product request was cancelled */
  cancelled_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** It's when the product was finally delivered */
  delivered_at: Maybe<Scalars['timestamptz']['output']>;
  /** The price that was used to buy this product and make this request */
  product_price_uuid: Maybe<Scalars['uuid']['output']>;
  /** It's when the product became ready for delivery */
  ready_for_delivery_at: Maybe<Scalars['timestamptz']['output']>;
  /** Status of the request. Can be one of these: requested, ready_for_delivery, delivered, cancelled */
  status: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** The user that made this request */
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "product_request" */
export type Product_Request_Min_Order_By = {
  /** The admin that changed the request status */
  admin_uuid?: InputMaybe<Order_By>;
  /** The reason because the product request was cancelled */
  cancel_reason?: InputMaybe<Order_By>;
  /** It's when the product request was cancelled */
  cancelled_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** It's when the product was finally delivered */
  delivered_at?: InputMaybe<Order_By>;
  /** The price that was used to buy this product and make this request */
  product_price_uuid?: InputMaybe<Order_By>;
  /** It's when the product became ready for delivery */
  ready_for_delivery_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** The user that made this request */
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "product_request" */
export type Product_Request_Mutation_Response = {
  __typename?: 'product_request_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Product_Request>;
};

/** input type for inserting object relation for remote table "product_request" */
export type Product_Request_Obj_Rel_Insert_Input = {
  data: Product_Request_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Product_Request_On_Conflict>;
};

/** on_conflict condition type for table "product_request" */
export type Product_Request_On_Conflict = {
  constraint: Product_Request_Constraint;
  update_columns?: Array<Product_Request_Update_Column>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};

/** Ordering options when selecting data from "product_request". */
export type Product_Request_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  cancel_reason?: InputMaybe<Order_By>;
  cancelled_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  delivered_at?: InputMaybe<Order_By>;
  product_price?: InputMaybe<Product_Price_Order_By>;
  product_price_uuid?: InputMaybe<Order_By>;
  ready_for_delivery_at?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  userKmpsByNewProductRequestUuid_aggregate?: InputMaybe<User_Kmps_Aggregate_Order_By>;
  user_kmps_aggregate?: InputMaybe<User_Kmps_Aggregate_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: product_request */
export type Product_Request_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "product_request" */
export enum Product_Request_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CancelReason = 'cancel_reason',
  /** column name */
  CancelledAt = 'cancelled_at',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeliveredAt = 'delivered_at',
  /** column name */
  ProductPriceUuid = 'product_price_uuid',
  /** column name */
  ReadyForDeliveryAt = 'ready_for_delivery_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "product_request" */
export type Product_Request_Set_Input = {
  /** The admin that changed the request status */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The reason because the product request was cancelled */
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  /** It's when the product request was cancelled */
  cancelled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** It's when the product was finally delivered */
  delivered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The price that was used to buy this product and make this request */
  product_price_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** It's when the product became ready for delivery */
  ready_for_delivery_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user that made this request */
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "product_request" */
export type Product_Request_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Product_Request_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Product_Request_Stream_Cursor_Value_Input = {
  /** The admin that changed the request status */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The reason because the product request was cancelled */
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  /** It's when the product request was cancelled */
  cancelled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** It's when the product was finally delivered */
  delivered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The price that was used to buy this product and make this request */
  product_price_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** It's when the product became ready for delivery */
  ready_for_delivery_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user that made this request */
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "product_request" */
export enum Product_Request_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CancelReason = 'cancel_reason',
  /** column name */
  CancelledAt = 'cancelled_at',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeliveredAt = 'delivered_at',
  /** column name */
  ProductPriceUuid = 'product_price_uuid',
  /** column name */
  ReadyForDeliveryAt = 'ready_for_delivery_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Product_Request_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Product_Request_Set_Input>;
  /** filter the rows which have to be updated */
  where: Product_Request_Bool_Exp;
};

/** select columns of table "product" */
export enum Product_Select_Column {
  /** column name */
  CarrouselOrder = 'carrousel_order',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "product" */
export type Product_Set_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Product_Stddev_Fields = {
  __typename?: 'product_stddev_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Product_Stddev_Pop_Fields = {
  __typename?: 'product_stddev_pop_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Product_Stddev_Samp_Fields = {
  __typename?: 'product_stddev_samp_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "product" */
export type Product_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Product_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Product_Stream_Cursor_Value_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Product_Sum_Fields = {
  __typename?: 'product_sum_fields';
  carrousel_order: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "product" */
export enum Product_Update_Column {
  /** column name */
  CarrouselOrder = 'carrousel_order',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Product_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Product_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Product_Set_Input>;
  /** filter the rows which have to be updated */
  where: Product_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Product_Var_Pop_Fields = {
  __typename?: 'product_var_pop_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Product_Var_Samp_Fields = {
  __typename?: 'product_var_samp_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Product_Variance_Fields = {
  __typename?: 'product_variance_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "product_current_price" */
  current_price: Maybe<Scalars['Int']['output']>;
  quantity: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "profile" */
export type Profile = {
  __typename?: 'profile';
  /** An array relationship */
  admin_fk_profiles: Array<Admin_Fk_Profile>;
  /** An aggregate relationship */
  admin_fk_profiles_aggregate: Admin_Fk_Profile_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  profile_permissions: Array<Profile_Permission>;
  /** An aggregate relationship */
  profile_permissions_aggregate: Profile_Permission_Aggregate;
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "profile" */
export type ProfileAdmin_Fk_ProfilesArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileAdmin_Fk_Profiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileProfile_PermissionsArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileProfile_Permissions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};

/** aggregated selection of "profile" */
export type Profile_Aggregate = {
  __typename?: 'profile_aggregate';
  aggregate: Maybe<Profile_Aggregate_Fields>;
  nodes: Array<Profile>;
};

/** aggregate fields of "profile" */
export type Profile_Aggregate_Fields = {
  __typename?: 'profile_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Profile_Max_Fields>;
  min: Maybe<Profile_Min_Fields>;
};


/** aggregate fields of "profile" */
export type Profile_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Profile_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "profile". All fields are combined with a logical 'AND'. */
export type Profile_Bool_Exp = {
  _and?: InputMaybe<Array<Profile_Bool_Exp>>;
  _not?: InputMaybe<Profile_Bool_Exp>;
  _or?: InputMaybe<Array<Profile_Bool_Exp>>;
  admin_fk_profiles?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
  admin_fk_profiles_aggregate?: InputMaybe<Admin_Fk_Profile_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  profile_permissions?: InputMaybe<Profile_Permission_Bool_Exp>;
  profile_permissions_aggregate?: InputMaybe<Profile_Permission_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "profile" */
export enum Profile_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  ProfilePkey = 'profile_pkey'
}

/** input type for inserting data into table "profile" */
export type Profile_Insert_Input = {
  admin_fk_profiles?: InputMaybe<Admin_Fk_Profile_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  profile_permissions?: InputMaybe<Profile_Permission_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Profile_Max_Fields = {
  __typename?: 'profile_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Profile_Min_Fields = {
  __typename?: 'profile_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "profile" */
export type Profile_Mutation_Response = {
  __typename?: 'profile_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Profile>;
};

/** input type for inserting object relation for remote table "profile" */
export type Profile_Obj_Rel_Insert_Input = {
  data: Profile_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Profile_On_Conflict>;
};

/** on_conflict condition type for table "profile" */
export type Profile_On_Conflict = {
  constraint: Profile_Constraint;
  update_columns?: Array<Profile_Update_Column>;
  where?: InputMaybe<Profile_Bool_Exp>;
};

/** Ordering options when selecting data from "profile". */
export type Profile_Order_By = {
  admin_fk_profiles_aggregate?: InputMaybe<Admin_Fk_Profile_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  profile_permissions_aggregate?: InputMaybe<Profile_Permission_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** columns and relationships of "profile_permission" */
export type Profile_Permission = {
  __typename?: 'profile_permission';
  action: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  module_permission: Module_Permission;
  /** An object relationship */
  profile: Profile;
  profile_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "profile_permission" */
export type Profile_Permission_Aggregate = {
  __typename?: 'profile_permission_aggregate';
  aggregate: Maybe<Profile_Permission_Aggregate_Fields>;
  nodes: Array<Profile_Permission>;
};

export type Profile_Permission_Aggregate_Bool_Exp = {
  count?: InputMaybe<Profile_Permission_Aggregate_Bool_Exp_Count>;
};

export type Profile_Permission_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Profile_Permission_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "profile_permission" */
export type Profile_Permission_Aggregate_Fields = {
  __typename?: 'profile_permission_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Profile_Permission_Max_Fields>;
  min: Maybe<Profile_Permission_Min_Fields>;
};


/** aggregate fields of "profile_permission" */
export type Profile_Permission_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "profile_permission" */
export type Profile_Permission_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Profile_Permission_Max_Order_By>;
  min?: InputMaybe<Profile_Permission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "profile_permission" */
export type Profile_Permission_Arr_Rel_Insert_Input = {
  data: Array<Profile_Permission_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Profile_Permission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "profile_permission". All fields are combined with a logical 'AND'. */
export type Profile_Permission_Bool_Exp = {
  _and?: InputMaybe<Array<Profile_Permission_Bool_Exp>>;
  _not?: InputMaybe<Profile_Permission_Bool_Exp>;
  _or?: InputMaybe<Array<Profile_Permission_Bool_Exp>>;
  action?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deleted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  module_permission?: InputMaybe<Module_Permission_Bool_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "profile_permission" */
export enum Profile_Permission_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  ProfilePermissionPkey = 'profile_permission_pkey'
}

/** input type for inserting data into table "profile_permission" */
export type Profile_Permission_Insert_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  module_permission?: InputMaybe<Module_Permission_Obj_Rel_Insert_Input>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Profile_Permission_Max_Fields = {
  __typename?: 'profile_permission_max_fields';
  action: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  profile_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "profile_permission" */
export type Profile_Permission_Max_Order_By = {
  action?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  profile_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Profile_Permission_Min_Fields = {
  __typename?: 'profile_permission_min_fields';
  action: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  deleted_at: Maybe<Scalars['timestamptz']['output']>;
  profile_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "profile_permission" */
export type Profile_Permission_Min_Order_By = {
  action?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  profile_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "profile_permission" */
export type Profile_Permission_Mutation_Response = {
  __typename?: 'profile_permission_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Profile_Permission>;
};

/** on_conflict condition type for table "profile_permission" */
export type Profile_Permission_On_Conflict = {
  constraint: Profile_Permission_Constraint;
  update_columns?: Array<Profile_Permission_Update_Column>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};

/** Ordering options when selecting data from "profile_permission". */
export type Profile_Permission_Order_By = {
  action?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted_at?: InputMaybe<Order_By>;
  module_permission?: InputMaybe<Module_Permission_Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: profile_permission */
export type Profile_Permission_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "profile_permission" */
export enum Profile_Permission_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  ProfileUuid = 'profile_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "profile_permission" */
export type Profile_Permission_Set_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  profile_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "profile_permission" */
export type Profile_Permission_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Profile_Permission_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Profile_Permission_Stream_Cursor_Value_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  profile_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "profile_permission" */
export enum Profile_Permission_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  ProfileUuid = 'profile_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Profile_Permission_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Profile_Permission_Set_Input>;
  /** filter the rows which have to be updated */
  where: Profile_Permission_Bool_Exp;
};

/** primary key columns input for table: profile */
export type Profile_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "profile" */
export enum Profile_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "profile" */
export type Profile_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "profile" */
export type Profile_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Profile_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Profile_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "profile" */
export enum Profile_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Profile_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Profile_Set_Input>;
  /** filter the rows which have to be updated */
  where: Profile_Bool_Exp;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "CurrentTiresByVehicle" */
  CurrentTiresByVehicle: Array<CurrentTiresByVehicle>;
  /** fetch aggregated fields from the table: "CurrentTiresByVehicle" */
  CurrentTiresByVehicle_aggregate: CurrentTiresByVehicle_Aggregate;
  /** fetch data from the table: "ParametroAlertaConducao" */
  ParametroAlertaConducao: Array<ParametroAlertaConducao>;
  /** fetch aggregated fields from the table: "ParametroAlertaConducao" */
  ParametroAlertaConducao_aggregate: ParametroAlertaConducao_Aggregate;
  /** fetch data from the table: "ParametroAlertaConducao" using primary key columns */
  ParametroAlertaConducao_by_pk: Maybe<ParametroAlertaConducao>;
  /** fetch data from the table: "PerformanceParameter" */
  PerformanceParameter: Array<PerformanceParameter>;
  /** fetch aggregated fields from the table: "PerformanceParameter" */
  PerformanceParameter_aggregate: PerformanceParameter_Aggregate;
  /** fetch data from the table: "PerformanceParameter" using primary key columns */
  PerformanceParameter_by_pk: Maybe<PerformanceParameter>;
  /** fetch data from the table: "PontosRastro" */
  PontosRastro: Array<PontosRastro>;
  /** fetch aggregated fields from the table: "PontosRastro" */
  PontosRastro_aggregate: PontosRastro_Aggregate;
  /** fetch data from the table: "PontosRastro" using primary key columns */
  PontosRastro_by_pk: Maybe<PontosRastro>;
  /** fetch data from the table: "ScoreParameter" */
  ScoreParameter: Array<ScoreParameter>;
  /** fetch aggregated fields from the table: "ScoreParameter" */
  ScoreParameter_aggregate: ScoreParameter_Aggregate;
  /** fetch data from the table: "ScoreParameter" using primary key columns */
  ScoreParameter_by_pk: Maybe<ScoreParameter>;
  /** fetch data from the table: "ScoreType" */
  ScoreType: Array<ScoreType>;
  /** fetch aggregated fields from the table: "ScoreType" */
  ScoreType_aggregate: ScoreType_Aggregate;
  /** fetch data from the table: "ScoreType" using primary key columns */
  ScoreType_by_pk: Maybe<ScoreType>;
  /** fetch data from the table: "SuntechEquipamento" */
  SuntechEquipamento: Array<SuntechEquipamento>;
  /** fetch aggregated fields from the table: "SuntechEquipamento" */
  SuntechEquipamento_aggregate: SuntechEquipamento_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommand" */
  SuntechTrackerBatchCommand: Array<SuntechTrackerBatchCommand>;
  /** fetch data from the table: "SuntechTrackerBatchCommandDevice" */
  SuntechTrackerBatchCommandDevice: Array<SuntechTrackerBatchCommandDevice>;
  /** fetch aggregated fields from the table: "SuntechTrackerBatchCommandDevice" */
  SuntechTrackerBatchCommandDevice_aggregate: SuntechTrackerBatchCommandDevice_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommandDevice" using primary key columns */
  SuntechTrackerBatchCommandDevice_by_pk: Maybe<SuntechTrackerBatchCommandDevice>;
  /** fetch data from the table: "SuntechTrackerBatchCommandPreset" */
  SuntechTrackerBatchCommandPreset: Array<SuntechTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "SuntechTrackerBatchCommandPreset" */
  SuntechTrackerBatchCommandPreset_aggregate: SuntechTrackerBatchCommandPreset_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommandPreset" using primary key columns */
  SuntechTrackerBatchCommandPreset_by_pk: Maybe<SuntechTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "SuntechTrackerBatchCommand" */
  SuntechTrackerBatchCommand_aggregate: SuntechTrackerBatchCommand_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommand" using primary key columns */
  SuntechTrackerBatchCommand_by_pk: Maybe<SuntechTrackerBatchCommand>;
  /** fetch data from the table: "SuntechTrackerCommand" */
  SuntechTrackerCommand: Array<SuntechTrackerCommand>;
  /** fetch aggregated fields from the table: "SuntechTrackerCommand" */
  SuntechTrackerCommand_aggregate: SuntechTrackerCommand_Aggregate;
  /** fetch data from the table: "SuntechTrackerCommand" using primary key columns */
  SuntechTrackerCommand_by_pk: Maybe<SuntechTrackerCommand>;
  TireAnalysisReport: Array<TireAnalysisReport>;
  /** fetch data from the table: "VirlocTrackerBatchCommand" */
  VirlocTrackerBatchCommand: Array<VirlocTrackerBatchCommand>;
  /** fetch data from the table: "VirlocTrackerBatchCommandDevice" */
  VirlocTrackerBatchCommandDevice: Array<VirlocTrackerBatchCommandDevice>;
  /** fetch aggregated fields from the table: "VirlocTrackerBatchCommandDevice" */
  VirlocTrackerBatchCommandDevice_aggregate: VirlocTrackerBatchCommandDevice_Aggregate;
  /** fetch data from the table: "VirlocTrackerBatchCommandDevice" using primary key columns */
  VirlocTrackerBatchCommandDevice_by_pk: Maybe<VirlocTrackerBatchCommandDevice>;
  /** fetch data from the table: "VirlocTrackerBatchCommandPreset" */
  VirlocTrackerBatchCommandPreset: Array<VirlocTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "VirlocTrackerBatchCommandPreset" */
  VirlocTrackerBatchCommandPreset_aggregate: VirlocTrackerBatchCommandPreset_Aggregate;
  /** fetch data from the table: "VirlocTrackerBatchCommandPreset" using primary key columns */
  VirlocTrackerBatchCommandPreset_by_pk: Maybe<VirlocTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "VirlocTrackerBatchCommand" */
  VirlocTrackerBatchCommand_aggregate: VirlocTrackerBatchCommand_Aggregate;
  /** fetch data from the table: "VirlocTrackerBatchCommand" using primary key columns */
  VirlocTrackerBatchCommand_by_pk: Maybe<VirlocTrackerBatchCommand>;
  /** fetch data from the table: "VirlocTrackerCommand" */
  VirlocTrackerCommand: Array<VirlocTrackerCommand>;
  /** fetch aggregated fields from the table: "VirlocTrackerCommand" */
  VirlocTrackerCommand_aggregate: VirlocTrackerCommand_Aggregate;
  /** fetch data from the table: "VirlocTrackerCommand" using primary key columns */
  VirlocTrackerCommand_by_pk: Maybe<VirlocTrackerCommand>;
  /** fetch data from the table: "VirlocTrackerDevice" */
  VirlocTrackerDevice: Array<VirlocTrackerDevice>;
  /** fetch aggregated fields from the table: "VirlocTrackerDevice" */
  VirlocTrackerDevice_aggregate: VirlocTrackerDevice_Aggregate;
  /** fetch data from the table: "VirlocTrackerDevice" using primary key columns */
  VirlocTrackerDevice_by_pk: Maybe<VirlocTrackerDevice>;
  /** fetch data from the table: "achievement" */
  achievement: Array<Achievement>;
  /** fetch aggregated fields from the table: "achievement" */
  achievement_aggregate: Achievement_Aggregate;
  /** fetch data from the table: "achievement" using primary key columns */
  achievement_by_pk: Maybe<Achievement>;
  /** fetch data from the table: "admin" */
  admin: Array<Admin>;
  /** fetch aggregated fields from the table: "admin" */
  admin_aggregate: Admin_Aggregate;
  /** fetch data from the table: "admin" using primary key columns */
  admin_by_pk: Maybe<Admin>;
  /** An array relationship */
  admin_fk_notifications: Array<Admin_Fk_Notifications>;
  /** An aggregate relationship */
  admin_fk_notifications_aggregate: Admin_Fk_Notifications_Aggregate;
  /** fetch data from the table: "admin_fk_notifications" using primary key columns */
  admin_fk_notifications_by_pk: Maybe<Admin_Fk_Notifications>;
  /** fetch data from the table: "admin_fk_profile" */
  admin_fk_profile: Array<Admin_Fk_Profile>;
  /** fetch aggregated fields from the table: "admin_fk_profile" */
  admin_fk_profile_aggregate: Admin_Fk_Profile_Aggregate;
  /** fetch data from the table: "admin_fk_profile" using primary key columns */
  admin_fk_profile_by_pk: Maybe<Admin_Fk_Profile>;
  /** fetch data from the table: "admin_permission" */
  admin_permission: Array<Admin_Permission>;
  /** fetch aggregated fields from the table: "admin_permission" */
  admin_permission_aggregate: Admin_Permission_Aggregate;
  /** fetch data from the table: "admin_permission" using primary key columns */
  admin_permission_by_pk: Maybe<Admin_Permission>;
  admin_signin: Maybe<AdminSignInOutput>;
  /** Used to signin in the app, for both users and admins */
  app_signin: Maybe<AppSigninOutput>;
  /** fetch data from the table: "auto" */
  auto: Array<Auto>;
  /** fetch aggregated fields from the table: "auto" */
  auto_aggregate: Auto_Aggregate;
  /** fetch data from the table: "auto" using primary key columns */
  auto_by_pk: Maybe<Auto>;
  /** fetch data from the table: "bi.dashboard" */
  bi_dashboard: Array<Bi_Dashboard>;
  /** fetch aggregated fields from the table: "bi.dashboard" */
  bi_dashboard_aggregate: Bi_Dashboard_Aggregate;
  /** fetch data from the table: "bi.dashboard" using primary key columns */
  bi_dashboard_by_pk: Maybe<Bi_Dashboard>;
  /** fetch data from the table: "bi.dashboard_item" */
  bi_dashboard_item: Array<Bi_Dashboard_Item>;
  /** fetch aggregated fields from the table: "bi.dashboard_item" */
  bi_dashboard_item_aggregate: Bi_Dashboard_Item_Aggregate;
  /** fetch data from the table: "bi.dashboard_item" using primary key columns */
  bi_dashboard_item_by_pk: Maybe<Bi_Dashboard_Item>;
  /** fetch data from the table: "bi.dashboard_item_type" */
  bi_dashboard_item_type: Array<Bi_Dashboard_Item_Type>;
  /** fetch aggregated fields from the table: "bi.dashboard_item_type" */
  bi_dashboard_item_type_aggregate: Bi_Dashboard_Item_Type_Aggregate;
  /** fetch data from the table: "bi.dashboard_item_type" using primary key columns */
  bi_dashboard_item_type_by_pk: Maybe<Bi_Dashboard_Item_Type>;
  /** fetch data from the table: "bi.datasource" */
  bi_datasource: Array<Bi_Datasource>;
  /** fetch aggregated fields from the table: "bi.datasource" */
  bi_datasource_aggregate: Bi_Datasource_Aggregate;
  /** fetch data from the table: "bi.datasource" using primary key columns */
  bi_datasource_by_pk: Maybe<Bi_Datasource>;
  /** fetch data from the table: "bi.datasource_type" */
  bi_datasource_type: Array<Bi_Datasource_Type>;
  /** fetch aggregated fields from the table: "bi.datasource_type" */
  bi_datasource_type_aggregate: Bi_Datasource_Type_Aggregate;
  /** fetch data from the table: "bi.datasource_type" using primary key columns */
  bi_datasource_type_by_pk: Maybe<Bi_Datasource_Type>;
  /** fetch data from the table: "bi.permission" */
  bi_permission: Array<Bi_Permission>;
  /** fetch aggregated fields from the table: "bi.permission" */
  bi_permission_aggregate: Bi_Permission_Aggregate;
  /** fetch data from the table: "bi.permission" using primary key columns */
  bi_permission_by_pk: Maybe<Bi_Permission>;
  /** fetch data from the table: "bi.permission_module" */
  bi_permission_module: Array<Bi_Permission_Module>;
  /** fetch aggregated fields from the table: "bi.permission_module" */
  bi_permission_module_aggregate: Bi_Permission_Module_Aggregate;
  /** fetch data from the table: "bi.permission_module" using primary key columns */
  bi_permission_module_by_pk: Maybe<Bi_Permission_Module>;
  /** fetch data from the table: "bi.public_link" */
  bi_public_link: Array<Bi_Public_Link>;
  /** fetch aggregated fields from the table: "bi.public_link" */
  bi_public_link_aggregate: Bi_Public_Link_Aggregate;
  /** fetch data from the table: "bi.public_link" using primary key columns */
  bi_public_link_by_pk: Maybe<Bi_Public_Link>;
  /** fetch data from the table: "bi.query" */
  bi_query: Array<Bi_Query>;
  /** fetch aggregated fields from the table: "bi.query" */
  bi_query_aggregate: Bi_Query_Aggregate;
  /** fetch data from the table: "bi.query_analytics" */
  bi_query_analytics: Array<Bi_Query_Analytics>;
  /** fetch aggregated fields from the table: "bi.query_analytics" */
  bi_query_analytics_aggregate: Bi_Query_Analytics_Aggregate;
  /** fetch data from the table: "bi.query_analytics" using primary key columns */
  bi_query_analytics_by_pk: Maybe<Bi_Query_Analytics>;
  /** fetch data from the table: "bi.query" using primary key columns */
  bi_query_by_pk: Maybe<Bi_Query>;
  /** fetch data from the table: "bi.query_cache" */
  bi_query_cache: Array<Bi_Query_Cache>;
  /** fetch aggregated fields from the table: "bi.query_cache" */
  bi_query_cache_aggregate: Bi_Query_Cache_Aggregate;
  /** fetch data from the table: "bi.query_cache" using primary key columns */
  bi_query_cache_by_pk: Maybe<Bi_Query_Cache>;
  /** fetch data from the table: "bi.subquery" */
  bi_subquery: Array<Bi_Subquery>;
  /** fetch aggregated fields from the table: "bi.subquery" */
  bi_subquery_aggregate: Bi_Subquery_Aggregate;
  /** fetch data from the table: "bi.subquery" using primary key columns */
  bi_subquery_by_pk: Maybe<Bi_Subquery>;
  /** fetch data from the table: "bi.user_permission" */
  bi_user_permission: Array<Bi_User_Permission>;
  /** fetch aggregated fields from the table: "bi.user_permission" */
  bi_user_permission_aggregate: Bi_User_Permission_Aggregate;
  /** fetch data from the table: "bi.user_permission" using primary key columns */
  bi_user_permission_by_pk: Maybe<Bi_User_Permission>;
  /** fetch data from the table: "challenge" */
  challenge: Array<Challenge>;
  /** fetch aggregated fields from the table: "challenge" */
  challenge_aggregate: Challenge_Aggregate;
  /** fetch data from the table: "challenge" using primary key columns */
  challenge_by_pk: Maybe<Challenge>;
  /** fetch data from the table: "challenge_type" */
  challenge_type: Array<Challenge_Type>;
  /** fetch aggregated fields from the table: "challenge_type" */
  challenge_type_aggregate: Challenge_Type_Aggregate;
  /** fetch data from the table: "challenge_type" using primary key columns */
  challenge_type_by_pk: Maybe<Challenge_Type>;
  /** fetch data from the table: "config" */
  config: Array<Config>;
  /** fetch aggregated fields from the table: "config" */
  config_aggregate: Config_Aggregate;
  /** fetch data from the table: "config" using primary key columns */
  config_by_pk: Maybe<Config>;
  /** fetch data from the table: "critical_point" */
  critical_point: Array<Critical_Point>;
  /** fetch aggregated fields from the table: "critical_point" */
  critical_point_aggregate: Critical_Point_Aggregate;
  /** fetch data from the table: "critical_point" using primary key columns */
  critical_point_by_pk: Maybe<Critical_Point>;
  /** fetch data from the table: "critical_segment" */
  critical_segment: Array<Critical_Segment>;
  /** fetch aggregated fields from the table: "critical_segment" */
  critical_segment_aggregate: Critical_Segment_Aggregate;
  /** fetch data from the table: "critical_segment" using primary key columns */
  critical_segment_by_pk: Maybe<Critical_Segment>;
  /** fetch data from the table: "cte.nf_lock" */
  cte_nf_lock: Array<Cte_Nf_Lock>;
  /** fetch aggregated fields from the table: "cte.nf_lock" */
  cte_nf_lock_aggregate: Cte_Nf_Lock_Aggregate;
  /** fetch data from the table: "cte.nf_lock" using primary key columns */
  cte_nf_lock_by_pk: Maybe<Cte_Nf_Lock>;
  /** fetch data from the table: "current_config" */
  current_config: Array<Current_Config>;
  /** fetch aggregated fields from the table: "current_config" */
  current_config_aggregate: Current_Config_Aggregate;
  /** fetch data from the table: "deleted_row" */
  deleted_row: Array<Deleted_Row>;
  /** fetch aggregated fields from the table: "deleted_row" */
  deleted_row_aggregate: Deleted_Row_Aggregate;
  /** fetch data from the table: "deleted_row" using primary key columns */
  deleted_row_by_pk: Maybe<Deleted_Row>;
  /** fetch data from the table: "delivery" */
  delivery: Array<Delivery>;
  /** fetch aggregated fields from the table: "delivery" */
  delivery_aggregate: Delivery_Aggregate;
  /** fetch data from the table: "delivery" using primary key columns */
  delivery_by_pk: Maybe<Delivery>;
  /** execute function "driver_performance_data" which returns "empty_tables.driver_performance_data" */
  driver_performance_data: Array<Empty_Tables_Driver_Performance_Data>;
  /** execute function "driver_performance_data" and query aggregates on result of table type "empty_tables.driver_performance_data" */
  driver_performance_data_aggregate: Empty_Tables_Driver_Performance_Data_Aggregate;
  /** fetch data from the table: "driver_warning" */
  driver_warning: Array<Driver_Warning>;
  /** fetch aggregated fields from the table: "driver_warning" */
  driver_warning_aggregate: Driver_Warning_Aggregate;
  /** fetch data from the table: "driver_warning" using primary key columns */
  driver_warning_by_pk: Maybe<Driver_Warning>;
  /** fetch data from the table: "driver_warning_comment" */
  driver_warning_comment: Array<Driver_Warning_Comment>;
  /** fetch aggregated fields from the table: "driver_warning_comment" */
  driver_warning_comment_aggregate: Driver_Warning_Comment_Aggregate;
  /** fetch data from the table: "driver_warning_comment" using primary key columns */
  driver_warning_comment_by_pk: Maybe<Driver_Warning_Comment>;
  /** fetch data from the table: "driver_warning_fk_whatsapp_message" */
  driver_warning_fk_whatsapp_message: Array<Driver_Warning_Fk_Whatsapp_Message>;
  /** fetch aggregated fields from the table: "driver_warning_fk_whatsapp_message" */
  driver_warning_fk_whatsapp_message_aggregate: Driver_Warning_Fk_Whatsapp_Message_Aggregate;
  /** fetch data from the table: "driver_warning_fk_whatsapp_message" using primary key columns */
  driver_warning_fk_whatsapp_message_by_pk: Maybe<Driver_Warning_Fk_Whatsapp_Message>;
  /** fetch data from the table: "driver_warning_risk_level" */
  driver_warning_risk_level: Array<Driver_Warning_Risk_Level>;
  /** fetch aggregated fields from the table: "driver_warning_risk_level" */
  driver_warning_risk_level_aggregate: Driver_Warning_Risk_Level_Aggregate;
  /** fetch data from the table: "driver_warning_risk_level" using primary key columns */
  driver_warning_risk_level_by_pk: Maybe<Driver_Warning_Risk_Level>;
  /** fetch data from the table: "driver_warning_risk_level_view" */
  driver_warning_risk_level_view: Array<Driver_Warning_Risk_Level_View>;
  /** fetch aggregated fields from the table: "driver_warning_risk_level_view" */
  driver_warning_risk_level_view_aggregate: Driver_Warning_Risk_Level_View_Aggregate;
  /** fetch data from the table: "driver_warning_trip" */
  driver_warning_trip: Array<Driver_Warning_Trip>;
  /** fetch aggregated fields from the table: "driver_warning_trip" */
  driver_warning_trip_aggregate: Driver_Warning_Trip_Aggregate;
  /** fetch data from the table: "driver_warning_trip" using primary key columns */
  driver_warning_trip_by_pk: Maybe<Driver_Warning_Trip>;
  /** fetch data from the table: "driver_warning_trip_point" */
  driver_warning_trip_point: Array<Driver_Warning_Trip_Point>;
  /** fetch aggregated fields from the table: "driver_warning_trip_point" */
  driver_warning_trip_point_aggregate: Driver_Warning_Trip_Point_Aggregate;
  /** fetch data from the table: "driver_warning_trip_point" using primary key columns */
  driver_warning_trip_point_by_pk: Maybe<Driver_Warning_Trip_Point>;
  /** fetch data from the table: "driver_warning_trip_severity" */
  driver_warning_trip_severity: Array<Driver_Warning_Trip_Severity>;
  /** fetch aggregated fields from the table: "driver_warning_trip_severity" */
  driver_warning_trip_severity_aggregate: Driver_Warning_Trip_Severity_Aggregate;
  /** fetch data from the table: "driver_warning_trip_severity" using primary key columns */
  driver_warning_trip_severity_by_pk: Maybe<Driver_Warning_Trip_Severity>;
  /** fetch data from the table: "edi.busca_nfe_job" */
  edi_busca_nfe_job: Array<Edi_Busca_Nfe_Job>;
  /** fetch aggregated fields from the table: "edi.busca_nfe_job" */
  edi_busca_nfe_job_aggregate: Edi_Busca_Nfe_Job_Aggregate;
  /** fetch data from the table: "edi.busca_nfe_job" using primary key columns */
  edi_busca_nfe_job_by_pk: Maybe<Edi_Busca_Nfe_Job>;
  /** fetch data from the table: "edi.busca_nfe_response" */
  edi_busca_nfe_response: Array<Edi_Busca_Nfe_Response>;
  /** fetch aggregated fields from the table: "edi.busca_nfe_response" */
  edi_busca_nfe_response_aggregate: Edi_Busca_Nfe_Response_Aggregate;
  /** fetch data from the table: "edi.busca_nfe_response" using primary key columns */
  edi_busca_nfe_response_by_pk: Maybe<Edi_Busca_Nfe_Response>;
  /** fetch data from the table: "empty_tables.critical_segment_from_critical_point" */
  empty_tables_critical_segment_from_critical_point: Array<Empty_Tables_Critical_Segment_From_Critical_Point>;
  /** fetch aggregated fields from the table: "empty_tables.critical_segment_from_critical_point" */
  empty_tables_critical_segment_from_critical_point_aggregate: Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate;
  /** fetch data from the table: "empty_tables.driver_performance_data" */
  empty_tables_driver_performance_data: Array<Empty_Tables_Driver_Performance_Data>;
  /** fetch aggregated fields from the table: "empty_tables.driver_performance_data" */
  empty_tables_driver_performance_data_aggregate: Empty_Tables_Driver_Performance_Data_Aggregate;
  /** fetch data from the table: "empty_tables.fleet_performance_data" */
  empty_tables_fleet_performance_data: Array<Empty_Tables_Fleet_Performance_Data>;
  /** fetch aggregated fields from the table: "empty_tables.fleet_performance_data" */
  empty_tables_fleet_performance_data_aggregate: Empty_Tables_Fleet_Performance_Data_Aggregate;
  /** fetch data from the table: "empty_tables.fleet_performance_data" using primary key columns */
  empty_tables_fleet_performance_data_by_pk: Maybe<Empty_Tables_Fleet_Performance_Data>;
  /** fetch data from the table: "empty_tables.geojson_trip" */
  empty_tables_geojson_trip: Array<Empty_Tables_Geojson_Trip>;
  /** fetch aggregated fields from the table: "empty_tables.geojson_trip" */
  empty_tables_geojson_trip_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  /** fetch data from the table: "empty_tables.geojson_trip" using primary key columns */
  empty_tables_geojson_trip_by_pk: Maybe<Empty_Tables_Geojson_Trip>;
  /** fetch data from the table: "empty_tables.instructor_drivers_performance_history" */
  empty_tables_instructor_drivers_performance_history: Array<Empty_Tables_Instructor_Drivers_Performance_History>;
  /** fetch aggregated fields from the table: "empty_tables.instructor_drivers_performance_history" */
  empty_tables_instructor_drivers_performance_history_aggregate: Empty_Tables_Instructor_Drivers_Performance_History_Aggregate;
  /** fetch data from the table: "fidelity_range_points" */
  fidelity_range_points: Array<Fidelity_Range_Points>;
  /** fetch aggregated fields from the table: "fidelity_range_points" */
  fidelity_range_points_aggregate: Fidelity_Range_Points_Aggregate;
  /** fetch data from the table: "fidelity_range_points" using primary key columns */
  fidelity_range_points_by_pk: Maybe<Fidelity_Range_Points>;
  /** fetch data from the table: "fipe.price" */
  fipe_price: Array<Fipe_Price>;
  /** fetch aggregated fields from the table: "fipe.price" */
  fipe_price_aggregate: Fipe_Price_Aggregate;
  /** fetch data from the table: "fipe.price" using primary key columns */
  fipe_price_by_pk: Maybe<Fipe_Price>;
  /** fetch data from the table: "fipe.reference_month" */
  fipe_reference_month: Array<Fipe_Reference_Month>;
  /** fetch aggregated fields from the table: "fipe.reference_month" */
  fipe_reference_month_aggregate: Fipe_Reference_Month_Aggregate;
  /** fetch data from the table: "fipe.reference_month" using primary key columns */
  fipe_reference_month_by_pk: Maybe<Fipe_Reference_Month>;
  /** execute function "fipe.search_fipe_vehicle" which returns "fipe.vehicle" */
  fipe_search_fipe_vehicle: Array<Fipe_Vehicle>;
  /** execute function "fipe.search_fipe_vehicle" and query aggregates on result of table type "fipe.vehicle" */
  fipe_search_fipe_vehicle_aggregate: Fipe_Vehicle_Aggregate;
  /** fetch data from the table: "fipe.selected_vehicle" */
  fipe_selected_vehicle: Array<Fipe_Selected_Vehicle>;
  /** fetch aggregated fields from the table: "fipe.selected_vehicle" */
  fipe_selected_vehicle_aggregate: Fipe_Selected_Vehicle_Aggregate;
  /** fetch data from the table: "fipe.selected_vehicle" using primary key columns */
  fipe_selected_vehicle_by_pk: Maybe<Fipe_Selected_Vehicle>;
  /** fetch data from the table: "fipe.vehicle" */
  fipe_vehicle: Array<Fipe_Vehicle>;
  /** fetch aggregated fields from the table: "fipe.vehicle" */
  fipe_vehicle_aggregate: Fipe_Vehicle_Aggregate;
  /** fetch data from the table: "fipe.vehicle" using primary key columns */
  fipe_vehicle_by_pk: Maybe<Fipe_Vehicle>;
  /** execute function "fleet_performance_data" which returns "empty_tables.fleet_performance_data" */
  fleet_performance_data: Maybe<Empty_Tables_Fleet_Performance_Data>;
  /** execute function "fleet_performance_data" and query aggregates on result of table type "empty_tables.fleet_performance_data" */
  fleet_performance_data_aggregate: Empty_Tables_Fleet_Performance_Data_Aggregate;
  fuel_analysis_by_all_drivers: Array<FuelAnalysisByAllDriversResult>;
  fuel_analysis_by_drivers: Array<FuelAnalysisByDriversResult>;
  getNfsPendingCte: Maybe<Array<Maybe<NfPendingCte>>>;
  /** get_trip_headers_by_date_range_and_codmoto */
  getTripHeadersByDateRangeAndCodmoto: Maybe<Array<TripHeadersOutput>>;
  /** get_trips_reports_by_trip_ids */
  getTripsReportsByTripIds: Maybe<TripsReportsByTripIdsOutput>;
  getVolvoReport: Maybe<TripsReportsByTripIdsOutput>;
  /** execute function "get_critical_segments_from_critical_point" which returns "empty_tables.critical_segment_from_critical_point" */
  get_critical_segments_from_critical_point: Array<Empty_Tables_Critical_Segment_From_Critical_Point>;
  /** execute function "get_critical_segments_from_critical_point" and query aggregates on result of table type "empty_tables.critical_segment_from_critical_point" */
  get_critical_segments_from_critical_point_aggregate: Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate;
  /** execute function "get_driver_warning_geojson" which returns "empty_tables.geojson_trip" */
  get_driver_warning_geojson: Maybe<Empty_Tables_Geojson_Trip>;
  /** execute function "get_driver_warning_geojson" and query aggregates on result of table type "empty_tables.geojson_trip" */
  get_driver_warning_geojson_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  get_refresh_token: Maybe<RefreshTokenOutput>;
  /** execute function "get_route_geojson_by_score_processed" which returns "empty_tables.geojson_trip" */
  get_route_geojson_by_score_processed: Maybe<Empty_Tables_Geojson_Trip>;
  /** execute function "get_route_geojson_by_score_processed" and query aggregates on result of table type "empty_tables.geojson_trip" */
  get_route_geojson_by_score_processed_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  get_tracker_traces: Maybe<TrackerTracesOutput>;
  /** execute function "get_trips_geojson" which returns "empty_tables.geojson_trip" */
  get_trips_geojson: Array<Empty_Tables_Geojson_Trip>;
  /** execute function "get_trips_geojson" and query aggregates on result of table type "empty_tables.geojson_trip" */
  get_trips_geojson_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  /** fetch data from the table: "inspection" */
  inspection: Array<Inspection>;
  /** fetch aggregated fields from the table: "inspection" */
  inspection_aggregate: Inspection_Aggregate;
  /** fetch data from the table: "inspection_analysis_parameter" */
  inspection_analysis_parameter: Array<Inspection_Analysis_Parameter>;
  /** fetch aggregated fields from the table: "inspection_analysis_parameter" */
  inspection_analysis_parameter_aggregate: Inspection_Analysis_Parameter_Aggregate;
  /** fetch data from the table: "inspection_analysis_parameter" using primary key columns */
  inspection_analysis_parameter_by_pk: Maybe<Inspection_Analysis_Parameter>;
  /** fetch data from the table: "inspection" using primary key columns */
  inspection_by_pk: Maybe<Inspection>;
  /** fetch data from the table: "inspection_fk_tire" */
  inspection_fk_tire: Array<Inspection_Fk_Tire>;
  /** fetch aggregated fields from the table: "inspection_fk_tire" */
  inspection_fk_tire_aggregate: Inspection_Fk_Tire_Aggregate;
  /** fetch data from the table: "inspection_fk_tire" using primary key columns */
  inspection_fk_tire_by_pk: Maybe<Inspection_Fk_Tire>;
  inspections_export: Array<InspectionsExport>;
  inspections_that_reported_excessive_high_pressure: Array<InspectionProblem>;
  inspections_that_reported_excessive_low_pressure: Array<InspectionProblem>;
  inspections_that_reported_high_pressure: Array<InspectionProblem>;
  inspections_that_reported_high_twin_tires_minimum_depth_difference: Array<InspectionProblem>;
  inspections_that_reported_low_pressure: Array<InspectionProblem>;
  inspections_that_reported_low_tire_depth: Array<InspectionProblem>;
  inspections_that_reported_open_services: Array<InspectionProblem>;
  inspections_that_reported_wear_irregular: Array<InspectionProblem>;
  inspections_that_reported_wear_severe: Array<InspectionProblem>;
  inspections_that_reported_wear_severe_cavalo_mecanico: Array<InspectionProblem>;
  inspections_that_reported_wear_severe_semi_reboque: Array<InspectionProblem>;
  /** execute function "instructor_drivers_performance_history" which returns "empty_tables.instructor_drivers_performance_history" */
  instructor_drivers_performance_history: Array<Empty_Tables_Instructor_Drivers_Performance_History>;
  /** execute function "instructor_drivers_performance_history" and query aggregates on result of table type "empty_tables.instructor_drivers_performance_history" */
  instructor_drivers_performance_history_aggregate: Empty_Tables_Instructor_Drivers_Performance_History_Aggregate;
  /** fetch data from the table: "instructor_supervision" */
  instructor_supervision: Array<Instructor_Supervision>;
  /** fetch aggregated fields from the table: "instructor_supervision" */
  instructor_supervision_aggregate: Instructor_Supervision_Aggregate;
  /** fetch data from the table: "instructor_supervision" using primary key columns */
  instructor_supervision_by_pk: Maybe<Instructor_Supervision>;
  /** fetch data from the table: "instructor_supervision_observation" */
  instructor_supervision_observation: Array<Instructor_Supervision_Observation>;
  /** fetch aggregated fields from the table: "instructor_supervision_observation" */
  instructor_supervision_observation_aggregate: Instructor_Supervision_Observation_Aggregate;
  /** fetch data from the table: "instructor_supervision_observation" using primary key columns */
  instructor_supervision_observation_by_pk: Maybe<Instructor_Supervision_Observation>;
  /** fetch data from the table: "instructor_supervision_with_user" */
  instructor_supervision_with_user: Array<Instructor_Supervision_With_User>;
  /** fetch aggregated fields from the table: "instructor_supervision_with_user" */
  instructor_supervision_with_user_aggregate: Instructor_Supervision_With_User_Aggregate;
  /** fetch data from the table: "last_inspection_tire_by_vehicle" */
  last_inspection_tire_by_vehicle: Array<Last_Inspection_Tire_By_Vehicle>;
  /** fetch aggregated fields from the table: "last_inspection_tire_by_vehicle" */
  last_inspection_tire_by_vehicle_aggregate: Last_Inspection_Tire_By_Vehicle_Aggregate;
  last_inspection_tire_by_vehicle_plate: Array<Inspection_Tire_By_Vehicle>;
  /** fetch data from the table: "level" */
  level: Array<Level>;
  /** fetch aggregated fields from the table: "level" */
  level_aggregate: Level_Aggregate;
  /** fetch data from the table: "level" using primary key columns */
  level_by_pk: Maybe<Level>;
  /** fetch data from the table: "level_option" */
  level_option: Array<Level_Option>;
  /** fetch aggregated fields from the table: "level_option" */
  level_option_aggregate: Level_Option_Aggregate;
  /** fetch data from the table: "level_option" using primary key columns */
  level_option_by_pk: Maybe<Level_Option>;
  /** fetch data from the table: "module" */
  module: Array<Module>;
  /** fetch aggregated fields from the table: "module" */
  module_aggregate: Module_Aggregate;
  /** fetch data from the table: "module" using primary key columns */
  module_by_pk: Maybe<Module>;
  /** fetch data from the table: "module_permission" */
  module_permission: Array<Module_Permission>;
  /** fetch aggregated fields from the table: "module_permission" */
  module_permission_aggregate: Module_Permission_Aggregate;
  /** fetch data from the table: "module_permission" using primary key columns */
  module_permission_by_pk: Maybe<Module_Permission>;
  next_tire_processing_date_range: Array<Next_Tire_Processing_Unit>;
  /** fetch data from the table: "note" */
  note: Array<Note>;
  /** fetch aggregated fields from the table: "note" */
  note_aggregate: Note_Aggregate;
  /** fetch data from the table: "note" using primary key columns */
  note_by_pk: Maybe<Note>;
  /** fetch data from the table: "notification" */
  notification: Array<Notification>;
  /** fetch aggregated fields from the table: "notification" */
  notification_aggregate: Notification_Aggregate;
  /** fetch data from the table: "notification" using primary key columns */
  notification_by_pk: Maybe<Notification>;
  /** fetch data from the table: "planet_osm_line" */
  planet_osm_line: Array<Planet_Osm_Line>;
  /** fetch aggregated fields from the table: "planet_osm_line" */
  planet_osm_line_aggregate: Planet_Osm_Line_Aggregate;
  /** fetch data from the table: "product" */
  product: Array<Product>;
  /** fetch aggregated fields from the table: "product" */
  product_aggregate: Product_Aggregate;
  /** fetch data from the table: "product" using primary key columns */
  product_by_pk: Maybe<Product>;
  /** fetch data from the table: "product_price" */
  product_price: Array<Product_Price>;
  /** fetch aggregated fields from the table: "product_price" */
  product_price_aggregate: Product_Price_Aggregate;
  /** fetch data from the table: "product_price" using primary key columns */
  product_price_by_pk: Maybe<Product_Price>;
  /** fetch data from the table: "product_request" */
  product_request: Array<Product_Request>;
  /** fetch aggregated fields from the table: "product_request" */
  product_request_aggregate: Product_Request_Aggregate;
  /** fetch data from the table: "product_request" using primary key columns */
  product_request_by_pk: Maybe<Product_Request>;
  /** fetch data from the table: "profile" */
  profile: Array<Profile>;
  /** fetch aggregated fields from the table: "profile" */
  profile_aggregate: Profile_Aggregate;
  /** fetch data from the table: "profile" using primary key columns */
  profile_by_pk: Maybe<Profile>;
  /** fetch data from the table: "profile_permission" */
  profile_permission: Array<Profile_Permission>;
  /** fetch aggregated fields from the table: "profile_permission" */
  profile_permission_aggregate: Profile_Permission_Aggregate;
  /** fetch data from the table: "profile_permission" using primary key columns */
  profile_permission_by_pk: Maybe<Profile_Permission>;
  /** fetch data from the table: "refresh_token" */
  refresh_token: Array<Refresh_Token>;
  /** fetch aggregated fields from the table: "refresh_token" */
  refresh_token_aggregate: Refresh_Token_Aggregate;
  /** fetch data from the table: "refresh_token" using primary key columns */
  refresh_token_by_pk: Maybe<Refresh_Token>;
  risk_intensity_avg_and_max: Array<Risk_Intensity_Model>;
  risk_intensity_indicators_by_driver: Array<Risk_Intensity_Indicators_Model>;
  risky_intensity_by_driver: Array<Risk_Intensity_By_Driver_Model>;
  /** fetch data from the table: "score_processed" */
  score_processed: Array<Score_Processed>;
  /** fetch aggregated fields from the table: "score_processed" */
  score_processed_aggregate: Score_Processed_Aggregate;
  /** fetch data from the table: "score_processed" using primary key columns */
  score_processed_by_pk: Maybe<Score_Processed>;
  /** fetch data from the table: "score_type" */
  score_type: Array<Score_Type>;
  /** fetch aggregated fields from the table: "score_type" */
  score_type_aggregate: Score_Type_Aggregate;
  /** fetch data from the table: "score_type" using primary key columns */
  score_type_by_pk: Maybe<Score_Type>;
  signin: Maybe<SigninOutput>;
  /** fetch data from the table: "status_truck_hardware" */
  status_truck_hardware: Array<Status_Truck_Hardware>;
  /** fetch aggregated fields from the table: "status_truck_hardware" */
  status_truck_hardware_aggregate: Status_Truck_Hardware_Aggregate;
  /** fetch data from the table: "status_truck_hardware" using primary key columns */
  status_truck_hardware_by_pk: Maybe<Status_Truck_Hardware>;
  /** fetch data from the table: "tire" */
  tire: Array<Tire>;
  /** fetch aggregated fields from the table: "tire" */
  tire_aggregate: Tire_Aggregate;
  /** fetch data from the table: "tire" using primary key columns */
  tire_by_pk: Maybe<Tire>;
  /** fetch data from the table: "tire.inspection" */
  tire_inspection: Array<Tire_Inspection>;
  /** fetch aggregated fields from the table: "tire.inspection" */
  tire_inspection_aggregate: Tire_Inspection_Aggregate;
  /** fetch data from the table: "tire.inspection" using primary key columns */
  tire_inspection_by_pk: Maybe<Tire_Inspection>;
  /** fetch data from the table: "tire.inspection_fk_tire" */
  tire_inspection_fk_tire: Array<Tire_Inspection_Fk_Tire>;
  /** fetch aggregated fields from the table: "tire.inspection_fk_tire" */
  tire_inspection_fk_tire_aggregate: Tire_Inspection_Fk_Tire_Aggregate;
  /** fetch data from the table: "tire.inspection_fk_tire" using primary key columns */
  tire_inspection_fk_tire_by_pk: Maybe<Tire_Inspection_Fk_Tire>;
  /** fetch data from the table: "tire.inspection_note" */
  tire_inspection_note: Array<Tire_Inspection_Note>;
  /** fetch aggregated fields from the table: "tire.inspection_note" */
  tire_inspection_note_aggregate: Tire_Inspection_Note_Aggregate;
  /** fetch data from the table: "tire.inspection_note_attachment" */
  tire_inspection_note_attachment: Array<Tire_Inspection_Note_Attachment>;
  /** fetch aggregated fields from the table: "tire.inspection_note_attachment" */
  tire_inspection_note_attachment_aggregate: Tire_Inspection_Note_Attachment_Aggregate;
  /** fetch data from the table: "tire.inspection_note_attachment" using primary key columns */
  tire_inspection_note_attachment_by_pk: Maybe<Tire_Inspection_Note_Attachment>;
  /** fetch data from the table: "tire.inspection_note" using primary key columns */
  tire_inspection_note_by_pk: Maybe<Tire_Inspection_Note>;
  /** fetch data from the table: "tire.inspection_origin" */
  tire_inspection_origin: Array<Tire_Inspection_Origin>;
  /** fetch aggregated fields from the table: "tire.inspection_origin" */
  tire_inspection_origin_aggregate: Tire_Inspection_Origin_Aggregate;
  /** fetch data from the table: "tire.inspection_origin" using primary key columns */
  tire_inspection_origin_by_pk: Maybe<Tire_Inspection_Origin>;
  /** fetch data from the table: "tire.note_type" */
  tire_note_type: Array<Tire_Note_Type>;
  /** fetch aggregated fields from the table: "tire.note_type" */
  tire_note_type_aggregate: Tire_Note_Type_Aggregate;
  /** fetch data from the table: "tire.note_type" using primary key columns */
  tire_note_type_by_pk: Maybe<Tire_Note_Type>;
  /** fetch data from the table: "tire.parameter" */
  tire_parameter: Array<Tire_Parameter>;
  /** fetch aggregated fields from the table: "tire.parameter" */
  tire_parameter_aggregate: Tire_Parameter_Aggregate;
  /** fetch data from the table: "tire.parameter" using primary key columns */
  tire_parameter_by_pk: Maybe<Tire_Parameter>;
  /** fetch data from the table: "tire_processing_history" */
  tire_processing_history: Array<Tire_Processing_History>;
  /** fetch aggregated fields from the table: "tire_processing_history" */
  tire_processing_history_aggregate: Tire_Processing_History_Aggregate;
  /** fetch data from the table: "tire_processing_history" using primary key columns */
  tire_processing_history_by_pk: Maybe<Tire_Processing_History>;
  /** fetch data from the table: "tirecheck_inconsistency" */
  tirecheck_inconsistency: Array<Tirecheck_Inconsistency>;
  /** fetch aggregated fields from the table: "tirecheck_inconsistency" */
  tirecheck_inconsistency_aggregate: Tirecheck_Inconsistency_Aggregate;
  /** fetch data from the table: "tirecheck_inconsistency" using primary key columns */
  tirecheck_inconsistency_by_pk: Maybe<Tirecheck_Inconsistency>;
  /** fetch data from the table: "training" */
  training: Array<Training>;
  /** fetch aggregated fields from the table: "training" */
  training_aggregate: Training_Aggregate;
  /** fetch data from the table: "training" using primary key columns */
  training_by_pk: Maybe<Training>;
  /** fetch data from the table: "training_document" */
  training_document: Array<Training_Document>;
  /** fetch aggregated fields from the table: "training_document" */
  training_document_aggregate: Training_Document_Aggregate;
  /** fetch data from the table: "training_document" using primary key columns */
  training_document_by_pk: Maybe<Training_Document>;
  /** fetch data from the table: "training_document_view" */
  training_document_view: Array<Training_Document_View>;
  /** fetch aggregated fields from the table: "training_document_view" */
  training_document_view_aggregate: Training_Document_View_Aggregate;
  /** fetch data from the table: "training_document_view" using primary key columns */
  training_document_view_by_pk: Maybe<Training_Document_View>;
  trip_analysis_with_all_drivers_by_month: Array<TripAnalysisWithAllDriversByMonthSingleOutput>;
  trip_analysis_with_all_months_by_driver: Array<TripAnalysisWithAllMonthsByDriverSingleOutput>;
  /** fetch data from the table: "user" */
  user: Array<User>;
  /** fetch aggregated fields from the table: "user" */
  user_aggregate: User_Aggregate;
  /** fetch data from the table: "user" using primary key columns */
  user_by_pk: Maybe<User>;
  /** fetch data from the table: "user_fk_achievement" */
  user_fk_achievement: Array<User_Fk_Achievement>;
  /** fetch aggregated fields from the table: "user_fk_achievement" */
  user_fk_achievement_aggregate: User_Fk_Achievement_Aggregate;
  /** fetch data from the table: "user_fk_achievement" using primary key columns */
  user_fk_achievement_by_pk: Maybe<User_Fk_Achievement>;
  /** fetch data from the table: "user_fk_challenge" */
  user_fk_challenge: Array<User_Fk_Challenge>;
  /** fetch aggregated fields from the table: "user_fk_challenge" */
  user_fk_challenge_aggregate: User_Fk_Challenge_Aggregate;
  /** fetch data from the table: "user_fk_challenge" using primary key columns */
  user_fk_challenge_by_pk: Maybe<User_Fk_Challenge>;
  /** fetch data from the table: "user_fk_level" */
  user_fk_level: Array<User_Fk_Level>;
  /** fetch aggregated fields from the table: "user_fk_level" */
  user_fk_level_aggregate: User_Fk_Level_Aggregate;
  /** fetch data from the table: "user_fk_level" using primary key columns */
  user_fk_level_by_pk: Maybe<User_Fk_Level>;
  /** fetch data from the table: "user_fk_notification" */
  user_fk_notification: Array<User_Fk_Notification>;
  /** fetch aggregated fields from the table: "user_fk_notification" */
  user_fk_notification_aggregate: User_Fk_Notification_Aggregate;
  /** fetch data from the table: "user_fk_notification" using primary key columns */
  user_fk_notification_by_pk: Maybe<User_Fk_Notification>;
  /** fetch data from the table: "user_fk_privacy_policy" */
  user_fk_privacy_policy: Array<User_Fk_Privacy_Policy>;
  /** fetch aggregated fields from the table: "user_fk_privacy_policy" */
  user_fk_privacy_policy_aggregate: User_Fk_Privacy_Policy_Aggregate;
  /** fetch data from the table: "user_fk_privacy_policy" using primary key columns */
  user_fk_privacy_policy_by_pk: Maybe<User_Fk_Privacy_Policy>;
  /** fetch data from the table: "user_km_points_approval" */
  user_km_points_approval: Array<User_Km_Points_Approval>;
  /** fetch aggregated fields from the table: "user_km_points_approval" */
  user_km_points_approval_aggregate: User_Km_Points_Approval_Aggregate;
  /** fetch data from the table: "user_km_points_approval" using primary key columns */
  user_km_points_approval_by_pk: Maybe<User_Km_Points_Approval>;
  /** An array relationship */
  user_kmps: Array<User_Kmps>;
  /** An aggregate relationship */
  user_kmps_aggregate: User_Kmps_Aggregate;
  /** fetch data from the table: "user_kmps" using primary key columns */
  user_kmps_by_pk: Maybe<User_Kmps>;
  /** fetch data from the table: "user_score" */
  user_score: Array<User_Score>;
  /** fetch aggregated fields from the table: "user_score" */
  user_score_aggregate: User_Score_Aggregate;
  /** fetch data from the table: "user_score" using primary key columns */
  user_score_by_pk: Maybe<User_Score>;
  /** An array relationship */
  user_score_ranking: Array<User_Score_Ranking>;
  /** An aggregate relationship */
  user_score_ranking_aggregate: User_Score_Ranking_Aggregate;
  /** fetch data from the table: "user_training" */
  user_training: Array<User_Training>;
  /** fetch aggregated fields from the table: "user_training" */
  user_training_aggregate: User_Training_Aggregate;
  /** fetch data from the table: "user_training" using primary key columns */
  user_training_by_pk: Maybe<User_Training>;
  /** fetch data from the table: "vehicle" */
  vehicle: Array<Vehicle>;
  /** fetch aggregated fields from the table: "vehicle" */
  vehicle_aggregate: Vehicle_Aggregate;
  /** fetch data from the table: "vehicle" using primary key columns */
  vehicle_by_pk: Maybe<Vehicle>;
  /** fetch data from the table: "whatsapp_event" */
  whatsapp_event: Array<Whatsapp_Event>;
  /** fetch aggregated fields from the table: "whatsapp_event" */
  whatsapp_event_aggregate: Whatsapp_Event_Aggregate;
  /** fetch data from the table: "whatsapp_event" using primary key columns */
  whatsapp_event_by_pk: Maybe<Whatsapp_Event>;
  /** fetch data from the table: "whatsapp_message" */
  whatsapp_message: Array<Whatsapp_Message>;
  /** fetch aggregated fields from the table: "whatsapp_message" */
  whatsapp_message_aggregate: Whatsapp_Message_Aggregate;
  /** fetch data from the table: "whatsapp_message" using primary key columns */
  whatsapp_message_by_pk: Maybe<Whatsapp_Message>;
  /** fetch data from the table: "whatsapp_message_history" */
  whatsapp_message_history: Array<Whatsapp_Message_History>;
  /** fetch aggregated fields from the table: "whatsapp_message_history" */
  whatsapp_message_history_aggregate: Whatsapp_Message_History_Aggregate;
  /** fetch data from the table: "whatsapp_message_history" using primary key columns */
  whatsapp_message_history_by_pk: Maybe<Whatsapp_Message_History>;
  /** fetch data from the table: "whatsapp_trigger" */
  whatsapp_trigger: Array<Whatsapp_Trigger>;
  /** fetch aggregated fields from the table: "whatsapp_trigger" */
  whatsapp_trigger_aggregate: Whatsapp_Trigger_Aggregate;
  /** fetch data from the table: "whatsapp_trigger" using primary key columns */
  whatsapp_trigger_by_pk: Maybe<Whatsapp_Trigger>;
  wrong_data_trips: Array<WrongDataTrips>;
};


export type Query_RootCurrentTiresByVehicleArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CurrentTiresByVehicle_Order_By>>;
  where?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
};


export type Query_RootCurrentTiresByVehicle_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CurrentTiresByVehicle_Order_By>>;
  where?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
};


export type Query_RootParametroAlertaConducaoArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ParametroAlertaConducao_Order_By>>;
  where?: InputMaybe<ParametroAlertaConducao_Bool_Exp>;
};


export type Query_RootParametroAlertaConducao_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ParametroAlertaConducao_Order_By>>;
  where?: InputMaybe<ParametroAlertaConducao_Bool_Exp>;
};


export type Query_RootParametroAlertaConducao_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootPerformanceParameterArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PerformanceParameter_Order_By>>;
  where?: InputMaybe<PerformanceParameter_Bool_Exp>;
};


export type Query_RootPerformanceParameter_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PerformanceParameter_Order_By>>;
  where?: InputMaybe<PerformanceParameter_Bool_Exp>;
};


export type Query_RootPerformanceParameter_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootPontosRastroArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PontosRastro_Order_By>>;
  where?: InputMaybe<PontosRastro_Bool_Exp>;
};


export type Query_RootPontosRastro_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PontosRastro_Order_By>>;
  where?: InputMaybe<PontosRastro_Bool_Exp>;
};


export type Query_RootPontosRastro_By_PkArgs = {
  PontoRastroId: Scalars['Int']['input'];
};


export type Query_RootScoreParameterArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};


export type Query_RootScoreParameter_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};


export type Query_RootScoreParameter_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootScoreTypeArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreType_Order_By>>;
  where?: InputMaybe<ScoreType_Bool_Exp>;
};


export type Query_RootScoreType_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreType_Order_By>>;
  where?: InputMaybe<ScoreType_Bool_Exp>;
};


export type Query_RootScoreType_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootSuntechEquipamentoArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechEquipamento_Order_By>>;
  where?: InputMaybe<SuntechEquipamento_Bool_Exp>;
};


export type Query_RootSuntechEquipamento_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechEquipamento_Order_By>>;
  where?: InputMaybe<SuntechEquipamento_Bool_Exp>;
};


export type Query_RootSuntechTrackerBatchCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommand_Bool_Exp>;
};


export type Query_RootSuntechTrackerBatchCommandDeviceArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
};


export type Query_RootSuntechTrackerBatchCommandDevice_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
};


export type Query_RootSuntechTrackerBatchCommandDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootSuntechTrackerBatchCommandPresetArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandPreset_Bool_Exp>;
};


export type Query_RootSuntechTrackerBatchCommandPreset_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandPreset_Bool_Exp>;
};


export type Query_RootSuntechTrackerBatchCommandPreset_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootSuntechTrackerBatchCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommand_Bool_Exp>;
};


export type Query_RootSuntechTrackerBatchCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootSuntechTrackerCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
};


export type Query_RootSuntechTrackerCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
};


export type Query_RootSuntechTrackerCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootTireAnalysisReportArgs = {
  args: TireAnalysisReport_Arguments;
  distinct_on?: InputMaybe<Array<TireAnalysisReport_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TireAnalysisReport_Order_By>>;
  where?: InputMaybe<TireAnalysisReport_Bool_Exp_Bool_Exp>;
};


export type Query_RootVirlocTrackerBatchCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommand_Bool_Exp>;
};


export type Query_RootVirlocTrackerBatchCommandDeviceArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
};


export type Query_RootVirlocTrackerBatchCommandDevice_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
};


export type Query_RootVirlocTrackerBatchCommandDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootVirlocTrackerBatchCommandPresetArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandPreset_Bool_Exp>;
};


export type Query_RootVirlocTrackerBatchCommandPreset_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandPreset_Bool_Exp>;
};


export type Query_RootVirlocTrackerBatchCommandPreset_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootVirlocTrackerBatchCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommand_Bool_Exp>;
};


export type Query_RootVirlocTrackerBatchCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootVirlocTrackerCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
};


export type Query_RootVirlocTrackerCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
};


export type Query_RootVirlocTrackerCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootVirlocTrackerDeviceArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerDevice_Bool_Exp>;
};


export type Query_RootVirlocTrackerDevice_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerDevice_Bool_Exp>;
};


export type Query_RootVirlocTrackerDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Query_RootAchievementArgs = {
  distinct_on?: InputMaybe<Array<Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Achievement_Order_By>>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};


export type Query_RootAchievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Achievement_Order_By>>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};


export type Query_RootAchievement_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootAdminArgs = {
  distinct_on?: InputMaybe<Array<Admin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Order_By>>;
  where?: InputMaybe<Admin_Bool_Exp>;
};


export type Query_RootAdmin_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Order_By>>;
  where?: InputMaybe<Admin_Bool_Exp>;
};


export type Query_RootAdmin_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootAdmin_Fk_NotificationsArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


export type Query_RootAdmin_Fk_Notifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


export type Query_RootAdmin_Fk_Notifications_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  notification_uuid: Scalars['uuid']['input'];
};


export type Query_RootAdmin_Fk_ProfileArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


export type Query_RootAdmin_Fk_Profile_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


export type Query_RootAdmin_Fk_Profile_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  created_at: Scalars['timestamptz']['input'];
  profile_uuid: Scalars['uuid']['input'];
};


export type Query_RootAdmin_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


export type Query_RootAdmin_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


export type Query_RootAdmin_Permission_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
};


export type Query_RootAdmin_SigninArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type Query_RootApp_SigninArgs = {
  cpf: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type Query_RootAutoArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Auto_Order_By>>;
  where?: InputMaybe<Auto_Bool_Exp>;
};


export type Query_RootAuto_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Auto_Order_By>>;
  where?: InputMaybe<Auto_Bool_Exp>;
};


export type Query_RootAuto_By_PkArgs = {
  placa: Scalars['String']['input'];
};


export type Query_RootBi_DashboardArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Bool_Exp>;
};


export type Query_RootBi_Dashboard_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Bool_Exp>;
};


export type Query_RootBi_Dashboard_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_Dashboard_ItemArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


export type Query_RootBi_Dashboard_Item_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


export type Query_RootBi_Dashboard_Item_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_Dashboard_Item_TypeArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Type_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
};


export type Query_RootBi_Dashboard_Item_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Type_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
};


export type Query_RootBi_Dashboard_Item_Type_By_PkArgs = {
  type: Scalars['String']['input'];
};


export type Query_RootBi_DatasourceArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};


export type Query_RootBi_Datasource_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};


export type Query_RootBi_Datasource_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_Datasource_TypeArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Type_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
};


export type Query_RootBi_Datasource_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Type_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
};


export type Query_RootBi_Datasource_Type_By_PkArgs = {
  type: Scalars['String']['input'];
};


export type Query_RootBi_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Order_By>>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};


export type Query_RootBi_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Order_By>>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};


export type Query_RootBi_Permission_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootBi_Permission_ModuleArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Module_Order_By>>;
  where?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
};


export type Query_RootBi_Permission_Module_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Module_Order_By>>;
  where?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
};


export type Query_RootBi_Permission_Module_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootBi_Public_LinkArgs = {
  distinct_on?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Public_Link_Order_By>>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};


export type Query_RootBi_Public_Link_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Public_Link_Order_By>>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};


export type Query_RootBi_Public_Link_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_QueryArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Order_By>>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};


export type Query_RootBi_Query_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Order_By>>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};


export type Query_RootBi_Query_AnalyticsArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Analytics_Order_By>>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};


export type Query_RootBi_Query_Analytics_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Analytics_Order_By>>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};


export type Query_RootBi_Query_Analytics_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_Query_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_Query_CacheArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


export type Query_RootBi_Query_Cache_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


export type Query_RootBi_Query_Cache_By_PkArgs = {
  dashboard_uuid: Scalars['uuid']['input'];
  params_hash: Scalars['String']['input'];
  query_uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_SubqueryArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


export type Query_RootBi_Subquery_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


export type Query_RootBi_Subquery_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootBi_User_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_User_Permission_Order_By>>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};


export type Query_RootBi_User_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_User_Permission_Order_By>>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};


export type Query_RootBi_User_Permission_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootChallengeArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Order_By>>;
  where?: InputMaybe<Challenge_Bool_Exp>;
};


export type Query_RootChallenge_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Order_By>>;
  where?: InputMaybe<Challenge_Bool_Exp>;
};


export type Query_RootChallenge_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootChallenge_TypeArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Type_Order_By>>;
  where?: InputMaybe<Challenge_Type_Bool_Exp>;
};


export type Query_RootChallenge_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Type_Order_By>>;
  where?: InputMaybe<Challenge_Type_Bool_Exp>;
};


export type Query_RootChallenge_Type_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Query_RootConfigArgs = {
  distinct_on?: InputMaybe<Array<Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Config_Order_By>>;
  where?: InputMaybe<Config_Bool_Exp>;
};


export type Query_RootConfig_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Config_Order_By>>;
  where?: InputMaybe<Config_Bool_Exp>;
};


export type Query_RootConfig_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCritical_PointArgs = {
  distinct_on?: InputMaybe<Array<Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Point_Order_By>>;
  where?: InputMaybe<Critical_Point_Bool_Exp>;
};


export type Query_RootCritical_Point_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Point_Order_By>>;
  where?: InputMaybe<Critical_Point_Bool_Exp>;
};


export type Query_RootCritical_Point_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCritical_SegmentArgs = {
  distinct_on?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Segment_Order_By>>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};


export type Query_RootCritical_Segment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Segment_Order_By>>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};


export type Query_RootCritical_Segment_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCte_Nf_LockArgs = {
  distinct_on?: InputMaybe<Array<Cte_Nf_Lock_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cte_Nf_Lock_Order_By>>;
  where?: InputMaybe<Cte_Nf_Lock_Bool_Exp>;
};


export type Query_RootCte_Nf_Lock_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cte_Nf_Lock_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cte_Nf_Lock_Order_By>>;
  where?: InputMaybe<Cte_Nf_Lock_Bool_Exp>;
};


export type Query_RootCte_Nf_Lock_By_PkArgs = {
  nf: Scalars['Int']['input'];
};


export type Query_RootCurrent_ConfigArgs = {
  distinct_on?: InputMaybe<Array<Current_Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Current_Config_Order_By>>;
  where?: InputMaybe<Current_Config_Bool_Exp>;
};


export type Query_RootCurrent_Config_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Current_Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Current_Config_Order_By>>;
  where?: InputMaybe<Current_Config_Bool_Exp>;
};


export type Query_RootDeleted_RowArgs = {
  distinct_on?: InputMaybe<Array<Deleted_Row_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Deleted_Row_Order_By>>;
  where?: InputMaybe<Deleted_Row_Bool_Exp>;
};


export type Query_RootDeleted_Row_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Deleted_Row_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Deleted_Row_Order_By>>;
  where?: InputMaybe<Deleted_Row_Bool_Exp>;
};


export type Query_RootDeleted_Row_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDeliveryArgs = {
  distinct_on?: InputMaybe<Array<Delivery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Delivery_Order_By>>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};


export type Query_RootDelivery_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Delivery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Delivery_Order_By>>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};


export type Query_RootDelivery_By_PkArgs = {
  document_number: Scalars['String']['input'];
  invoice_number: Scalars['String']['input'];
  trip_id: Scalars['String']['input'];
};


export type Query_RootDriver_Performance_DataArgs = {
  args: Driver_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Query_RootDriver_Performance_Data_AggregateArgs = {
  args: Driver_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Query_RootDriver_WarningArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


export type Query_RootDriver_Warning_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


export type Query_RootDriver_Warning_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootDriver_Warning_CommentArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


export type Query_RootDriver_Warning_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


export type Query_RootDriver_Warning_Comment_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootDriver_Warning_Fk_Whatsapp_MessageArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>;
};


export type Query_RootDriver_Warning_Fk_Whatsapp_Message_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>;
};


export type Query_RootDriver_Warning_Fk_Whatsapp_Message_By_PkArgs = {
  driver_warning_uuid: Scalars['uuid']['input'];
  whatsapp_message_uuid: Scalars['uuid']['input'];
};


export type Query_RootDriver_Warning_Risk_LevelArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_Bool_Exp>;
};


export type Query_RootDriver_Warning_Risk_Level_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_Bool_Exp>;
};


export type Query_RootDriver_Warning_Risk_Level_By_PkArgs = {
  level_name: Scalars['String']['input'];
};


export type Query_RootDriver_Warning_Risk_Level_ViewArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_View_Bool_Exp>;
};


export type Query_RootDriver_Warning_Risk_Level_View_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_View_Bool_Exp>;
};


export type Query_RootDriver_Warning_TripArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};


export type Query_RootDriver_Warning_Trip_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};


export type Query_RootDriver_Warning_Trip_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootDriver_Warning_Trip_PointArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Point_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};


export type Query_RootDriver_Warning_Trip_Point_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Point_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};


export type Query_RootDriver_Warning_Trip_Point_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriver_Warning_Trip_SeverityArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Severity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Severity_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
};


export type Query_RootDriver_Warning_Trip_Severity_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Severity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Severity_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
};


export type Query_RootDriver_Warning_Trip_Severity_By_PkArgs = {
  severity_level: Scalars['Int']['input'];
};


export type Query_RootEdi_Busca_Nfe_JobArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Job_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Job_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
};


export type Query_RootEdi_Busca_Nfe_Job_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Job_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Job_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
};


export type Query_RootEdi_Busca_Nfe_Job_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootEdi_Busca_Nfe_ResponseArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Response_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};


export type Query_RootEdi_Busca_Nfe_Response_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Response_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};


export type Query_RootEdi_Busca_Nfe_Response_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootEmpty_Tables_Critical_Segment_From_Critical_PointArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Critical_Segment_From_Critical_Point_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Driver_Performance_DataArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Driver_Performance_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Fleet_Performance_DataArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Fleet_Performance_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Fleet_Performance_Data_By_PkArgs = {
  brake_use_avg: Scalars['Int']['input'];
  economic_range_avg: Scalars['Int']['input'];
  engine_load_avg: Scalars['Int']['input'];
  inertia_avg: Scalars['Int']['input'];
  note_avg: Scalars['Int']['input'];
  slow_running_avg: Scalars['Int']['input'];
  speed_control_avg: Scalars['Int']['input'];
  total_count: Scalars['Int']['input'];
  total_drivers: Scalars['Int']['input'];
  total_km: Scalars['float8']['input'];
  total_km_avg: Scalars['float8']['input'];
  total_periods: Scalars['Int']['input'];
};


export type Query_RootEmpty_Tables_Geojson_TripArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Geojson_Trip_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Geojson_Trip_By_PkArgs = {
  trip_id: Scalars['Int']['input'];
};


export type Query_RootEmpty_Tables_Instructor_Drivers_Performance_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Query_RootEmpty_Tables_Instructor_Drivers_Performance_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Query_RootFidelity_Range_PointsArgs = {
  distinct_on?: InputMaybe<Array<Fidelity_Range_Points_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fidelity_Range_Points_Order_By>>;
  where?: InputMaybe<Fidelity_Range_Points_Bool_Exp>;
};


export type Query_RootFidelity_Range_Points_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fidelity_Range_Points_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fidelity_Range_Points_Order_By>>;
  where?: InputMaybe<Fidelity_Range_Points_Bool_Exp>;
};


export type Query_RootFidelity_Range_Points_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootFipe_PriceArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


export type Query_RootFipe_Price_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


export type Query_RootFipe_Price_By_PkArgs = {
  reference_table_date: Scalars['date']['input'];
  vehicle_fipe_code: Scalars['String']['input'];
  vehicle_model_year: Scalars['Int']['input'];
};


export type Query_RootFipe_Reference_MonthArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Reference_Month_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Reference_Month_Order_By>>;
  where?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
};


export type Query_RootFipe_Reference_Month_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Reference_Month_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Reference_Month_Order_By>>;
  where?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
};


export type Query_RootFipe_Reference_Month_By_PkArgs = {
  code: Scalars['Int']['input'];
};


export type Query_RootFipe_Search_Fipe_VehicleArgs = {
  args: Fipe_Search_Fipe_Vehicle_Args;
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Query_RootFipe_Search_Fipe_Vehicle_AggregateArgs = {
  args: Fipe_Search_Fipe_Vehicle_Args;
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Query_RootFipe_Selected_VehicleArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Selected_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};


export type Query_RootFipe_Selected_Vehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Selected_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};


export type Query_RootFipe_Selected_Vehicle_By_PkArgs = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};


export type Query_RootFipe_VehicleArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Query_RootFipe_Vehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Query_RootFipe_Vehicle_By_PkArgs = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};


export type Query_RootFleet_Performance_DataArgs = {
  args: Fleet_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Query_RootFleet_Performance_Data_AggregateArgs = {
  args: Fleet_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Query_RootFuel_Analysis_By_All_DriversArgs = {
  end_date: Scalars['timestamptz']['input'];
  motorista_codes?: InputMaybe<Array<Scalars['String']['input']>>;
  start_date: Scalars['timestamptz']['input'];
};


export type Query_RootFuel_Analysis_By_DriversArgs = {
  end_date: Scalars['timestamptz']['input'];
  motorista_codes: Array<Scalars['String']['input']>;
  start_date: Scalars['timestamptz']['input'];
};


export type Query_RootGetTripHeadersByDateRangeAndCodmotoArgs = {
  codmoto: Scalars['String']['input'];
  endAt: Scalars['timestamptz']['input'];
  startAt: Scalars['timestamptz']['input'];
};


export type Query_RootGetTripsReportsByTripIdsArgs = {
  tripIds: Array<Scalars['Int']['input']>;
};


export type Query_RootGetVolvoReportArgs = {
  codmoto: Scalars['String']['input'];
  endAt: Scalars['timestamptz']['input'];
  licensePlate: Scalars['String']['input'];
  startAt: Scalars['timestamptz']['input'];
};


export type Query_RootGet_Critical_Segments_From_Critical_PointArgs = {
  args: Get_Critical_Segments_From_Critical_Point_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Query_RootGet_Critical_Segments_From_Critical_Point_AggregateArgs = {
  args: Get_Critical_Segments_From_Critical_Point_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Query_RootGet_Driver_Warning_GeojsonArgs = {
  args: Get_Driver_Warning_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootGet_Driver_Warning_Geojson_AggregateArgs = {
  args: Get_Driver_Warning_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootGet_Refresh_TokenArgs = {
  refresh_token: Scalars['String']['input'];
};


export type Query_RootGet_Route_Geojson_By_Score_ProcessedArgs = {
  args: Get_Route_Geojson_By_Score_Processed_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootGet_Route_Geojson_By_Score_Processed_AggregateArgs = {
  args: Get_Route_Geojson_By_Score_Processed_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootGet_Tracker_TracesArgs = {
  codmoto: Scalars['String']['input'];
  end_at: Scalars['timestamptz']['input'];
  start_at: Scalars['timestamptz']['input'];
};


export type Query_RootGet_Trips_GeojsonArgs = {
  args: Get_Trips_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootGet_Trips_Geojson_AggregateArgs = {
  args: Get_Trips_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Query_RootInspectionArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Order_By>>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};


export type Query_RootInspection_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Order_By>>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};


export type Query_RootInspection_Analysis_ParameterArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Analysis_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Analysis_Parameter_Order_By>>;
  where?: InputMaybe<Inspection_Analysis_Parameter_Bool_Exp>;
};


export type Query_RootInspection_Analysis_Parameter_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Analysis_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Analysis_Parameter_Order_By>>;
  where?: InputMaybe<Inspection_Analysis_Parameter_Bool_Exp>;
};


export type Query_RootInspection_Analysis_Parameter_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Query_RootInspection_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootInspection_Fk_TireArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


export type Query_RootInspection_Fk_Tire_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


export type Query_RootInspection_Fk_Tire_By_PkArgs = {
  inspection_id: Scalars['String']['input'];
  tire_id: Scalars['String']['input'];
};


export type Query_RootInspections_ExportArgs = {
  args: Inspections_Export_Arguments;
  distinct_on?: InputMaybe<Array<InspectionsExport_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionsExport_Order_By>>;
  where?: InputMaybe<InspectionsExport_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Excessive_High_PressureArgs = {
  args: Inspections_That_Reported_Excessive_High_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Excessive_Low_PressureArgs = {
  args: Inspections_That_Reported_Excessive_Low_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_High_PressureArgs = {
  args: Inspections_That_Reported_High_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_High_Twin_Tires_Minimum_Depth_DifferenceArgs = {
  args: Inspections_That_Reported_High_Twin_Tires_Minimum_Depth_Difference_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Low_PressureArgs = {
  args: Inspections_That_Reported_Low_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Low_Tire_DepthArgs = {
  args: Inspections_That_Reported_Low_Tire_Depth_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Open_ServicesArgs = {
  args: Inspections_That_Reported_Open_Services_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Wear_IrregularArgs = {
  args: Inspections_That_Reported_Wear_Irregular_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Wear_SevereArgs = {
  args: Inspections_That_Reported_Wear_Severe_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Wear_Severe_Cavalo_MecanicoArgs = {
  args: Inspections_That_Reported_Wear_Severe_Cavalo_Mecanico_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInspections_That_Reported_Wear_Severe_Semi_ReboqueArgs = {
  args: Inspections_That_Reported_Wear_Severe_Semi_Reboque_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Query_RootInstructor_Drivers_Performance_HistoryArgs = {
  args: Instructor_Drivers_Performance_History_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Query_RootInstructor_Drivers_Performance_History_AggregateArgs = {
  args: Instructor_Drivers_Performance_History_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Query_RootInstructor_SupervisionArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


export type Query_RootInstructor_Supervision_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


export type Query_RootInstructor_Supervision_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootInstructor_Supervision_ObservationArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};


export type Query_RootInstructor_Supervision_Observation_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};


export type Query_RootInstructor_Supervision_Observation_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootInstructor_Supervision_With_UserArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_With_User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_With_User_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_With_User_Bool_Exp>;
};


export type Query_RootInstructor_Supervision_With_User_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_With_User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_With_User_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_With_User_Bool_Exp>;
};


export type Query_RootLast_Inspection_Tire_By_VehicleArgs = {
  distinct_on?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Order_By>>;
  where?: InputMaybe<Last_Inspection_Tire_By_Vehicle_Bool_Exp>;
};


export type Query_RootLast_Inspection_Tire_By_Vehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Order_By>>;
  where?: InputMaybe<Last_Inspection_Tire_By_Vehicle_Bool_Exp>;
};


export type Query_RootLast_Inspection_Tire_By_Vehicle_PlateArgs = {
  args: Last_Inspection_Tire_By_Vehicle_Plate_Arguments;
  distinct_on?: InputMaybe<Array<Inspection_Tire_By_Vehicle_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Tire_By_Vehicle_Order_By>>;
  where?: InputMaybe<Inspection_Tire_By_Vehicle_Bool_Exp_Bool_Exp>;
};


export type Query_RootLevelArgs = {
  distinct_on?: InputMaybe<Array<Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Order_By>>;
  where?: InputMaybe<Level_Bool_Exp>;
};


export type Query_RootLevel_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Order_By>>;
  where?: InputMaybe<Level_Bool_Exp>;
};


export type Query_RootLevel_By_PkArgs = {
  number: Scalars['Int']['input'];
};


export type Query_RootLevel_OptionArgs = {
  distinct_on?: InputMaybe<Array<Level_Option_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Option_Order_By>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


export type Query_RootLevel_Option_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Level_Option_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Option_Order_By>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


export type Query_RootLevel_Option_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootModuleArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Query_RootModule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Query_RootModule_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Query_RootModule_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Module_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Permission_Order_By>>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};


export type Query_RootModule_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Permission_Order_By>>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};


export type Query_RootModule_Permission_By_PkArgs = {
  action: Scalars['String']['input'];
};


export type Query_RootNext_Tire_Processing_Date_RangeArgs = {
  args: Next_Tire_Processing_Date_Range_Arguments;
  distinct_on?: InputMaybe<Array<Next_Tire_Processing_Unit_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Next_Tire_Processing_Unit_Order_By>>;
  where?: InputMaybe<Next_Tire_Processing_Unit_Bool_Exp_Bool_Exp>;
};


export type Query_RootNoteArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};


export type Query_RootNote_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};


export type Query_RootNote_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootNotificationArgs = {
  distinct_on?: InputMaybe<Array<Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notification_Order_By>>;
  where?: InputMaybe<Notification_Bool_Exp>;
};


export type Query_RootNotification_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notification_Order_By>>;
  where?: InputMaybe<Notification_Bool_Exp>;
};


export type Query_RootNotification_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootPlanet_Osm_LineArgs = {
  distinct_on?: InputMaybe<Array<Planet_Osm_Line_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Planet_Osm_Line_Order_By>>;
  where?: InputMaybe<Planet_Osm_Line_Bool_Exp>;
};


export type Query_RootPlanet_Osm_Line_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Planet_Osm_Line_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Planet_Osm_Line_Order_By>>;
  where?: InputMaybe<Planet_Osm_Line_Bool_Exp>;
};


export type Query_RootProductArgs = {
  distinct_on?: InputMaybe<Array<Product_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Order_By>>;
  where?: InputMaybe<Product_Bool_Exp>;
};


export type Query_RootProduct_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Order_By>>;
  where?: InputMaybe<Product_Bool_Exp>;
};


export type Query_RootProduct_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootProduct_PriceArgs = {
  distinct_on?: InputMaybe<Array<Product_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Price_Order_By>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};


export type Query_RootProduct_Price_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Price_Order_By>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};


export type Query_RootProduct_Price_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootProduct_RequestArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


export type Query_RootProduct_Request_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


export type Query_RootProduct_Request_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootProfileArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Query_RootProfile_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Query_RootProfile_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootProfile_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};


export type Query_RootProfile_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};


export type Query_RootProfile_Permission_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootRefresh_TokenArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


export type Query_RootRefresh_Token_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


export type Query_RootRefresh_Token_By_PkArgs = {
  refresh_token: Scalars['String']['input'];
};


export type Query_RootRisk_Intensity_Avg_And_MaxArgs = {
  args: Risk_Intensity_Avg_And_Max_Arguments;
  distinct_on?: InputMaybe<Array<Risk_Intensity_Model_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Risk_Intensity_Model_Order_By>>;
  where?: InputMaybe<Risk_Intensity_Model_Bool_Exp_Bool_Exp>;
};


export type Query_RootRisk_Intensity_Indicators_By_DriverArgs = {
  args: Risk_Intensity_Indicators_By_Driver_Arguments;
  distinct_on?: InputMaybe<Array<Risk_Intensity_Indicators_Model_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Risk_Intensity_Indicators_Model_Order_By>>;
  where?: InputMaybe<Risk_Intensity_Indicators_Model_Bool_Exp_Bool_Exp>;
};


export type Query_RootRisky_Intensity_By_DriverArgs = {
  args: Risky_Intensity_By_Driver_Arguments;
  distinct_on?: InputMaybe<Array<Risk_Intensity_By_Driver_Model_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Risk_Intensity_By_Driver_Model_Order_By>>;
  where?: InputMaybe<Risk_Intensity_By_Driver_Model_Bool_Exp_Bool_Exp>;
};


export type Query_RootScore_ProcessedArgs = {
  distinct_on?: InputMaybe<Array<Score_Processed_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Processed_Order_By>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};


export type Query_RootScore_Processed_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Score_Processed_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Processed_Order_By>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};


export type Query_RootScore_Processed_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootScore_TypeArgs = {
  distinct_on?: InputMaybe<Array<Score_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Type_Order_By>>;
  where?: InputMaybe<Score_Type_Bool_Exp>;
};


export type Query_RootScore_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Score_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Type_Order_By>>;
  where?: InputMaybe<Score_Type_Bool_Exp>;
};


export type Query_RootScore_Type_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Query_RootSigninArgs = {
  cpf: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type Query_RootStatus_Truck_HardwareArgs = {
  distinct_on?: InputMaybe<Array<Status_Truck_Hardware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Status_Truck_Hardware_Order_By>>;
  where?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
};


export type Query_RootStatus_Truck_Hardware_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Status_Truck_Hardware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Status_Truck_Hardware_Order_By>>;
  where?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
};


export type Query_RootStatus_Truck_Hardware_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootTireArgs = {
  distinct_on?: InputMaybe<Array<Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Order_By>>;
  where?: InputMaybe<Tire_Bool_Exp>;
};


export type Query_RootTire_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Order_By>>;
  where?: InputMaybe<Tire_Bool_Exp>;
};


export type Query_RootTire_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootTire_InspectionArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};


export type Query_RootTire_Inspection_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};


export type Query_RootTire_Inspection_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootTire_Inspection_Fk_TireArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};


export type Query_RootTire_Inspection_Fk_Tire_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};


export type Query_RootTire_Inspection_Fk_Tire_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTire_Inspection_NoteArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};


export type Query_RootTire_Inspection_Note_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};


export type Query_RootTire_Inspection_Note_AttachmentArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};


export type Query_RootTire_Inspection_Note_Attachment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};


export type Query_RootTire_Inspection_Note_Attachment_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTire_Inspection_Note_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTire_Inspection_OriginArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Origin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Origin_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
};


export type Query_RootTire_Inspection_Origin_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Origin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Origin_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
};


export type Query_RootTire_Inspection_Origin_By_PkArgs = {
  origin: Scalars['String']['input'];
};


export type Query_RootTire_Note_TypeArgs = {
  distinct_on?: InputMaybe<Array<Tire_Note_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Note_Type_Order_By>>;
  where?: InputMaybe<Tire_Note_Type_Bool_Exp>;
};


export type Query_RootTire_Note_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Note_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Note_Type_Order_By>>;
  where?: InputMaybe<Tire_Note_Type_Bool_Exp>;
};


export type Query_RootTire_Note_Type_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTire_ParameterArgs = {
  distinct_on?: InputMaybe<Array<Tire_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Parameter_Order_By>>;
  where?: InputMaybe<Tire_Parameter_Bool_Exp>;
};


export type Query_RootTire_Parameter_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Parameter_Order_By>>;
  where?: InputMaybe<Tire_Parameter_Bool_Exp>;
};


export type Query_RootTire_Parameter_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Query_RootTire_Processing_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Tire_Processing_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Processing_History_Order_By>>;
  where?: InputMaybe<Tire_Processing_History_Bool_Exp>;
};


export type Query_RootTire_Processing_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Processing_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Processing_History_Order_By>>;
  where?: InputMaybe<Tire_Processing_History_Bool_Exp>;
};


export type Query_RootTire_Processing_History_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootTirecheck_InconsistencyArgs = {
  distinct_on?: InputMaybe<Array<Tirecheck_Inconsistency_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tirecheck_Inconsistency_Order_By>>;
  where?: InputMaybe<Tirecheck_Inconsistency_Bool_Exp>;
};


export type Query_RootTirecheck_Inconsistency_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tirecheck_Inconsistency_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tirecheck_Inconsistency_Order_By>>;
  where?: InputMaybe<Tirecheck_Inconsistency_Bool_Exp>;
};


export type Query_RootTirecheck_Inconsistency_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTrainingArgs = {
  distinct_on?: InputMaybe<Array<Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Order_By>>;
  where?: InputMaybe<Training_Bool_Exp>;
};


export type Query_RootTraining_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Order_By>>;
  where?: InputMaybe<Training_Bool_Exp>;
};


export type Query_RootTraining_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTraining_DocumentArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_Order_By>>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};


export type Query_RootTraining_Document_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_Order_By>>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};


export type Query_RootTraining_Document_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTraining_Document_ViewArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


export type Query_RootTraining_Document_View_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


export type Query_RootTraining_Document_View_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootTrip_Analysis_With_All_Drivers_By_MonthArgs = {
  args: TripAnalysisWithAllDriversByMonthInput;
};


export type Query_RootTrip_Analysis_With_All_Months_By_DriverArgs = {
  motorista_code: Scalars['String']['input'];
};


export type Query_RootUserArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Query_RootUser_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Query_RootUser_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_Fk_AchievementArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


export type Query_RootUser_Fk_Achievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


export type Query_RootUser_Fk_Achievement_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_Fk_ChallengeArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Challenge_Order_By>>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};


export type Query_RootUser_Fk_Challenge_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Challenge_Order_By>>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};


export type Query_RootUser_Fk_Challenge_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_Fk_LevelArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


export type Query_RootUser_Fk_Level_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


export type Query_RootUser_Fk_Level_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_Fk_NotificationArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


export type Query_RootUser_Fk_Notification_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


export type Query_RootUser_Fk_Notification_By_PkArgs = {
  notification_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_Fk_Privacy_PolicyArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Privacy_Policy_Order_By>>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};


export type Query_RootUser_Fk_Privacy_Policy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Privacy_Policy_Order_By>>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};


export type Query_RootUser_Fk_Privacy_Policy_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_Km_Points_ApprovalArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


export type Query_RootUser_Km_Points_Approval_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


export type Query_RootUser_Km_Points_Approval_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_KmpsArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


export type Query_RootUser_Kmps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


export type Query_RootUser_Kmps_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_ScoreArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


export type Query_RootUser_Score_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


export type Query_RootUser_Score_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_Score_RankingArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


export type Query_RootUser_Score_Ranking_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


export type Query_RootUser_TrainingArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};


export type Query_RootUser_Training_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};


export type Query_RootUser_Training_By_PkArgs = {
  training_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


export type Query_RootVehicleArgs = {
  distinct_on?: InputMaybe<Array<Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicle_Order_By>>;
  where?: InputMaybe<Vehicle_Bool_Exp>;
};


export type Query_RootVehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicle_Order_By>>;
  where?: InputMaybe<Vehicle_Bool_Exp>;
};


export type Query_RootVehicle_By_PkArgs = {
  plate: Scalars['String']['input'];
};


export type Query_RootWhatsapp_EventArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


export type Query_RootWhatsapp_Event_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


export type Query_RootWhatsapp_Event_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootWhatsapp_MessageArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_Bool_Exp>;
};


export type Query_RootWhatsapp_Message_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_Bool_Exp>;
};


export type Query_RootWhatsapp_Message_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootWhatsapp_Message_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_History_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};


export type Query_RootWhatsapp_Message_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_History_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};


export type Query_RootWhatsapp_Message_History_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootWhatsapp_TriggerArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Trigger_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Trigger_Order_By>>;
  where?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
};


export type Query_RootWhatsapp_Trigger_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Trigger_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Trigger_Order_By>>;
  where?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
};


export type Query_RootWhatsapp_Trigger_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootWrong_Data_TripsArgs = {
  end_date: Scalars['timestamptz']['input'];
  start_date: Scalars['timestamptz']['input'];
};

/** columns and relationships of "refresh_token" */
export type Refresh_Token = {
  __typename?: 'refresh_token';
  /** An object relationship */
  admin: Maybe<Admin>;
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  can_be_used: Scalars['Boolean']['output'];
  created_at: Maybe<Scalars['timestamptz']['output']>;
  refresh_token: Scalars['String']['output'];
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: Maybe<User>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "refresh_token" */
export type Refresh_Token_Aggregate = {
  __typename?: 'refresh_token_aggregate';
  aggregate: Maybe<Refresh_Token_Aggregate_Fields>;
  nodes: Array<Refresh_Token>;
};

export type Refresh_Token_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Refresh_Token_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Refresh_Token_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Refresh_Token_Aggregate_Bool_Exp_Count>;
};

export type Refresh_Token_Aggregate_Bool_Exp_Bool_And = {
  arguments: Refresh_Token_Select_Column_Refresh_Token_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Refresh_Token_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Refresh_Token_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Refresh_Token_Select_Column_Refresh_Token_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Refresh_Token_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Refresh_Token_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Refresh_Token_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "refresh_token" */
export type Refresh_Token_Aggregate_Fields = {
  __typename?: 'refresh_token_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Refresh_Token_Max_Fields>;
  min: Maybe<Refresh_Token_Min_Fields>;
};


/** aggregate fields of "refresh_token" */
export type Refresh_Token_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "refresh_token" */
export type Refresh_Token_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Refresh_Token_Max_Order_By>;
  min?: InputMaybe<Refresh_Token_Min_Order_By>;
};

/** input type for inserting array relation for remote table "refresh_token" */
export type Refresh_Token_Arr_Rel_Insert_Input = {
  data: Array<Refresh_Token_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Refresh_Token_On_Conflict>;
};

/** Boolean expression to filter rows from the table "refresh_token". All fields are combined with a logical 'AND'. */
export type Refresh_Token_Bool_Exp = {
  _and?: InputMaybe<Array<Refresh_Token_Bool_Exp>>;
  _not?: InputMaybe<Refresh_Token_Bool_Exp>;
  _or?: InputMaybe<Array<Refresh_Token_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  can_be_used?: InputMaybe<Boolean_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  refresh_token?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "refresh_token" */
export enum Refresh_Token_Constraint {
  /** unique or primary key constraint on columns "refresh_token" */
  RefreshTokenPkey = 'refresh_token_pkey'
}

/** input type for inserting data into table "refresh_token" */
export type Refresh_Token_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  can_be_used?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Refresh_Token_Max_Fields = {
  __typename?: 'refresh_token_max_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  refresh_token: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "refresh_token" */
export type Refresh_Token_Max_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  refresh_token?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Refresh_Token_Min_Fields = {
  __typename?: 'refresh_token_min_fields';
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  refresh_token: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "refresh_token" */
export type Refresh_Token_Min_Order_By = {
  admin_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  refresh_token?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "refresh_token" */
export type Refresh_Token_Mutation_Response = {
  __typename?: 'refresh_token_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Refresh_Token>;
};

/** on_conflict condition type for table "refresh_token" */
export type Refresh_Token_On_Conflict = {
  constraint: Refresh_Token_Constraint;
  update_columns?: Array<Refresh_Token_Update_Column>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};

/** Ordering options when selecting data from "refresh_token". */
export type Refresh_Token_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  can_be_used?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  refresh_token?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: refresh_token */
export type Refresh_Token_Pk_Columns_Input = {
  refresh_token: Scalars['String']['input'];
};

/** select columns of table "refresh_token" */
export enum Refresh_Token_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CanBeUsed = 'can_be_used',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid'
}

/** select "refresh_token_aggregate_bool_exp_bool_and_arguments_columns" columns of table "refresh_token" */
export enum Refresh_Token_Select_Column_Refresh_Token_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  CanBeUsed = 'can_be_used'
}

/** select "refresh_token_aggregate_bool_exp_bool_or_arguments_columns" columns of table "refresh_token" */
export enum Refresh_Token_Select_Column_Refresh_Token_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  CanBeUsed = 'can_be_used'
}

/** input type for updating data in table "refresh_token" */
export type Refresh_Token_Set_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  can_be_used?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "refresh_token" */
export type Refresh_Token_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Refresh_Token_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Refresh_Token_Stream_Cursor_Value_Input = {
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  can_be_used?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "refresh_token" */
export enum Refresh_Token_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  CanBeUsed = 'can_be_used',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid'
}

export type Refresh_Token_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Refresh_Token_Set_Input>;
  /** filter the rows which have to be updated */
  where: Refresh_Token_Bool_Exp;
};

/** risk_intensity_avg_and_maxNative Query Arguments */
export type Risk_Intensity_Avg_And_Max_Arguments = {
  end: Scalars['date']['input'];
  start: Scalars['date']['input'];
};

export type Risk_Intensity_By_Driver_Model = {
  __typename?: 'risk_intensity_by_driver_model';
  codmoto: Scalars['String']['output'];
  max_risk_intensity: Scalars['Int']['output'];
  reference_date: Scalars['date']['output'];
};

/** Boolean expression to filter rows from the logical model for "risk_intensity_by_driver_model". All fields are combined with a logical 'AND'. */
export type Risk_Intensity_By_Driver_Model_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<Risk_Intensity_By_Driver_Model_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<Risk_Intensity_By_Driver_Model_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<Risk_Intensity_By_Driver_Model_Bool_Exp_Bool_Exp>>;
  codmoto?: InputMaybe<String_Comparison_Exp>;
  max_risk_intensity?: InputMaybe<Int_Comparison_Exp>;
  reference_date?: InputMaybe<Date_Comparison_Exp>;
};

export enum Risk_Intensity_By_Driver_Model_Enum_Name {
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  MaxRiskIntensity = 'max_risk_intensity',
  /** column name */
  ReferenceDate = 'reference_date'
}

/** Ordering options when selecting data from "risk_intensity_by_driver_model". */
export type Risk_Intensity_By_Driver_Model_Order_By = {
  codmoto?: InputMaybe<Order_By>;
  max_risk_intensity?: InputMaybe<Order_By>;
  reference_date?: InputMaybe<Order_By>;
};

/** risk_intensity_indicators_by_driverNative Query Arguments */
export type Risk_Intensity_Indicators_By_Driver_Arguments = {
  codmoto: Scalars['String']['input'];
  end: Scalars['date']['input'];
  start: Scalars['date']['input'];
};

export type Risk_Intensity_Indicators_Model = {
  __typename?: 'risk_intensity_indicators_model';
  avg_risk_intensity: Scalars['numeric']['output'];
  codmoto: Scalars['String']['output'];
  count_high_risk_intensity: Scalars['bigint']['output'];
  max_risk_intensity: Scalars['Int']['output'];
  min_risk_intensity: Scalars['Int']['output'];
  sum_risk_intensity: Scalars['bigint']['output'];
};

/** Boolean expression to filter rows from the logical model for "risk_intensity_indicators_model". All fields are combined with a logical 'AND'. */
export type Risk_Intensity_Indicators_Model_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<Risk_Intensity_Indicators_Model_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<Risk_Intensity_Indicators_Model_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<Risk_Intensity_Indicators_Model_Bool_Exp_Bool_Exp>>;
  avg_risk_intensity?: InputMaybe<Numeric_Comparison_Exp>;
  codmoto?: InputMaybe<String_Comparison_Exp>;
  count_high_risk_intensity?: InputMaybe<Bigint_Comparison_Exp>;
  max_risk_intensity?: InputMaybe<Int_Comparison_Exp>;
  min_risk_intensity?: InputMaybe<Int_Comparison_Exp>;
  sum_risk_intensity?: InputMaybe<Bigint_Comparison_Exp>;
};

export enum Risk_Intensity_Indicators_Model_Enum_Name {
  /** column name */
  AvgRiskIntensity = 'avg_risk_intensity',
  /** column name */
  Codmoto = 'codmoto',
  /** column name */
  CountHighRiskIntensity = 'count_high_risk_intensity',
  /** column name */
  MaxRiskIntensity = 'max_risk_intensity',
  /** column name */
  MinRiskIntensity = 'min_risk_intensity',
  /** column name */
  SumRiskIntensity = 'sum_risk_intensity'
}

/** Ordering options when selecting data from "risk_intensity_indicators_model". */
export type Risk_Intensity_Indicators_Model_Order_By = {
  avg_risk_intensity?: InputMaybe<Order_By>;
  codmoto?: InputMaybe<Order_By>;
  count_high_risk_intensity?: InputMaybe<Order_By>;
  max_risk_intensity?: InputMaybe<Order_By>;
  min_risk_intensity?: InputMaybe<Order_By>;
  sum_risk_intensity?: InputMaybe<Order_By>;
};

export type Risk_Intensity_Model = {
  __typename?: 'risk_intensity_model';
  avg_risk_intensity: Scalars['numeric']['output'];
  max_risk_intensity: Scalars['Int']['output'];
  reference_date: Scalars['date']['output'];
};

/** Boolean expression to filter rows from the logical model for "risk_intensity_model". All fields are combined with a logical 'AND'. */
export type Risk_Intensity_Model_Bool_Exp_Bool_Exp = {
  _and?: InputMaybe<Array<Risk_Intensity_Model_Bool_Exp_Bool_Exp>>;
  _not?: InputMaybe<Risk_Intensity_Model_Bool_Exp_Bool_Exp>;
  _or?: InputMaybe<Array<Risk_Intensity_Model_Bool_Exp_Bool_Exp>>;
  avg_risk_intensity?: InputMaybe<Numeric_Comparison_Exp>;
  max_risk_intensity?: InputMaybe<Int_Comparison_Exp>;
  reference_date?: InputMaybe<Date_Comparison_Exp>;
};

export enum Risk_Intensity_Model_Enum_Name {
  /** column name */
  AvgRiskIntensity = 'avg_risk_intensity',
  /** column name */
  MaxRiskIntensity = 'max_risk_intensity',
  /** column name */
  ReferenceDate = 'reference_date'
}

/** Ordering options when selecting data from "risk_intensity_model". */
export type Risk_Intensity_Model_Order_By = {
  avg_risk_intensity?: InputMaybe<Order_By>;
  max_risk_intensity?: InputMaybe<Order_By>;
  reference_date?: InputMaybe<Order_By>;
};

/** risky_intensity_by_driverNative Query Arguments */
export type Risky_Intensity_By_Driver_Arguments = {
  codmoto: Scalars['String']['input'];
  end: Scalars['date']['input'];
  start: Scalars['date']['input'];
};

/** columns and relationships of "score_processed" */
export type Score_Processed = {
  __typename?: 'score_processed';
  created_at: Scalars['timestamptz']['output'];
  /** The end date that the trips started to be considered (exclusive) */
  end_at: Scalars['timestamptz']['output'];
  /** The expected final result score_processed.end_at + score_type.finish_interval */
  expected_final_result: Maybe<Scalars['timestamptz']['output']>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** Returns true if need to be processed based on start, end and last processed dates */
  need_to_be_processed: Maybe<Scalars['Boolean']['output']>;
  /** Returns if the score_processed after now > end and last_processed_at is less than end_at + finish_interval */
  need_to_be_processed_after_finish: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  scoreTypeByScoreType: Score_Type;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type: Scalars['String']['output'];
  /** The first date that the trips started to be considered (inclusive) */
  start_at: Scalars['timestamptz']['output'];
  start_at_date: Maybe<Scalars['date']['output']>;
  /** An array relationship */
  user_fk_achievements: Array<User_Fk_Achievement>;
  /** An aggregate relationship */
  user_fk_achievements_aggregate: User_Fk_Achievement_Aggregate;
  /** An array relationship */
  user_km_points_approvals: Array<User_Km_Points_Approval>;
  /** An aggregate relationship */
  user_km_points_approvals_aggregate: User_Km_Points_Approval_Aggregate;
  /** An array relationship */
  user_score_ranking: Array<User_Score_Ranking>;
  /** An aggregate relationship */
  user_score_ranking_aggregate: User_Score_Ranking_Aggregate;
  /** An array relationship */
  user_scores: Array<User_Score>;
  /** An aggregate relationship */
  user_scores_aggregate: User_Score_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_Fk_AchievementsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_Fk_Achievements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_Km_Points_ApprovalsArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_Km_Points_Approvals_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_Score_RankingArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_Score_Ranking_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_ScoresArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


/** columns and relationships of "score_processed" */
export type Score_ProcessedUser_Scores_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};

/** aggregated selection of "score_processed" */
export type Score_Processed_Aggregate = {
  __typename?: 'score_processed_aggregate';
  aggregate: Maybe<Score_Processed_Aggregate_Fields>;
  nodes: Array<Score_Processed>;
};

export type Score_Processed_Aggregate_Bool_Exp = {
  count?: InputMaybe<Score_Processed_Aggregate_Bool_Exp_Count>;
};

export type Score_Processed_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Score_Processed_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Score_Processed_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "score_processed" */
export type Score_Processed_Aggregate_Fields = {
  __typename?: 'score_processed_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Score_Processed_Max_Fields>;
  min: Maybe<Score_Processed_Min_Fields>;
};


/** aggregate fields of "score_processed" */
export type Score_Processed_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Score_Processed_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "score_processed" */
export type Score_Processed_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Score_Processed_Max_Order_By>;
  min?: InputMaybe<Score_Processed_Min_Order_By>;
};

/** input type for inserting array relation for remote table "score_processed" */
export type Score_Processed_Arr_Rel_Insert_Input = {
  data: Array<Score_Processed_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Score_Processed_On_Conflict>;
};

/** Boolean expression to filter rows from the table "score_processed". All fields are combined with a logical 'AND'. */
export type Score_Processed_Bool_Exp = {
  _and?: InputMaybe<Array<Score_Processed_Bool_Exp>>;
  _not?: InputMaybe<Score_Processed_Bool_Exp>;
  _or?: InputMaybe<Array<Score_Processed_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  end_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  expected_final_result?: InputMaybe<Timestamptz_Comparison_Exp>;
  finished_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  last_processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  need_to_be_processed?: InputMaybe<Boolean_Comparison_Exp>;
  need_to_be_processed_after_finish?: InputMaybe<Boolean_Comparison_Exp>;
  scoreTypeByScoreType?: InputMaybe<Score_Type_Bool_Exp>;
  score_type?: InputMaybe<String_Comparison_Exp>;
  start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  start_at_date?: InputMaybe<Date_Comparison_Exp>;
  user_fk_achievements?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
  user_fk_achievements_aggregate?: InputMaybe<User_Fk_Achievement_Aggregate_Bool_Exp>;
  user_km_points_approvals?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  user_km_points_approvals_aggregate?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp>;
  user_score_ranking?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  user_score_ranking_aggregate?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp>;
  user_scores?: InputMaybe<User_Score_Bool_Exp>;
  user_scores_aggregate?: InputMaybe<User_Score_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "score_processed" */
export enum Score_Processed_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  ScoreProcessedPkey = 'score_processed_pkey',
  /** unique or primary key constraint on columns "score_type", "start_at" */
  ScoreProcessedScoreTypeStartAtUk = 'score_processed_score_type_start_at_uk'
}

/** input type for inserting data into table "score_processed" */
export type Score_Processed_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The end date that the trips started to be considered (exclusive) */
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  scoreTypeByScoreType?: InputMaybe<Score_Type_Obj_Rel_Insert_Input>;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type?: InputMaybe<Scalars['String']['input']>;
  /** The first date that the trips started to be considered (inclusive) */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  start_at_date?: InputMaybe<Scalars['date']['input']>;
  user_fk_achievements?: InputMaybe<User_Fk_Achievement_Arr_Rel_Insert_Input>;
  user_km_points_approvals?: InputMaybe<User_Km_Points_Approval_Arr_Rel_Insert_Input>;
  user_score_ranking?: InputMaybe<User_Score_Ranking_Arr_Rel_Insert_Input>;
  user_scores?: InputMaybe<User_Score_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Score_Processed_Max_Fields = {
  __typename?: 'score_processed_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The end date that the trips started to be considered (exclusive) */
  end_at: Maybe<Scalars['timestamptz']['output']>;
  /** The expected final result score_processed.end_at + score_type.finish_interval */
  expected_final_result: Maybe<Scalars['timestamptz']['output']>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type: Maybe<Scalars['String']['output']>;
  /** The first date that the trips started to be considered (inclusive) */
  start_at: Maybe<Scalars['timestamptz']['output']>;
  start_at_date: Maybe<Scalars['date']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "score_processed" */
export type Score_Processed_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** The end date that the trips started to be considered (exclusive) */
  end_at?: InputMaybe<Order_By>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at?: InputMaybe<Order_By>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at?: InputMaybe<Order_By>;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type?: InputMaybe<Order_By>;
  /** The first date that the trips started to be considered (inclusive) */
  start_at?: InputMaybe<Order_By>;
  start_at_date?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Score_Processed_Min_Fields = {
  __typename?: 'score_processed_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The end date that the trips started to be considered (exclusive) */
  end_at: Maybe<Scalars['timestamptz']['output']>;
  /** The expected final result score_processed.end_at + score_type.finish_interval */
  expected_final_result: Maybe<Scalars['timestamptz']['output']>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at: Maybe<Scalars['timestamptz']['output']>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type: Maybe<Scalars['String']['output']>;
  /** The first date that the trips started to be considered (inclusive) */
  start_at: Maybe<Scalars['timestamptz']['output']>;
  start_at_date: Maybe<Scalars['date']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "score_processed" */
export type Score_Processed_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** The end date that the trips started to be considered (exclusive) */
  end_at?: InputMaybe<Order_By>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at?: InputMaybe<Order_By>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at?: InputMaybe<Order_By>;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type?: InputMaybe<Order_By>;
  /** The first date that the trips started to be considered (inclusive) */
  start_at?: InputMaybe<Order_By>;
  start_at_date?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "score_processed" */
export type Score_Processed_Mutation_Response = {
  __typename?: 'score_processed_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Score_Processed>;
};

/** input type for inserting object relation for remote table "score_processed" */
export type Score_Processed_Obj_Rel_Insert_Input = {
  data: Score_Processed_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Score_Processed_On_Conflict>;
};

/** on_conflict condition type for table "score_processed" */
export type Score_Processed_On_Conflict = {
  constraint: Score_Processed_Constraint;
  update_columns?: Array<Score_Processed_Update_Column>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};

/** Ordering options when selecting data from "score_processed". */
export type Score_Processed_Order_By = {
  created_at?: InputMaybe<Order_By>;
  end_at?: InputMaybe<Order_By>;
  expected_final_result?: InputMaybe<Order_By>;
  finished_at?: InputMaybe<Order_By>;
  last_processed_at?: InputMaybe<Order_By>;
  need_to_be_processed?: InputMaybe<Order_By>;
  need_to_be_processed_after_finish?: InputMaybe<Order_By>;
  scoreTypeByScoreType?: InputMaybe<Score_Type_Order_By>;
  score_type?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
  start_at_date?: InputMaybe<Order_By>;
  user_fk_achievements_aggregate?: InputMaybe<User_Fk_Achievement_Aggregate_Order_By>;
  user_km_points_approvals_aggregate?: InputMaybe<User_Km_Points_Approval_Aggregate_Order_By>;
  user_score_ranking_aggregate?: InputMaybe<User_Score_Ranking_Aggregate_Order_By>;
  user_scores_aggregate?: InputMaybe<User_Score_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: score_processed */
export type Score_Processed_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "score_processed" */
export enum Score_Processed_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  FinishedAt = 'finished_at',
  /** column name */
  LastProcessedAt = 'last_processed_at',
  /** column name */
  ScoreType = 'score_type',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  StartAtDate = 'start_at_date',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "score_processed" */
export type Score_Processed_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The end date that the trips started to be considered (exclusive) */
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type?: InputMaybe<Scalars['String']['input']>;
  /** The first date that the trips started to be considered (inclusive) */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  start_at_date?: InputMaybe<Scalars['date']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "score_processed" */
export type Score_Processed_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Score_Processed_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Score_Processed_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The end date that the trips started to be considered (exclusive) */
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When occurred the last processing of this score_processed. With this field achievements are given to users, and it only occurs after (score_processed.end_at + score_type.finish_interval) */
  finished_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time when all the notes were processed. Null if they weren't processed yet */
  last_processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The type range that the notes were processed. Like daily, monthly */
  score_type?: InputMaybe<Scalars['String']['input']>;
  /** The first date that the trips started to be considered (inclusive) */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
  start_at_date?: InputMaybe<Scalars['date']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "score_processed" */
export enum Score_Processed_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  FinishedAt = 'finished_at',
  /** column name */
  LastProcessedAt = 'last_processed_at',
  /** column name */
  ScoreType = 'score_type',
  /** column name */
  StartAt = 'start_at',
  /** column name */
  StartAtDate = 'start_at_date',
  /** column name */
  Uuid = 'uuid'
}

export type Score_Processed_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Score_Processed_Set_Input>;
  /** filter the rows which have to be updated */
  where: Score_Processed_Bool_Exp;
};

/** columns and relationships of "score_type" */
export type Score_Type = {
  __typename?: 'score_type';
  /** An array relationship */
  achievements: Array<Achievement>;
  /** An aggregate relationship */
  achievements_aggregate: Achievement_Aggregate;
  /** The interval applied after the end range to give the finish results */
  finish_interval: Scalars['interval']['output'];
  /** The name of the score type. Like daily, monthly */
  name: Scalars['String']['output'];
  /** The time interval which it does not need to be processed */
  process_interval: Scalars['interval']['output'];
  /** The range which this score is processed */
  range: Scalars['interval']['output'];
  /** An array relationship */
  score_processeds: Array<Score_Processed>;
  /** An aggregate relationship */
  score_processeds_aggregate: Score_Processed_Aggregate;
  /** The first date when the score begin to be processed. This date is important because it decides the timezone of the next generated dates */
  start_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "score_type" */
export type Score_TypeAchievementsArgs = {
  distinct_on?: InputMaybe<Array<Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Achievement_Order_By>>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};


/** columns and relationships of "score_type" */
export type Score_TypeAchievements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Achievement_Order_By>>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};


/** columns and relationships of "score_type" */
export type Score_TypeScore_ProcessedsArgs = {
  distinct_on?: InputMaybe<Array<Score_Processed_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Processed_Order_By>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};


/** columns and relationships of "score_type" */
export type Score_TypeScore_Processeds_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Score_Processed_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Processed_Order_By>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};

/** aggregated selection of "score_type" */
export type Score_Type_Aggregate = {
  __typename?: 'score_type_aggregate';
  aggregate: Maybe<Score_Type_Aggregate_Fields>;
  nodes: Array<Score_Type>;
};

/** aggregate fields of "score_type" */
export type Score_Type_Aggregate_Fields = {
  __typename?: 'score_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Score_Type_Max_Fields>;
  min: Maybe<Score_Type_Min_Fields>;
};


/** aggregate fields of "score_type" */
export type Score_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Score_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "score_type". All fields are combined with a logical 'AND'. */
export type Score_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Score_Type_Bool_Exp>>;
  _not?: InputMaybe<Score_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Score_Type_Bool_Exp>>;
  achievements?: InputMaybe<Achievement_Bool_Exp>;
  achievements_aggregate?: InputMaybe<Achievement_Aggregate_Bool_Exp>;
  finish_interval?: InputMaybe<Interval_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  process_interval?: InputMaybe<Interval_Comparison_Exp>;
  range?: InputMaybe<Interval_Comparison_Exp>;
  score_processeds?: InputMaybe<Score_Processed_Bool_Exp>;
  score_processeds_aggregate?: InputMaybe<Score_Processed_Aggregate_Bool_Exp>;
  start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "score_type" */
export enum Score_Type_Constraint {
  /** unique or primary key constraint on columns "name" */
  ScoreTypePkey = 'score_type_pkey'
}

/** input type for inserting data into table "score_type" */
export type Score_Type_Insert_Input = {
  achievements?: InputMaybe<Achievement_Arr_Rel_Insert_Input>;
  /** The interval applied after the end range to give the finish results */
  finish_interval?: InputMaybe<Scalars['interval']['input']>;
  /** The name of the score type. Like daily, monthly */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The time interval which it does not need to be processed */
  process_interval?: InputMaybe<Scalars['interval']['input']>;
  /** The range which this score is processed */
  range?: InputMaybe<Scalars['interval']['input']>;
  score_processeds?: InputMaybe<Score_Processed_Arr_Rel_Insert_Input>;
  /** The first date when the score begin to be processed. This date is important because it decides the timezone of the next generated dates */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Score_Type_Max_Fields = {
  __typename?: 'score_type_max_fields';
  /** The name of the score type. Like daily, monthly */
  name: Maybe<Scalars['String']['output']>;
  /** The first date when the score begin to be processed. This date is important because it decides the timezone of the next generated dates */
  start_at: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Score_Type_Min_Fields = {
  __typename?: 'score_type_min_fields';
  /** The name of the score type. Like daily, monthly */
  name: Maybe<Scalars['String']['output']>;
  /** The first date when the score begin to be processed. This date is important because it decides the timezone of the next generated dates */
  start_at: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "score_type" */
export type Score_Type_Mutation_Response = {
  __typename?: 'score_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Score_Type>;
};

/** input type for inserting object relation for remote table "score_type" */
export type Score_Type_Obj_Rel_Insert_Input = {
  data: Score_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Score_Type_On_Conflict>;
};

/** on_conflict condition type for table "score_type" */
export type Score_Type_On_Conflict = {
  constraint: Score_Type_Constraint;
  update_columns?: Array<Score_Type_Update_Column>;
  where?: InputMaybe<Score_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "score_type". */
export type Score_Type_Order_By = {
  achievements_aggregate?: InputMaybe<Achievement_Aggregate_Order_By>;
  finish_interval?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  process_interval?: InputMaybe<Order_By>;
  range?: InputMaybe<Order_By>;
  score_processeds_aggregate?: InputMaybe<Score_Processed_Aggregate_Order_By>;
  start_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: score_type */
export type Score_Type_Pk_Columns_Input = {
  /** The name of the score type. Like daily, monthly */
  name: Scalars['String']['input'];
};

/** select columns of table "score_type" */
export enum Score_Type_Select_Column {
  /** column name */
  FinishInterval = 'finish_interval',
  /** column name */
  Name = 'name',
  /** column name */
  ProcessInterval = 'process_interval',
  /** column name */
  Range = 'range',
  /** column name */
  StartAt = 'start_at'
}

/** input type for updating data in table "score_type" */
export type Score_Type_Set_Input = {
  /** The interval applied after the end range to give the finish results */
  finish_interval?: InputMaybe<Scalars['interval']['input']>;
  /** The name of the score type. Like daily, monthly */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The time interval which it does not need to be processed */
  process_interval?: InputMaybe<Scalars['interval']['input']>;
  /** The range which this score is processed */
  range?: InputMaybe<Scalars['interval']['input']>;
  /** The first date when the score begin to be processed. This date is important because it decides the timezone of the next generated dates */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "score_type" */
export type Score_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Score_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Score_Type_Stream_Cursor_Value_Input = {
  /** The interval applied after the end range to give the finish results */
  finish_interval?: InputMaybe<Scalars['interval']['input']>;
  /** The name of the score type. Like daily, monthly */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The time interval which it does not need to be processed */
  process_interval?: InputMaybe<Scalars['interval']['input']>;
  /** The range which this score is processed */
  range?: InputMaybe<Scalars['interval']['input']>;
  /** The first date when the score begin to be processed. This date is important because it decides the timezone of the next generated dates */
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "score_type" */
export enum Score_Type_Update_Column {
  /** column name */
  FinishInterval = 'finish_interval',
  /** column name */
  Name = 'name',
  /** column name */
  ProcessInterval = 'process_interval',
  /** column name */
  Range = 'range',
  /** column name */
  StartAt = 'start_at'
}

export type Score_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Score_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Score_Type_Bool_Exp;
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type Smallint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['smallint']['input']>;
  _gt?: InputMaybe<Scalars['smallint']['input']>;
  _gte?: InputMaybe<Scalars['smallint']['input']>;
  _in?: InputMaybe<Array<Scalars['smallint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['smallint']['input']>;
  _lte?: InputMaybe<Scalars['smallint']['input']>;
  _neq?: InputMaybe<Scalars['smallint']['input']>;
  _nin?: InputMaybe<Array<Scalars['smallint']['input']>>;
};

export type St_D_Within_Geography_Input = {
  distance: Scalars['Float']['input'];
  from: Scalars['geography']['input'];
  use_spheroid?: InputMaybe<Scalars['Boolean']['input']>;
};

export type St_D_Within_Input = {
  distance: Scalars['Float']['input'];
  from: Scalars['geometry']['input'];
};

/** Store status of the vehicle hardware. If there is one row of a truck inhere with solved=false, then it has a problem in it's hardware */
export type Status_Truck_Hardware = {
  __typename?: 'status_truck_hardware';
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  last_analysis: Scalars['timestamptz']['output'];
  /** When the problem was solved for this device. If it's null there is a problem. This time is not precise. It is based on the time when the API was called */
  solved_at: Maybe<Scalars['timestamptz']['output']>;
  /** The plate of the vehicle with problem */
  vehicle_plate: Scalars['String']['output'];
};

/** aggregated selection of "status_truck_hardware" */
export type Status_Truck_Hardware_Aggregate = {
  __typename?: 'status_truck_hardware_aggregate';
  aggregate: Maybe<Status_Truck_Hardware_Aggregate_Fields>;
  nodes: Array<Status_Truck_Hardware>;
};

/** aggregate fields of "status_truck_hardware" */
export type Status_Truck_Hardware_Aggregate_Fields = {
  __typename?: 'status_truck_hardware_aggregate_fields';
  avg: Maybe<Status_Truck_Hardware_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Status_Truck_Hardware_Max_Fields>;
  min: Maybe<Status_Truck_Hardware_Min_Fields>;
  stddev: Maybe<Status_Truck_Hardware_Stddev_Fields>;
  stddev_pop: Maybe<Status_Truck_Hardware_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Status_Truck_Hardware_Stddev_Samp_Fields>;
  sum: Maybe<Status_Truck_Hardware_Sum_Fields>;
  var_pop: Maybe<Status_Truck_Hardware_Var_Pop_Fields>;
  var_samp: Maybe<Status_Truck_Hardware_Var_Samp_Fields>;
  variance: Maybe<Status_Truck_Hardware_Variance_Fields>;
};


/** aggregate fields of "status_truck_hardware" */
export type Status_Truck_Hardware_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Status_Truck_Hardware_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Status_Truck_Hardware_Avg_Fields = {
  __typename?: 'status_truck_hardware_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "status_truck_hardware". All fields are combined with a logical 'AND'. */
export type Status_Truck_Hardware_Bool_Exp = {
  _and?: InputMaybe<Array<Status_Truck_Hardware_Bool_Exp>>;
  _not?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
  _or?: InputMaybe<Array<Status_Truck_Hardware_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  last_analysis?: InputMaybe<Timestamptz_Comparison_Exp>;
  solved_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vehicle_plate?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "status_truck_hardware" */
export enum Status_Truck_Hardware_Constraint {
  /** unique or primary key constraint on columns "id" */
  StatusTruckHardwarePkey = 'status_truck_hardware_pkey'
}

/** input type for incrementing numeric columns in table "status_truck_hardware" */
export type Status_Truck_Hardware_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "status_truck_hardware" */
export type Status_Truck_Hardware_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_analysis?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When the problem was solved for this device. If it's null there is a problem. This time is not precise. It is based on the time when the API was called */
  solved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The plate of the vehicle with problem */
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Status_Truck_Hardware_Max_Fields = {
  __typename?: 'status_truck_hardware_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  last_analysis: Maybe<Scalars['timestamptz']['output']>;
  /** When the problem was solved for this device. If it's null there is a problem. This time is not precise. It is based on the time when the API was called */
  solved_at: Maybe<Scalars['timestamptz']['output']>;
  /** The plate of the vehicle with problem */
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Status_Truck_Hardware_Min_Fields = {
  __typename?: 'status_truck_hardware_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  last_analysis: Maybe<Scalars['timestamptz']['output']>;
  /** When the problem was solved for this device. If it's null there is a problem. This time is not precise. It is based on the time when the API was called */
  solved_at: Maybe<Scalars['timestamptz']['output']>;
  /** The plate of the vehicle with problem */
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "status_truck_hardware" */
export type Status_Truck_Hardware_Mutation_Response = {
  __typename?: 'status_truck_hardware_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Status_Truck_Hardware>;
};

/** on_conflict condition type for table "status_truck_hardware" */
export type Status_Truck_Hardware_On_Conflict = {
  constraint: Status_Truck_Hardware_Constraint;
  update_columns?: Array<Status_Truck_Hardware_Update_Column>;
  where?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
};

/** Ordering options when selecting data from "status_truck_hardware". */
export type Status_Truck_Hardware_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_analysis?: InputMaybe<Order_By>;
  solved_at?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** primary key columns input for table: status_truck_hardware */
export type Status_Truck_Hardware_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "status_truck_hardware" */
export enum Status_Truck_Hardware_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  LastAnalysis = 'last_analysis',
  /** column name */
  SolvedAt = 'solved_at',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

/** input type for updating data in table "status_truck_hardware" */
export type Status_Truck_Hardware_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_analysis?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When the problem was solved for this device. If it's null there is a problem. This time is not precise. It is based on the time when the API was called */
  solved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The plate of the vehicle with problem */
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Status_Truck_Hardware_Stddev_Fields = {
  __typename?: 'status_truck_hardware_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Status_Truck_Hardware_Stddev_Pop_Fields = {
  __typename?: 'status_truck_hardware_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Status_Truck_Hardware_Stddev_Samp_Fields = {
  __typename?: 'status_truck_hardware_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "status_truck_hardware" */
export type Status_Truck_Hardware_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Status_Truck_Hardware_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Status_Truck_Hardware_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_analysis?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When the problem was solved for this device. If it's null there is a problem. This time is not precise. It is based on the time when the API was called */
  solved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The plate of the vehicle with problem */
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Status_Truck_Hardware_Sum_Fields = {
  __typename?: 'status_truck_hardware_sum_fields';
  id: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "status_truck_hardware" */
export enum Status_Truck_Hardware_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  LastAnalysis = 'last_analysis',
  /** column name */
  SolvedAt = 'solved_at',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

export type Status_Truck_Hardware_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Status_Truck_Hardware_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Status_Truck_Hardware_Set_Input>;
  /** filter the rows which have to be updated */
  where: Status_Truck_Hardware_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Status_Truck_Hardware_Var_Pop_Fields = {
  __typename?: 'status_truck_hardware_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Status_Truck_Hardware_Var_Samp_Fields = {
  __typename?: 'status_truck_hardware_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Status_Truck_Hardware_Variance_Fields = {
  __typename?: 'status_truck_hardware_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "CurrentTiresByVehicle" */
  CurrentTiresByVehicle: Array<CurrentTiresByVehicle>;
  /** fetch aggregated fields from the table: "CurrentTiresByVehicle" */
  CurrentTiresByVehicle_aggregate: CurrentTiresByVehicle_Aggregate;
  /** fetch data from the table: "ParametroAlertaConducao" */
  ParametroAlertaConducao: Array<ParametroAlertaConducao>;
  /** fetch aggregated fields from the table: "ParametroAlertaConducao" */
  ParametroAlertaConducao_aggregate: ParametroAlertaConducao_Aggregate;
  /** fetch data from the table: "ParametroAlertaConducao" using primary key columns */
  ParametroAlertaConducao_by_pk: Maybe<ParametroAlertaConducao>;
  /** fetch data from the table: "PerformanceParameter" */
  PerformanceParameter: Array<PerformanceParameter>;
  /** fetch aggregated fields from the table: "PerformanceParameter" */
  PerformanceParameter_aggregate: PerformanceParameter_Aggregate;
  /** fetch data from the table: "PerformanceParameter" using primary key columns */
  PerformanceParameter_by_pk: Maybe<PerformanceParameter>;
  /** fetch data from the table: "PontosRastro" */
  PontosRastro: Array<PontosRastro>;
  /** fetch aggregated fields from the table: "PontosRastro" */
  PontosRastro_aggregate: PontosRastro_Aggregate;
  /** fetch data from the table: "PontosRastro" using primary key columns */
  PontosRastro_by_pk: Maybe<PontosRastro>;
  /** fetch data from the table: "ScoreParameter" */
  ScoreParameter: Array<ScoreParameter>;
  /** fetch aggregated fields from the table: "ScoreParameter" */
  ScoreParameter_aggregate: ScoreParameter_Aggregate;
  /** fetch data from the table: "ScoreParameter" using primary key columns */
  ScoreParameter_by_pk: Maybe<ScoreParameter>;
  /** fetch data from the table: "ScoreType" */
  ScoreType: Array<ScoreType>;
  /** fetch aggregated fields from the table: "ScoreType" */
  ScoreType_aggregate: ScoreType_Aggregate;
  /** fetch data from the table: "ScoreType" using primary key columns */
  ScoreType_by_pk: Maybe<ScoreType>;
  /** fetch data from the table: "SuntechEquipamento" */
  SuntechEquipamento: Array<SuntechEquipamento>;
  /** fetch aggregated fields from the table: "SuntechEquipamento" */
  SuntechEquipamento_aggregate: SuntechEquipamento_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommand" */
  SuntechTrackerBatchCommand: Array<SuntechTrackerBatchCommand>;
  /** fetch data from the table: "SuntechTrackerBatchCommandDevice" */
  SuntechTrackerBatchCommandDevice: Array<SuntechTrackerBatchCommandDevice>;
  /** fetch aggregated fields from the table: "SuntechTrackerBatchCommandDevice" */
  SuntechTrackerBatchCommandDevice_aggregate: SuntechTrackerBatchCommandDevice_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommandDevice" using primary key columns */
  SuntechTrackerBatchCommandDevice_by_pk: Maybe<SuntechTrackerBatchCommandDevice>;
  /** fetch data from the table: "SuntechTrackerBatchCommandPreset" */
  SuntechTrackerBatchCommandPreset: Array<SuntechTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "SuntechTrackerBatchCommandPreset" */
  SuntechTrackerBatchCommandPreset_aggregate: SuntechTrackerBatchCommandPreset_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommandPreset" using primary key columns */
  SuntechTrackerBatchCommandPreset_by_pk: Maybe<SuntechTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "SuntechTrackerBatchCommand" */
  SuntechTrackerBatchCommand_aggregate: SuntechTrackerBatchCommand_Aggregate;
  /** fetch data from the table: "SuntechTrackerBatchCommand" using primary key columns */
  SuntechTrackerBatchCommand_by_pk: Maybe<SuntechTrackerBatchCommand>;
  /** fetch data from the table: "SuntechTrackerCommand" */
  SuntechTrackerCommand: Array<SuntechTrackerCommand>;
  /** fetch aggregated fields from the table: "SuntechTrackerCommand" */
  SuntechTrackerCommand_aggregate: SuntechTrackerCommand_Aggregate;
  /** fetch data from the table: "SuntechTrackerCommand" using primary key columns */
  SuntechTrackerCommand_by_pk: Maybe<SuntechTrackerCommand>;
  TireAnalysisReport: Array<TireAnalysisReport>;
  /** fetch data from the table: "VirlocTrackerBatchCommand" */
  VirlocTrackerBatchCommand: Array<VirlocTrackerBatchCommand>;
  /** fetch data from the table: "VirlocTrackerBatchCommandDevice" */
  VirlocTrackerBatchCommandDevice: Array<VirlocTrackerBatchCommandDevice>;
  /** fetch aggregated fields from the table: "VirlocTrackerBatchCommandDevice" */
  VirlocTrackerBatchCommandDevice_aggregate: VirlocTrackerBatchCommandDevice_Aggregate;
  /** fetch data from the table: "VirlocTrackerBatchCommandDevice" using primary key columns */
  VirlocTrackerBatchCommandDevice_by_pk: Maybe<VirlocTrackerBatchCommandDevice>;
  /** fetch data from the table: "VirlocTrackerBatchCommandPreset" */
  VirlocTrackerBatchCommandPreset: Array<VirlocTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "VirlocTrackerBatchCommandPreset" */
  VirlocTrackerBatchCommandPreset_aggregate: VirlocTrackerBatchCommandPreset_Aggregate;
  /** fetch data from the table: "VirlocTrackerBatchCommandPreset" using primary key columns */
  VirlocTrackerBatchCommandPreset_by_pk: Maybe<VirlocTrackerBatchCommandPreset>;
  /** fetch aggregated fields from the table: "VirlocTrackerBatchCommand" */
  VirlocTrackerBatchCommand_aggregate: VirlocTrackerBatchCommand_Aggregate;
  /** fetch data from the table: "VirlocTrackerBatchCommand" using primary key columns */
  VirlocTrackerBatchCommand_by_pk: Maybe<VirlocTrackerBatchCommand>;
  /** fetch data from the table: "VirlocTrackerCommand" */
  VirlocTrackerCommand: Array<VirlocTrackerCommand>;
  /** fetch aggregated fields from the table: "VirlocTrackerCommand" */
  VirlocTrackerCommand_aggregate: VirlocTrackerCommand_Aggregate;
  /** fetch data from the table: "VirlocTrackerCommand" using primary key columns */
  VirlocTrackerCommand_by_pk: Maybe<VirlocTrackerCommand>;
  /** fetch data from the table: "VirlocTrackerDevice" */
  VirlocTrackerDevice: Array<VirlocTrackerDevice>;
  /** fetch aggregated fields from the table: "VirlocTrackerDevice" */
  VirlocTrackerDevice_aggregate: VirlocTrackerDevice_Aggregate;
  /** fetch data from the table: "VirlocTrackerDevice" using primary key columns */
  VirlocTrackerDevice_by_pk: Maybe<VirlocTrackerDevice>;
  /** fetch data from the table: "achievement" */
  achievement: Array<Achievement>;
  /** fetch aggregated fields from the table: "achievement" */
  achievement_aggregate: Achievement_Aggregate;
  /** fetch data from the table: "achievement" using primary key columns */
  achievement_by_pk: Maybe<Achievement>;
  /** fetch data from the table in a streaming manner: "achievement" */
  achievement_stream: Array<Achievement>;
  /** fetch data from the table: "admin" */
  admin: Array<Admin>;
  /** fetch aggregated fields from the table: "admin" */
  admin_aggregate: Admin_Aggregate;
  /** fetch data from the table: "admin" using primary key columns */
  admin_by_pk: Maybe<Admin>;
  /** An array relationship */
  admin_fk_notifications: Array<Admin_Fk_Notifications>;
  /** An aggregate relationship */
  admin_fk_notifications_aggregate: Admin_Fk_Notifications_Aggregate;
  /** fetch data from the table: "admin_fk_notifications" using primary key columns */
  admin_fk_notifications_by_pk: Maybe<Admin_Fk_Notifications>;
  /** fetch data from the table in a streaming manner: "admin_fk_notifications" */
  admin_fk_notifications_stream: Array<Admin_Fk_Notifications>;
  /** fetch data from the table: "admin_fk_profile" */
  admin_fk_profile: Array<Admin_Fk_Profile>;
  /** fetch aggregated fields from the table: "admin_fk_profile" */
  admin_fk_profile_aggregate: Admin_Fk_Profile_Aggregate;
  /** fetch data from the table: "admin_fk_profile" using primary key columns */
  admin_fk_profile_by_pk: Maybe<Admin_Fk_Profile>;
  /** fetch data from the table in a streaming manner: "admin_fk_profile" */
  admin_fk_profile_stream: Array<Admin_Fk_Profile>;
  /** fetch data from the table: "admin_permission" */
  admin_permission: Array<Admin_Permission>;
  /** fetch aggregated fields from the table: "admin_permission" */
  admin_permission_aggregate: Admin_Permission_Aggregate;
  /** fetch data from the table: "admin_permission" using primary key columns */
  admin_permission_by_pk: Maybe<Admin_Permission>;
  /** fetch data from the table in a streaming manner: "admin_permission" */
  admin_permission_stream: Array<Admin_Permission>;
  /** fetch data from the table in a streaming manner: "admin" */
  admin_stream: Array<Admin>;
  /** fetch data from the table: "auto" */
  auto: Array<Auto>;
  /** fetch aggregated fields from the table: "auto" */
  auto_aggregate: Auto_Aggregate;
  /** fetch data from the table: "auto" using primary key columns */
  auto_by_pk: Maybe<Auto>;
  /** fetch data from the table: "bi.dashboard" */
  bi_dashboard: Array<Bi_Dashboard>;
  /** fetch aggregated fields from the table: "bi.dashboard" */
  bi_dashboard_aggregate: Bi_Dashboard_Aggregate;
  /** fetch data from the table: "bi.dashboard" using primary key columns */
  bi_dashboard_by_pk: Maybe<Bi_Dashboard>;
  /** fetch data from the table: "bi.dashboard_item" */
  bi_dashboard_item: Array<Bi_Dashboard_Item>;
  /** fetch aggregated fields from the table: "bi.dashboard_item" */
  bi_dashboard_item_aggregate: Bi_Dashboard_Item_Aggregate;
  /** fetch data from the table: "bi.dashboard_item" using primary key columns */
  bi_dashboard_item_by_pk: Maybe<Bi_Dashboard_Item>;
  /** fetch data from the table in a streaming manner: "bi.dashboard_item" */
  bi_dashboard_item_stream: Array<Bi_Dashboard_Item>;
  /** fetch data from the table: "bi.dashboard_item_type" */
  bi_dashboard_item_type: Array<Bi_Dashboard_Item_Type>;
  /** fetch aggregated fields from the table: "bi.dashboard_item_type" */
  bi_dashboard_item_type_aggregate: Bi_Dashboard_Item_Type_Aggregate;
  /** fetch data from the table: "bi.dashboard_item_type" using primary key columns */
  bi_dashboard_item_type_by_pk: Maybe<Bi_Dashboard_Item_Type>;
  /** fetch data from the table in a streaming manner: "bi.dashboard_item_type" */
  bi_dashboard_item_type_stream: Array<Bi_Dashboard_Item_Type>;
  /** fetch data from the table in a streaming manner: "bi.dashboard" */
  bi_dashboard_stream: Array<Bi_Dashboard>;
  /** fetch data from the table: "bi.datasource" */
  bi_datasource: Array<Bi_Datasource>;
  /** fetch aggregated fields from the table: "bi.datasource" */
  bi_datasource_aggregate: Bi_Datasource_Aggregate;
  /** fetch data from the table: "bi.datasource" using primary key columns */
  bi_datasource_by_pk: Maybe<Bi_Datasource>;
  /** fetch data from the table in a streaming manner: "bi.datasource" */
  bi_datasource_stream: Array<Bi_Datasource>;
  /** fetch data from the table: "bi.datasource_type" */
  bi_datasource_type: Array<Bi_Datasource_Type>;
  /** fetch aggregated fields from the table: "bi.datasource_type" */
  bi_datasource_type_aggregate: Bi_Datasource_Type_Aggregate;
  /** fetch data from the table: "bi.datasource_type" using primary key columns */
  bi_datasource_type_by_pk: Maybe<Bi_Datasource_Type>;
  /** fetch data from the table in a streaming manner: "bi.datasource_type" */
  bi_datasource_type_stream: Array<Bi_Datasource_Type>;
  /** fetch data from the table: "bi.permission" */
  bi_permission: Array<Bi_Permission>;
  /** fetch aggregated fields from the table: "bi.permission" */
  bi_permission_aggregate: Bi_Permission_Aggregate;
  /** fetch data from the table: "bi.permission" using primary key columns */
  bi_permission_by_pk: Maybe<Bi_Permission>;
  /** fetch data from the table: "bi.permission_module" */
  bi_permission_module: Array<Bi_Permission_Module>;
  /** fetch aggregated fields from the table: "bi.permission_module" */
  bi_permission_module_aggregate: Bi_Permission_Module_Aggregate;
  /** fetch data from the table: "bi.permission_module" using primary key columns */
  bi_permission_module_by_pk: Maybe<Bi_Permission_Module>;
  /** fetch data from the table in a streaming manner: "bi.permission_module" */
  bi_permission_module_stream: Array<Bi_Permission_Module>;
  /** fetch data from the table in a streaming manner: "bi.permission" */
  bi_permission_stream: Array<Bi_Permission>;
  /** fetch data from the table: "bi.public_link" */
  bi_public_link: Array<Bi_Public_Link>;
  /** fetch aggregated fields from the table: "bi.public_link" */
  bi_public_link_aggregate: Bi_Public_Link_Aggregate;
  /** fetch data from the table: "bi.public_link" using primary key columns */
  bi_public_link_by_pk: Maybe<Bi_Public_Link>;
  /** fetch data from the table in a streaming manner: "bi.public_link" */
  bi_public_link_stream: Array<Bi_Public_Link>;
  /** fetch data from the table: "bi.query" */
  bi_query: Array<Bi_Query>;
  /** fetch aggregated fields from the table: "bi.query" */
  bi_query_aggregate: Bi_Query_Aggregate;
  /** fetch data from the table: "bi.query_analytics" */
  bi_query_analytics: Array<Bi_Query_Analytics>;
  /** fetch aggregated fields from the table: "bi.query_analytics" */
  bi_query_analytics_aggregate: Bi_Query_Analytics_Aggregate;
  /** fetch data from the table: "bi.query_analytics" using primary key columns */
  bi_query_analytics_by_pk: Maybe<Bi_Query_Analytics>;
  /** fetch data from the table in a streaming manner: "bi.query_analytics" */
  bi_query_analytics_stream: Array<Bi_Query_Analytics>;
  /** fetch data from the table: "bi.query" using primary key columns */
  bi_query_by_pk: Maybe<Bi_Query>;
  /** fetch data from the table: "bi.query_cache" */
  bi_query_cache: Array<Bi_Query_Cache>;
  /** fetch aggregated fields from the table: "bi.query_cache" */
  bi_query_cache_aggregate: Bi_Query_Cache_Aggregate;
  /** fetch data from the table: "bi.query_cache" using primary key columns */
  bi_query_cache_by_pk: Maybe<Bi_Query_Cache>;
  /** fetch data from the table in a streaming manner: "bi.query_cache" */
  bi_query_cache_stream: Array<Bi_Query_Cache>;
  /** fetch data from the table in a streaming manner: "bi.query" */
  bi_query_stream: Array<Bi_Query>;
  /** fetch data from the table: "bi.subquery" */
  bi_subquery: Array<Bi_Subquery>;
  /** fetch aggregated fields from the table: "bi.subquery" */
  bi_subquery_aggregate: Bi_Subquery_Aggregate;
  /** fetch data from the table: "bi.subquery" using primary key columns */
  bi_subquery_by_pk: Maybe<Bi_Subquery>;
  /** fetch data from the table in a streaming manner: "bi.subquery" */
  bi_subquery_stream: Array<Bi_Subquery>;
  /** fetch data from the table: "bi.user_permission" */
  bi_user_permission: Array<Bi_User_Permission>;
  /** fetch aggregated fields from the table: "bi.user_permission" */
  bi_user_permission_aggregate: Bi_User_Permission_Aggregate;
  /** fetch data from the table: "bi.user_permission" using primary key columns */
  bi_user_permission_by_pk: Maybe<Bi_User_Permission>;
  /** fetch data from the table in a streaming manner: "bi.user_permission" */
  bi_user_permission_stream: Array<Bi_User_Permission>;
  /** fetch data from the table: "challenge" */
  challenge: Array<Challenge>;
  /** fetch aggregated fields from the table: "challenge" */
  challenge_aggregate: Challenge_Aggregate;
  /** fetch data from the table: "challenge" using primary key columns */
  challenge_by_pk: Maybe<Challenge>;
  /** fetch data from the table in a streaming manner: "challenge" */
  challenge_stream: Array<Challenge>;
  /** fetch data from the table: "challenge_type" */
  challenge_type: Array<Challenge_Type>;
  /** fetch aggregated fields from the table: "challenge_type" */
  challenge_type_aggregate: Challenge_Type_Aggregate;
  /** fetch data from the table: "challenge_type" using primary key columns */
  challenge_type_by_pk: Maybe<Challenge_Type>;
  /** fetch data from the table in a streaming manner: "challenge_type" */
  challenge_type_stream: Array<Challenge_Type>;
  /** fetch data from the table: "config" */
  config: Array<Config>;
  /** fetch aggregated fields from the table: "config" */
  config_aggregate: Config_Aggregate;
  /** fetch data from the table: "config" using primary key columns */
  config_by_pk: Maybe<Config>;
  /** fetch data from the table in a streaming manner: "config" */
  config_stream: Array<Config>;
  /** fetch data from the table: "critical_point" */
  critical_point: Array<Critical_Point>;
  /** fetch aggregated fields from the table: "critical_point" */
  critical_point_aggregate: Critical_Point_Aggregate;
  /** fetch data from the table: "critical_point" using primary key columns */
  critical_point_by_pk: Maybe<Critical_Point>;
  /** fetch data from the table in a streaming manner: "critical_point" */
  critical_point_stream: Array<Critical_Point>;
  /** fetch data from the table: "critical_segment" */
  critical_segment: Array<Critical_Segment>;
  /** fetch aggregated fields from the table: "critical_segment" */
  critical_segment_aggregate: Critical_Segment_Aggregate;
  /** fetch data from the table: "critical_segment" using primary key columns */
  critical_segment_by_pk: Maybe<Critical_Segment>;
  /** fetch data from the table in a streaming manner: "critical_segment" */
  critical_segment_stream: Array<Critical_Segment>;
  /** fetch data from the table: "cte.nf_lock" */
  cte_nf_lock: Array<Cte_Nf_Lock>;
  /** fetch aggregated fields from the table: "cte.nf_lock" */
  cte_nf_lock_aggregate: Cte_Nf_Lock_Aggregate;
  /** fetch data from the table: "cte.nf_lock" using primary key columns */
  cte_nf_lock_by_pk: Maybe<Cte_Nf_Lock>;
  /** fetch data from the table in a streaming manner: "cte.nf_lock" */
  cte_nf_lock_stream: Array<Cte_Nf_Lock>;
  /** fetch data from the table: "current_config" */
  current_config: Array<Current_Config>;
  /** fetch aggregated fields from the table: "current_config" */
  current_config_aggregate: Current_Config_Aggregate;
  /** fetch data from the table in a streaming manner: "current_config" */
  current_config_stream: Array<Current_Config>;
  /** fetch data from the table: "deleted_row" */
  deleted_row: Array<Deleted_Row>;
  /** fetch aggregated fields from the table: "deleted_row" */
  deleted_row_aggregate: Deleted_Row_Aggregate;
  /** fetch data from the table: "deleted_row" using primary key columns */
  deleted_row_by_pk: Maybe<Deleted_Row>;
  /** fetch data from the table in a streaming manner: "deleted_row" */
  deleted_row_stream: Array<Deleted_Row>;
  /** fetch data from the table: "delivery" */
  delivery: Array<Delivery>;
  /** fetch aggregated fields from the table: "delivery" */
  delivery_aggregate: Delivery_Aggregate;
  /** fetch data from the table: "delivery" using primary key columns */
  delivery_by_pk: Maybe<Delivery>;
  /** fetch data from the table in a streaming manner: "delivery" */
  delivery_stream: Array<Delivery>;
  /** execute function "driver_performance_data" which returns "empty_tables.driver_performance_data" */
  driver_performance_data: Array<Empty_Tables_Driver_Performance_Data>;
  /** execute function "driver_performance_data" and query aggregates on result of table type "empty_tables.driver_performance_data" */
  driver_performance_data_aggregate: Empty_Tables_Driver_Performance_Data_Aggregate;
  /** fetch data from the table: "driver_warning" */
  driver_warning: Array<Driver_Warning>;
  /** fetch aggregated fields from the table: "driver_warning" */
  driver_warning_aggregate: Driver_Warning_Aggregate;
  /** fetch data from the table: "driver_warning" using primary key columns */
  driver_warning_by_pk: Maybe<Driver_Warning>;
  /** fetch data from the table: "driver_warning_comment" */
  driver_warning_comment: Array<Driver_Warning_Comment>;
  /** fetch aggregated fields from the table: "driver_warning_comment" */
  driver_warning_comment_aggregate: Driver_Warning_Comment_Aggregate;
  /** fetch data from the table: "driver_warning_comment" using primary key columns */
  driver_warning_comment_by_pk: Maybe<Driver_Warning_Comment>;
  /** fetch data from the table in a streaming manner: "driver_warning_comment" */
  driver_warning_comment_stream: Array<Driver_Warning_Comment>;
  /** fetch data from the table: "driver_warning_fk_whatsapp_message" */
  driver_warning_fk_whatsapp_message: Array<Driver_Warning_Fk_Whatsapp_Message>;
  /** fetch aggregated fields from the table: "driver_warning_fk_whatsapp_message" */
  driver_warning_fk_whatsapp_message_aggregate: Driver_Warning_Fk_Whatsapp_Message_Aggregate;
  /** fetch data from the table: "driver_warning_fk_whatsapp_message" using primary key columns */
  driver_warning_fk_whatsapp_message_by_pk: Maybe<Driver_Warning_Fk_Whatsapp_Message>;
  /** fetch data from the table in a streaming manner: "driver_warning_fk_whatsapp_message" */
  driver_warning_fk_whatsapp_message_stream: Array<Driver_Warning_Fk_Whatsapp_Message>;
  /** fetch data from the table: "driver_warning_risk_level" */
  driver_warning_risk_level: Array<Driver_Warning_Risk_Level>;
  /** fetch aggregated fields from the table: "driver_warning_risk_level" */
  driver_warning_risk_level_aggregate: Driver_Warning_Risk_Level_Aggregate;
  /** fetch data from the table: "driver_warning_risk_level" using primary key columns */
  driver_warning_risk_level_by_pk: Maybe<Driver_Warning_Risk_Level>;
  /** fetch data from the table in a streaming manner: "driver_warning_risk_level" */
  driver_warning_risk_level_stream: Array<Driver_Warning_Risk_Level>;
  /** fetch data from the table: "driver_warning_risk_level_view" */
  driver_warning_risk_level_view: Array<Driver_Warning_Risk_Level_View>;
  /** fetch aggregated fields from the table: "driver_warning_risk_level_view" */
  driver_warning_risk_level_view_aggregate: Driver_Warning_Risk_Level_View_Aggregate;
  /** fetch data from the table in a streaming manner: "driver_warning_risk_level_view" */
  driver_warning_risk_level_view_stream: Array<Driver_Warning_Risk_Level_View>;
  /** fetch data from the table in a streaming manner: "driver_warning" */
  driver_warning_stream: Array<Driver_Warning>;
  /** fetch data from the table: "driver_warning_trip" */
  driver_warning_trip: Array<Driver_Warning_Trip>;
  /** fetch aggregated fields from the table: "driver_warning_trip" */
  driver_warning_trip_aggregate: Driver_Warning_Trip_Aggregate;
  /** fetch data from the table: "driver_warning_trip" using primary key columns */
  driver_warning_trip_by_pk: Maybe<Driver_Warning_Trip>;
  /** fetch data from the table: "driver_warning_trip_point" */
  driver_warning_trip_point: Array<Driver_Warning_Trip_Point>;
  /** fetch aggregated fields from the table: "driver_warning_trip_point" */
  driver_warning_trip_point_aggregate: Driver_Warning_Trip_Point_Aggregate;
  /** fetch data from the table: "driver_warning_trip_point" using primary key columns */
  driver_warning_trip_point_by_pk: Maybe<Driver_Warning_Trip_Point>;
  /** fetch data from the table in a streaming manner: "driver_warning_trip_point" */
  driver_warning_trip_point_stream: Array<Driver_Warning_Trip_Point>;
  /** fetch data from the table: "driver_warning_trip_severity" */
  driver_warning_trip_severity: Array<Driver_Warning_Trip_Severity>;
  /** fetch aggregated fields from the table: "driver_warning_trip_severity" */
  driver_warning_trip_severity_aggregate: Driver_Warning_Trip_Severity_Aggregate;
  /** fetch data from the table: "driver_warning_trip_severity" using primary key columns */
  driver_warning_trip_severity_by_pk: Maybe<Driver_Warning_Trip_Severity>;
  /** fetch data from the table in a streaming manner: "driver_warning_trip_severity" */
  driver_warning_trip_severity_stream: Array<Driver_Warning_Trip_Severity>;
  /** fetch data from the table in a streaming manner: "driver_warning_trip" */
  driver_warning_trip_stream: Array<Driver_Warning_Trip>;
  /** fetch data from the table: "edi.busca_nfe_job" */
  edi_busca_nfe_job: Array<Edi_Busca_Nfe_Job>;
  /** fetch aggregated fields from the table: "edi.busca_nfe_job" */
  edi_busca_nfe_job_aggregate: Edi_Busca_Nfe_Job_Aggregate;
  /** fetch data from the table: "edi.busca_nfe_job" using primary key columns */
  edi_busca_nfe_job_by_pk: Maybe<Edi_Busca_Nfe_Job>;
  /** fetch data from the table in a streaming manner: "edi.busca_nfe_job" */
  edi_busca_nfe_job_stream: Array<Edi_Busca_Nfe_Job>;
  /** fetch data from the table: "edi.busca_nfe_response" */
  edi_busca_nfe_response: Array<Edi_Busca_Nfe_Response>;
  /** fetch aggregated fields from the table: "edi.busca_nfe_response" */
  edi_busca_nfe_response_aggregate: Edi_Busca_Nfe_Response_Aggregate;
  /** fetch data from the table: "edi.busca_nfe_response" using primary key columns */
  edi_busca_nfe_response_by_pk: Maybe<Edi_Busca_Nfe_Response>;
  /** fetch data from the table in a streaming manner: "edi.busca_nfe_response" */
  edi_busca_nfe_response_stream: Array<Edi_Busca_Nfe_Response>;
  /** fetch data from the table: "empty_tables.critical_segment_from_critical_point" */
  empty_tables_critical_segment_from_critical_point: Array<Empty_Tables_Critical_Segment_From_Critical_Point>;
  /** fetch aggregated fields from the table: "empty_tables.critical_segment_from_critical_point" */
  empty_tables_critical_segment_from_critical_point_aggregate: Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate;
  /** fetch data from the table in a streaming manner: "empty_tables.critical_segment_from_critical_point" */
  empty_tables_critical_segment_from_critical_point_stream: Array<Empty_Tables_Critical_Segment_From_Critical_Point>;
  /** fetch data from the table: "empty_tables.driver_performance_data" */
  empty_tables_driver_performance_data: Array<Empty_Tables_Driver_Performance_Data>;
  /** fetch aggregated fields from the table: "empty_tables.driver_performance_data" */
  empty_tables_driver_performance_data_aggregate: Empty_Tables_Driver_Performance_Data_Aggregate;
  /** fetch data from the table in a streaming manner: "empty_tables.driver_performance_data" */
  empty_tables_driver_performance_data_stream: Array<Empty_Tables_Driver_Performance_Data>;
  /** fetch data from the table: "empty_tables.fleet_performance_data" */
  empty_tables_fleet_performance_data: Array<Empty_Tables_Fleet_Performance_Data>;
  /** fetch aggregated fields from the table: "empty_tables.fleet_performance_data" */
  empty_tables_fleet_performance_data_aggregate: Empty_Tables_Fleet_Performance_Data_Aggregate;
  /** fetch data from the table: "empty_tables.fleet_performance_data" using primary key columns */
  empty_tables_fleet_performance_data_by_pk: Maybe<Empty_Tables_Fleet_Performance_Data>;
  /** fetch data from the table in a streaming manner: "empty_tables.fleet_performance_data" */
  empty_tables_fleet_performance_data_stream: Array<Empty_Tables_Fleet_Performance_Data>;
  /** fetch data from the table: "empty_tables.geojson_trip" */
  empty_tables_geojson_trip: Array<Empty_Tables_Geojson_Trip>;
  /** fetch aggregated fields from the table: "empty_tables.geojson_trip" */
  empty_tables_geojson_trip_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  /** fetch data from the table: "empty_tables.geojson_trip" using primary key columns */
  empty_tables_geojson_trip_by_pk: Maybe<Empty_Tables_Geojson_Trip>;
  /** fetch data from the table in a streaming manner: "empty_tables.geojson_trip" */
  empty_tables_geojson_trip_stream: Array<Empty_Tables_Geojson_Trip>;
  /** fetch data from the table: "empty_tables.instructor_drivers_performance_history" */
  empty_tables_instructor_drivers_performance_history: Array<Empty_Tables_Instructor_Drivers_Performance_History>;
  /** fetch aggregated fields from the table: "empty_tables.instructor_drivers_performance_history" */
  empty_tables_instructor_drivers_performance_history_aggregate: Empty_Tables_Instructor_Drivers_Performance_History_Aggregate;
  /** fetch data from the table in a streaming manner: "empty_tables.instructor_drivers_performance_history" */
  empty_tables_instructor_drivers_performance_history_stream: Array<Empty_Tables_Instructor_Drivers_Performance_History>;
  /** fetch data from the table: "fidelity_range_points" */
  fidelity_range_points: Array<Fidelity_Range_Points>;
  /** fetch aggregated fields from the table: "fidelity_range_points" */
  fidelity_range_points_aggregate: Fidelity_Range_Points_Aggregate;
  /** fetch data from the table: "fidelity_range_points" using primary key columns */
  fidelity_range_points_by_pk: Maybe<Fidelity_Range_Points>;
  /** fetch data from the table in a streaming manner: "fidelity_range_points" */
  fidelity_range_points_stream: Array<Fidelity_Range_Points>;
  /** fetch data from the table: "fipe.price" */
  fipe_price: Array<Fipe_Price>;
  /** fetch aggregated fields from the table: "fipe.price" */
  fipe_price_aggregate: Fipe_Price_Aggregate;
  /** fetch data from the table: "fipe.price" using primary key columns */
  fipe_price_by_pk: Maybe<Fipe_Price>;
  /** fetch data from the table in a streaming manner: "fipe.price" */
  fipe_price_stream: Array<Fipe_Price>;
  /** fetch data from the table: "fipe.reference_month" */
  fipe_reference_month: Array<Fipe_Reference_Month>;
  /** fetch aggregated fields from the table: "fipe.reference_month" */
  fipe_reference_month_aggregate: Fipe_Reference_Month_Aggregate;
  /** fetch data from the table: "fipe.reference_month" using primary key columns */
  fipe_reference_month_by_pk: Maybe<Fipe_Reference_Month>;
  /** fetch data from the table in a streaming manner: "fipe.reference_month" */
  fipe_reference_month_stream: Array<Fipe_Reference_Month>;
  /** execute function "fipe.search_fipe_vehicle" which returns "fipe.vehicle" */
  fipe_search_fipe_vehicle: Array<Fipe_Vehicle>;
  /** execute function "fipe.search_fipe_vehicle" and query aggregates on result of table type "fipe.vehicle" */
  fipe_search_fipe_vehicle_aggregate: Fipe_Vehicle_Aggregate;
  /** fetch data from the table: "fipe.selected_vehicle" */
  fipe_selected_vehicle: Array<Fipe_Selected_Vehicle>;
  /** fetch aggregated fields from the table: "fipe.selected_vehicle" */
  fipe_selected_vehicle_aggregate: Fipe_Selected_Vehicle_Aggregate;
  /** fetch data from the table: "fipe.selected_vehicle" using primary key columns */
  fipe_selected_vehicle_by_pk: Maybe<Fipe_Selected_Vehicle>;
  /** fetch data from the table in a streaming manner: "fipe.selected_vehicle" */
  fipe_selected_vehicle_stream: Array<Fipe_Selected_Vehicle>;
  /** fetch data from the table: "fipe.vehicle" */
  fipe_vehicle: Array<Fipe_Vehicle>;
  /** fetch aggregated fields from the table: "fipe.vehicle" */
  fipe_vehicle_aggregate: Fipe_Vehicle_Aggregate;
  /** fetch data from the table: "fipe.vehicle" using primary key columns */
  fipe_vehicle_by_pk: Maybe<Fipe_Vehicle>;
  /** fetch data from the table in a streaming manner: "fipe.vehicle" */
  fipe_vehicle_stream: Array<Fipe_Vehicle>;
  /** execute function "fleet_performance_data" which returns "empty_tables.fleet_performance_data" */
  fleet_performance_data: Maybe<Empty_Tables_Fleet_Performance_Data>;
  /** execute function "fleet_performance_data" and query aggregates on result of table type "empty_tables.fleet_performance_data" */
  fleet_performance_data_aggregate: Empty_Tables_Fleet_Performance_Data_Aggregate;
  /** execute function "get_critical_segments_from_critical_point" which returns "empty_tables.critical_segment_from_critical_point" */
  get_critical_segments_from_critical_point: Array<Empty_Tables_Critical_Segment_From_Critical_Point>;
  /** execute function "get_critical_segments_from_critical_point" and query aggregates on result of table type "empty_tables.critical_segment_from_critical_point" */
  get_critical_segments_from_critical_point_aggregate: Empty_Tables_Critical_Segment_From_Critical_Point_Aggregate;
  /** execute function "get_driver_warning_geojson" which returns "empty_tables.geojson_trip" */
  get_driver_warning_geojson: Maybe<Empty_Tables_Geojson_Trip>;
  /** execute function "get_driver_warning_geojson" and query aggregates on result of table type "empty_tables.geojson_trip" */
  get_driver_warning_geojson_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  /** execute function "get_route_geojson_by_score_processed" which returns "empty_tables.geojson_trip" */
  get_route_geojson_by_score_processed: Maybe<Empty_Tables_Geojson_Trip>;
  /** execute function "get_route_geojson_by_score_processed" and query aggregates on result of table type "empty_tables.geojson_trip" */
  get_route_geojson_by_score_processed_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  /** execute function "get_trips_geojson" which returns "empty_tables.geojson_trip" */
  get_trips_geojson: Array<Empty_Tables_Geojson_Trip>;
  /** execute function "get_trips_geojson" and query aggregates on result of table type "empty_tables.geojson_trip" */
  get_trips_geojson_aggregate: Empty_Tables_Geojson_Trip_Aggregate;
  /** fetch data from the table: "inspection" */
  inspection: Array<Inspection>;
  /** fetch aggregated fields from the table: "inspection" */
  inspection_aggregate: Inspection_Aggregate;
  /** fetch data from the table: "inspection_analysis_parameter" */
  inspection_analysis_parameter: Array<Inspection_Analysis_Parameter>;
  /** fetch aggregated fields from the table: "inspection_analysis_parameter" */
  inspection_analysis_parameter_aggregate: Inspection_Analysis_Parameter_Aggregate;
  /** fetch data from the table: "inspection_analysis_parameter" using primary key columns */
  inspection_analysis_parameter_by_pk: Maybe<Inspection_Analysis_Parameter>;
  /** fetch data from the table in a streaming manner: "inspection_analysis_parameter" */
  inspection_analysis_parameter_stream: Array<Inspection_Analysis_Parameter>;
  /** fetch data from the table: "inspection" using primary key columns */
  inspection_by_pk: Maybe<Inspection>;
  /** fetch data from the table: "inspection_fk_tire" */
  inspection_fk_tire: Array<Inspection_Fk_Tire>;
  /** fetch aggregated fields from the table: "inspection_fk_tire" */
  inspection_fk_tire_aggregate: Inspection_Fk_Tire_Aggregate;
  /** fetch data from the table: "inspection_fk_tire" using primary key columns */
  inspection_fk_tire_by_pk: Maybe<Inspection_Fk_Tire>;
  /** fetch data from the table in a streaming manner: "inspection_fk_tire" */
  inspection_fk_tire_stream: Array<Inspection_Fk_Tire>;
  /** fetch data from the table in a streaming manner: "inspection" */
  inspection_stream: Array<Inspection>;
  inspections_export: Array<InspectionsExport>;
  inspections_that_reported_excessive_high_pressure: Array<InspectionProblem>;
  inspections_that_reported_excessive_low_pressure: Array<InspectionProblem>;
  inspections_that_reported_high_pressure: Array<InspectionProblem>;
  inspections_that_reported_high_twin_tires_minimum_depth_difference: Array<InspectionProblem>;
  inspections_that_reported_low_pressure: Array<InspectionProblem>;
  inspections_that_reported_low_tire_depth: Array<InspectionProblem>;
  inspections_that_reported_open_services: Array<InspectionProblem>;
  inspections_that_reported_wear_irregular: Array<InspectionProblem>;
  inspections_that_reported_wear_severe: Array<InspectionProblem>;
  inspections_that_reported_wear_severe_cavalo_mecanico: Array<InspectionProblem>;
  inspections_that_reported_wear_severe_semi_reboque: Array<InspectionProblem>;
  /** execute function "instructor_drivers_performance_history" which returns "empty_tables.instructor_drivers_performance_history" */
  instructor_drivers_performance_history: Array<Empty_Tables_Instructor_Drivers_Performance_History>;
  /** execute function "instructor_drivers_performance_history" and query aggregates on result of table type "empty_tables.instructor_drivers_performance_history" */
  instructor_drivers_performance_history_aggregate: Empty_Tables_Instructor_Drivers_Performance_History_Aggregate;
  /** fetch data from the table: "instructor_supervision" */
  instructor_supervision: Array<Instructor_Supervision>;
  /** fetch aggregated fields from the table: "instructor_supervision" */
  instructor_supervision_aggregate: Instructor_Supervision_Aggregate;
  /** fetch data from the table: "instructor_supervision" using primary key columns */
  instructor_supervision_by_pk: Maybe<Instructor_Supervision>;
  /** fetch data from the table: "instructor_supervision_observation" */
  instructor_supervision_observation: Array<Instructor_Supervision_Observation>;
  /** fetch aggregated fields from the table: "instructor_supervision_observation" */
  instructor_supervision_observation_aggregate: Instructor_Supervision_Observation_Aggregate;
  /** fetch data from the table: "instructor_supervision_observation" using primary key columns */
  instructor_supervision_observation_by_pk: Maybe<Instructor_Supervision_Observation>;
  /** fetch data from the table in a streaming manner: "instructor_supervision_observation" */
  instructor_supervision_observation_stream: Array<Instructor_Supervision_Observation>;
  /** fetch data from the table in a streaming manner: "instructor_supervision" */
  instructor_supervision_stream: Array<Instructor_Supervision>;
  /** fetch data from the table: "instructor_supervision_with_user" */
  instructor_supervision_with_user: Array<Instructor_Supervision_With_User>;
  /** fetch aggregated fields from the table: "instructor_supervision_with_user" */
  instructor_supervision_with_user_aggregate: Instructor_Supervision_With_User_Aggregate;
  /** fetch data from the table in a streaming manner: "instructor_supervision_with_user" */
  instructor_supervision_with_user_stream: Array<Instructor_Supervision_With_User>;
  /** fetch data from the table: "last_inspection_tire_by_vehicle" */
  last_inspection_tire_by_vehicle: Array<Last_Inspection_Tire_By_Vehicle>;
  /** fetch aggregated fields from the table: "last_inspection_tire_by_vehicle" */
  last_inspection_tire_by_vehicle_aggregate: Last_Inspection_Tire_By_Vehicle_Aggregate;
  last_inspection_tire_by_vehicle_plate: Array<Inspection_Tire_By_Vehicle>;
  /** fetch data from the table in a streaming manner: "last_inspection_tire_by_vehicle" */
  last_inspection_tire_by_vehicle_stream: Array<Last_Inspection_Tire_By_Vehicle>;
  /** fetch data from the table: "level" */
  level: Array<Level>;
  /** fetch aggregated fields from the table: "level" */
  level_aggregate: Level_Aggregate;
  /** fetch data from the table: "level" using primary key columns */
  level_by_pk: Maybe<Level>;
  /** fetch data from the table: "level_option" */
  level_option: Array<Level_Option>;
  /** fetch aggregated fields from the table: "level_option" */
  level_option_aggregate: Level_Option_Aggregate;
  /** fetch data from the table: "level_option" using primary key columns */
  level_option_by_pk: Maybe<Level_Option>;
  /** fetch data from the table in a streaming manner: "level_option" */
  level_option_stream: Array<Level_Option>;
  /** fetch data from the table in a streaming manner: "level" */
  level_stream: Array<Level>;
  /** fetch data from the table: "module" */
  module: Array<Module>;
  /** fetch aggregated fields from the table: "module" */
  module_aggregate: Module_Aggregate;
  /** fetch data from the table: "module" using primary key columns */
  module_by_pk: Maybe<Module>;
  /** fetch data from the table: "module_permission" */
  module_permission: Array<Module_Permission>;
  /** fetch aggregated fields from the table: "module_permission" */
  module_permission_aggregate: Module_Permission_Aggregate;
  /** fetch data from the table: "module_permission" using primary key columns */
  module_permission_by_pk: Maybe<Module_Permission>;
  /** fetch data from the table in a streaming manner: "module_permission" */
  module_permission_stream: Array<Module_Permission>;
  /** fetch data from the table in a streaming manner: "module" */
  module_stream: Array<Module>;
  next_tire_processing_date_range: Array<Next_Tire_Processing_Unit>;
  /** fetch data from the table: "note" */
  note: Array<Note>;
  /** fetch aggregated fields from the table: "note" */
  note_aggregate: Note_Aggregate;
  /** fetch data from the table: "note" using primary key columns */
  note_by_pk: Maybe<Note>;
  /** fetch data from the table in a streaming manner: "note" */
  note_stream: Array<Note>;
  /** fetch data from the table: "notification" */
  notification: Array<Notification>;
  /** fetch aggregated fields from the table: "notification" */
  notification_aggregate: Notification_Aggregate;
  /** fetch data from the table: "notification" using primary key columns */
  notification_by_pk: Maybe<Notification>;
  /** fetch data from the table in a streaming manner: "notification" */
  notification_stream: Array<Notification>;
  /** fetch data from the table: "planet_osm_line" */
  planet_osm_line: Array<Planet_Osm_Line>;
  /** fetch aggregated fields from the table: "planet_osm_line" */
  planet_osm_line_aggregate: Planet_Osm_Line_Aggregate;
  /** fetch data from the table in a streaming manner: "planet_osm_line" */
  planet_osm_line_stream: Array<Planet_Osm_Line>;
  /** fetch data from the table: "product" */
  product: Array<Product>;
  /** fetch aggregated fields from the table: "product" */
  product_aggregate: Product_Aggregate;
  /** fetch data from the table: "product" using primary key columns */
  product_by_pk: Maybe<Product>;
  /** fetch data from the table: "product_price" */
  product_price: Array<Product_Price>;
  /** fetch aggregated fields from the table: "product_price" */
  product_price_aggregate: Product_Price_Aggregate;
  /** fetch data from the table: "product_price" using primary key columns */
  product_price_by_pk: Maybe<Product_Price>;
  /** fetch data from the table in a streaming manner: "product_price" */
  product_price_stream: Array<Product_Price>;
  /** fetch data from the table: "product_request" */
  product_request: Array<Product_Request>;
  /** fetch aggregated fields from the table: "product_request" */
  product_request_aggregate: Product_Request_Aggregate;
  /** fetch data from the table: "product_request" using primary key columns */
  product_request_by_pk: Maybe<Product_Request>;
  /** fetch data from the table in a streaming manner: "product_request" */
  product_request_stream: Array<Product_Request>;
  /** fetch data from the table in a streaming manner: "product" */
  product_stream: Array<Product>;
  /** fetch data from the table: "profile" */
  profile: Array<Profile>;
  /** fetch aggregated fields from the table: "profile" */
  profile_aggregate: Profile_Aggregate;
  /** fetch data from the table: "profile" using primary key columns */
  profile_by_pk: Maybe<Profile>;
  /** fetch data from the table: "profile_permission" */
  profile_permission: Array<Profile_Permission>;
  /** fetch aggregated fields from the table: "profile_permission" */
  profile_permission_aggregate: Profile_Permission_Aggregate;
  /** fetch data from the table: "profile_permission" using primary key columns */
  profile_permission_by_pk: Maybe<Profile_Permission>;
  /** fetch data from the table in a streaming manner: "profile_permission" */
  profile_permission_stream: Array<Profile_Permission>;
  /** fetch data from the table in a streaming manner: "profile" */
  profile_stream: Array<Profile>;
  /** fetch data from the table: "refresh_token" */
  refresh_token: Array<Refresh_Token>;
  /** fetch aggregated fields from the table: "refresh_token" */
  refresh_token_aggregate: Refresh_Token_Aggregate;
  /** fetch data from the table: "refresh_token" using primary key columns */
  refresh_token_by_pk: Maybe<Refresh_Token>;
  /** fetch data from the table in a streaming manner: "refresh_token" */
  refresh_token_stream: Array<Refresh_Token>;
  risk_intensity_avg_and_max: Array<Risk_Intensity_Model>;
  risk_intensity_indicators_by_driver: Array<Risk_Intensity_Indicators_Model>;
  risky_intensity_by_driver: Array<Risk_Intensity_By_Driver_Model>;
  /** fetch data from the table: "score_processed" */
  score_processed: Array<Score_Processed>;
  /** fetch aggregated fields from the table: "score_processed" */
  score_processed_aggregate: Score_Processed_Aggregate;
  /** fetch data from the table: "score_processed" using primary key columns */
  score_processed_by_pk: Maybe<Score_Processed>;
  /** fetch data from the table in a streaming manner: "score_processed" */
  score_processed_stream: Array<Score_Processed>;
  /** fetch data from the table: "score_type" */
  score_type: Array<Score_Type>;
  /** fetch aggregated fields from the table: "score_type" */
  score_type_aggregate: Score_Type_Aggregate;
  /** fetch data from the table: "score_type" using primary key columns */
  score_type_by_pk: Maybe<Score_Type>;
  /** fetch data from the table in a streaming manner: "score_type" */
  score_type_stream: Array<Score_Type>;
  /** fetch data from the table: "status_truck_hardware" */
  status_truck_hardware: Array<Status_Truck_Hardware>;
  /** fetch aggregated fields from the table: "status_truck_hardware" */
  status_truck_hardware_aggregate: Status_Truck_Hardware_Aggregate;
  /** fetch data from the table: "status_truck_hardware" using primary key columns */
  status_truck_hardware_by_pk: Maybe<Status_Truck_Hardware>;
  /** fetch data from the table in a streaming manner: "status_truck_hardware" */
  status_truck_hardware_stream: Array<Status_Truck_Hardware>;
  /** fetch data from the table: "tire" */
  tire: Array<Tire>;
  /** fetch aggregated fields from the table: "tire" */
  tire_aggregate: Tire_Aggregate;
  /** fetch data from the table: "tire" using primary key columns */
  tire_by_pk: Maybe<Tire>;
  /** fetch data from the table: "tire.inspection" */
  tire_inspection: Array<Tire_Inspection>;
  /** fetch aggregated fields from the table: "tire.inspection" */
  tire_inspection_aggregate: Tire_Inspection_Aggregate;
  /** fetch data from the table: "tire.inspection" using primary key columns */
  tire_inspection_by_pk: Maybe<Tire_Inspection>;
  /** fetch data from the table: "tire.inspection_fk_tire" */
  tire_inspection_fk_tire: Array<Tire_Inspection_Fk_Tire>;
  /** fetch aggregated fields from the table: "tire.inspection_fk_tire" */
  tire_inspection_fk_tire_aggregate: Tire_Inspection_Fk_Tire_Aggregate;
  /** fetch data from the table: "tire.inspection_fk_tire" using primary key columns */
  tire_inspection_fk_tire_by_pk: Maybe<Tire_Inspection_Fk_Tire>;
  /** fetch data from the table in a streaming manner: "tire.inspection_fk_tire" */
  tire_inspection_fk_tire_stream: Array<Tire_Inspection_Fk_Tire>;
  /** fetch data from the table: "tire.inspection_note" */
  tire_inspection_note: Array<Tire_Inspection_Note>;
  /** fetch aggregated fields from the table: "tire.inspection_note" */
  tire_inspection_note_aggregate: Tire_Inspection_Note_Aggregate;
  /** fetch data from the table: "tire.inspection_note_attachment" */
  tire_inspection_note_attachment: Array<Tire_Inspection_Note_Attachment>;
  /** fetch aggregated fields from the table: "tire.inspection_note_attachment" */
  tire_inspection_note_attachment_aggregate: Tire_Inspection_Note_Attachment_Aggregate;
  /** fetch data from the table: "tire.inspection_note_attachment" using primary key columns */
  tire_inspection_note_attachment_by_pk: Maybe<Tire_Inspection_Note_Attachment>;
  /** fetch data from the table in a streaming manner: "tire.inspection_note_attachment" */
  tire_inspection_note_attachment_stream: Array<Tire_Inspection_Note_Attachment>;
  /** fetch data from the table: "tire.inspection_note" using primary key columns */
  tire_inspection_note_by_pk: Maybe<Tire_Inspection_Note>;
  /** fetch data from the table in a streaming manner: "tire.inspection_note" */
  tire_inspection_note_stream: Array<Tire_Inspection_Note>;
  /** fetch data from the table: "tire.inspection_origin" */
  tire_inspection_origin: Array<Tire_Inspection_Origin>;
  /** fetch aggregated fields from the table: "tire.inspection_origin" */
  tire_inspection_origin_aggregate: Tire_Inspection_Origin_Aggregate;
  /** fetch data from the table: "tire.inspection_origin" using primary key columns */
  tire_inspection_origin_by_pk: Maybe<Tire_Inspection_Origin>;
  /** fetch data from the table in a streaming manner: "tire.inspection_origin" */
  tire_inspection_origin_stream: Array<Tire_Inspection_Origin>;
  /** fetch data from the table in a streaming manner: "tire.inspection" */
  tire_inspection_stream: Array<Tire_Inspection>;
  /** fetch data from the table: "tire.note_type" */
  tire_note_type: Array<Tire_Note_Type>;
  /** fetch aggregated fields from the table: "tire.note_type" */
  tire_note_type_aggregate: Tire_Note_Type_Aggregate;
  /** fetch data from the table: "tire.note_type" using primary key columns */
  tire_note_type_by_pk: Maybe<Tire_Note_Type>;
  /** fetch data from the table in a streaming manner: "tire.note_type" */
  tire_note_type_stream: Array<Tire_Note_Type>;
  /** fetch data from the table: "tire.parameter" */
  tire_parameter: Array<Tire_Parameter>;
  /** fetch aggregated fields from the table: "tire.parameter" */
  tire_parameter_aggregate: Tire_Parameter_Aggregate;
  /** fetch data from the table: "tire.parameter" using primary key columns */
  tire_parameter_by_pk: Maybe<Tire_Parameter>;
  /** fetch data from the table in a streaming manner: "tire.parameter" */
  tire_parameter_stream: Array<Tire_Parameter>;
  /** fetch data from the table: "tire_processing_history" */
  tire_processing_history: Array<Tire_Processing_History>;
  /** fetch aggregated fields from the table: "tire_processing_history" */
  tire_processing_history_aggregate: Tire_Processing_History_Aggregate;
  /** fetch data from the table: "tire_processing_history" using primary key columns */
  tire_processing_history_by_pk: Maybe<Tire_Processing_History>;
  /** fetch data from the table in a streaming manner: "tire_processing_history" */
  tire_processing_history_stream: Array<Tire_Processing_History>;
  /** fetch data from the table in a streaming manner: "tire" */
  tire_stream: Array<Tire>;
  /** fetch data from the table: "tirecheck_inconsistency" */
  tirecheck_inconsistency: Array<Tirecheck_Inconsistency>;
  /** fetch aggregated fields from the table: "tirecheck_inconsistency" */
  tirecheck_inconsistency_aggregate: Tirecheck_Inconsistency_Aggregate;
  /** fetch data from the table: "tirecheck_inconsistency" using primary key columns */
  tirecheck_inconsistency_by_pk: Maybe<Tirecheck_Inconsistency>;
  /** fetch data from the table in a streaming manner: "tirecheck_inconsistency" */
  tirecheck_inconsistency_stream: Array<Tirecheck_Inconsistency>;
  /** fetch data from the table: "training" */
  training: Array<Training>;
  /** fetch aggregated fields from the table: "training" */
  training_aggregate: Training_Aggregate;
  /** fetch data from the table: "training" using primary key columns */
  training_by_pk: Maybe<Training>;
  /** fetch data from the table: "training_document" */
  training_document: Array<Training_Document>;
  /** fetch aggregated fields from the table: "training_document" */
  training_document_aggregate: Training_Document_Aggregate;
  /** fetch data from the table: "training_document" using primary key columns */
  training_document_by_pk: Maybe<Training_Document>;
  /** fetch data from the table in a streaming manner: "training_document" */
  training_document_stream: Array<Training_Document>;
  /** fetch data from the table: "training_document_view" */
  training_document_view: Array<Training_Document_View>;
  /** fetch aggregated fields from the table: "training_document_view" */
  training_document_view_aggregate: Training_Document_View_Aggregate;
  /** fetch data from the table: "training_document_view" using primary key columns */
  training_document_view_by_pk: Maybe<Training_Document_View>;
  /** fetch data from the table in a streaming manner: "training_document_view" */
  training_document_view_stream: Array<Training_Document_View>;
  /** fetch data from the table in a streaming manner: "training" */
  training_stream: Array<Training>;
  /** fetch data from the table: "user" */
  user: Array<User>;
  /** fetch aggregated fields from the table: "user" */
  user_aggregate: User_Aggregate;
  /** fetch data from the table: "user" using primary key columns */
  user_by_pk: Maybe<User>;
  /** fetch data from the table: "user_fk_achievement" */
  user_fk_achievement: Array<User_Fk_Achievement>;
  /** fetch aggregated fields from the table: "user_fk_achievement" */
  user_fk_achievement_aggregate: User_Fk_Achievement_Aggregate;
  /** fetch data from the table: "user_fk_achievement" using primary key columns */
  user_fk_achievement_by_pk: Maybe<User_Fk_Achievement>;
  /** fetch data from the table in a streaming manner: "user_fk_achievement" */
  user_fk_achievement_stream: Array<User_Fk_Achievement>;
  /** fetch data from the table: "user_fk_challenge" */
  user_fk_challenge: Array<User_Fk_Challenge>;
  /** fetch aggregated fields from the table: "user_fk_challenge" */
  user_fk_challenge_aggregate: User_Fk_Challenge_Aggregate;
  /** fetch data from the table: "user_fk_challenge" using primary key columns */
  user_fk_challenge_by_pk: Maybe<User_Fk_Challenge>;
  /** fetch data from the table in a streaming manner: "user_fk_challenge" */
  user_fk_challenge_stream: Array<User_Fk_Challenge>;
  /** fetch data from the table: "user_fk_level" */
  user_fk_level: Array<User_Fk_Level>;
  /** fetch aggregated fields from the table: "user_fk_level" */
  user_fk_level_aggregate: User_Fk_Level_Aggregate;
  /** fetch data from the table: "user_fk_level" using primary key columns */
  user_fk_level_by_pk: Maybe<User_Fk_Level>;
  /** fetch data from the table in a streaming manner: "user_fk_level" */
  user_fk_level_stream: Array<User_Fk_Level>;
  /** fetch data from the table: "user_fk_notification" */
  user_fk_notification: Array<User_Fk_Notification>;
  /** fetch aggregated fields from the table: "user_fk_notification" */
  user_fk_notification_aggregate: User_Fk_Notification_Aggregate;
  /** fetch data from the table: "user_fk_notification" using primary key columns */
  user_fk_notification_by_pk: Maybe<User_Fk_Notification>;
  /** fetch data from the table in a streaming manner: "user_fk_notification" */
  user_fk_notification_stream: Array<User_Fk_Notification>;
  /** fetch data from the table: "user_fk_privacy_policy" */
  user_fk_privacy_policy: Array<User_Fk_Privacy_Policy>;
  /** fetch aggregated fields from the table: "user_fk_privacy_policy" */
  user_fk_privacy_policy_aggregate: User_Fk_Privacy_Policy_Aggregate;
  /** fetch data from the table: "user_fk_privacy_policy" using primary key columns */
  user_fk_privacy_policy_by_pk: Maybe<User_Fk_Privacy_Policy>;
  /** fetch data from the table in a streaming manner: "user_fk_privacy_policy" */
  user_fk_privacy_policy_stream: Array<User_Fk_Privacy_Policy>;
  /** fetch data from the table: "user_km_points_approval" */
  user_km_points_approval: Array<User_Km_Points_Approval>;
  /** fetch aggregated fields from the table: "user_km_points_approval" */
  user_km_points_approval_aggregate: User_Km_Points_Approval_Aggregate;
  /** fetch data from the table: "user_km_points_approval" using primary key columns */
  user_km_points_approval_by_pk: Maybe<User_Km_Points_Approval>;
  /** fetch data from the table in a streaming manner: "user_km_points_approval" */
  user_km_points_approval_stream: Array<User_Km_Points_Approval>;
  /** An array relationship */
  user_kmps: Array<User_Kmps>;
  /** An aggregate relationship */
  user_kmps_aggregate: User_Kmps_Aggregate;
  /** fetch data from the table: "user_kmps" using primary key columns */
  user_kmps_by_pk: Maybe<User_Kmps>;
  /** fetch data from the table in a streaming manner: "user_kmps" */
  user_kmps_stream: Array<User_Kmps>;
  /** fetch data from the table: "user_score" */
  user_score: Array<User_Score>;
  /** fetch aggregated fields from the table: "user_score" */
  user_score_aggregate: User_Score_Aggregate;
  /** fetch data from the table: "user_score" using primary key columns */
  user_score_by_pk: Maybe<User_Score>;
  /** An array relationship */
  user_score_ranking: Array<User_Score_Ranking>;
  /** An aggregate relationship */
  user_score_ranking_aggregate: User_Score_Ranking_Aggregate;
  /** fetch data from the table in a streaming manner: "user_score_ranking" */
  user_score_ranking_stream: Array<User_Score_Ranking>;
  /** fetch data from the table in a streaming manner: "user_score" */
  user_score_stream: Array<User_Score>;
  /** fetch data from the table in a streaming manner: "user" */
  user_stream: Array<User>;
  /** fetch data from the table: "user_training" */
  user_training: Array<User_Training>;
  /** fetch aggregated fields from the table: "user_training" */
  user_training_aggregate: User_Training_Aggregate;
  /** fetch data from the table: "user_training" using primary key columns */
  user_training_by_pk: Maybe<User_Training>;
  /** fetch data from the table in a streaming manner: "user_training" */
  user_training_stream: Array<User_Training>;
  /** fetch data from the table: "vehicle" */
  vehicle: Array<Vehicle>;
  /** fetch aggregated fields from the table: "vehicle" */
  vehicle_aggregate: Vehicle_Aggregate;
  /** fetch data from the table: "vehicle" using primary key columns */
  vehicle_by_pk: Maybe<Vehicle>;
  /** fetch data from the table in a streaming manner: "vehicle" */
  vehicle_stream: Array<Vehicle>;
  /** fetch data from the table: "whatsapp_event" */
  whatsapp_event: Array<Whatsapp_Event>;
  /** fetch aggregated fields from the table: "whatsapp_event" */
  whatsapp_event_aggregate: Whatsapp_Event_Aggregate;
  /** fetch data from the table: "whatsapp_event" using primary key columns */
  whatsapp_event_by_pk: Maybe<Whatsapp_Event>;
  /** fetch data from the table in a streaming manner: "whatsapp_event" */
  whatsapp_event_stream: Array<Whatsapp_Event>;
  /** fetch data from the table: "whatsapp_message" */
  whatsapp_message: Array<Whatsapp_Message>;
  /** fetch aggregated fields from the table: "whatsapp_message" */
  whatsapp_message_aggregate: Whatsapp_Message_Aggregate;
  /** fetch data from the table: "whatsapp_message" using primary key columns */
  whatsapp_message_by_pk: Maybe<Whatsapp_Message>;
  /** fetch data from the table: "whatsapp_message_history" */
  whatsapp_message_history: Array<Whatsapp_Message_History>;
  /** fetch aggregated fields from the table: "whatsapp_message_history" */
  whatsapp_message_history_aggregate: Whatsapp_Message_History_Aggregate;
  /** fetch data from the table: "whatsapp_message_history" using primary key columns */
  whatsapp_message_history_by_pk: Maybe<Whatsapp_Message_History>;
  /** fetch data from the table in a streaming manner: "whatsapp_message_history" */
  whatsapp_message_history_stream: Array<Whatsapp_Message_History>;
  /** fetch data from the table in a streaming manner: "whatsapp_message" */
  whatsapp_message_stream: Array<Whatsapp_Message>;
  /** fetch data from the table: "whatsapp_trigger" */
  whatsapp_trigger: Array<Whatsapp_Trigger>;
  /** fetch aggregated fields from the table: "whatsapp_trigger" */
  whatsapp_trigger_aggregate: Whatsapp_Trigger_Aggregate;
  /** fetch data from the table: "whatsapp_trigger" using primary key columns */
  whatsapp_trigger_by_pk: Maybe<Whatsapp_Trigger>;
  /** fetch data from the table in a streaming manner: "whatsapp_trigger" */
  whatsapp_trigger_stream: Array<Whatsapp_Trigger>;
};


export type Subscription_RootCurrentTiresByVehicleArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CurrentTiresByVehicle_Order_By>>;
  where?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
};


export type Subscription_RootCurrentTiresByVehicle_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CurrentTiresByVehicle_Order_By>>;
  where?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
};


export type Subscription_RootParametroAlertaConducaoArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ParametroAlertaConducao_Order_By>>;
  where?: InputMaybe<ParametroAlertaConducao_Bool_Exp>;
};


export type Subscription_RootParametroAlertaConducao_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ParametroAlertaConducao_Order_By>>;
  where?: InputMaybe<ParametroAlertaConducao_Bool_Exp>;
};


export type Subscription_RootParametroAlertaConducao_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootPerformanceParameterArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PerformanceParameter_Order_By>>;
  where?: InputMaybe<PerformanceParameter_Bool_Exp>;
};


export type Subscription_RootPerformanceParameter_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PerformanceParameter_Order_By>>;
  where?: InputMaybe<PerformanceParameter_Bool_Exp>;
};


export type Subscription_RootPerformanceParameter_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootPontosRastroArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PontosRastro_Order_By>>;
  where?: InputMaybe<PontosRastro_Bool_Exp>;
};


export type Subscription_RootPontosRastro_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PontosRastro_Order_By>>;
  where?: InputMaybe<PontosRastro_Bool_Exp>;
};


export type Subscription_RootPontosRastro_By_PkArgs = {
  PontoRastroId: Scalars['Int']['input'];
};


export type Subscription_RootScoreParameterArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};


export type Subscription_RootScoreParameter_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreParameter_Order_By>>;
  where?: InputMaybe<ScoreParameter_Bool_Exp>;
};


export type Subscription_RootScoreParameter_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootScoreTypeArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreType_Order_By>>;
  where?: InputMaybe<ScoreType_Bool_Exp>;
};


export type Subscription_RootScoreType_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ScoreType_Order_By>>;
  where?: InputMaybe<ScoreType_Bool_Exp>;
};


export type Subscription_RootScoreType_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootSuntechEquipamentoArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechEquipamento_Order_By>>;
  where?: InputMaybe<SuntechEquipamento_Bool_Exp>;
};


export type Subscription_RootSuntechEquipamento_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechEquipamento_Order_By>>;
  where?: InputMaybe<SuntechEquipamento_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerBatchCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommand_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerBatchCommandDeviceArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerBatchCommandDevice_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandDevice_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerBatchCommandDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootSuntechTrackerBatchCommandPresetArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandPreset_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerBatchCommandPreset_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommandPreset_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerBatchCommandPreset_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootSuntechTrackerBatchCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerBatchCommand_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerBatchCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootSuntechTrackerCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SuntechTrackerCommand_Order_By>>;
  where?: InputMaybe<SuntechTrackerCommand_Bool_Exp>;
};


export type Subscription_RootSuntechTrackerCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootTireAnalysisReportArgs = {
  args: TireAnalysisReport_Arguments;
  distinct_on?: InputMaybe<Array<TireAnalysisReport_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TireAnalysisReport_Order_By>>;
  where?: InputMaybe<TireAnalysisReport_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerBatchCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommand_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerBatchCommandDeviceArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerBatchCommandDevice_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandDevice_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerBatchCommandDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootVirlocTrackerBatchCommandPresetArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandPreset_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerBatchCommandPreset_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommandPreset_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommandPreset_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerBatchCommandPreset_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootVirlocTrackerBatchCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerBatchCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerBatchCommand_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerBatchCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootVirlocTrackerCommandArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerCommand_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerCommand_Order_By>>;
  where?: InputMaybe<VirlocTrackerCommand_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerCommand_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootVirlocTrackerDeviceArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerDevice_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerDevice_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VirlocTrackerDevice_Order_By>>;
  where?: InputMaybe<VirlocTrackerDevice_Bool_Exp>;
};


export type Subscription_RootVirlocTrackerDevice_By_PkArgs = {
  Id: Scalars['Int']['input'];
};


export type Subscription_RootAchievementArgs = {
  distinct_on?: InputMaybe<Array<Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Achievement_Order_By>>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};


export type Subscription_RootAchievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Achievement_Order_By>>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};


export type Subscription_RootAchievement_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootAchievement_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Achievement_Stream_Cursor_Input>>;
  where?: InputMaybe<Achievement_Bool_Exp>;
};


export type Subscription_RootAdminArgs = {
  distinct_on?: InputMaybe<Array<Admin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Order_By>>;
  where?: InputMaybe<Admin_Bool_Exp>;
};


export type Subscription_RootAdmin_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Order_By>>;
  where?: InputMaybe<Admin_Bool_Exp>;
};


export type Subscription_RootAdmin_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootAdmin_Fk_NotificationsArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


export type Subscription_RootAdmin_Fk_Notifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Notifications_Order_By>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


export type Subscription_RootAdmin_Fk_Notifications_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  notification_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootAdmin_Fk_Notifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Admin_Fk_Notifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Admin_Fk_Notifications_Bool_Exp>;
};


export type Subscription_RootAdmin_Fk_ProfileArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


export type Subscription_RootAdmin_Fk_Profile_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Fk_Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Fk_Profile_Order_By>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


export type Subscription_RootAdmin_Fk_Profile_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  created_at: Scalars['timestamptz']['input'];
  profile_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootAdmin_Fk_Profile_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Admin_Fk_Profile_Stream_Cursor_Input>>;
  where?: InputMaybe<Admin_Fk_Profile_Bool_Exp>;
};


export type Subscription_RootAdmin_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


export type Subscription_RootAdmin_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Admin_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Admin_Permission_Order_By>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


export type Subscription_RootAdmin_Permission_By_PkArgs = {
  admin_uuid: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
};


export type Subscription_RootAdmin_Permission_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Admin_Permission_Stream_Cursor_Input>>;
  where?: InputMaybe<Admin_Permission_Bool_Exp>;
};


export type Subscription_RootAdmin_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Admin_Stream_Cursor_Input>>;
  where?: InputMaybe<Admin_Bool_Exp>;
};


export type Subscription_RootAutoArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Auto_Order_By>>;
  where?: InputMaybe<Auto_Bool_Exp>;
};


export type Subscription_RootAuto_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Auto_Order_By>>;
  where?: InputMaybe<Auto_Bool_Exp>;
};


export type Subscription_RootAuto_By_PkArgs = {
  placa: Scalars['String']['input'];
};


export type Subscription_RootBi_DashboardArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Dashboard_ItemArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_Item_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_Item_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Dashboard_Item_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Dashboard_Item_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Dashboard_Item_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_Item_TypeArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Type_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_Item_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Dashboard_Item_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Dashboard_Item_Type_Order_By>>;
  where?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_Item_Type_By_PkArgs = {
  type: Scalars['String']['input'];
};


export type Subscription_RootBi_Dashboard_Item_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Dashboard_Item_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Dashboard_Item_Type_Bool_Exp>;
};


export type Subscription_RootBi_Dashboard_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Dashboard_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Dashboard_Bool_Exp>;
};


export type Subscription_RootBi_DatasourceArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};


export type Subscription_RootBi_Datasource_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};


export type Subscription_RootBi_Datasource_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Datasource_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Datasource_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Datasource_Bool_Exp>;
};


export type Subscription_RootBi_Datasource_TypeArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Type_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
};


export type Subscription_RootBi_Datasource_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Datasource_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Datasource_Type_Order_By>>;
  where?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
};


export type Subscription_RootBi_Datasource_Type_By_PkArgs = {
  type: Scalars['String']['input'];
};


export type Subscription_RootBi_Datasource_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Datasource_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Datasource_Type_Bool_Exp>;
};


export type Subscription_RootBi_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Order_By>>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};


export type Subscription_RootBi_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Order_By>>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};


export type Subscription_RootBi_Permission_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootBi_Permission_ModuleArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Module_Order_By>>;
  where?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
};


export type Subscription_RootBi_Permission_Module_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Permission_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Permission_Module_Order_By>>;
  where?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
};


export type Subscription_RootBi_Permission_Module_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootBi_Permission_Module_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Permission_Module_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Permission_Module_Bool_Exp>;
};


export type Subscription_RootBi_Permission_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Permission_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Permission_Bool_Exp>;
};


export type Subscription_RootBi_Public_LinkArgs = {
  distinct_on?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Public_Link_Order_By>>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};


export type Subscription_RootBi_Public_Link_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Public_Link_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Public_Link_Order_By>>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};


export type Subscription_RootBi_Public_Link_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Public_Link_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Public_Link_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Public_Link_Bool_Exp>;
};


export type Subscription_RootBi_QueryArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Order_By>>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};


export type Subscription_RootBi_Query_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Order_By>>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};


export type Subscription_RootBi_Query_AnalyticsArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Analytics_Order_By>>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};


export type Subscription_RootBi_Query_Analytics_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Analytics_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Analytics_Order_By>>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};


export type Subscription_RootBi_Query_Analytics_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Query_Analytics_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Query_Analytics_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Query_Analytics_Bool_Exp>;
};


export type Subscription_RootBi_Query_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Query_CacheArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


export type Subscription_RootBi_Query_Cache_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Query_Cache_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Query_Cache_Order_By>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


export type Subscription_RootBi_Query_Cache_By_PkArgs = {
  dashboard_uuid: Scalars['uuid']['input'];
  params_hash: Scalars['String']['input'];
  query_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Query_Cache_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Query_Cache_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Query_Cache_Bool_Exp>;
};


export type Subscription_RootBi_Query_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Query_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Query_Bool_Exp>;
};


export type Subscription_RootBi_SubqueryArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


export type Subscription_RootBi_Subquery_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_Subquery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_Subquery_Order_By>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


export type Subscription_RootBi_Subquery_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_Subquery_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_Subquery_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_Subquery_Bool_Exp>;
};


export type Subscription_RootBi_User_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_User_Permission_Order_By>>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};


export type Subscription_RootBi_User_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bi_User_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bi_User_Permission_Order_By>>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};


export type Subscription_RootBi_User_Permission_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootBi_User_Permission_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bi_User_Permission_Stream_Cursor_Input>>;
  where?: InputMaybe<Bi_User_Permission_Bool_Exp>;
};


export type Subscription_RootChallengeArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Order_By>>;
  where?: InputMaybe<Challenge_Bool_Exp>;
};


export type Subscription_RootChallenge_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Order_By>>;
  where?: InputMaybe<Challenge_Bool_Exp>;
};


export type Subscription_RootChallenge_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootChallenge_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Challenge_Stream_Cursor_Input>>;
  where?: InputMaybe<Challenge_Bool_Exp>;
};


export type Subscription_RootChallenge_TypeArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Type_Order_By>>;
  where?: InputMaybe<Challenge_Type_Bool_Exp>;
};


export type Subscription_RootChallenge_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Challenge_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Challenge_Type_Order_By>>;
  where?: InputMaybe<Challenge_Type_Bool_Exp>;
};


export type Subscription_RootChallenge_Type_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Subscription_RootChallenge_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Challenge_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Challenge_Type_Bool_Exp>;
};


export type Subscription_RootConfigArgs = {
  distinct_on?: InputMaybe<Array<Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Config_Order_By>>;
  where?: InputMaybe<Config_Bool_Exp>;
};


export type Subscription_RootConfig_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Config_Order_By>>;
  where?: InputMaybe<Config_Bool_Exp>;
};


export type Subscription_RootConfig_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootConfig_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Config_Stream_Cursor_Input>>;
  where?: InputMaybe<Config_Bool_Exp>;
};


export type Subscription_RootCritical_PointArgs = {
  distinct_on?: InputMaybe<Array<Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Point_Order_By>>;
  where?: InputMaybe<Critical_Point_Bool_Exp>;
};


export type Subscription_RootCritical_Point_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Point_Order_By>>;
  where?: InputMaybe<Critical_Point_Bool_Exp>;
};


export type Subscription_RootCritical_Point_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCritical_Point_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Critical_Point_Stream_Cursor_Input>>;
  where?: InputMaybe<Critical_Point_Bool_Exp>;
};


export type Subscription_RootCritical_SegmentArgs = {
  distinct_on?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Segment_Order_By>>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};


export type Subscription_RootCritical_Segment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Critical_Segment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Critical_Segment_Order_By>>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};


export type Subscription_RootCritical_Segment_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCritical_Segment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Critical_Segment_Stream_Cursor_Input>>;
  where?: InputMaybe<Critical_Segment_Bool_Exp>;
};


export type Subscription_RootCte_Nf_LockArgs = {
  distinct_on?: InputMaybe<Array<Cte_Nf_Lock_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cte_Nf_Lock_Order_By>>;
  where?: InputMaybe<Cte_Nf_Lock_Bool_Exp>;
};


export type Subscription_RootCte_Nf_Lock_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cte_Nf_Lock_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cte_Nf_Lock_Order_By>>;
  where?: InputMaybe<Cte_Nf_Lock_Bool_Exp>;
};


export type Subscription_RootCte_Nf_Lock_By_PkArgs = {
  nf: Scalars['Int']['input'];
};


export type Subscription_RootCte_Nf_Lock_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Cte_Nf_Lock_Stream_Cursor_Input>>;
  where?: InputMaybe<Cte_Nf_Lock_Bool_Exp>;
};


export type Subscription_RootCurrent_ConfigArgs = {
  distinct_on?: InputMaybe<Array<Current_Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Current_Config_Order_By>>;
  where?: InputMaybe<Current_Config_Bool_Exp>;
};


export type Subscription_RootCurrent_Config_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Current_Config_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Current_Config_Order_By>>;
  where?: InputMaybe<Current_Config_Bool_Exp>;
};


export type Subscription_RootCurrent_Config_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Current_Config_Stream_Cursor_Input>>;
  where?: InputMaybe<Current_Config_Bool_Exp>;
};


export type Subscription_RootDeleted_RowArgs = {
  distinct_on?: InputMaybe<Array<Deleted_Row_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Deleted_Row_Order_By>>;
  where?: InputMaybe<Deleted_Row_Bool_Exp>;
};


export type Subscription_RootDeleted_Row_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Deleted_Row_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Deleted_Row_Order_By>>;
  where?: InputMaybe<Deleted_Row_Bool_Exp>;
};


export type Subscription_RootDeleted_Row_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDeleted_Row_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Deleted_Row_Stream_Cursor_Input>>;
  where?: InputMaybe<Deleted_Row_Bool_Exp>;
};


export type Subscription_RootDeliveryArgs = {
  distinct_on?: InputMaybe<Array<Delivery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Delivery_Order_By>>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};


export type Subscription_RootDelivery_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Delivery_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Delivery_Order_By>>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};


export type Subscription_RootDelivery_By_PkArgs = {
  document_number: Scalars['String']['input'];
  invoice_number: Scalars['String']['input'];
  trip_id: Scalars['String']['input'];
};


export type Subscription_RootDelivery_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Delivery_Stream_Cursor_Input>>;
  where?: InputMaybe<Delivery_Bool_Exp>;
};


export type Subscription_RootDriver_Performance_DataArgs = {
  args: Driver_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Subscription_RootDriver_Performance_Data_AggregateArgs = {
  args: Driver_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Subscription_RootDriver_WarningArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootDriver_Warning_CommentArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Comment_Order_By>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Comment_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootDriver_Warning_Comment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Comment_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Comment_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Fk_Whatsapp_MessageArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Fk_Whatsapp_Message_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Fk_Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Fk_Whatsapp_Message_By_PkArgs = {
  driver_warning_uuid: Scalars['uuid']['input'];
  whatsapp_message_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootDriver_Warning_Fk_Whatsapp_Message_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Fk_Whatsapp_Message_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Risk_LevelArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Risk_Level_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Risk_Level_By_PkArgs = {
  level_name: Scalars['String']['input'];
};


export type Subscription_RootDriver_Warning_Risk_Level_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Risk_Level_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Risk_Level_ViewArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_View_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Risk_Level_View_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Risk_Level_View_Order_By>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_View_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Risk_Level_View_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Risk_Level_View_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Risk_Level_View_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_TripArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootDriver_Warning_Trip_PointArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Point_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_Point_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Point_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_Point_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDriver_Warning_Trip_Point_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Trip_Point_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Trip_Point_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_SeverityArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Severity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Severity_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_Severity_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Trip_Severity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Trip_Severity_Order_By>>;
  where?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_Severity_By_PkArgs = {
  severity_level: Scalars['Int']['input'];
};


export type Subscription_RootDriver_Warning_Trip_Severity_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Trip_Severity_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Trip_Severity_Bool_Exp>;
};


export type Subscription_RootDriver_Warning_Trip_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Warning_Trip_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Warning_Trip_Bool_Exp>;
};


export type Subscription_RootEdi_Busca_Nfe_JobArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Job_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Job_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
};


export type Subscription_RootEdi_Busca_Nfe_Job_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Job_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Job_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
};


export type Subscription_RootEdi_Busca_Nfe_Job_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootEdi_Busca_Nfe_Job_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Edi_Busca_Nfe_Job_Stream_Cursor_Input>>;
  where?: InputMaybe<Edi_Busca_Nfe_Job_Bool_Exp>;
};


export type Subscription_RootEdi_Busca_Nfe_ResponseArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Response_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};


export type Subscription_RootEdi_Busca_Nfe_Response_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Edi_Busca_Nfe_Response_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Edi_Busca_Nfe_Response_Order_By>>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};


export type Subscription_RootEdi_Busca_Nfe_Response_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootEdi_Busca_Nfe_Response_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Edi_Busca_Nfe_Response_Stream_Cursor_Input>>;
  where?: InputMaybe<Edi_Busca_Nfe_Response_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Critical_Segment_From_Critical_PointArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Critical_Segment_From_Critical_Point_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Critical_Segment_From_Critical_Point_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Stream_Cursor_Input>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Driver_Performance_DataArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Driver_Performance_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Driver_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Driver_Performance_Data_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Empty_Tables_Driver_Performance_Data_Stream_Cursor_Input>>;
  where?: InputMaybe<Empty_Tables_Driver_Performance_Data_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Fleet_Performance_DataArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Fleet_Performance_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Fleet_Performance_Data_By_PkArgs = {
  brake_use_avg: Scalars['Int']['input'];
  economic_range_avg: Scalars['Int']['input'];
  engine_load_avg: Scalars['Int']['input'];
  inertia_avg: Scalars['Int']['input'];
  note_avg: Scalars['Int']['input'];
  slow_running_avg: Scalars['Int']['input'];
  speed_control_avg: Scalars['Int']['input'];
  total_count: Scalars['Int']['input'];
  total_drivers: Scalars['Int']['input'];
  total_km: Scalars['float8']['input'];
  total_km_avg: Scalars['float8']['input'];
  total_periods: Scalars['Int']['input'];
};


export type Subscription_RootEmpty_Tables_Fleet_Performance_Data_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Empty_Tables_Fleet_Performance_Data_Stream_Cursor_Input>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Geojson_TripArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Geojson_Trip_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Geojson_Trip_By_PkArgs = {
  trip_id: Scalars['Int']['input'];
};


export type Subscription_RootEmpty_Tables_Geojson_Trip_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Empty_Tables_Geojson_Trip_Stream_Cursor_Input>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Instructor_Drivers_Performance_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Instructor_Drivers_Performance_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Subscription_RootEmpty_Tables_Instructor_Drivers_Performance_History_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Stream_Cursor_Input>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Subscription_RootFidelity_Range_PointsArgs = {
  distinct_on?: InputMaybe<Array<Fidelity_Range_Points_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fidelity_Range_Points_Order_By>>;
  where?: InputMaybe<Fidelity_Range_Points_Bool_Exp>;
};


export type Subscription_RootFidelity_Range_Points_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fidelity_Range_Points_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fidelity_Range_Points_Order_By>>;
  where?: InputMaybe<Fidelity_Range_Points_Bool_Exp>;
};


export type Subscription_RootFidelity_Range_Points_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootFidelity_Range_Points_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Fidelity_Range_Points_Stream_Cursor_Input>>;
  where?: InputMaybe<Fidelity_Range_Points_Bool_Exp>;
};


export type Subscription_RootFipe_PriceArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


export type Subscription_RootFipe_Price_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Price_Order_By>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


export type Subscription_RootFipe_Price_By_PkArgs = {
  reference_table_date: Scalars['date']['input'];
  vehicle_fipe_code: Scalars['String']['input'];
  vehicle_model_year: Scalars['Int']['input'];
};


export type Subscription_RootFipe_Price_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Fipe_Price_Stream_Cursor_Input>>;
  where?: InputMaybe<Fipe_Price_Bool_Exp>;
};


export type Subscription_RootFipe_Reference_MonthArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Reference_Month_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Reference_Month_Order_By>>;
  where?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
};


export type Subscription_RootFipe_Reference_Month_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Reference_Month_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Reference_Month_Order_By>>;
  where?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
};


export type Subscription_RootFipe_Reference_Month_By_PkArgs = {
  code: Scalars['Int']['input'];
};


export type Subscription_RootFipe_Reference_Month_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Fipe_Reference_Month_Stream_Cursor_Input>>;
  where?: InputMaybe<Fipe_Reference_Month_Bool_Exp>;
};


export type Subscription_RootFipe_Search_Fipe_VehicleArgs = {
  args: Fipe_Search_Fipe_Vehicle_Args;
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Subscription_RootFipe_Search_Fipe_Vehicle_AggregateArgs = {
  args: Fipe_Search_Fipe_Vehicle_Args;
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Subscription_RootFipe_Selected_VehicleArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Selected_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};


export type Subscription_RootFipe_Selected_Vehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Selected_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Selected_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};


export type Subscription_RootFipe_Selected_Vehicle_By_PkArgs = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};


export type Subscription_RootFipe_Selected_Vehicle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Fipe_Selected_Vehicle_Stream_Cursor_Input>>;
  where?: InputMaybe<Fipe_Selected_Vehicle_Bool_Exp>;
};


export type Subscription_RootFipe_VehicleArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Subscription_RootFipe_Vehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fipe_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fipe_Vehicle_Order_By>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Subscription_RootFipe_Vehicle_By_PkArgs = {
  fipe_code: Scalars['String']['input'];
  model_year: Scalars['Int']['input'];
};


export type Subscription_RootFipe_Vehicle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Fipe_Vehicle_Stream_Cursor_Input>>;
  where?: InputMaybe<Fipe_Vehicle_Bool_Exp>;
};


export type Subscription_RootFleet_Performance_DataArgs = {
  args: Fleet_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Subscription_RootFleet_Performance_Data_AggregateArgs = {
  args: Fleet_Performance_Data_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Fleet_Performance_Data_Order_By>>;
  where?: InputMaybe<Empty_Tables_Fleet_Performance_Data_Bool_Exp>;
};


export type Subscription_RootGet_Critical_Segments_From_Critical_PointArgs = {
  args: Get_Critical_Segments_From_Critical_Point_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Subscription_RootGet_Critical_Segments_From_Critical_Point_AggregateArgs = {
  args: Get_Critical_Segments_From_Critical_Point_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Critical_Segment_From_Critical_Point_Order_By>>;
  where?: InputMaybe<Empty_Tables_Critical_Segment_From_Critical_Point_Bool_Exp>;
};


export type Subscription_RootGet_Driver_Warning_GeojsonArgs = {
  args: Get_Driver_Warning_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootGet_Driver_Warning_Geojson_AggregateArgs = {
  args: Get_Driver_Warning_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootGet_Route_Geojson_By_Score_ProcessedArgs = {
  args: Get_Route_Geojson_By_Score_Processed_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootGet_Route_Geojson_By_Score_Processed_AggregateArgs = {
  args: Get_Route_Geojson_By_Score_Processed_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootGet_Trips_GeojsonArgs = {
  args: Get_Trips_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootGet_Trips_Geojson_AggregateArgs = {
  args: Get_Trips_Geojson_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Geojson_Trip_Order_By>>;
  where?: InputMaybe<Empty_Tables_Geojson_Trip_Bool_Exp>;
};


export type Subscription_RootInspectionArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Order_By>>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};


export type Subscription_RootInspection_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Order_By>>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};


export type Subscription_RootInspection_Analysis_ParameterArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Analysis_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Analysis_Parameter_Order_By>>;
  where?: InputMaybe<Inspection_Analysis_Parameter_Bool_Exp>;
};


export type Subscription_RootInspection_Analysis_Parameter_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Analysis_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Analysis_Parameter_Order_By>>;
  where?: InputMaybe<Inspection_Analysis_Parameter_Bool_Exp>;
};


export type Subscription_RootInspection_Analysis_Parameter_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Subscription_RootInspection_Analysis_Parameter_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Inspection_Analysis_Parameter_Stream_Cursor_Input>>;
  where?: InputMaybe<Inspection_Analysis_Parameter_Bool_Exp>;
};


export type Subscription_RootInspection_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootInspection_Fk_TireArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


export type Subscription_RootInspection_Fk_Tire_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


export type Subscription_RootInspection_Fk_Tire_By_PkArgs = {
  inspection_id: Scalars['String']['input'];
  tire_id: Scalars['String']['input'];
};


export type Subscription_RootInspection_Fk_Tire_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Inspection_Fk_Tire_Stream_Cursor_Input>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


export type Subscription_RootInspection_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Inspection_Stream_Cursor_Input>>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};


export type Subscription_RootInspections_ExportArgs = {
  args: Inspections_Export_Arguments;
  distinct_on?: InputMaybe<Array<InspectionsExport_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionsExport_Order_By>>;
  where?: InputMaybe<InspectionsExport_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Excessive_High_PressureArgs = {
  args: Inspections_That_Reported_Excessive_High_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Excessive_Low_PressureArgs = {
  args: Inspections_That_Reported_Excessive_Low_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_High_PressureArgs = {
  args: Inspections_That_Reported_High_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_High_Twin_Tires_Minimum_Depth_DifferenceArgs = {
  args: Inspections_That_Reported_High_Twin_Tires_Minimum_Depth_Difference_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Low_PressureArgs = {
  args: Inspections_That_Reported_Low_Pressure_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Low_Tire_DepthArgs = {
  args: Inspections_That_Reported_Low_Tire_Depth_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Open_ServicesArgs = {
  args: Inspections_That_Reported_Open_Services_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Wear_IrregularArgs = {
  args: Inspections_That_Reported_Wear_Irregular_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Wear_SevereArgs = {
  args: Inspections_That_Reported_Wear_Severe_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Wear_Severe_Cavalo_MecanicoArgs = {
  args: Inspections_That_Reported_Wear_Severe_Cavalo_Mecanico_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInspections_That_Reported_Wear_Severe_Semi_ReboqueArgs = {
  args: Inspections_That_Reported_Wear_Severe_Semi_Reboque_Arguments;
  distinct_on?: InputMaybe<Array<InspectionProblem_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InspectionProblem_Order_By>>;
  where?: InputMaybe<InspectionProblem_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootInstructor_Drivers_Performance_HistoryArgs = {
  args: Instructor_Drivers_Performance_History_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Subscription_RootInstructor_Drivers_Performance_History_AggregateArgs = {
  args: Instructor_Drivers_Performance_History_Args;
  distinct_on?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Empty_Tables_Instructor_Drivers_Performance_History_Order_By>>;
  where?: InputMaybe<Empty_Tables_Instructor_Drivers_Performance_History_Bool_Exp>;
};


export type Subscription_RootInstructor_SupervisionArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootInstructor_Supervision_ObservationArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_Observation_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Observation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Observation_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_Observation_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootInstructor_Supervision_Observation_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Instructor_Supervision_Observation_Stream_Cursor_Input>>;
  where?: InputMaybe<Instructor_Supervision_Observation_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Instructor_Supervision_Stream_Cursor_Input>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_With_UserArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_With_User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_With_User_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_With_User_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_With_User_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_With_User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_With_User_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_With_User_Bool_Exp>;
};


export type Subscription_RootInstructor_Supervision_With_User_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Instructor_Supervision_With_User_Stream_Cursor_Input>>;
  where?: InputMaybe<Instructor_Supervision_With_User_Bool_Exp>;
};


export type Subscription_RootLast_Inspection_Tire_By_VehicleArgs = {
  distinct_on?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Order_By>>;
  where?: InputMaybe<Last_Inspection_Tire_By_Vehicle_Bool_Exp>;
};


export type Subscription_RootLast_Inspection_Tire_By_Vehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Last_Inspection_Tire_By_Vehicle_Order_By>>;
  where?: InputMaybe<Last_Inspection_Tire_By_Vehicle_Bool_Exp>;
};


export type Subscription_RootLast_Inspection_Tire_By_Vehicle_PlateArgs = {
  args: Last_Inspection_Tire_By_Vehicle_Plate_Arguments;
  distinct_on?: InputMaybe<Array<Inspection_Tire_By_Vehicle_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Tire_By_Vehicle_Order_By>>;
  where?: InputMaybe<Inspection_Tire_By_Vehicle_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootLast_Inspection_Tire_By_Vehicle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Last_Inspection_Tire_By_Vehicle_Stream_Cursor_Input>>;
  where?: InputMaybe<Last_Inspection_Tire_By_Vehicle_Bool_Exp>;
};


export type Subscription_RootLevelArgs = {
  distinct_on?: InputMaybe<Array<Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Order_By>>;
  where?: InputMaybe<Level_Bool_Exp>;
};


export type Subscription_RootLevel_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Order_By>>;
  where?: InputMaybe<Level_Bool_Exp>;
};


export type Subscription_RootLevel_By_PkArgs = {
  number: Scalars['Int']['input'];
};


export type Subscription_RootLevel_OptionArgs = {
  distinct_on?: InputMaybe<Array<Level_Option_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Option_Order_By>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


export type Subscription_RootLevel_Option_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Level_Option_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Option_Order_By>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


export type Subscription_RootLevel_Option_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootLevel_Option_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Level_Option_Stream_Cursor_Input>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


export type Subscription_RootLevel_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Level_Stream_Cursor_Input>>;
  where?: InputMaybe<Level_Bool_Exp>;
};


export type Subscription_RootModuleArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Subscription_RootModule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Subscription_RootModule_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Subscription_RootModule_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Module_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Permission_Order_By>>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};


export type Subscription_RootModule_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Module_Permission_Order_By>>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};


export type Subscription_RootModule_Permission_By_PkArgs = {
  action: Scalars['String']['input'];
};


export type Subscription_RootModule_Permission_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Module_Permission_Stream_Cursor_Input>>;
  where?: InputMaybe<Module_Permission_Bool_Exp>;
};


export type Subscription_RootModule_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Module_Stream_Cursor_Input>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Subscription_RootNext_Tire_Processing_Date_RangeArgs = {
  args: Next_Tire_Processing_Date_Range_Arguments;
  distinct_on?: InputMaybe<Array<Next_Tire_Processing_Unit_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Next_Tire_Processing_Unit_Order_By>>;
  where?: InputMaybe<Next_Tire_Processing_Unit_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootNoteArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};


export type Subscription_RootNote_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};


export type Subscription_RootNote_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootNote_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Note_Stream_Cursor_Input>>;
  where?: InputMaybe<Note_Bool_Exp>;
};


export type Subscription_RootNotificationArgs = {
  distinct_on?: InputMaybe<Array<Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notification_Order_By>>;
  where?: InputMaybe<Notification_Bool_Exp>;
};


export type Subscription_RootNotification_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notification_Order_By>>;
  where?: InputMaybe<Notification_Bool_Exp>;
};


export type Subscription_RootNotification_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootNotification_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Notification_Stream_Cursor_Input>>;
  where?: InputMaybe<Notification_Bool_Exp>;
};


export type Subscription_RootPlanet_Osm_LineArgs = {
  distinct_on?: InputMaybe<Array<Planet_Osm_Line_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Planet_Osm_Line_Order_By>>;
  where?: InputMaybe<Planet_Osm_Line_Bool_Exp>;
};


export type Subscription_RootPlanet_Osm_Line_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Planet_Osm_Line_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Planet_Osm_Line_Order_By>>;
  where?: InputMaybe<Planet_Osm_Line_Bool_Exp>;
};


export type Subscription_RootPlanet_Osm_Line_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Planet_Osm_Line_Stream_Cursor_Input>>;
  where?: InputMaybe<Planet_Osm_Line_Bool_Exp>;
};


export type Subscription_RootProductArgs = {
  distinct_on?: InputMaybe<Array<Product_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Order_By>>;
  where?: InputMaybe<Product_Bool_Exp>;
};


export type Subscription_RootProduct_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Order_By>>;
  where?: InputMaybe<Product_Bool_Exp>;
};


export type Subscription_RootProduct_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootProduct_PriceArgs = {
  distinct_on?: InputMaybe<Array<Product_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Price_Order_By>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};


export type Subscription_RootProduct_Price_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Price_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Price_Order_By>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};


export type Subscription_RootProduct_Price_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootProduct_Price_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Product_Price_Stream_Cursor_Input>>;
  where?: InputMaybe<Product_Price_Bool_Exp>;
};


export type Subscription_RootProduct_RequestArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


export type Subscription_RootProduct_Request_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


export type Subscription_RootProduct_Request_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootProduct_Request_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Product_Request_Stream_Cursor_Input>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


export type Subscription_RootProduct_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Product_Stream_Cursor_Input>>;
  where?: InputMaybe<Product_Bool_Exp>;
};


export type Subscription_RootProfileArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Subscription_RootProfile_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Subscription_RootProfile_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootProfile_PermissionArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};


export type Subscription_RootProfile_Permission_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Permission_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Profile_Permission_Order_By>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};


export type Subscription_RootProfile_Permission_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootProfile_Permission_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Profile_Permission_Stream_Cursor_Input>>;
  where?: InputMaybe<Profile_Permission_Bool_Exp>;
};


export type Subscription_RootProfile_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Profile_Stream_Cursor_Input>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Subscription_RootRefresh_TokenArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


export type Subscription_RootRefresh_Token_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


export type Subscription_RootRefresh_Token_By_PkArgs = {
  refresh_token: Scalars['String']['input'];
};


export type Subscription_RootRefresh_Token_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Refresh_Token_Stream_Cursor_Input>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


export type Subscription_RootRisk_Intensity_Avg_And_MaxArgs = {
  args: Risk_Intensity_Avg_And_Max_Arguments;
  distinct_on?: InputMaybe<Array<Risk_Intensity_Model_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Risk_Intensity_Model_Order_By>>;
  where?: InputMaybe<Risk_Intensity_Model_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootRisk_Intensity_Indicators_By_DriverArgs = {
  args: Risk_Intensity_Indicators_By_Driver_Arguments;
  distinct_on?: InputMaybe<Array<Risk_Intensity_Indicators_Model_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Risk_Intensity_Indicators_Model_Order_By>>;
  where?: InputMaybe<Risk_Intensity_Indicators_Model_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootRisky_Intensity_By_DriverArgs = {
  args: Risky_Intensity_By_Driver_Arguments;
  distinct_on?: InputMaybe<Array<Risk_Intensity_By_Driver_Model_Enum_Name>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Risk_Intensity_By_Driver_Model_Order_By>>;
  where?: InputMaybe<Risk_Intensity_By_Driver_Model_Bool_Exp_Bool_Exp>;
};


export type Subscription_RootScore_ProcessedArgs = {
  distinct_on?: InputMaybe<Array<Score_Processed_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Processed_Order_By>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};


export type Subscription_RootScore_Processed_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Score_Processed_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Processed_Order_By>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};


export type Subscription_RootScore_Processed_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootScore_Processed_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Score_Processed_Stream_Cursor_Input>>;
  where?: InputMaybe<Score_Processed_Bool_Exp>;
};


export type Subscription_RootScore_TypeArgs = {
  distinct_on?: InputMaybe<Array<Score_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Type_Order_By>>;
  where?: InputMaybe<Score_Type_Bool_Exp>;
};


export type Subscription_RootScore_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Score_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Score_Type_Order_By>>;
  where?: InputMaybe<Score_Type_Bool_Exp>;
};


export type Subscription_RootScore_Type_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Subscription_RootScore_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Score_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Score_Type_Bool_Exp>;
};


export type Subscription_RootStatus_Truck_HardwareArgs = {
  distinct_on?: InputMaybe<Array<Status_Truck_Hardware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Status_Truck_Hardware_Order_By>>;
  where?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
};


export type Subscription_RootStatus_Truck_Hardware_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Status_Truck_Hardware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Status_Truck_Hardware_Order_By>>;
  where?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
};


export type Subscription_RootStatus_Truck_Hardware_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootStatus_Truck_Hardware_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Status_Truck_Hardware_Stream_Cursor_Input>>;
  where?: InputMaybe<Status_Truck_Hardware_Bool_Exp>;
};


export type Subscription_RootTireArgs = {
  distinct_on?: InputMaybe<Array<Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Order_By>>;
  where?: InputMaybe<Tire_Bool_Exp>;
};


export type Subscription_RootTire_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Order_By>>;
  where?: InputMaybe<Tire_Bool_Exp>;
};


export type Subscription_RootTire_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootTire_InspectionArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootTire_Inspection_Fk_TireArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Fk_Tire_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Fk_Tire_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTire_Inspection_Fk_Tire_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Inspection_Fk_Tire_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_NoteArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Note_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Note_AttachmentArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Note_Attachment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Note_Attachment_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTire_Inspection_Note_Attachment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Inspection_Note_Attachment_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Note_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTire_Inspection_Note_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Inspection_Note_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_OriginArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Origin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Origin_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Origin_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Origin_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Origin_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_Origin_By_PkArgs = {
  origin: Scalars['String']['input'];
};


export type Subscription_RootTire_Inspection_Origin_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Inspection_Origin_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
};


export type Subscription_RootTire_Inspection_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Inspection_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};


export type Subscription_RootTire_Note_TypeArgs = {
  distinct_on?: InputMaybe<Array<Tire_Note_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Note_Type_Order_By>>;
  where?: InputMaybe<Tire_Note_Type_Bool_Exp>;
};


export type Subscription_RootTire_Note_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Note_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Note_Type_Order_By>>;
  where?: InputMaybe<Tire_Note_Type_Bool_Exp>;
};


export type Subscription_RootTire_Note_Type_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTire_Note_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Note_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Note_Type_Bool_Exp>;
};


export type Subscription_RootTire_ParameterArgs = {
  distinct_on?: InputMaybe<Array<Tire_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Parameter_Order_By>>;
  where?: InputMaybe<Tire_Parameter_Bool_Exp>;
};


export type Subscription_RootTire_Parameter_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Parameter_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Parameter_Order_By>>;
  where?: InputMaybe<Tire_Parameter_Bool_Exp>;
};


export type Subscription_RootTire_Parameter_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Subscription_RootTire_Parameter_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Parameter_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Parameter_Bool_Exp>;
};


export type Subscription_RootTire_Processing_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Tire_Processing_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Processing_History_Order_By>>;
  where?: InputMaybe<Tire_Processing_History_Bool_Exp>;
};


export type Subscription_RootTire_Processing_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Processing_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Processing_History_Order_By>>;
  where?: InputMaybe<Tire_Processing_History_Bool_Exp>;
};


export type Subscription_RootTire_Processing_History_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootTire_Processing_History_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Processing_History_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Processing_History_Bool_Exp>;
};


export type Subscription_RootTire_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tire_Stream_Cursor_Input>>;
  where?: InputMaybe<Tire_Bool_Exp>;
};


export type Subscription_RootTirecheck_InconsistencyArgs = {
  distinct_on?: InputMaybe<Array<Tirecheck_Inconsistency_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tirecheck_Inconsistency_Order_By>>;
  where?: InputMaybe<Tirecheck_Inconsistency_Bool_Exp>;
};


export type Subscription_RootTirecheck_Inconsistency_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tirecheck_Inconsistency_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tirecheck_Inconsistency_Order_By>>;
  where?: InputMaybe<Tirecheck_Inconsistency_Bool_Exp>;
};


export type Subscription_RootTirecheck_Inconsistency_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTirecheck_Inconsistency_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tirecheck_Inconsistency_Stream_Cursor_Input>>;
  where?: InputMaybe<Tirecheck_Inconsistency_Bool_Exp>;
};


export type Subscription_RootTrainingArgs = {
  distinct_on?: InputMaybe<Array<Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Order_By>>;
  where?: InputMaybe<Training_Bool_Exp>;
};


export type Subscription_RootTraining_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Order_By>>;
  where?: InputMaybe<Training_Bool_Exp>;
};


export type Subscription_RootTraining_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTraining_DocumentArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_Order_By>>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};


export type Subscription_RootTraining_Document_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_Order_By>>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};


export type Subscription_RootTraining_Document_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTraining_Document_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Training_Document_Stream_Cursor_Input>>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};


export type Subscription_RootTraining_Document_ViewArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


export type Subscription_RootTraining_Document_View_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


export type Subscription_RootTraining_Document_View_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootTraining_Document_View_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Training_Document_View_Stream_Cursor_Input>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


export type Subscription_RootTraining_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Training_Stream_Cursor_Input>>;
  where?: InputMaybe<Training_Bool_Exp>;
};


export type Subscription_RootUserArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Subscription_RootUser_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Subscription_RootUser_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Fk_AchievementArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Achievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Achievement_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Fk_Achievement_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Fk_Achievement_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


export type Subscription_RootUser_Fk_ChallengeArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Challenge_Order_By>>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Challenge_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Challenge_Order_By>>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Challenge_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Fk_Challenge_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Fk_Challenge_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};


export type Subscription_RootUser_Fk_LevelArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Level_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Level_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Fk_Level_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Fk_Level_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


export type Subscription_RootUser_Fk_NotificationArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Notification_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Notification_By_PkArgs = {
  notification_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Fk_Notification_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Fk_Notification_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Privacy_PolicyArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Privacy_Policy_Order_By>>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Privacy_Policy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Privacy_Policy_Order_By>>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};


export type Subscription_RootUser_Fk_Privacy_Policy_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Fk_Privacy_Policy_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Fk_Privacy_Policy_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};


export type Subscription_RootUser_Km_Points_ApprovalArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


export type Subscription_RootUser_Km_Points_Approval_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


export type Subscription_RootUser_Km_Points_Approval_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Km_Points_Approval_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Km_Points_Approval_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


export type Subscription_RootUser_KmpsArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


export type Subscription_RootUser_Kmps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


export type Subscription_RootUser_Kmps_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Kmps_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Kmps_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


export type Subscription_RootUser_ScoreArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


export type Subscription_RootUser_Score_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


export type Subscription_RootUser_Score_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Score_RankingArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


export type Subscription_RootUser_Score_Ranking_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


export type Subscription_RootUser_Score_Ranking_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Score_Ranking_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


export type Subscription_RootUser_Score_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Score_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


export type Subscription_RootUser_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Subscription_RootUser_TrainingArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};


export type Subscription_RootUser_Training_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};


export type Subscription_RootUser_Training_By_PkArgs = {
  training_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Training_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Training_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};


export type Subscription_RootVehicleArgs = {
  distinct_on?: InputMaybe<Array<Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicle_Order_By>>;
  where?: InputMaybe<Vehicle_Bool_Exp>;
};


export type Subscription_RootVehicle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehicle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicle_Order_By>>;
  where?: InputMaybe<Vehicle_Bool_Exp>;
};


export type Subscription_RootVehicle_By_PkArgs = {
  plate: Scalars['String']['input'];
};


export type Subscription_RootVehicle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Vehicle_Stream_Cursor_Input>>;
  where?: InputMaybe<Vehicle_Bool_Exp>;
};


export type Subscription_RootWhatsapp_EventArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Event_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Event_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootWhatsapp_Event_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Whatsapp_Event_Stream_Cursor_Input>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


export type Subscription_RootWhatsapp_MessageArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Message_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Message_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootWhatsapp_Message_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_History_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Message_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_History_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Message_History_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootWhatsapp_Message_History_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Whatsapp_Message_History_Stream_Cursor_Input>>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Message_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Whatsapp_Message_Stream_Cursor_Input>>;
  where?: InputMaybe<Whatsapp_Message_Bool_Exp>;
};


export type Subscription_RootWhatsapp_TriggerArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Trigger_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Trigger_Order_By>>;
  where?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Trigger_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Trigger_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Trigger_Order_By>>;
  where?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
};


export type Subscription_RootWhatsapp_Trigger_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootWhatsapp_Trigger_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Whatsapp_Trigger_Stream_Cursor_Input>>;
  where?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** columns and relationships of "tire" */
export type Tire = {
  __typename?: 'tire';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['smallint']['output']>;
  band: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  dimension: Maybe<Scalars['String']['output']>;
  ibor_tire: Maybe<CurrentTiresByVehicle>;
  id: Scalars['String']['output'];
  identifier: Scalars['String']['output'];
  /** An array relationship */
  inspection_fk_tires: Array<Inspection_Fk_Tire>;
  /** An aggregate relationship */
  inspection_fk_tires_aggregate: Inspection_Fk_Tire_Aggregate;
  life: Scalars['String']['output'];
  /** An array relationship */
  notes: Array<Note>;
  /** An aggregate relationship */
  notes_aggregate: Note_Aggregate;
  optimal_pressure: Maybe<Scalars['Int']['output']>;
  /** The position which the tire is located (external/internal - E/I) */
  position: Maybe<Scalars['bpchar']['output']>;
  /** The side which the tire is located (left/right - E/D) */
  side: Maybe<Scalars['bpchar']['output']>;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "tire" */
export type TireInspection_Fk_TiresArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


/** columns and relationships of "tire" */
export type TireInspection_Fk_Tires_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
};


/** columns and relationships of "tire" */
export type TireNotesArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};


/** columns and relationships of "tire" */
export type TireNotes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Note_Order_By>>;
  where?: InputMaybe<Note_Bool_Exp>;
};

/** aggregated selection of "tire" */
export type Tire_Aggregate = {
  __typename?: 'tire_aggregate';
  aggregate: Maybe<Tire_Aggregate_Fields>;
  nodes: Array<Tire>;
};

/** aggregate fields of "tire" */
export type Tire_Aggregate_Fields = {
  __typename?: 'tire_aggregate_fields';
  avg: Maybe<Tire_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Max_Fields>;
  min: Maybe<Tire_Min_Fields>;
  stddev: Maybe<Tire_Stddev_Fields>;
  stddev_pop: Maybe<Tire_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Tire_Stddev_Samp_Fields>;
  sum: Maybe<Tire_Sum_Fields>;
  var_pop: Maybe<Tire_Var_Pop_Fields>;
  var_samp: Maybe<Tire_Var_Samp_Fields>;
  variance: Maybe<Tire_Variance_Fields>;
};


/** aggregate fields of "tire" */
export type Tire_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Tire_Avg_Fields = {
  __typename?: 'tire_avg_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  optimal_pressure: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "tire". All fields are combined with a logical 'AND'. */
export type Tire_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Bool_Exp>>;
  _not?: InputMaybe<Tire_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Bool_Exp>>;
  axis?: InputMaybe<Smallint_Comparison_Exp>;
  band?: InputMaybe<String_Comparison_Exp>;
  brand_name?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  dimension?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  identifier?: InputMaybe<String_Comparison_Exp>;
  inspection_fk_tires?: InputMaybe<Inspection_Fk_Tire_Bool_Exp>;
  inspection_fk_tires_aggregate?: InputMaybe<Inspection_Fk_Tire_Aggregate_Bool_Exp>;
  life?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<Note_Bool_Exp>;
  notes_aggregate?: InputMaybe<Note_Aggregate_Bool_Exp>;
  optimal_pressure?: InputMaybe<Int_Comparison_Exp>;
  position?: InputMaybe<Bpchar_Comparison_Exp>;
  side?: InputMaybe<Bpchar_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire" */
export enum Tire_Constraint {
  /** unique or primary key constraint on columns "id" */
  TirePkey = 'tire_pkey'
}

/** input type for incrementing numeric columns in table "tire" */
export type Tire_Inc_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['smallint']['input']>;
  optimal_pressure?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "tire" */
export type Tire_Insert_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['smallint']['input']>;
  band?: InputMaybe<Scalars['String']['input']>;
  brand_name?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  dimension?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  inspection_fk_tires?: InputMaybe<Inspection_Fk_Tire_Arr_Rel_Insert_Input>;
  life?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Note_Arr_Rel_Insert_Input>;
  optimal_pressure?: InputMaybe<Scalars['Int']['input']>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Scalars['bpchar']['input']>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Scalars['bpchar']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "tire.inspection" */
export type Tire_Inspection = {
  __typename?: 'tire_inspection';
  created_at: Scalars['timestamptz']['output'];
  ended_at: Scalars['timestamptz']['output'];
  exported: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['String']['output'];
  /** An array relationship */
  inspection_fk_tires: Array<Tire_Inspection_Fk_Tire>;
  /** An aggregate relationship */
  inspection_fk_tires_aggregate: Tire_Inspection_Fk_Tire_Aggregate;
  /** An object relationship */
  inspection_origin: Tire_Inspection_Origin;
  only_null_tire_pressure: Maybe<Scalars['Boolean']['output']>;
  origin: Scalars['String']['output'];
  started_at: Scalars['timestamptz']['output'];
  updated_at: Scalars['timestamptz']['output'];
  user_name: Scalars['String']['output'];
  user_uuid: Scalars['uuid']['output'];
  vehicle_km: Maybe<Scalars['Int']['output']>;
  vehicle_km_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_plate: Scalars['String']['output'];
};


/** columns and relationships of "tire.inspection" */
export type Tire_InspectionInspection_Fk_TiresArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};


/** columns and relationships of "tire.inspection" */
export type Tire_InspectionInspection_Fk_Tires_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};

/** aggregated selection of "tire.inspection" */
export type Tire_Inspection_Aggregate = {
  __typename?: 'tire_inspection_aggregate';
  aggregate: Maybe<Tire_Inspection_Aggregate_Fields>;
  nodes: Array<Tire_Inspection>;
};

export type Tire_Inspection_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Tire_Inspection_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Tire_Inspection_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Tire_Inspection_Aggregate_Bool_Exp_Count>;
};

export type Tire_Inspection_Aggregate_Bool_Exp_Bool_And = {
  arguments: Tire_Inspection_Select_Column_Tire_Inspection_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tire_Inspection_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Tire_Inspection_Select_Column_Tire_Inspection_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tire_Inspection_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tire.inspection" */
export type Tire_Inspection_Aggregate_Fields = {
  __typename?: 'tire_inspection_aggregate_fields';
  avg: Maybe<Tire_Inspection_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Inspection_Max_Fields>;
  min: Maybe<Tire_Inspection_Min_Fields>;
  stddev: Maybe<Tire_Inspection_Stddev_Fields>;
  stddev_pop: Maybe<Tire_Inspection_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Tire_Inspection_Stddev_Samp_Fields>;
  sum: Maybe<Tire_Inspection_Sum_Fields>;
  var_pop: Maybe<Tire_Inspection_Var_Pop_Fields>;
  var_samp: Maybe<Tire_Inspection_Var_Samp_Fields>;
  variance: Maybe<Tire_Inspection_Variance_Fields>;
};


/** aggregate fields of "tire.inspection" */
export type Tire_Inspection_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "tire.inspection" */
export type Tire_Inspection_Aggregate_Order_By = {
  avg?: InputMaybe<Tire_Inspection_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Tire_Inspection_Max_Order_By>;
  min?: InputMaybe<Tire_Inspection_Min_Order_By>;
  stddev?: InputMaybe<Tire_Inspection_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Tire_Inspection_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Tire_Inspection_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Tire_Inspection_Sum_Order_By>;
  var_pop?: InputMaybe<Tire_Inspection_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Tire_Inspection_Var_Samp_Order_By>;
  variance?: InputMaybe<Tire_Inspection_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "tire.inspection" */
export type Tire_Inspection_Arr_Rel_Insert_Input = {
  data: Array<Tire_Inspection_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_On_Conflict>;
};

/** aggregate avg on columns */
export type Tire_Inspection_Avg_Fields = {
  __typename?: 'tire_inspection_avg_fields';
  vehicle_km: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "tire.inspection" */
export type Tire_Inspection_Avg_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tire.inspection". All fields are combined with a logical 'AND'. */
export type Tire_Inspection_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Inspection_Bool_Exp>>;
  _not?: InputMaybe<Tire_Inspection_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Inspection_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  ended_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  exported?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  inspection_fk_tires?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  inspection_fk_tires_aggregate?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp>;
  inspection_origin?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
  only_null_tire_pressure?: InputMaybe<Boolean_Comparison_Exp>;
  origin?: InputMaybe<String_Comparison_Exp>;
  started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_name?: InputMaybe<String_Comparison_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  vehicle_km?: InputMaybe<Int_Comparison_Exp>;
  vehicle_km_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vehicle_plate?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire.inspection" */
export enum Tire_Inspection_Constraint {
  /** unique or primary key constraint on columns "id" */
  InspectionPkey = 'inspection_pkey'
}

/** columns and relationships of "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire = {
  __typename?: 'tire_inspection_fk_tire';
  created_at: Scalars['timestamptz']['output'];
  depth_1: Maybe<Scalars['float8']['output']>;
  depth_2: Maybe<Scalars['float8']['output']>;
  depth_3: Maybe<Scalars['float8']['output']>;
  /** Fire number that was read during inspection */
  fire_number: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  inspection: Tire_Inspection;
  inspection_id: Scalars['String']['output'];
  /** An array relationship */
  inspection_notes: Array<Tire_Inspection_Note>;
  /** An aggregate relationship */
  inspection_notes_aggregate: Tire_Inspection_Note_Aggregate;
  life: Scalars['String']['output'];
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id: Scalars['String']['output'];
  tire_identifier: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_TireInspection_NotesArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};


/** columns and relationships of "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_TireInspection_Notes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};

/** aggregated selection of "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Aggregate = {
  __typename?: 'tire_inspection_fk_tire_aggregate';
  aggregate: Maybe<Tire_Inspection_Fk_Tire_Aggregate_Fields>;
  nodes: Array<Tire_Inspection_Fk_Tire>;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp = {
  avg?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp>;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg = {
  arguments: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr = {
  arguments: Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Max = {
  arguments: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Min = {
  arguments: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum = {
  arguments: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Aggregate_Fields = {
  __typename?: 'tire_inspection_fk_tire_aggregate_fields';
  avg: Maybe<Tire_Inspection_Fk_Tire_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Inspection_Fk_Tire_Max_Fields>;
  min: Maybe<Tire_Inspection_Fk_Tire_Min_Fields>;
  stddev: Maybe<Tire_Inspection_Fk_Tire_Stddev_Fields>;
  stddev_pop: Maybe<Tire_Inspection_Fk_Tire_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Tire_Inspection_Fk_Tire_Stddev_Samp_Fields>;
  sum: Maybe<Tire_Inspection_Fk_Tire_Sum_Fields>;
  var_pop: Maybe<Tire_Inspection_Fk_Tire_Var_Pop_Fields>;
  var_samp: Maybe<Tire_Inspection_Fk_Tire_Var_Samp_Fields>;
  variance: Maybe<Tire_Inspection_Fk_Tire_Variance_Fields>;
};


/** aggregate fields of "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Aggregate_Order_By = {
  avg?: InputMaybe<Tire_Inspection_Fk_Tire_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Tire_Inspection_Fk_Tire_Max_Order_By>;
  min?: InputMaybe<Tire_Inspection_Fk_Tire_Min_Order_By>;
  stddev?: InputMaybe<Tire_Inspection_Fk_Tire_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Tire_Inspection_Fk_Tire_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Tire_Inspection_Fk_Tire_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Tire_Inspection_Fk_Tire_Sum_Order_By>;
  var_pop?: InputMaybe<Tire_Inspection_Fk_Tire_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Tire_Inspection_Fk_Tire_Var_Samp_Order_By>;
  variance?: InputMaybe<Tire_Inspection_Fk_Tire_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Arr_Rel_Insert_Input = {
  data: Array<Tire_Inspection_Fk_Tire_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_Fk_Tire_On_Conflict>;
};

/** aggregate avg on columns */
export type Tire_Inspection_Fk_Tire_Avg_Fields = {
  __typename?: 'tire_inspection_fk_tire_avg_fields';
  depth_1: Maybe<Scalars['Float']['output']>;
  depth_2: Maybe<Scalars['Float']['output']>;
  depth_3: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Avg_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tire.inspection_fk_tire". All fields are combined with a logical 'AND'. */
export type Tire_Inspection_Fk_Tire_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Bool_Exp>>;
  _not?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Inspection_Fk_Tire_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  depth_1?: InputMaybe<Float8_Comparison_Exp>;
  depth_2?: InputMaybe<Float8_Comparison_Exp>;
  depth_3?: InputMaybe<Float8_Comparison_Exp>;
  fire_number?: InputMaybe<String_Comparison_Exp>;
  inspection?: InputMaybe<Tire_Inspection_Bool_Exp>;
  inspection_id?: InputMaybe<String_Comparison_Exp>;
  inspection_notes?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
  inspection_notes_aggregate?: InputMaybe<Tire_Inspection_Note_Aggregate_Bool_Exp>;
  life?: InputMaybe<String_Comparison_Exp>;
  maximum_depth?: InputMaybe<Float8_Comparison_Exp>;
  minimum_depth?: InputMaybe<Float8_Comparison_Exp>;
  pressure?: InputMaybe<Int_Comparison_Exp>;
  tire_id?: InputMaybe<String_Comparison_Exp>;
  tire_identifier?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  InspectionFkTirePkey = 'inspection_fk_tire_pkey',
  /** unique or primary key constraint on columns "uuid" */
  InspectionFkTireUuidKey = 'inspection_fk_tire_uuid_key'
}

/** input type for incrementing numeric columns in table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Inc_Input = {
  depth_1?: InputMaybe<Scalars['float8']['input']>;
  depth_2?: InputMaybe<Scalars['float8']['input']>;
  depth_3?: InputMaybe<Scalars['float8']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  depth_1?: InputMaybe<Scalars['float8']['input']>;
  depth_2?: InputMaybe<Scalars['float8']['input']>;
  depth_3?: InputMaybe<Scalars['float8']['input']>;
  /** Fire number that was read during inspection */
  fire_number?: InputMaybe<Scalars['String']['input']>;
  inspection?: InputMaybe<Tire_Inspection_Obj_Rel_Insert_Input>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  inspection_notes?: InputMaybe<Tire_Inspection_Note_Arr_Rel_Insert_Input>;
  life?: InputMaybe<Scalars['String']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Tire_Inspection_Fk_Tire_Max_Fields = {
  __typename?: 'tire_inspection_fk_tire_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  depth_1: Maybe<Scalars['float8']['output']>;
  depth_2: Maybe<Scalars['float8']['output']>;
  depth_3: Maybe<Scalars['float8']['output']>;
  /** Fire number that was read during inspection */
  fire_number: Maybe<Scalars['String']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  life: Maybe<Scalars['String']['output']>;
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  /** Fire number that was read during inspection */
  fire_number?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  life?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Tire_Inspection_Fk_Tire_Min_Fields = {
  __typename?: 'tire_inspection_fk_tire_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  depth_1: Maybe<Scalars['float8']['output']>;
  depth_2: Maybe<Scalars['float8']['output']>;
  depth_3: Maybe<Scalars['float8']['output']>;
  /** Fire number that was read during inspection */
  fire_number: Maybe<Scalars['String']['output']>;
  inspection_id: Maybe<Scalars['String']['output']>;
  life: Maybe<Scalars['String']['output']>;
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id: Maybe<Scalars['String']['output']>;
  tire_identifier: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  /** Fire number that was read during inspection */
  fire_number?: InputMaybe<Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  life?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Mutation_Response = {
  __typename?: 'tire_inspection_fk_tire_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Inspection_Fk_Tire>;
};

/** input type for inserting object relation for remote table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Obj_Rel_Insert_Input = {
  data: Tire_Inspection_Fk_Tire_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_Fk_Tire_On_Conflict>;
};

/** on_conflict condition type for table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_On_Conflict = {
  constraint: Tire_Inspection_Fk_Tire_Constraint;
  update_columns?: Array<Tire_Inspection_Fk_Tire_Update_Column>;
  where?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
};

/** Ordering options when selecting data from "tire.inspection_fk_tire". */
export type Tire_Inspection_Fk_Tire_Order_By = {
  created_at?: InputMaybe<Order_By>;
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  fire_number?: InputMaybe<Order_By>;
  inspection?: InputMaybe<Tire_Inspection_Order_By>;
  inspection_id?: InputMaybe<Order_By>;
  inspection_notes_aggregate?: InputMaybe<Tire_Inspection_Note_Aggregate_Order_By>;
  life?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
  tire_id?: InputMaybe<Order_By>;
  tire_identifier?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tire.inspection_fk_tire */
export type Tire_Inspection_Fk_Tire_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  FireNumber = 'fire_number',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  Life = 'life',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth',
  /** column name */
  Pressure = 'pressure',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_avg_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_corr_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_max_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_min_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_sum_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** select "tire_inspection_fk_tire_aggregate_bool_exp_var_samp_arguments_columns" columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Select_Column_Tire_Inspection_Fk_Tire_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth'
}

/** input type for updating data in table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  depth_1?: InputMaybe<Scalars['float8']['input']>;
  depth_2?: InputMaybe<Scalars['float8']['input']>;
  depth_3?: InputMaybe<Scalars['float8']['input']>;
  /** Fire number that was read during inspection */
  fire_number?: InputMaybe<Scalars['String']['input']>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  life?: InputMaybe<Scalars['String']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Tire_Inspection_Fk_Tire_Stddev_Fields = {
  __typename?: 'tire_inspection_fk_tire_stddev_fields';
  depth_1: Maybe<Scalars['Float']['output']>;
  depth_2: Maybe<Scalars['Float']['output']>;
  depth_3: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Stddev_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tire_Inspection_Fk_Tire_Stddev_Pop_Fields = {
  __typename?: 'tire_inspection_fk_tire_stddev_pop_fields';
  depth_1: Maybe<Scalars['Float']['output']>;
  depth_2: Maybe<Scalars['Float']['output']>;
  depth_3: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Stddev_Pop_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tire_Inspection_Fk_Tire_Stddev_Samp_Fields = {
  __typename?: 'tire_inspection_fk_tire_stddev_samp_fields';
  depth_1: Maybe<Scalars['Float']['output']>;
  depth_2: Maybe<Scalars['Float']['output']>;
  depth_3: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Stddev_Samp_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "tire_inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Inspection_Fk_Tire_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Inspection_Fk_Tire_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  depth_1?: InputMaybe<Scalars['float8']['input']>;
  depth_2?: InputMaybe<Scalars['float8']['input']>;
  depth_3?: InputMaybe<Scalars['float8']['input']>;
  /** Fire number that was read during inspection */
  fire_number?: InputMaybe<Scalars['String']['input']>;
  inspection_id?: InputMaybe<Scalars['String']['input']>;
  life?: InputMaybe<Scalars['String']['input']>;
  maximum_depth?: InputMaybe<Scalars['float8']['input']>;
  minimum_depth?: InputMaybe<Scalars['float8']['input']>;
  pressure?: InputMaybe<Scalars['Int']['input']>;
  /** Fire number indicated at Protheus database during inspection */
  tire_id?: InputMaybe<Scalars['String']['input']>;
  tire_identifier?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Tire_Inspection_Fk_Tire_Sum_Fields = {
  __typename?: 'tire_inspection_fk_tire_sum_fields';
  depth_1: Maybe<Scalars['float8']['output']>;
  depth_2: Maybe<Scalars['float8']['output']>;
  depth_3: Maybe<Scalars['float8']['output']>;
  maximum_depth: Maybe<Scalars['float8']['output']>;
  minimum_depth: Maybe<Scalars['float8']['output']>;
  pressure: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Sum_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** update columns of table "tire.inspection_fk_tire" */
export enum Tire_Inspection_Fk_Tire_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Depth_1 = 'depth_1',
  /** column name */
  Depth_2 = 'depth_2',
  /** column name */
  Depth_3 = 'depth_3',
  /** column name */
  FireNumber = 'fire_number',
  /** column name */
  InspectionId = 'inspection_id',
  /** column name */
  Life = 'life',
  /** column name */
  MaximumDepth = 'maximum_depth',
  /** column name */
  MinimumDepth = 'minimum_depth',
  /** column name */
  Pressure = 'pressure',
  /** column name */
  TireId = 'tire_id',
  /** column name */
  TireIdentifier = 'tire_identifier',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Tire_Inspection_Fk_Tire_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Tire_Inspection_Fk_Tire_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Inspection_Fk_Tire_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Inspection_Fk_Tire_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tire_Inspection_Fk_Tire_Var_Pop_Fields = {
  __typename?: 'tire_inspection_fk_tire_var_pop_fields';
  depth_1: Maybe<Scalars['Float']['output']>;
  depth_2: Maybe<Scalars['Float']['output']>;
  depth_3: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Var_Pop_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tire_Inspection_Fk_Tire_Var_Samp_Fields = {
  __typename?: 'tire_inspection_fk_tire_var_samp_fields';
  depth_1: Maybe<Scalars['Float']['output']>;
  depth_2: Maybe<Scalars['Float']['output']>;
  depth_3: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Var_Samp_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Tire_Inspection_Fk_Tire_Variance_Fields = {
  __typename?: 'tire_inspection_fk_tire_variance_fields';
  depth_1: Maybe<Scalars['Float']['output']>;
  depth_2: Maybe<Scalars['Float']['output']>;
  depth_3: Maybe<Scalars['Float']['output']>;
  maximum_depth: Maybe<Scalars['Float']['output']>;
  minimum_depth: Maybe<Scalars['Float']['output']>;
  pressure: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "tire.inspection_fk_tire" */
export type Tire_Inspection_Fk_Tire_Variance_Order_By = {
  depth_1?: InputMaybe<Order_By>;
  depth_2?: InputMaybe<Order_By>;
  depth_3?: InputMaybe<Order_By>;
  maximum_depth?: InputMaybe<Order_By>;
  minimum_depth?: InputMaybe<Order_By>;
  pressure?: InputMaybe<Order_By>;
};

/** input type for incrementing numeric columns in table "tire.inspection" */
export type Tire_Inspection_Inc_Input = {
  vehicle_km?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "tire.inspection" */
export type Tire_Inspection_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ended_at?: InputMaybe<Scalars['timestamptz']['input']>;
  exported?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inspection_fk_tires?: InputMaybe<Tire_Inspection_Fk_Tire_Arr_Rel_Insert_Input>;
  inspection_origin?: InputMaybe<Tire_Inspection_Origin_Obj_Rel_Insert_Input>;
  only_null_tire_pressure?: InputMaybe<Scalars['Boolean']['input']>;
  origin?: InputMaybe<Scalars['String']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_name?: InputMaybe<Scalars['String']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  vehicle_km?: InputMaybe<Scalars['Int']['input']>;
  vehicle_km_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Tire_Inspection_Max_Fields = {
  __typename?: 'tire_inspection_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  ended_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['String']['output']>;
  origin: Maybe<Scalars['String']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_name: Maybe<Scalars['String']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  vehicle_km: Maybe<Scalars['Int']['output']>;
  vehicle_km_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "tire.inspection" */
export type Tire_Inspection_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  ended_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  origin?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_name?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  vehicle_km?: InputMaybe<Order_By>;
  vehicle_km_at?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Tire_Inspection_Min_Fields = {
  __typename?: 'tire_inspection_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  ended_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['String']['output']>;
  origin: Maybe<Scalars['String']['output']>;
  started_at: Maybe<Scalars['timestamptz']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_name: Maybe<Scalars['String']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  vehicle_km: Maybe<Scalars['Int']['output']>;
  vehicle_km_at: Maybe<Scalars['timestamptz']['output']>;
  vehicle_plate: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "tire.inspection" */
export type Tire_Inspection_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  ended_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  origin?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_name?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  vehicle_km?: InputMaybe<Order_By>;
  vehicle_km_at?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "tire.inspection" */
export type Tire_Inspection_Mutation_Response = {
  __typename?: 'tire_inspection_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Inspection>;
};

/** columns and relationships of "tire.inspection_note" */
export type Tire_Inspection_Note = {
  __typename?: 'tire_inspection_note';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  inspection_fk_tire: Tire_Inspection_Fk_Tire;
  inspection_fk_tire_uuid: Scalars['uuid']['output'];
  /** An array relationship */
  inspection_note_attachments: Array<Tire_Inspection_Note_Attachment>;
  /** An aggregate relationship */
  inspection_note_attachments_aggregate: Tire_Inspection_Note_Attachment_Aggregate;
  /** An object relationship */
  note_type: Tire_Note_Type;
  note_type_uuid: Scalars['uuid']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "tire.inspection_note" */
export type Tire_Inspection_NoteInspection_Note_AttachmentsArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};


/** columns and relationships of "tire.inspection_note" */
export type Tire_Inspection_NoteInspection_Note_Attachments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};

/** aggregated selection of "tire.inspection_note" */
export type Tire_Inspection_Note_Aggregate = {
  __typename?: 'tire_inspection_note_aggregate';
  aggregate: Maybe<Tire_Inspection_Note_Aggregate_Fields>;
  nodes: Array<Tire_Inspection_Note>;
};

export type Tire_Inspection_Note_Aggregate_Bool_Exp = {
  count?: InputMaybe<Tire_Inspection_Note_Aggregate_Bool_Exp_Count>;
};

export type Tire_Inspection_Note_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tire.inspection_note" */
export type Tire_Inspection_Note_Aggregate_Fields = {
  __typename?: 'tire_inspection_note_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Inspection_Note_Max_Fields>;
  min: Maybe<Tire_Inspection_Note_Min_Fields>;
};


/** aggregate fields of "tire.inspection_note" */
export type Tire_Inspection_Note_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "tire.inspection_note" */
export type Tire_Inspection_Note_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Tire_Inspection_Note_Max_Order_By>;
  min?: InputMaybe<Tire_Inspection_Note_Min_Order_By>;
};

/** input type for inserting array relation for remote table "tire.inspection_note" */
export type Tire_Inspection_Note_Arr_Rel_Insert_Input = {
  data: Array<Tire_Inspection_Note_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_Note_On_Conflict>;
};

/** columns and relationships of "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment = {
  __typename?: 'tire_inspection_note_attachment';
  created_at: Scalars['timestamptz']['output'];
  file_url: Scalars['String']['output'];
  /** An object relationship */
  inspection_note: Tire_Inspection_Note;
  inspection_note_uuid: Scalars['uuid']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Aggregate = {
  __typename?: 'tire_inspection_note_attachment_aggregate';
  aggregate: Maybe<Tire_Inspection_Note_Attachment_Aggregate_Fields>;
  nodes: Array<Tire_Inspection_Note_Attachment>;
};

export type Tire_Inspection_Note_Attachment_Aggregate_Bool_Exp = {
  count?: InputMaybe<Tire_Inspection_Note_Attachment_Aggregate_Bool_Exp_Count>;
};

export type Tire_Inspection_Note_Attachment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Aggregate_Fields = {
  __typename?: 'tire_inspection_note_attachment_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Inspection_Note_Attachment_Max_Fields>;
  min: Maybe<Tire_Inspection_Note_Attachment_Min_Fields>;
};


/** aggregate fields of "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Tire_Inspection_Note_Attachment_Max_Order_By>;
  min?: InputMaybe<Tire_Inspection_Note_Attachment_Min_Order_By>;
};

/** input type for inserting array relation for remote table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Arr_Rel_Insert_Input = {
  data: Array<Tire_Inspection_Note_Attachment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_Note_Attachment_On_Conflict>;
};

/** Boolean expression to filter rows from the table "tire.inspection_note_attachment". All fields are combined with a logical 'AND'. */
export type Tire_Inspection_Note_Attachment_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Bool_Exp>>;
  _not?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Inspection_Note_Attachment_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  file_url?: InputMaybe<String_Comparison_Exp>;
  inspection_note?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
  inspection_note_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire.inspection_note_attachment" */
export enum Tire_Inspection_Note_Attachment_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  InspectionNoteAttachmentPkey = 'inspection_note_attachment_pkey'
}

/** input type for inserting data into table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  file_url?: InputMaybe<Scalars['String']['input']>;
  inspection_note?: InputMaybe<Tire_Inspection_Note_Obj_Rel_Insert_Input>;
  inspection_note_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Tire_Inspection_Note_Attachment_Max_Fields = {
  __typename?: 'tire_inspection_note_attachment_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  file_url: Maybe<Scalars['String']['output']>;
  inspection_note_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  file_url?: InputMaybe<Order_By>;
  inspection_note_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Tire_Inspection_Note_Attachment_Min_Fields = {
  __typename?: 'tire_inspection_note_attachment_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  file_url: Maybe<Scalars['String']['output']>;
  inspection_note_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  file_url?: InputMaybe<Order_By>;
  inspection_note_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Mutation_Response = {
  __typename?: 'tire_inspection_note_attachment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Inspection_Note_Attachment>;
};

/** on_conflict condition type for table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_On_Conflict = {
  constraint: Tire_Inspection_Note_Attachment_Constraint;
  update_columns?: Array<Tire_Inspection_Note_Attachment_Update_Column>;
  where?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
};

/** Ordering options when selecting data from "tire.inspection_note_attachment". */
export type Tire_Inspection_Note_Attachment_Order_By = {
  created_at?: InputMaybe<Order_By>;
  file_url?: InputMaybe<Order_By>;
  inspection_note?: InputMaybe<Tire_Inspection_Note_Order_By>;
  inspection_note_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tire.inspection_note_attachment */
export type Tire_Inspection_Note_Attachment_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "tire.inspection_note_attachment" */
export enum Tire_Inspection_Note_Attachment_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FileUrl = 'file_url',
  /** column name */
  InspectionNoteUuid = 'inspection_note_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "tire.inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  file_url?: InputMaybe<Scalars['String']['input']>;
  inspection_note_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "tire_inspection_note_attachment" */
export type Tire_Inspection_Note_Attachment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Inspection_Note_Attachment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Inspection_Note_Attachment_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  file_url?: InputMaybe<Scalars['String']['input']>;
  inspection_note_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "tire.inspection_note_attachment" */
export enum Tire_Inspection_Note_Attachment_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FileUrl = 'file_url',
  /** column name */
  InspectionNoteUuid = 'inspection_note_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Tire_Inspection_Note_Attachment_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Inspection_Note_Attachment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Inspection_Note_Attachment_Bool_Exp;
};

/** Boolean expression to filter rows from the table "tire.inspection_note". All fields are combined with a logical 'AND'. */
export type Tire_Inspection_Note_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Inspection_Note_Bool_Exp>>;
  _not?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Inspection_Note_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  inspection_fk_tire?: InputMaybe<Tire_Inspection_Fk_Tire_Bool_Exp>;
  inspection_fk_tire_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  inspection_note_attachments?: InputMaybe<Tire_Inspection_Note_Attachment_Bool_Exp>;
  inspection_note_attachments_aggregate?: InputMaybe<Tire_Inspection_Note_Attachment_Aggregate_Bool_Exp>;
  note_type?: InputMaybe<Tire_Note_Type_Bool_Exp>;
  note_type_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire.inspection_note" */
export enum Tire_Inspection_Note_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  InspectionNotePkey = 'inspection_note_pkey'
}

/** input type for inserting data into table "tire.inspection_note" */
export type Tire_Inspection_Note_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  inspection_fk_tire?: InputMaybe<Tire_Inspection_Fk_Tire_Obj_Rel_Insert_Input>;
  inspection_fk_tire_uuid?: InputMaybe<Scalars['uuid']['input']>;
  inspection_note_attachments?: InputMaybe<Tire_Inspection_Note_Attachment_Arr_Rel_Insert_Input>;
  note_type?: InputMaybe<Tire_Note_Type_Obj_Rel_Insert_Input>;
  note_type_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Tire_Inspection_Note_Max_Fields = {
  __typename?: 'tire_inspection_note_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  inspection_fk_tire_uuid: Maybe<Scalars['uuid']['output']>;
  note_type_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "tire.inspection_note" */
export type Tire_Inspection_Note_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  inspection_fk_tire_uuid?: InputMaybe<Order_By>;
  note_type_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Tire_Inspection_Note_Min_Fields = {
  __typename?: 'tire_inspection_note_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  inspection_fk_tire_uuid: Maybe<Scalars['uuid']['output']>;
  note_type_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "tire.inspection_note" */
export type Tire_Inspection_Note_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  inspection_fk_tire_uuid?: InputMaybe<Order_By>;
  note_type_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "tire.inspection_note" */
export type Tire_Inspection_Note_Mutation_Response = {
  __typename?: 'tire_inspection_note_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Inspection_Note>;
};

/** input type for inserting object relation for remote table "tire.inspection_note" */
export type Tire_Inspection_Note_Obj_Rel_Insert_Input = {
  data: Tire_Inspection_Note_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_Note_On_Conflict>;
};

/** on_conflict condition type for table "tire.inspection_note" */
export type Tire_Inspection_Note_On_Conflict = {
  constraint: Tire_Inspection_Note_Constraint;
  update_columns?: Array<Tire_Inspection_Note_Update_Column>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};

/** Ordering options when selecting data from "tire.inspection_note". */
export type Tire_Inspection_Note_Order_By = {
  created_at?: InputMaybe<Order_By>;
  inspection_fk_tire?: InputMaybe<Tire_Inspection_Fk_Tire_Order_By>;
  inspection_fk_tire_uuid?: InputMaybe<Order_By>;
  inspection_note_attachments_aggregate?: InputMaybe<Tire_Inspection_Note_Attachment_Aggregate_Order_By>;
  note_type?: InputMaybe<Tire_Note_Type_Order_By>;
  note_type_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tire.inspection_note */
export type Tire_Inspection_Note_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "tire.inspection_note" */
export enum Tire_Inspection_Note_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InspectionFkTireUuid = 'inspection_fk_tire_uuid',
  /** column name */
  NoteTypeUuid = 'note_type_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "tire.inspection_note" */
export type Tire_Inspection_Note_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  inspection_fk_tire_uuid?: InputMaybe<Scalars['uuid']['input']>;
  note_type_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "tire_inspection_note" */
export type Tire_Inspection_Note_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Inspection_Note_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Inspection_Note_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  inspection_fk_tire_uuid?: InputMaybe<Scalars['uuid']['input']>;
  note_type_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "tire.inspection_note" */
export enum Tire_Inspection_Note_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InspectionFkTireUuid = 'inspection_fk_tire_uuid',
  /** column name */
  NoteTypeUuid = 'note_type_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type Tire_Inspection_Note_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Inspection_Note_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Inspection_Note_Bool_Exp;
};

/** input type for inserting object relation for remote table "tire.inspection" */
export type Tire_Inspection_Obj_Rel_Insert_Input = {
  data: Tire_Inspection_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_On_Conflict>;
};

/** on_conflict condition type for table "tire.inspection" */
export type Tire_Inspection_On_Conflict = {
  constraint: Tire_Inspection_Constraint;
  update_columns?: Array<Tire_Inspection_Update_Column>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};

/** Ordering options when selecting data from "tire.inspection". */
export type Tire_Inspection_Order_By = {
  created_at?: InputMaybe<Order_By>;
  ended_at?: InputMaybe<Order_By>;
  exported?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inspection_fk_tires_aggregate?: InputMaybe<Tire_Inspection_Fk_Tire_Aggregate_Order_By>;
  inspection_origin?: InputMaybe<Tire_Inspection_Origin_Order_By>;
  only_null_tire_pressure?: InputMaybe<Order_By>;
  origin?: InputMaybe<Order_By>;
  started_at?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_name?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  vehicle_km?: InputMaybe<Order_By>;
  vehicle_km_at?: InputMaybe<Order_By>;
  vehicle_plate?: InputMaybe<Order_By>;
};

/** columns and relationships of "tire.inspection_origin" */
export type Tire_Inspection_Origin = {
  __typename?: 'tire_inspection_origin';
  /** An array relationship */
  inspections: Array<Tire_Inspection>;
  /** An aggregate relationship */
  inspections_aggregate: Tire_Inspection_Aggregate;
  origin: Scalars['String']['output'];
};


/** columns and relationships of "tire.inspection_origin" */
export type Tire_Inspection_OriginInspectionsArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};


/** columns and relationships of "tire.inspection_origin" */
export type Tire_Inspection_OriginInspections_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Bool_Exp>;
};

/** aggregated selection of "tire.inspection_origin" */
export type Tire_Inspection_Origin_Aggregate = {
  __typename?: 'tire_inspection_origin_aggregate';
  aggregate: Maybe<Tire_Inspection_Origin_Aggregate_Fields>;
  nodes: Array<Tire_Inspection_Origin>;
};

/** aggregate fields of "tire.inspection_origin" */
export type Tire_Inspection_Origin_Aggregate_Fields = {
  __typename?: 'tire_inspection_origin_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Inspection_Origin_Max_Fields>;
  min: Maybe<Tire_Inspection_Origin_Min_Fields>;
};


/** aggregate fields of "tire.inspection_origin" */
export type Tire_Inspection_Origin_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Inspection_Origin_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "tire.inspection_origin". All fields are combined with a logical 'AND'. */
export type Tire_Inspection_Origin_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Inspection_Origin_Bool_Exp>>;
  _not?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Inspection_Origin_Bool_Exp>>;
  inspections?: InputMaybe<Tire_Inspection_Bool_Exp>;
  inspections_aggregate?: InputMaybe<Tire_Inspection_Aggregate_Bool_Exp>;
  origin?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire.inspection_origin" */
export enum Tire_Inspection_Origin_Constraint {
  /** unique or primary key constraint on columns "origin" */
  InspectionOriginPkey = 'inspection_origin_pkey'
}

/** input type for inserting data into table "tire.inspection_origin" */
export type Tire_Inspection_Origin_Insert_Input = {
  inspections?: InputMaybe<Tire_Inspection_Arr_Rel_Insert_Input>;
  origin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Tire_Inspection_Origin_Max_Fields = {
  __typename?: 'tire_inspection_origin_max_fields';
  origin: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Tire_Inspection_Origin_Min_Fields = {
  __typename?: 'tire_inspection_origin_min_fields';
  origin: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "tire.inspection_origin" */
export type Tire_Inspection_Origin_Mutation_Response = {
  __typename?: 'tire_inspection_origin_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Inspection_Origin>;
};

/** input type for inserting object relation for remote table "tire.inspection_origin" */
export type Tire_Inspection_Origin_Obj_Rel_Insert_Input = {
  data: Tire_Inspection_Origin_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Inspection_Origin_On_Conflict>;
};

/** on_conflict condition type for table "tire.inspection_origin" */
export type Tire_Inspection_Origin_On_Conflict = {
  constraint: Tire_Inspection_Origin_Constraint;
  update_columns?: Array<Tire_Inspection_Origin_Update_Column>;
  where?: InputMaybe<Tire_Inspection_Origin_Bool_Exp>;
};

/** Ordering options when selecting data from "tire.inspection_origin". */
export type Tire_Inspection_Origin_Order_By = {
  inspections_aggregate?: InputMaybe<Tire_Inspection_Aggregate_Order_By>;
  origin?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tire.inspection_origin */
export type Tire_Inspection_Origin_Pk_Columns_Input = {
  origin: Scalars['String']['input'];
};

/** select columns of table "tire.inspection_origin" */
export enum Tire_Inspection_Origin_Select_Column {
  /** column name */
  Origin = 'origin'
}

/** input type for updating data in table "tire.inspection_origin" */
export type Tire_Inspection_Origin_Set_Input = {
  origin?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "tire_inspection_origin" */
export type Tire_Inspection_Origin_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Inspection_Origin_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Inspection_Origin_Stream_Cursor_Value_Input = {
  origin?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "tire.inspection_origin" */
export enum Tire_Inspection_Origin_Update_Column {
  /** column name */
  Origin = 'origin'
}

export type Tire_Inspection_Origin_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Inspection_Origin_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Inspection_Origin_Bool_Exp;
};

/** primary key columns input for table: tire.inspection */
export type Tire_Inspection_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "tire.inspection" */
export enum Tire_Inspection_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Exported = 'exported',
  /** column name */
  Id = 'id',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure',
  /** column name */
  Origin = 'origin',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserName = 'user_name',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  VehicleKm = 'vehicle_km',
  /** column name */
  VehicleKmAt = 'vehicle_km_at',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

/** select "tire_inspection_aggregate_bool_exp_bool_and_arguments_columns" columns of table "tire.inspection" */
export enum Tire_Inspection_Select_Column_Tire_Inspection_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Exported = 'exported',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure'
}

/** select "tire_inspection_aggregate_bool_exp_bool_or_arguments_columns" columns of table "tire.inspection" */
export enum Tire_Inspection_Select_Column_Tire_Inspection_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Exported = 'exported',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure'
}

/** input type for updating data in table "tire.inspection" */
export type Tire_Inspection_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ended_at?: InputMaybe<Scalars['timestamptz']['input']>;
  exported?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  only_null_tire_pressure?: InputMaybe<Scalars['Boolean']['input']>;
  origin?: InputMaybe<Scalars['String']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_name?: InputMaybe<Scalars['String']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  vehicle_km?: InputMaybe<Scalars['Int']['input']>;
  vehicle_km_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Tire_Inspection_Stddev_Fields = {
  __typename?: 'tire_inspection_stddev_fields';
  vehicle_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "tire.inspection" */
export type Tire_Inspection_Stddev_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tire_Inspection_Stddev_Pop_Fields = {
  __typename?: 'tire_inspection_stddev_pop_fields';
  vehicle_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "tire.inspection" */
export type Tire_Inspection_Stddev_Pop_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tire_Inspection_Stddev_Samp_Fields = {
  __typename?: 'tire_inspection_stddev_samp_fields';
  vehicle_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "tire.inspection" */
export type Tire_Inspection_Stddev_Samp_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "tire_inspection" */
export type Tire_Inspection_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Inspection_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Inspection_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ended_at?: InputMaybe<Scalars['timestamptz']['input']>;
  exported?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  only_null_tire_pressure?: InputMaybe<Scalars['Boolean']['input']>;
  origin?: InputMaybe<Scalars['String']['input']>;
  started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_name?: InputMaybe<Scalars['String']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  vehicle_km?: InputMaybe<Scalars['Int']['input']>;
  vehicle_km_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_plate?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Tire_Inspection_Sum_Fields = {
  __typename?: 'tire_inspection_sum_fields';
  vehicle_km: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "tire.inspection" */
export type Tire_Inspection_Sum_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** update columns of table "tire.inspection" */
export enum Tire_Inspection_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Exported = 'exported',
  /** column name */
  Id = 'id',
  /** column name */
  OnlyNullTirePressure = 'only_null_tire_pressure',
  /** column name */
  Origin = 'origin',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserName = 'user_name',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  VehicleKm = 'vehicle_km',
  /** column name */
  VehicleKmAt = 'vehicle_km_at',
  /** column name */
  VehiclePlate = 'vehicle_plate'
}

export type Tire_Inspection_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Tire_Inspection_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Inspection_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Inspection_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tire_Inspection_Var_Pop_Fields = {
  __typename?: 'tire_inspection_var_pop_fields';
  vehicle_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "tire.inspection" */
export type Tire_Inspection_Var_Pop_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tire_Inspection_Var_Samp_Fields = {
  __typename?: 'tire_inspection_var_samp_fields';
  vehicle_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "tire.inspection" */
export type Tire_Inspection_Var_Samp_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Tire_Inspection_Variance_Fields = {
  __typename?: 'tire_inspection_variance_fields';
  vehicle_km: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "tire.inspection" */
export type Tire_Inspection_Variance_Order_By = {
  vehicle_km?: InputMaybe<Order_By>;
};

/** aggregate max on columns */
export type Tire_Max_Fields = {
  __typename?: 'tire_max_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['smallint']['output']>;
  band: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  dimension: Maybe<Scalars['String']['output']>;
  id: Maybe<Scalars['String']['output']>;
  identifier: Maybe<Scalars['String']['output']>;
  life: Maybe<Scalars['String']['output']>;
  optimal_pressure: Maybe<Scalars['Int']['output']>;
  /** The position which the tire is located (external/internal - E/I) */
  position: Maybe<Scalars['bpchar']['output']>;
  /** The side which the tire is located (left/right - E/D) */
  side: Maybe<Scalars['bpchar']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Tire_Min_Fields = {
  __typename?: 'tire_min_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['smallint']['output']>;
  band: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  dimension: Maybe<Scalars['String']['output']>;
  id: Maybe<Scalars['String']['output']>;
  identifier: Maybe<Scalars['String']['output']>;
  life: Maybe<Scalars['String']['output']>;
  optimal_pressure: Maybe<Scalars['Int']['output']>;
  /** The position which the tire is located (external/internal - E/I) */
  position: Maybe<Scalars['bpchar']['output']>;
  /** The side which the tire is located (left/right - E/D) */
  side: Maybe<Scalars['bpchar']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "tire" */
export type Tire_Mutation_Response = {
  __typename?: 'tire_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire>;
};

/** columns and relationships of "tire.note_type" */
export type Tire_Note_Type = {
  __typename?: 'tire_note_type';
  action: Scalars['String']['output'];
  description: Scalars['String']['output'];
  image_url: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  inspection_notes: Array<Tire_Inspection_Note>;
  /** An aggregate relationship */
  inspection_notes_aggregate: Tire_Inspection_Note_Aggregate;
  name: Scalars['String']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "tire.note_type" */
export type Tire_Note_TypeInspection_NotesArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};


/** columns and relationships of "tire.note_type" */
export type Tire_Note_TypeInspection_Notes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tire_Inspection_Note_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tire_Inspection_Note_Order_By>>;
  where?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
};

/** aggregated selection of "tire.note_type" */
export type Tire_Note_Type_Aggregate = {
  __typename?: 'tire_note_type_aggregate';
  aggregate: Maybe<Tire_Note_Type_Aggregate_Fields>;
  nodes: Array<Tire_Note_Type>;
};

/** aggregate fields of "tire.note_type" */
export type Tire_Note_Type_Aggregate_Fields = {
  __typename?: 'tire_note_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Note_Type_Max_Fields>;
  min: Maybe<Tire_Note_Type_Min_Fields>;
};


/** aggregate fields of "tire.note_type" */
export type Tire_Note_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Note_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "tire.note_type". All fields are combined with a logical 'AND'. */
export type Tire_Note_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Note_Type_Bool_Exp>>;
  _not?: InputMaybe<Tire_Note_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Note_Type_Bool_Exp>>;
  action?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  image_url?: InputMaybe<String_Comparison_Exp>;
  inspection_notes?: InputMaybe<Tire_Inspection_Note_Bool_Exp>;
  inspection_notes_aggregate?: InputMaybe<Tire_Inspection_Note_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire.note_type" */
export enum Tire_Note_Type_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  NoteTypePkey = 'note_type_pkey'
}

/** input type for inserting data into table "tire.note_type" */
export type Tire_Note_Type_Insert_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  inspection_notes?: InputMaybe<Tire_Inspection_Note_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Tire_Note_Type_Max_Fields = {
  __typename?: 'tire_note_type_max_fields';
  action: Maybe<Scalars['String']['output']>;
  description: Maybe<Scalars['String']['output']>;
  image_url: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Tire_Note_Type_Min_Fields = {
  __typename?: 'tire_note_type_min_fields';
  action: Maybe<Scalars['String']['output']>;
  description: Maybe<Scalars['String']['output']>;
  image_url: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "tire.note_type" */
export type Tire_Note_Type_Mutation_Response = {
  __typename?: 'tire_note_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Note_Type>;
};

/** input type for inserting object relation for remote table "tire.note_type" */
export type Tire_Note_Type_Obj_Rel_Insert_Input = {
  data: Tire_Note_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_Note_Type_On_Conflict>;
};

/** on_conflict condition type for table "tire.note_type" */
export type Tire_Note_Type_On_Conflict = {
  constraint: Tire_Note_Type_Constraint;
  update_columns?: Array<Tire_Note_Type_Update_Column>;
  where?: InputMaybe<Tire_Note_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "tire.note_type". */
export type Tire_Note_Type_Order_By = {
  action?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  image_url?: InputMaybe<Order_By>;
  inspection_notes_aggregate?: InputMaybe<Tire_Inspection_Note_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tire.note_type */
export type Tire_Note_Type_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "tire.note_type" */
export enum Tire_Note_Type_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  Description = 'description',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "tire.note_type" */
export type Tire_Note_Type_Set_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "tire_note_type" */
export type Tire_Note_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Note_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Note_Type_Stream_Cursor_Value_Input = {
  action?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  image_url?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "tire.note_type" */
export enum Tire_Note_Type_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  Description = 'description',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  Uuid = 'uuid'
}

export type Tire_Note_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Note_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Note_Type_Bool_Exp;
};

/** input type for inserting object relation for remote table "tire" */
export type Tire_Obj_Rel_Insert_Input = {
  data: Tire_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Tire_On_Conflict>;
};

/** on_conflict condition type for table "tire" */
export type Tire_On_Conflict = {
  constraint: Tire_Constraint;
  update_columns?: Array<Tire_Update_Column>;
  where?: InputMaybe<Tire_Bool_Exp>;
};

/** Ordering options when selecting data from "tire". */
export type Tire_Order_By = {
  axis?: InputMaybe<Order_By>;
  band?: InputMaybe<Order_By>;
  brand_name?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  dimension?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  identifier?: InputMaybe<Order_By>;
  inspection_fk_tires_aggregate?: InputMaybe<Inspection_Fk_Tire_Aggregate_Order_By>;
  life?: InputMaybe<Order_By>;
  notes_aggregate?: InputMaybe<Note_Aggregate_Order_By>;
  optimal_pressure?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  side?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** columns and relationships of "tire.parameter" */
export type Tire_Parameter = {
  __typename?: 'tire_parameter';
  created_at: Scalars['timestamptz']['output'];
  description: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  value: Scalars['String']['output'];
};

/** aggregated selection of "tire.parameter" */
export type Tire_Parameter_Aggregate = {
  __typename?: 'tire_parameter_aggregate';
  aggregate: Maybe<Tire_Parameter_Aggregate_Fields>;
  nodes: Array<Tire_Parameter>;
};

/** aggregate fields of "tire.parameter" */
export type Tire_Parameter_Aggregate_Fields = {
  __typename?: 'tire_parameter_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Parameter_Max_Fields>;
  min: Maybe<Tire_Parameter_Min_Fields>;
};


/** aggregate fields of "tire.parameter" */
export type Tire_Parameter_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Parameter_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "tire.parameter". All fields are combined with a logical 'AND'. */
export type Tire_Parameter_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Parameter_Bool_Exp>>;
  _not?: InputMaybe<Tire_Parameter_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Parameter_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire.parameter" */
export enum Tire_Parameter_Constraint {
  /** unique or primary key constraint on columns "name" */
  ParameterPkey = 'parameter_pkey'
}

/** input type for inserting data into table "tire.parameter" */
export type Tire_Parameter_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Tire_Parameter_Max_Fields = {
  __typename?: 'tire_parameter_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  value: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Tire_Parameter_Min_Fields = {
  __typename?: 'tire_parameter_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  value: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "tire.parameter" */
export type Tire_Parameter_Mutation_Response = {
  __typename?: 'tire_parameter_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Parameter>;
};

/** on_conflict condition type for table "tire.parameter" */
export type Tire_Parameter_On_Conflict = {
  constraint: Tire_Parameter_Constraint;
  update_columns?: Array<Tire_Parameter_Update_Column>;
  where?: InputMaybe<Tire_Parameter_Bool_Exp>;
};

/** Ordering options when selecting data from "tire.parameter". */
export type Tire_Parameter_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tire.parameter */
export type Tire_Parameter_Pk_Columns_Input = {
  name: Scalars['String']['input'];
};

/** select columns of table "tire.parameter" */
export enum Tire_Parameter_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "tire.parameter" */
export type Tire_Parameter_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "tire_parameter" */
export type Tire_Parameter_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Parameter_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Parameter_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "tire.parameter" */
export enum Tire_Parameter_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

export type Tire_Parameter_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Parameter_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Parameter_Bool_Exp;
};

/** primary key columns input for table: tire */
export type Tire_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** columns and relationships of "tire_processing_history" */
export type Tire_Processing_History = {
  __typename?: 'tire_processing_history';
  company_name: Scalars['String']['output'];
  end_at: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  processed_at: Scalars['timestamptz']['output'];
  start_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "tire_processing_history" */
export type Tire_Processing_History_Aggregate = {
  __typename?: 'tire_processing_history_aggregate';
  aggregate: Maybe<Tire_Processing_History_Aggregate_Fields>;
  nodes: Array<Tire_Processing_History>;
};

/** aggregate fields of "tire_processing_history" */
export type Tire_Processing_History_Aggregate_Fields = {
  __typename?: 'tire_processing_history_aggregate_fields';
  avg: Maybe<Tire_Processing_History_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Tire_Processing_History_Max_Fields>;
  min: Maybe<Tire_Processing_History_Min_Fields>;
  stddev: Maybe<Tire_Processing_History_Stddev_Fields>;
  stddev_pop: Maybe<Tire_Processing_History_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Tire_Processing_History_Stddev_Samp_Fields>;
  sum: Maybe<Tire_Processing_History_Sum_Fields>;
  var_pop: Maybe<Tire_Processing_History_Var_Pop_Fields>;
  var_samp: Maybe<Tire_Processing_History_Var_Samp_Fields>;
  variance: Maybe<Tire_Processing_History_Variance_Fields>;
};


/** aggregate fields of "tire_processing_history" */
export type Tire_Processing_History_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tire_Processing_History_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Tire_Processing_History_Avg_Fields = {
  __typename?: 'tire_processing_history_avg_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "tire_processing_history". All fields are combined with a logical 'AND'. */
export type Tire_Processing_History_Bool_Exp = {
  _and?: InputMaybe<Array<Tire_Processing_History_Bool_Exp>>;
  _not?: InputMaybe<Tire_Processing_History_Bool_Exp>;
  _or?: InputMaybe<Array<Tire_Processing_History_Bool_Exp>>;
  company_name?: InputMaybe<String_Comparison_Exp>;
  end_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  start_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "tire_processing_history" */
export enum Tire_Processing_History_Constraint {
  /** unique or primary key constraint on columns "id" */
  TireProcessingHistoryPkey = 'tire_processing_history_pkey'
}

/** input type for incrementing numeric columns in table "tire_processing_history" */
export type Tire_Processing_History_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "tire_processing_history" */
export type Tire_Processing_History_Insert_Input = {
  company_name?: InputMaybe<Scalars['String']['input']>;
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Tire_Processing_History_Max_Fields = {
  __typename?: 'tire_processing_history_max_fields';
  company_name: Maybe<Scalars['String']['output']>;
  end_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  start_at: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Tire_Processing_History_Min_Fields = {
  __typename?: 'tire_processing_history_min_fields';
  company_name: Maybe<Scalars['String']['output']>;
  end_at: Maybe<Scalars['timestamptz']['output']>;
  id: Maybe<Scalars['bigint']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  start_at: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "tire_processing_history" */
export type Tire_Processing_History_Mutation_Response = {
  __typename?: 'tire_processing_history_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tire_Processing_History>;
};

/** on_conflict condition type for table "tire_processing_history" */
export type Tire_Processing_History_On_Conflict = {
  constraint: Tire_Processing_History_Constraint;
  update_columns?: Array<Tire_Processing_History_Update_Column>;
  where?: InputMaybe<Tire_Processing_History_Bool_Exp>;
};

/** Ordering options when selecting data from "tire_processing_history". */
export type Tire_Processing_History_Order_By = {
  company_name?: InputMaybe<Order_By>;
  end_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  start_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tire_processing_history */
export type Tire_Processing_History_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "tire_processing_history" */
export enum Tire_Processing_History_Select_Column {
  /** column name */
  CompanyName = 'company_name',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProcessedAt = 'processed_at',
  /** column name */
  StartAt = 'start_at'
}

/** input type for updating data in table "tire_processing_history" */
export type Tire_Processing_History_Set_Input = {
  company_name?: InputMaybe<Scalars['String']['input']>;
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Tire_Processing_History_Stddev_Fields = {
  __typename?: 'tire_processing_history_stddev_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Tire_Processing_History_Stddev_Pop_Fields = {
  __typename?: 'tire_processing_history_stddev_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Tire_Processing_History_Stddev_Samp_Fields = {
  __typename?: 'tire_processing_history_stddev_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "tire_processing_history" */
export type Tire_Processing_History_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Processing_History_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Processing_History_Stream_Cursor_Value_Input = {
  company_name?: InputMaybe<Scalars['String']['input']>;
  end_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  start_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Tire_Processing_History_Sum_Fields = {
  __typename?: 'tire_processing_history_sum_fields';
  id: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "tire_processing_history" */
export enum Tire_Processing_History_Update_Column {
  /** column name */
  CompanyName = 'company_name',
  /** column name */
  EndAt = 'end_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProcessedAt = 'processed_at',
  /** column name */
  StartAt = 'start_at'
}

export type Tire_Processing_History_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Tire_Processing_History_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Processing_History_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Processing_History_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tire_Processing_History_Var_Pop_Fields = {
  __typename?: 'tire_processing_history_var_pop_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Tire_Processing_History_Var_Samp_Fields = {
  __typename?: 'tire_processing_history_var_samp_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Tire_Processing_History_Variance_Fields = {
  __typename?: 'tire_processing_history_variance_fields';
  id: Maybe<Scalars['Float']['output']>;
};

/** select columns of table "tire" */
export enum Tire_Select_Column {
  /** column name */
  Axis = 'axis',
  /** column name */
  Band = 'band',
  /** column name */
  BrandName = 'brand_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Dimension = 'dimension',
  /** column name */
  Id = 'id',
  /** column name */
  Identifier = 'identifier',
  /** column name */
  Life = 'life',
  /** column name */
  OptimalPressure = 'optimal_pressure',
  /** column name */
  Position = 'position',
  /** column name */
  Side = 'side',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "tire" */
export type Tire_Set_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['smallint']['input']>;
  band?: InputMaybe<Scalars['String']['input']>;
  brand_name?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  dimension?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  life?: InputMaybe<Scalars['String']['input']>;
  optimal_pressure?: InputMaybe<Scalars['Int']['input']>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Scalars['bpchar']['input']>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Scalars['bpchar']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Tire_Stddev_Fields = {
  __typename?: 'tire_stddev_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  optimal_pressure: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Tire_Stddev_Pop_Fields = {
  __typename?: 'tire_stddev_pop_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  optimal_pressure: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Tire_Stddev_Samp_Fields = {
  __typename?: 'tire_stddev_samp_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  optimal_pressure: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "tire" */
export type Tire_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tire_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tire_Stream_Cursor_Value_Input = {
  /** The axis where the tire is located */
  axis?: InputMaybe<Scalars['smallint']['input']>;
  band?: InputMaybe<Scalars['String']['input']>;
  brand_name?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  dimension?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  life?: InputMaybe<Scalars['String']['input']>;
  optimal_pressure?: InputMaybe<Scalars['Int']['input']>;
  /** The position which the tire is located (external/internal - E/I) */
  position?: InputMaybe<Scalars['bpchar']['input']>;
  /** The side which the tire is located (left/right - E/D) */
  side?: InputMaybe<Scalars['bpchar']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Tire_Sum_Fields = {
  __typename?: 'tire_sum_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['smallint']['output']>;
  optimal_pressure: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "tire" */
export enum Tire_Update_Column {
  /** column name */
  Axis = 'axis',
  /** column name */
  Band = 'band',
  /** column name */
  BrandName = 'brand_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Dimension = 'dimension',
  /** column name */
  Id = 'id',
  /** column name */
  Identifier = 'identifier',
  /** column name */
  Life = 'life',
  /** column name */
  OptimalPressure = 'optimal_pressure',
  /** column name */
  Position = 'position',
  /** column name */
  Side = 'side',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Tire_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Tire_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tire_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tire_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tire_Var_Pop_Fields = {
  __typename?: 'tire_var_pop_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  optimal_pressure: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Tire_Var_Samp_Fields = {
  __typename?: 'tire_var_samp_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  optimal_pressure: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Tire_Variance_Fields = {
  __typename?: 'tire_variance_fields';
  /** The axis where the tire is located */
  axis: Maybe<Scalars['Float']['output']>;
  optimal_pressure: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency = {
  __typename?: 'tirecheck_inconsistency';
  created_at: Scalars['timestamptz']['output'];
  description: Scalars['String']['output'];
  ibor_license_plate: Maybe<Scalars['String']['output']>;
  ibor_tire_id: Maybe<Scalars['String']['output']>;
  ibor_tire_identifier: Maybe<Scalars['String']['output']>;
  inspection_started_at: Maybe<Scalars['timestamptz']['output']>;
  tirecheck_license_plate: Scalars['String']['output'];
  tirecheck_tire_id: Scalars['String']['output'];
  tirecheck_tire_identifier: Scalars['String']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_Aggregate = {
  __typename?: 'tirecheck_inconsistency_aggregate';
  aggregate: Maybe<Tirecheck_Inconsistency_Aggregate_Fields>;
  nodes: Array<Tirecheck_Inconsistency>;
};

/** aggregate fields of "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_Aggregate_Fields = {
  __typename?: 'tirecheck_inconsistency_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Tirecheck_Inconsistency_Max_Fields>;
  min: Maybe<Tirecheck_Inconsistency_Min_Fields>;
};


/** aggregate fields of "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tirecheck_Inconsistency_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "tirecheck_inconsistency". All fields are combined with a logical 'AND'. */
export type Tirecheck_Inconsistency_Bool_Exp = {
  _and?: InputMaybe<Array<Tirecheck_Inconsistency_Bool_Exp>>;
  _not?: InputMaybe<Tirecheck_Inconsistency_Bool_Exp>;
  _or?: InputMaybe<Array<Tirecheck_Inconsistency_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  ibor_license_plate?: InputMaybe<String_Comparison_Exp>;
  ibor_tire_id?: InputMaybe<String_Comparison_Exp>;
  ibor_tire_identifier?: InputMaybe<String_Comparison_Exp>;
  inspection_started_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  tirecheck_license_plate?: InputMaybe<String_Comparison_Exp>;
  tirecheck_tire_id?: InputMaybe<String_Comparison_Exp>;
  tirecheck_tire_identifier?: InputMaybe<String_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "tirecheck_inconsistency" */
export enum Tirecheck_Inconsistency_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  TirecheckInconsistencyPkey = 'tirecheck_inconsistency_pkey',
  /** unique or primary key constraint on columns "tirecheck_tire_identifier", "tirecheck_license_plate", "tirecheck_tire_id" */
  TirecheckInconsistencyTirecheckLicensePlateTirecheckTKey = 'tirecheck_inconsistency_tirecheck_license_plate_tirecheck_t_key',
  /** unique or primary key constraint on columns "uuid" */
  TirecheckInconsistencyUuidKey = 'tirecheck_inconsistency_uuid_key'
}

/** input type for inserting data into table "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  ibor_license_plate?: InputMaybe<Scalars['String']['input']>;
  ibor_tire_id?: InputMaybe<Scalars['String']['input']>;
  ibor_tire_identifier?: InputMaybe<Scalars['String']['input']>;
  inspection_started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  tirecheck_license_plate?: InputMaybe<Scalars['String']['input']>;
  tirecheck_tire_id?: InputMaybe<Scalars['String']['input']>;
  tirecheck_tire_identifier?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Tirecheck_Inconsistency_Max_Fields = {
  __typename?: 'tirecheck_inconsistency_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  ibor_license_plate: Maybe<Scalars['String']['output']>;
  ibor_tire_id: Maybe<Scalars['String']['output']>;
  ibor_tire_identifier: Maybe<Scalars['String']['output']>;
  inspection_started_at: Maybe<Scalars['timestamptz']['output']>;
  tirecheck_license_plate: Maybe<Scalars['String']['output']>;
  tirecheck_tire_id: Maybe<Scalars['String']['output']>;
  tirecheck_tire_identifier: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Tirecheck_Inconsistency_Min_Fields = {
  __typename?: 'tirecheck_inconsistency_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  ibor_license_plate: Maybe<Scalars['String']['output']>;
  ibor_tire_id: Maybe<Scalars['String']['output']>;
  ibor_tire_identifier: Maybe<Scalars['String']['output']>;
  inspection_started_at: Maybe<Scalars['timestamptz']['output']>;
  tirecheck_license_plate: Maybe<Scalars['String']['output']>;
  tirecheck_tire_id: Maybe<Scalars['String']['output']>;
  tirecheck_tire_identifier: Maybe<Scalars['String']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_Mutation_Response = {
  __typename?: 'tirecheck_inconsistency_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tirecheck_Inconsistency>;
};

/** on_conflict condition type for table "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_On_Conflict = {
  constraint: Tirecheck_Inconsistency_Constraint;
  update_columns?: Array<Tirecheck_Inconsistency_Update_Column>;
  where?: InputMaybe<Tirecheck_Inconsistency_Bool_Exp>;
};

/** Ordering options when selecting data from "tirecheck_inconsistency". */
export type Tirecheck_Inconsistency_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  ibor_license_plate?: InputMaybe<Order_By>;
  ibor_tire_id?: InputMaybe<Order_By>;
  ibor_tire_identifier?: InputMaybe<Order_By>;
  inspection_started_at?: InputMaybe<Order_By>;
  tirecheck_license_plate?: InputMaybe<Order_By>;
  tirecheck_tire_id?: InputMaybe<Order_By>;
  tirecheck_tire_identifier?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tirecheck_inconsistency */
export type Tirecheck_Inconsistency_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "tirecheck_inconsistency" */
export enum Tirecheck_Inconsistency_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  IborLicensePlate = 'ibor_license_plate',
  /** column name */
  IborTireId = 'ibor_tire_id',
  /** column name */
  IborTireIdentifier = 'ibor_tire_identifier',
  /** column name */
  InspectionStartedAt = 'inspection_started_at',
  /** column name */
  TirecheckLicensePlate = 'tirecheck_license_plate',
  /** column name */
  TirecheckTireId = 'tirecheck_tire_id',
  /** column name */
  TirecheckTireIdentifier = 'tirecheck_tire_identifier',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  ibor_license_plate?: InputMaybe<Scalars['String']['input']>;
  ibor_tire_id?: InputMaybe<Scalars['String']['input']>;
  ibor_tire_identifier?: InputMaybe<Scalars['String']['input']>;
  inspection_started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  tirecheck_license_plate?: InputMaybe<Scalars['String']['input']>;
  tirecheck_tire_id?: InputMaybe<Scalars['String']['input']>;
  tirecheck_tire_identifier?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "tirecheck_inconsistency" */
export type Tirecheck_Inconsistency_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tirecheck_Inconsistency_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tirecheck_Inconsistency_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  ibor_license_plate?: InputMaybe<Scalars['String']['input']>;
  ibor_tire_id?: InputMaybe<Scalars['String']['input']>;
  ibor_tire_identifier?: InputMaybe<Scalars['String']['input']>;
  inspection_started_at?: InputMaybe<Scalars['timestamptz']['input']>;
  tirecheck_license_plate?: InputMaybe<Scalars['String']['input']>;
  tirecheck_tire_id?: InputMaybe<Scalars['String']['input']>;
  tirecheck_tire_identifier?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "tirecheck_inconsistency" */
export enum Tirecheck_Inconsistency_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  IborLicensePlate = 'ibor_license_plate',
  /** column name */
  IborTireId = 'ibor_tire_id',
  /** column name */
  IborTireIdentifier = 'ibor_tire_identifier',
  /** column name */
  InspectionStartedAt = 'inspection_started_at',
  /** column name */
  TirecheckLicensePlate = 'tirecheck_license_plate',
  /** column name */
  TirecheckTireId = 'tirecheck_tire_id',
  /** column name */
  TirecheckTireIdentifier = 'tirecheck_tire_identifier',
  /** column name */
  Uuid = 'uuid'
}

export type Tirecheck_Inconsistency_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tirecheck_Inconsistency_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tirecheck_Inconsistency_Bool_Exp;
};

/** Boolean expression to compare columns of type "tracker_device_model". All fields are combined with logical 'AND'. */
export type Tracker_Device_Model_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['tracker_device_model']['input']>;
  _gt?: InputMaybe<Scalars['tracker_device_model']['input']>;
  _gte?: InputMaybe<Scalars['tracker_device_model']['input']>;
  _in?: InputMaybe<Array<Scalars['tracker_device_model']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['tracker_device_model']['input']>;
  _lte?: InputMaybe<Scalars['tracker_device_model']['input']>;
  _neq?: InputMaybe<Scalars['tracker_device_model']['input']>;
  _nin?: InputMaybe<Array<Scalars['tracker_device_model']['input']>>;
};

/** columns and relationships of "training" */
export type Training = {
  __typename?: 'training';
  carrousel_order: Maybe<Scalars['Int']['output']>;
  created_at: Scalars['timestamptz']['output'];
  description: Maybe<Scalars['String']['output']>;
  is_highlight: Scalars['Boolean']['output'];
  text: Maybe<Scalars['String']['output']>;
  thumbnail_url: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  /** An array relationship */
  training_documents: Array<Training_Document>;
  /** An aggregate relationship */
  training_documents_aggregate: Training_Document_Aggregate;
  /** "video" or "document" */
  type: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  user_trainings: Array<User_Training>;
  /** An aggregate relationship */
  user_trainings_aggregate: User_Training_Aggregate;
  uuid: Scalars['uuid']['output'];
  video_url: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "training" */
export type TrainingTraining_DocumentsArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_Order_By>>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};


/** columns and relationships of "training" */
export type TrainingTraining_Documents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_Order_By>>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};


/** columns and relationships of "training" */
export type TrainingUser_TrainingsArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};


/** columns and relationships of "training" */
export type TrainingUser_Trainings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};

/** aggregated selection of "training" */
export type Training_Aggregate = {
  __typename?: 'training_aggregate';
  aggregate: Maybe<Training_Aggregate_Fields>;
  nodes: Array<Training>;
};

/** aggregate fields of "training" */
export type Training_Aggregate_Fields = {
  __typename?: 'training_aggregate_fields';
  avg: Maybe<Training_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Training_Max_Fields>;
  min: Maybe<Training_Min_Fields>;
  stddev: Maybe<Training_Stddev_Fields>;
  stddev_pop: Maybe<Training_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Training_Stddev_Samp_Fields>;
  sum: Maybe<Training_Sum_Fields>;
  var_pop: Maybe<Training_Var_Pop_Fields>;
  var_samp: Maybe<Training_Var_Samp_Fields>;
  variance: Maybe<Training_Variance_Fields>;
};


/** aggregate fields of "training" */
export type Training_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Training_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Training_Avg_Fields = {
  __typename?: 'training_avg_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "training". All fields are combined with a logical 'AND'. */
export type Training_Bool_Exp = {
  _and?: InputMaybe<Array<Training_Bool_Exp>>;
  _not?: InputMaybe<Training_Bool_Exp>;
  _or?: InputMaybe<Array<Training_Bool_Exp>>;
  carrousel_order?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  is_highlight?: InputMaybe<Boolean_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  thumbnail_url?: InputMaybe<String_Comparison_Exp>;
  title?: InputMaybe<String_Comparison_Exp>;
  training_documents?: InputMaybe<Training_Document_Bool_Exp>;
  training_documents_aggregate?: InputMaybe<Training_Document_Aggregate_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_trainings?: InputMaybe<User_Training_Bool_Exp>;
  user_trainings_aggregate?: InputMaybe<User_Training_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  video_url?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "training" */
export enum Training_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  TrainingPkey = 'training_pkey'
}

/** columns and relationships of "training_document" */
export type Training_Document = {
  __typename?: 'training_document';
  created_at: Scalars['timestamptz']['output'];
  file_url: Scalars['String']['output'];
  order: Scalars['numeric']['output'];
  title: Scalars['String']['output'];
  /** An object relationship */
  training: Training;
  /** An array relationship */
  training_document_views: Array<Training_Document_View>;
  /** An aggregate relationship */
  training_document_views_aggregate: Training_Document_View_Aggregate;
  training_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "training_document" */
export type Training_DocumentTraining_Document_ViewsArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


/** columns and relationships of "training_document" */
export type Training_DocumentTraining_Document_Views_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};

/** aggregated selection of "training_document" */
export type Training_Document_Aggregate = {
  __typename?: 'training_document_aggregate';
  aggregate: Maybe<Training_Document_Aggregate_Fields>;
  nodes: Array<Training_Document>;
};

export type Training_Document_Aggregate_Bool_Exp = {
  count?: InputMaybe<Training_Document_Aggregate_Bool_Exp_Count>;
};

export type Training_Document_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Training_Document_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Training_Document_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "training_document" */
export type Training_Document_Aggregate_Fields = {
  __typename?: 'training_document_aggregate_fields';
  avg: Maybe<Training_Document_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Training_Document_Max_Fields>;
  min: Maybe<Training_Document_Min_Fields>;
  stddev: Maybe<Training_Document_Stddev_Fields>;
  stddev_pop: Maybe<Training_Document_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Training_Document_Stddev_Samp_Fields>;
  sum: Maybe<Training_Document_Sum_Fields>;
  var_pop: Maybe<Training_Document_Var_Pop_Fields>;
  var_samp: Maybe<Training_Document_Var_Samp_Fields>;
  variance: Maybe<Training_Document_Variance_Fields>;
};


/** aggregate fields of "training_document" */
export type Training_Document_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Training_Document_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "training_document" */
export type Training_Document_Aggregate_Order_By = {
  avg?: InputMaybe<Training_Document_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Training_Document_Max_Order_By>;
  min?: InputMaybe<Training_Document_Min_Order_By>;
  stddev?: InputMaybe<Training_Document_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Training_Document_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Training_Document_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Training_Document_Sum_Order_By>;
  var_pop?: InputMaybe<Training_Document_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Training_Document_Var_Samp_Order_By>;
  variance?: InputMaybe<Training_Document_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "training_document" */
export type Training_Document_Arr_Rel_Insert_Input = {
  data: Array<Training_Document_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Training_Document_On_Conflict>;
};

/** aggregate avg on columns */
export type Training_Document_Avg_Fields = {
  __typename?: 'training_document_avg_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "training_document" */
export type Training_Document_Avg_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "training_document". All fields are combined with a logical 'AND'. */
export type Training_Document_Bool_Exp = {
  _and?: InputMaybe<Array<Training_Document_Bool_Exp>>;
  _not?: InputMaybe<Training_Document_Bool_Exp>;
  _or?: InputMaybe<Array<Training_Document_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  file_url?: InputMaybe<String_Comparison_Exp>;
  order?: InputMaybe<Numeric_Comparison_Exp>;
  title?: InputMaybe<String_Comparison_Exp>;
  training?: InputMaybe<Training_Bool_Exp>;
  training_document_views?: InputMaybe<Training_Document_View_Bool_Exp>;
  training_document_views_aggregate?: InputMaybe<Training_Document_View_Aggregate_Bool_Exp>;
  training_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "training_document" */
export enum Training_Document_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  TrainingDocumentPkey = 'training_document_pkey'
}

/** input type for incrementing numeric columns in table "training_document" */
export type Training_Document_Inc_Input = {
  order?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "training_document" */
export type Training_Document_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  file_url?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['numeric']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  training?: InputMaybe<Training_Obj_Rel_Insert_Input>;
  training_document_views?: InputMaybe<Training_Document_View_Arr_Rel_Insert_Input>;
  training_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Training_Document_Max_Fields = {
  __typename?: 'training_document_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  file_url: Maybe<Scalars['String']['output']>;
  order: Maybe<Scalars['numeric']['output']>;
  title: Maybe<Scalars['String']['output']>;
  training_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "training_document" */
export type Training_Document_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  file_url?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  training_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Training_Document_Min_Fields = {
  __typename?: 'training_document_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  file_url: Maybe<Scalars['String']['output']>;
  order: Maybe<Scalars['numeric']['output']>;
  title: Maybe<Scalars['String']['output']>;
  training_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "training_document" */
export type Training_Document_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  file_url?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  training_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "training_document" */
export type Training_Document_Mutation_Response = {
  __typename?: 'training_document_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Training_Document>;
};

/** input type for inserting object relation for remote table "training_document" */
export type Training_Document_Obj_Rel_Insert_Input = {
  data: Training_Document_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Training_Document_On_Conflict>;
};

/** on_conflict condition type for table "training_document" */
export type Training_Document_On_Conflict = {
  constraint: Training_Document_Constraint;
  update_columns?: Array<Training_Document_Update_Column>;
  where?: InputMaybe<Training_Document_Bool_Exp>;
};

/** Ordering options when selecting data from "training_document". */
export type Training_Document_Order_By = {
  created_at?: InputMaybe<Order_By>;
  file_url?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  training?: InputMaybe<Training_Order_By>;
  training_document_views_aggregate?: InputMaybe<Training_Document_View_Aggregate_Order_By>;
  training_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: training_document */
export type Training_Document_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "training_document" */
export enum Training_Document_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FileUrl = 'file_url',
  /** column name */
  Order = 'order',
  /** column name */
  Title = 'title',
  /** column name */
  TrainingUuid = 'training_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "training_document" */
export type Training_Document_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  file_url?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['numeric']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  training_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Training_Document_Stddev_Fields = {
  __typename?: 'training_document_stddev_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "training_document" */
export type Training_Document_Stddev_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Training_Document_Stddev_Pop_Fields = {
  __typename?: 'training_document_stddev_pop_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "training_document" */
export type Training_Document_Stddev_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Training_Document_Stddev_Samp_Fields = {
  __typename?: 'training_document_stddev_samp_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "training_document" */
export type Training_Document_Stddev_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "training_document" */
export type Training_Document_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Training_Document_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Training_Document_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  file_url?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['numeric']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  training_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Training_Document_Sum_Fields = {
  __typename?: 'training_document_sum_fields';
  order: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "training_document" */
export type Training_Document_Sum_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** update columns of table "training_document" */
export enum Training_Document_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FileUrl = 'file_url',
  /** column name */
  Order = 'order',
  /** column name */
  Title = 'title',
  /** column name */
  TrainingUuid = 'training_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Training_Document_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Training_Document_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Training_Document_Set_Input>;
  /** filter the rows which have to be updated */
  where: Training_Document_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Training_Document_Var_Pop_Fields = {
  __typename?: 'training_document_var_pop_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "training_document" */
export type Training_Document_Var_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Training_Document_Var_Samp_Fields = {
  __typename?: 'training_document_var_samp_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "training_document" */
export type Training_Document_Var_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Training_Document_Variance_Fields = {
  __typename?: 'training_document_variance_fields';
  order: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "training_document" */
export type Training_Document_Variance_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** columns and relationships of "training_document_view" */
export type Training_Document_View = {
  __typename?: 'training_document_view';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  training_document: Training_Document;
  training_document_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "training_document_view" */
export type Training_Document_View_Aggregate = {
  __typename?: 'training_document_view_aggregate';
  aggregate: Maybe<Training_Document_View_Aggregate_Fields>;
  nodes: Array<Training_Document_View>;
};

export type Training_Document_View_Aggregate_Bool_Exp = {
  count?: InputMaybe<Training_Document_View_Aggregate_Bool_Exp_Count>;
};

export type Training_Document_View_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Training_Document_View_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "training_document_view" */
export type Training_Document_View_Aggregate_Fields = {
  __typename?: 'training_document_view_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Training_Document_View_Max_Fields>;
  min: Maybe<Training_Document_View_Min_Fields>;
};


/** aggregate fields of "training_document_view" */
export type Training_Document_View_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "training_document_view" */
export type Training_Document_View_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Training_Document_View_Max_Order_By>;
  min?: InputMaybe<Training_Document_View_Min_Order_By>;
};

/** input type for inserting array relation for remote table "training_document_view" */
export type Training_Document_View_Arr_Rel_Insert_Input = {
  data: Array<Training_Document_View_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Training_Document_View_On_Conflict>;
};

/** Boolean expression to filter rows from the table "training_document_view". All fields are combined with a logical 'AND'. */
export type Training_Document_View_Bool_Exp = {
  _and?: InputMaybe<Array<Training_Document_View_Bool_Exp>>;
  _not?: InputMaybe<Training_Document_View_Bool_Exp>;
  _or?: InputMaybe<Array<Training_Document_View_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  training_document?: InputMaybe<Training_Document_Bool_Exp>;
  training_document_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "training_document_view" */
export enum Training_Document_View_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  TrainingDocumentViewPkey = 'training_document_view_pkey'
}

/** input type for inserting data into table "training_document_view" */
export type Training_Document_View_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  training_document?: InputMaybe<Training_Document_Obj_Rel_Insert_Input>;
  training_document_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Training_Document_View_Max_Fields = {
  __typename?: 'training_document_view_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  training_document_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "training_document_view" */
export type Training_Document_View_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  training_document_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Training_Document_View_Min_Fields = {
  __typename?: 'training_document_view_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  training_document_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "training_document_view" */
export type Training_Document_View_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  training_document_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "training_document_view" */
export type Training_Document_View_Mutation_Response = {
  __typename?: 'training_document_view_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Training_Document_View>;
};

/** on_conflict condition type for table "training_document_view" */
export type Training_Document_View_On_Conflict = {
  constraint: Training_Document_View_Constraint;
  update_columns?: Array<Training_Document_View_Update_Column>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};

/** Ordering options when selecting data from "training_document_view". */
export type Training_Document_View_Order_By = {
  created_at?: InputMaybe<Order_By>;
  training_document?: InputMaybe<Training_Document_Order_By>;
  training_document_uuid?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: training_document_view */
export type Training_Document_View_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "training_document_view" */
export enum Training_Document_View_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  TrainingDocumentUuid = 'training_document_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "training_document_view" */
export type Training_Document_View_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  training_document_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "training_document_view" */
export type Training_Document_View_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Training_Document_View_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Training_Document_View_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  training_document_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "training_document_view" */
export enum Training_Document_View_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  TrainingDocumentUuid = 'training_document_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Training_Document_View_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Training_Document_View_Set_Input>;
  /** filter the rows which have to be updated */
  where: Training_Document_View_Bool_Exp;
};

/** input type for incrementing numeric columns in table "training" */
export type Training_Inc_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "training" */
export type Training_Insert_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  is_highlight?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  thumbnail_url?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  training_documents?: InputMaybe<Training_Document_Arr_Rel_Insert_Input>;
  /** "video" or "document" */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_trainings?: InputMaybe<User_Training_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  video_url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Training_Max_Fields = {
  __typename?: 'training_max_fields';
  carrousel_order: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  text: Maybe<Scalars['String']['output']>;
  thumbnail_url: Maybe<Scalars['String']['output']>;
  title: Maybe<Scalars['String']['output']>;
  /** "video" or "document" */
  type: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  video_url: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Training_Min_Fields = {
  __typename?: 'training_min_fields';
  carrousel_order: Maybe<Scalars['Int']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  description: Maybe<Scalars['String']['output']>;
  text: Maybe<Scalars['String']['output']>;
  thumbnail_url: Maybe<Scalars['String']['output']>;
  title: Maybe<Scalars['String']['output']>;
  /** "video" or "document" */
  type: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  video_url: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "training" */
export type Training_Mutation_Response = {
  __typename?: 'training_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Training>;
};

/** input type for inserting object relation for remote table "training" */
export type Training_Obj_Rel_Insert_Input = {
  data: Training_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Training_On_Conflict>;
};

/** on_conflict condition type for table "training" */
export type Training_On_Conflict = {
  constraint: Training_Constraint;
  update_columns?: Array<Training_Update_Column>;
  where?: InputMaybe<Training_Bool_Exp>;
};

/** Ordering options when selecting data from "training". */
export type Training_Order_By = {
  carrousel_order?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  is_highlight?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  thumbnail_url?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  training_documents_aggregate?: InputMaybe<Training_Document_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_trainings_aggregate?: InputMaybe<User_Training_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
  video_url?: InputMaybe<Order_By>;
};

/** primary key columns input for table: training */
export type Training_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "training" */
export enum Training_Select_Column {
  /** column name */
  CarrouselOrder = 'carrousel_order',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  IsHighlight = 'is_highlight',
  /** column name */
  Text = 'text',
  /** column name */
  ThumbnailUrl = 'thumbnail_url',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VideoUrl = 'video_url'
}

/** input type for updating data in table "training" */
export type Training_Set_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  is_highlight?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  thumbnail_url?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  /** "video" or "document" */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  video_url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Training_Stddev_Fields = {
  __typename?: 'training_stddev_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Training_Stddev_Pop_Fields = {
  __typename?: 'training_stddev_pop_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Training_Stddev_Samp_Fields = {
  __typename?: 'training_stddev_samp_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "training" */
export type Training_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Training_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Training_Stream_Cursor_Value_Input = {
  carrousel_order?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  is_highlight?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  thumbnail_url?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  /** "video" or "document" */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  video_url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Training_Sum_Fields = {
  __typename?: 'training_sum_fields';
  carrousel_order: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "training" */
export enum Training_Update_Column {
  /** column name */
  CarrouselOrder = 'carrousel_order',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  IsHighlight = 'is_highlight',
  /** column name */
  Text = 'text',
  /** column name */
  ThumbnailUrl = 'thumbnail_url',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  VideoUrl = 'video_url'
}

export type Training_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Training_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Training_Set_Input>;
  /** filter the rows which have to be updated */
  where: Training_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Training_Var_Pop_Fields = {
  __typename?: 'training_var_pop_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Training_Var_Samp_Fields = {
  __typename?: 'training_var_samp_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Training_Variance_Fields = {
  __typename?: 'training_variance_fields';
  carrousel_order: Maybe<Scalars['Float']['output']>;
};

export type Update_Status_Truck_Hardware_By_Vehicle_Plates_Args = {
  last_analysis_time?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_plates?: InputMaybe<Scalars['_text']['input']>;
};

/** columns and relationships of "user" */
export type User = {
  __typename?: 'user';
  /** Returns if the user accepted privacy policy. Use this instead of querying user_fk_policy, can change later */
  accepted_privacy_policy: Maybe<Scalars['Boolean']['output']>;
  admitted_at: Maybe<Scalars['timestamptz']['output']>;
  avatar_url: Scalars['String']['output'];
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  birthdate: Maybe<Scalars['date']['output']>;
  cpf: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_option" */
  current_level_option: Maybe<Array<Level_Option>>;
  /** An array relationship */
  driver_warnings: Array<Driver_Warning>;
  /** An aggregate relationship */
  driver_warnings_aggregate: Driver_Warning_Aggregate;
  /** If the user is enabled or not. This is overwritten in case it's not a driver with the driver replication cron event */
  enabled: Scalars['Boolean']['output'];
  /** An array relationship */
  instructor_supervisions: Array<Instructor_Supervision>;
  /** An aggregate relationship */
  instructor_supervisions_aggregate: Instructor_Supervision_Aggregate;
  license_plate: Maybe<Scalars['String']['output']>;
  motorista_code: Scalars['String']['output'];
  name: Scalars['String']['output'];
  password: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  product_requests: Array<Product_Request>;
  /** An aggregate relationship */
  product_requests_aggregate: Product_Request_Aggregate;
  /** An array relationship */
  refresh_tokens: Array<Refresh_Token>;
  /** An aggregate relationship */
  refresh_tokens_aggregate: Refresh_Token_Aggregate;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
  /** An array relationship */
  training_document_views: Array<Training_Document_View>;
  /** An aggregate relationship */
  training_document_views_aggregate: Training_Document_View_Aggregate;
  /** An array relationship */
  user_fk_achievements: Array<User_Fk_Achievement>;
  /** An aggregate relationship */
  user_fk_achievements_aggregate: User_Fk_Achievement_Aggregate;
  /** An array relationship */
  user_fk_levels: Array<User_Fk_Level>;
  /** An aggregate relationship */
  user_fk_levels_aggregate: User_Fk_Level_Aggregate;
  /** An array relationship */
  user_fk_notifications: Array<User_Fk_Notification>;
  /** An aggregate relationship */
  user_fk_notifications_aggregate: User_Fk_Notification_Aggregate;
  /** An array relationship */
  user_fk_privacy_policies: Array<User_Fk_Privacy_Policy>;
  /** An aggregate relationship */
  user_fk_privacy_policies_aggregate: User_Fk_Privacy_Policy_Aggregate;
  /** An array relationship */
  user_km_points_approvals: Array<User_Km_Points_Approval>;
  /** An aggregate relationship */
  user_km_points_approvals_aggregate: User_Km_Points_Approval_Aggregate;
  /** An array relationship */
  user_kmps: Array<User_Kmps>;
  /** An aggregate relationship */
  user_kmps_aggregate: User_Kmps_Aggregate;
  /** An array relationship */
  user_score_rankings: Array<User_Score_Ranking>;
  /** An aggregate relationship */
  user_score_rankings_aggregate: User_Score_Ranking_Aggregate;
  /** An array relationship */
  user_scores: Array<User_Score>;
  /** An aggregate relationship */
  user_scores_aggregate: User_Score_Aggregate;
  /** An array relationship */
  user_trainings: Array<User_Training>;
  /** An aggregate relationship */
  user_trainings_aggregate: User_Training_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "user" */
export type UserCurrent_Level_OptionArgs = {
  distinct_on?: InputMaybe<Array<Level_Option_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Level_Option_Order_By>>;
  where?: InputMaybe<Level_Option_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserDriver_WarningsArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserDriver_Warnings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Warning_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Warning_Order_By>>;
  where?: InputMaybe<Driver_Warning_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserInstructor_SupervisionsArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserInstructor_Supervisions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Instructor_Supervision_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Instructor_Supervision_Order_By>>;
  where?: InputMaybe<Instructor_Supervision_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserProduct_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserProduct_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Product_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Product_Request_Order_By>>;
  where?: InputMaybe<Product_Request_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserRefresh_TokensArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserRefresh_Tokens_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Refresh_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Refresh_Token_Order_By>>;
  where?: InputMaybe<Refresh_Token_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserTraining_Document_ViewsArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserTraining_Document_Views_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Training_Document_View_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Training_Document_View_Order_By>>;
  where?: InputMaybe<Training_Document_View_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_AchievementsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_Achievements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Achievement_Order_By>>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_LevelsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_Levels_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Level_Order_By>>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_NotificationsArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_Notifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Notification_Order_By>>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_Privacy_PoliciesArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Privacy_Policy_Order_By>>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Fk_Privacy_Policies_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Fk_Privacy_Policy_Order_By>>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Km_Points_ApprovalsArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Km_Points_Approvals_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Km_Points_Approval_Order_By>>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_KmpsArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Kmps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Score_RankingsArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Score_Rankings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Ranking_Order_By>>;
  where?: InputMaybe<User_Score_Ranking_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_ScoresArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Scores_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Score_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Score_Order_By>>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_TrainingsArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Trainings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Training_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Training_Order_By>>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};

/** aggregated selection of "user" */
export type User_Aggregate = {
  __typename?: 'user_aggregate';
  aggregate: Maybe<User_Aggregate_Fields>;
  nodes: Array<User>;
};

/** aggregate fields of "user" */
export type User_Aggregate_Fields = {
  __typename?: 'user_aggregate_fields';
  avg: Maybe<User_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<User_Max_Fields>;
  min: Maybe<User_Min_Fields>;
  stddev: Maybe<User_Stddev_Fields>;
  stddev_pop: Maybe<User_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Stddev_Samp_Fields>;
  sum: Maybe<User_Sum_Fields>;
  var_pop: Maybe<User_Var_Pop_Fields>;
  var_samp: Maybe<User_Var_Samp_Fields>;
  variance: Maybe<User_Variance_Fields>;
};


/** aggregate fields of "user" */
export type User_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type User_Avg_Fields = {
  __typename?: 'user_avg_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'. */
export type User_Bool_Exp = {
  _and?: InputMaybe<Array<User_Bool_Exp>>;
  _not?: InputMaybe<User_Bool_Exp>;
  _or?: InputMaybe<Array<User_Bool_Exp>>;
  accepted_privacy_policy?: InputMaybe<Boolean_Comparison_Exp>;
  admitted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  avatar_url?: InputMaybe<String_Comparison_Exp>;
  balance?: InputMaybe<Int_Comparison_Exp>;
  birthdate?: InputMaybe<Date_Comparison_Exp>;
  cpf?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  current_level_number?: InputMaybe<Int_Comparison_Exp>;
  current_level_option?: InputMaybe<Level_Option_Bool_Exp>;
  driver_warnings?: InputMaybe<Driver_Warning_Bool_Exp>;
  driver_warnings_aggregate?: InputMaybe<Driver_Warning_Aggregate_Bool_Exp>;
  enabled?: InputMaybe<Boolean_Comparison_Exp>;
  instructor_supervisions?: InputMaybe<Instructor_Supervision_Bool_Exp>;
  instructor_supervisions_aggregate?: InputMaybe<Instructor_Supervision_Aggregate_Bool_Exp>;
  license_plate?: InputMaybe<String_Comparison_Exp>;
  motorista_code?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  password?: InputMaybe<String_Comparison_Exp>;
  product_requests?: InputMaybe<Product_Request_Bool_Exp>;
  product_requests_aggregate?: InputMaybe<Product_Request_Aggregate_Bool_Exp>;
  refresh_tokens?: InputMaybe<Refresh_Token_Bool_Exp>;
  refresh_tokens_aggregate?: InputMaybe<Refresh_Token_Aggregate_Bool_Exp>;
  score_average?: InputMaybe<Float8_Comparison_Exp>;
  training_document_views?: InputMaybe<Training_Document_View_Bool_Exp>;
  training_document_views_aggregate?: InputMaybe<Training_Document_View_Aggregate_Bool_Exp>;
  user_fk_achievements?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
  user_fk_achievements_aggregate?: InputMaybe<User_Fk_Achievement_Aggregate_Bool_Exp>;
  user_fk_levels?: InputMaybe<User_Fk_Level_Bool_Exp>;
  user_fk_levels_aggregate?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp>;
  user_fk_notifications?: InputMaybe<User_Fk_Notification_Bool_Exp>;
  user_fk_notifications_aggregate?: InputMaybe<User_Fk_Notification_Aggregate_Bool_Exp>;
  user_fk_privacy_policies?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
  user_fk_privacy_policies_aggregate?: InputMaybe<User_Fk_Privacy_Policy_Aggregate_Bool_Exp>;
  user_km_points_approvals?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  user_km_points_approvals_aggregate?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp>;
  user_kmps?: InputMaybe<User_Kmps_Bool_Exp>;
  user_kmps_aggregate?: InputMaybe<User_Kmps_Aggregate_Bool_Exp>;
  user_score_rankings?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  user_score_rankings_aggregate?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp>;
  user_scores?: InputMaybe<User_Score_Bool_Exp>;
  user_scores_aggregate?: InputMaybe<User_Score_Aggregate_Bool_Exp>;
  user_trainings?: InputMaybe<User_Training_Bool_Exp>;
  user_trainings_aggregate?: InputMaybe<User_Training_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user" */
export enum User_Constraint {
  /** unique or primary key constraint on columns "motorista_code" */
  UserMotoristaCodeKey = 'user_motorista_code_key',
  /** unique or primary key constraint on columns "uuid" */
  UserPkey = 'user_pkey'
}

/** columns and relationships of "user_fk_achievement" */
export type User_Fk_Achievement = {
  __typename?: 'user_fk_achievement';
  /** An object relationship */
  achievement: Achievement;
  achievement_uuid: Scalars['uuid']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  score_processed: Score_Processed;
  score_processed_uuid: Scalars['uuid']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_fk_achievement" */
export type User_Fk_Achievement_Aggregate = {
  __typename?: 'user_fk_achievement_aggregate';
  aggregate: Maybe<User_Fk_Achievement_Aggregate_Fields>;
  nodes: Array<User_Fk_Achievement>;
};

export type User_Fk_Achievement_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Fk_Achievement_Aggregate_Bool_Exp_Count>;
};

export type User_Fk_Achievement_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_fk_achievement" */
export type User_Fk_Achievement_Aggregate_Fields = {
  __typename?: 'user_fk_achievement_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<User_Fk_Achievement_Max_Fields>;
  min: Maybe<User_Fk_Achievement_Min_Fields>;
};


/** aggregate fields of "user_fk_achievement" */
export type User_Fk_Achievement_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Fk_Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_fk_achievement" */
export type User_Fk_Achievement_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Fk_Achievement_Max_Order_By>;
  min?: InputMaybe<User_Fk_Achievement_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_fk_achievement" */
export type User_Fk_Achievement_Arr_Rel_Insert_Input = {
  data: Array<User_Fk_Achievement_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Fk_Achievement_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_fk_achievement". All fields are combined with a logical 'AND'. */
export type User_Fk_Achievement_Bool_Exp = {
  _and?: InputMaybe<Array<User_Fk_Achievement_Bool_Exp>>;
  _not?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
  _or?: InputMaybe<Array<User_Fk_Achievement_Bool_Exp>>;
  achievement?: InputMaybe<Achievement_Bool_Exp>;
  achievement_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  score_processed?: InputMaybe<Score_Processed_Bool_Exp>;
  score_processed_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_fk_achievement" */
export enum User_Fk_Achievement_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserFkAchievementPkey = 'user_fk_achievement_pkey',
  /** unique or primary key constraint on columns "achievement_uuid", "user_uuid", "score_processed_uuid" */
  UserFkAchievementScoreProcessedUuidUserUuidAchievement = 'user_fk_achievement_score_processed_uuid_user_uuid_achievement_',
  /** unique or primary key constraint on columns "achievement_uuid", "user_uuid", "score_processed_uuid" */
  UserFkAchievementUserUuidAchievementUuidScoreProcesKey = 'user_fk_achievement_user_uuid_achievement_uuid_score_proces_key'
}

/** input type for inserting data into table "user_fk_achievement" */
export type User_Fk_Achievement_Insert_Input = {
  achievement?: InputMaybe<Achievement_Obj_Rel_Insert_Input>;
  achievement_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  score_processed?: InputMaybe<Score_Processed_Obj_Rel_Insert_Input>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Fk_Achievement_Max_Fields = {
  __typename?: 'user_fk_achievement_max_fields';
  achievement_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_fk_achievement" */
export type User_Fk_Achievement_Max_Order_By = {
  achievement_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Fk_Achievement_Min_Fields = {
  __typename?: 'user_fk_achievement_min_fields';
  achievement_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_fk_achievement" */
export type User_Fk_Achievement_Min_Order_By = {
  achievement_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_fk_achievement" */
export type User_Fk_Achievement_Mutation_Response = {
  __typename?: 'user_fk_achievement_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Fk_Achievement>;
};

/** on_conflict condition type for table "user_fk_achievement" */
export type User_Fk_Achievement_On_Conflict = {
  constraint: User_Fk_Achievement_Constraint;
  update_columns?: Array<User_Fk_Achievement_Update_Column>;
  where?: InputMaybe<User_Fk_Achievement_Bool_Exp>;
};

/** Ordering options when selecting data from "user_fk_achievement". */
export type User_Fk_Achievement_Order_By = {
  achievement?: InputMaybe<Achievement_Order_By>;
  achievement_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  score_processed?: InputMaybe<Score_Processed_Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_fk_achievement */
export type User_Fk_Achievement_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_fk_achievement" */
export enum User_Fk_Achievement_Select_Column {
  /** column name */
  AchievementUuid = 'achievement_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "user_fk_achievement" */
export type User_Fk_Achievement_Set_Input = {
  achievement_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_fk_achievement" */
export type User_Fk_Achievement_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Fk_Achievement_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Fk_Achievement_Stream_Cursor_Value_Input = {
  achievement_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_fk_achievement" */
export enum User_Fk_Achievement_Update_Column {
  /** column name */
  AchievementUuid = 'achievement_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type User_Fk_Achievement_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Fk_Achievement_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Fk_Achievement_Bool_Exp;
};

/** columns and relationships of "user_fk_challenge" */
export type User_Fk_Challenge = {
  __typename?: 'user_fk_challenge';
  /** An object relationship */
  challenge: Challenge;
  challenge_uuid: Scalars['uuid']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Scalars['float8']['output'];
  /** The driver that made some progress in this challenge */
  motorista_code: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_fk_challenge" */
export type User_Fk_Challenge_Aggregate = {
  __typename?: 'user_fk_challenge_aggregate';
  aggregate: Maybe<User_Fk_Challenge_Aggregate_Fields>;
  nodes: Array<User_Fk_Challenge>;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp = {
  avg?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<User_Fk_Challenge_Aggregate_Bool_Exp_Var_Samp>;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Avg = {
  arguments: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Corr = {
  arguments: User_Fk_Challenge_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Corr_Arguments = {
  X: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: User_Fk_Challenge_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Max = {
  arguments: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Min = {
  arguments: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Sum = {
  arguments: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Challenge_Aggregate_Bool_Exp_Var_Samp = {
  arguments: User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "user_fk_challenge" */
export type User_Fk_Challenge_Aggregate_Fields = {
  __typename?: 'user_fk_challenge_aggregate_fields';
  avg: Maybe<User_Fk_Challenge_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<User_Fk_Challenge_Max_Fields>;
  min: Maybe<User_Fk_Challenge_Min_Fields>;
  stddev: Maybe<User_Fk_Challenge_Stddev_Fields>;
  stddev_pop: Maybe<User_Fk_Challenge_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Fk_Challenge_Stddev_Samp_Fields>;
  sum: Maybe<User_Fk_Challenge_Sum_Fields>;
  var_pop: Maybe<User_Fk_Challenge_Var_Pop_Fields>;
  var_samp: Maybe<User_Fk_Challenge_Var_Samp_Fields>;
  variance: Maybe<User_Fk_Challenge_Variance_Fields>;
};


/** aggregate fields of "user_fk_challenge" */
export type User_Fk_Challenge_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Fk_Challenge_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_fk_challenge" */
export type User_Fk_Challenge_Aggregate_Order_By = {
  avg?: InputMaybe<User_Fk_Challenge_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Fk_Challenge_Max_Order_By>;
  min?: InputMaybe<User_Fk_Challenge_Min_Order_By>;
  stddev?: InputMaybe<User_Fk_Challenge_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Fk_Challenge_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Fk_Challenge_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Fk_Challenge_Sum_Order_By>;
  var_pop?: InputMaybe<User_Fk_Challenge_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Fk_Challenge_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Fk_Challenge_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_fk_challenge" */
export type User_Fk_Challenge_Arr_Rel_Insert_Input = {
  data: Array<User_Fk_Challenge_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Fk_Challenge_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Fk_Challenge_Avg_Fields = {
  __typename?: 'user_fk_challenge_avg_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Avg_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_fk_challenge". All fields are combined with a logical 'AND'. */
export type User_Fk_Challenge_Bool_Exp = {
  _and?: InputMaybe<Array<User_Fk_Challenge_Bool_Exp>>;
  _not?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
  _or?: InputMaybe<Array<User_Fk_Challenge_Bool_Exp>>;
  challenge?: InputMaybe<Challenge_Bool_Exp>;
  challenge_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  kilometers?: InputMaybe<Float8_Comparison_Exp>;
  motorista_code?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_fk_challenge" */
export enum User_Fk_Challenge_Constraint {
  /** unique or primary key constraint on columns "motorista_code", "challenge_uuid" */
  UserFkChallengeMotoristaCodeChallengeUuidKey = 'user_fk_challenge_motorista_code_challenge_uuid_key',
  /** unique or primary key constraint on columns "uuid" */
  UserFkChallengePkey = 'user_fk_challenge_pkey'
}

/** input type for incrementing numeric columns in table "user_fk_challenge" */
export type User_Fk_Challenge_Inc_Input = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "user_fk_challenge" */
export type User_Fk_Challenge_Insert_Input = {
  challenge?: InputMaybe<Challenge_Obj_Rel_Insert_Input>;
  challenge_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Scalars['float8']['input']>;
  /** The driver that made some progress in this challenge */
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Fk_Challenge_Max_Fields = {
  __typename?: 'user_fk_challenge_max_fields';
  challenge_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['float8']['output']>;
  /** The driver that made some progress in this challenge */
  motorista_code: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Max_Order_By = {
  challenge_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
  /** The driver that made some progress in this challenge */
  motorista_code?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Fk_Challenge_Min_Fields = {
  __typename?: 'user_fk_challenge_min_fields';
  challenge_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['float8']['output']>;
  /** The driver that made some progress in this challenge */
  motorista_code: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Min_Order_By = {
  challenge_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
  /** The driver that made some progress in this challenge */
  motorista_code?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_fk_challenge" */
export type User_Fk_Challenge_Mutation_Response = {
  __typename?: 'user_fk_challenge_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Fk_Challenge>;
};

/** on_conflict condition type for table "user_fk_challenge" */
export type User_Fk_Challenge_On_Conflict = {
  constraint: User_Fk_Challenge_Constraint;
  update_columns?: Array<User_Fk_Challenge_Update_Column>;
  where?: InputMaybe<User_Fk_Challenge_Bool_Exp>;
};

/** Ordering options when selecting data from "user_fk_challenge". */
export type User_Fk_Challenge_Order_By = {
  challenge?: InputMaybe<Challenge_Order_By>;
  challenge_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  kilometers?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_fk_challenge */
export type User_Fk_Challenge_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column {
  /** column name */
  ChallengeUuid = 'challenge_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Kilometers = 'kilometers',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** select "user_fk_challenge_aggregate_bool_exp_avg_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** select "user_fk_challenge_aggregate_bool_exp_corr_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** select "user_fk_challenge_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** select "user_fk_challenge_aggregate_bool_exp_max_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** select "user_fk_challenge_aggregate_bool_exp_min_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** select "user_fk_challenge_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** select "user_fk_challenge_aggregate_bool_exp_sum_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** select "user_fk_challenge_aggregate_bool_exp_var_samp_arguments_columns" columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Select_Column_User_Fk_Challenge_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  Kilometers = 'kilometers'
}

/** input type for updating data in table "user_fk_challenge" */
export type User_Fk_Challenge_Set_Input = {
  challenge_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Scalars['float8']['input']>;
  /** The driver that made some progress in this challenge */
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type User_Fk_Challenge_Stddev_Fields = {
  __typename?: 'user_fk_challenge_stddev_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Stddev_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Fk_Challenge_Stddev_Pop_Fields = {
  __typename?: 'user_fk_challenge_stddev_pop_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Stddev_Pop_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Fk_Challenge_Stddev_Samp_Fields = {
  __typename?: 'user_fk_challenge_stddev_samp_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Stddev_Samp_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_fk_challenge" */
export type User_Fk_Challenge_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Fk_Challenge_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Fk_Challenge_Stream_Cursor_Value_Input = {
  challenge_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Scalars['float8']['input']>;
  /** The driver that made some progress in this challenge */
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type User_Fk_Challenge_Sum_Fields = {
  __typename?: 'user_fk_challenge_sum_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Sum_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** update columns of table "user_fk_challenge" */
export enum User_Fk_Challenge_Update_Column {
  /** column name */
  ChallengeUuid = 'challenge_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Kilometers = 'kilometers',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type User_Fk_Challenge_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<User_Fk_Challenge_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Fk_Challenge_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Fk_Challenge_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Fk_Challenge_Var_Pop_Fields = {
  __typename?: 'user_fk_challenge_var_pop_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Var_Pop_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Fk_Challenge_Var_Samp_Fields = {
  __typename?: 'user_fk_challenge_var_samp_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Var_Samp_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Fk_Challenge_Variance_Fields = {
  __typename?: 'user_fk_challenge_variance_fields';
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_fk_challenge" */
export type User_Fk_Challenge_Variance_Order_By = {
  /** The total of kilometers that this driver made for the specified challenge */
  kilometers?: InputMaybe<Order_By>;
};

/** The level of an user and all of it's notes. Today this is calculated based on the 4 last month notes averaged (0 for empty months). */
export type User_Fk_Level = {
  __typename?: 'user_fk_level';
  brake_use: Scalars['float8']['output'];
  created_at: Scalars['timestamptz']['output'];
  economic_range: Scalars['float8']['output'];
  engine_load: Scalars['float8']['output'];
  inertia: Scalars['float8']['output'];
  /** An object relationship */
  level: Level;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Scalars['Int']['output'];
  /** An object relationship */
  level_option: Level_Option;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid: Scalars['uuid']['output'];
  note: Scalars['float8']['output'];
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date: Scalars['date']['output'];
  slow_running: Scalars['float8']['output'];
  speed_control: Scalars['float8']['output'];
  truncated_month_reference_date: Maybe<Scalars['date']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_fk_level" */
export type User_Fk_Level_Aggregate = {
  __typename?: 'user_fk_level_aggregate';
  aggregate: Maybe<User_Fk_Level_Aggregate_Fields>;
  nodes: Array<User_Fk_Level>;
};

export type User_Fk_Level_Aggregate_Bool_Exp = {
  avg?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<User_Fk_Level_Aggregate_Bool_Exp_Var_Samp>;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Avg = {
  arguments: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Corr = {
  arguments: User_Fk_Level_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Corr_Arguments = {
  X: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: User_Fk_Level_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Max = {
  arguments: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Min = {
  arguments: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Sum = {
  arguments: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Fk_Level_Aggregate_Bool_Exp_Var_Samp = {
  arguments: User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Level_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "user_fk_level" */
export type User_Fk_Level_Aggregate_Fields = {
  __typename?: 'user_fk_level_aggregate_fields';
  avg: Maybe<User_Fk_Level_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<User_Fk_Level_Max_Fields>;
  min: Maybe<User_Fk_Level_Min_Fields>;
  stddev: Maybe<User_Fk_Level_Stddev_Fields>;
  stddev_pop: Maybe<User_Fk_Level_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Fk_Level_Stddev_Samp_Fields>;
  sum: Maybe<User_Fk_Level_Sum_Fields>;
  var_pop: Maybe<User_Fk_Level_Var_Pop_Fields>;
  var_samp: Maybe<User_Fk_Level_Var_Samp_Fields>;
  variance: Maybe<User_Fk_Level_Variance_Fields>;
};


/** aggregate fields of "user_fk_level" */
export type User_Fk_Level_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Fk_Level_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_fk_level" */
export type User_Fk_Level_Aggregate_Order_By = {
  avg?: InputMaybe<User_Fk_Level_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Fk_Level_Max_Order_By>;
  min?: InputMaybe<User_Fk_Level_Min_Order_By>;
  stddev?: InputMaybe<User_Fk_Level_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Fk_Level_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Fk_Level_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Fk_Level_Sum_Order_By>;
  var_pop?: InputMaybe<User_Fk_Level_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Fk_Level_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Fk_Level_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_fk_level" */
export type User_Fk_Level_Arr_Rel_Insert_Input = {
  data: Array<User_Fk_Level_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Fk_Level_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Fk_Level_Avg_Fields = {
  __typename?: 'user_fk_level_avg_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_fk_level" */
export type User_Fk_Level_Avg_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_fk_level". All fields are combined with a logical 'AND'. */
export type User_Fk_Level_Bool_Exp = {
  _and?: InputMaybe<Array<User_Fk_Level_Bool_Exp>>;
  _not?: InputMaybe<User_Fk_Level_Bool_Exp>;
  _or?: InputMaybe<Array<User_Fk_Level_Bool_Exp>>;
  brake_use?: InputMaybe<Float8_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  economic_range?: InputMaybe<Float8_Comparison_Exp>;
  engine_load?: InputMaybe<Float8_Comparison_Exp>;
  inertia?: InputMaybe<Float8_Comparison_Exp>;
  level?: InputMaybe<Level_Bool_Exp>;
  level_number?: InputMaybe<Int_Comparison_Exp>;
  level_option?: InputMaybe<Level_Option_Bool_Exp>;
  level_option_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  note?: InputMaybe<Float8_Comparison_Exp>;
  reference_date?: InputMaybe<Date_Comparison_Exp>;
  slow_running?: InputMaybe<Float8_Comparison_Exp>;
  speed_control?: InputMaybe<Float8_Comparison_Exp>;
  truncated_month_reference_date?: InputMaybe<Date_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_fk_level" */
export enum User_Fk_Level_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserFkLevelPkey = 'user_fk_level_pkey',
  /** unique or primary key constraint on columns "reference_date", "user_uuid" */
  UserFkLevelUserUuidReferenceDateKey = 'user_fk_level_user_uuid_reference_date_key'
}

/** input type for incrementing numeric columns in table "user_fk_level" */
export type User_Fk_Level_Inc_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "user_fk_level" */
export type User_Fk_Level_Insert_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  level?: InputMaybe<Level_Obj_Rel_Insert_Input>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  level_option?: InputMaybe<Level_Option_Obj_Rel_Insert_Input>;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid?: InputMaybe<Scalars['uuid']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date?: InputMaybe<Scalars['date']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Fk_Level_Max_Fields = {
  __typename?: 'user_fk_level_max_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Int']['output']>;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid: Maybe<Scalars['uuid']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date: Maybe<Scalars['date']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  truncated_month_reference_date: Maybe<Scalars['date']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_fk_level" */
export type User_Fk_Level_Max_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  truncated_month_reference_date?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Fk_Level_Min_Fields = {
  __typename?: 'user_fk_level_min_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Int']['output']>;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid: Maybe<Scalars['uuid']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date: Maybe<Scalars['date']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  truncated_month_reference_date: Maybe<Scalars['date']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_fk_level" */
export type User_Fk_Level_Min_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  truncated_month_reference_date?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_fk_level" */
export type User_Fk_Level_Mutation_Response = {
  __typename?: 'user_fk_level_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Fk_Level>;
};

/** on_conflict condition type for table "user_fk_level" */
export type User_Fk_Level_On_Conflict = {
  constraint: User_Fk_Level_Constraint;
  update_columns?: Array<User_Fk_Level_Update_Column>;
  where?: InputMaybe<User_Fk_Level_Bool_Exp>;
};

/** Ordering options when selecting data from "user_fk_level". */
export type User_Fk_Level_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  level?: InputMaybe<Level_Order_By>;
  level_number?: InputMaybe<Order_By>;
  level_option?: InputMaybe<Level_Option_Order_By>;
  level_option_uuid?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  reference_date?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  truncated_month_reference_date?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_fk_level */
export type User_Fk_Level_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  LevelNumber = 'level_number',
  /** column name */
  LevelOptionUuid = 'level_option_uuid',
  /** column name */
  Note = 'note',
  /** column name */
  ReferenceDate = 'reference_date',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TruncatedMonthReferenceDate = 'truncated_month_reference_date',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** select "user_fk_level_aggregate_bool_exp_avg_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** select "user_fk_level_aggregate_bool_exp_corr_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** select "user_fk_level_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** select "user_fk_level_aggregate_bool_exp_max_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** select "user_fk_level_aggregate_bool_exp_min_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** select "user_fk_level_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** select "user_fk_level_aggregate_bool_exp_sum_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** select "user_fk_level_aggregate_bool_exp_var_samp_arguments_columns" columns of table "user_fk_level" */
export enum User_Fk_Level_Select_Column_User_Fk_Level_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control'
}

/** input type for updating data in table "user_fk_level" */
export type User_Fk_Level_Set_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid?: InputMaybe<Scalars['uuid']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date?: InputMaybe<Scalars['date']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type User_Fk_Level_Stddev_Fields = {
  __typename?: 'user_fk_level_stddev_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_fk_level" */
export type User_Fk_Level_Stddev_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Fk_Level_Stddev_Pop_Fields = {
  __typename?: 'user_fk_level_stddev_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_fk_level" */
export type User_Fk_Level_Stddev_Pop_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Fk_Level_Stddev_Samp_Fields = {
  __typename?: 'user_fk_level_stddev_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_fk_level" */
export type User_Fk_Level_Stddev_Samp_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_fk_level" */
export type User_Fk_Level_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Fk_Level_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Fk_Level_Stream_Cursor_Value_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Scalars['Int']['input']>;
  /** The level_option that was used to set this level to this user, for history purpose */
  level_option_uuid?: InputMaybe<Scalars['uuid']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  /** The reference date of this user-level relationship. This usually will be the score_processed.start_at of each processing */
  reference_date?: InputMaybe<Scalars['date']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  truncated_month_reference_date?: InputMaybe<Scalars['date']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type User_Fk_Level_Sum_Fields = {
  __typename?: 'user_fk_level_sum_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Int']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "user_fk_level" */
export type User_Fk_Level_Sum_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** update columns of table "user_fk_level" */
export enum User_Fk_Level_Update_Column {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  LevelNumber = 'level_number',
  /** column name */
  LevelOptionUuid = 'level_option_uuid',
  /** column name */
  Note = 'note',
  /** column name */
  ReferenceDate = 'reference_date',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type User_Fk_Level_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<User_Fk_Level_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Fk_Level_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Fk_Level_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Fk_Level_Var_Pop_Fields = {
  __typename?: 'user_fk_level_var_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_fk_level" */
export type User_Fk_Level_Var_Pop_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Fk_Level_Var_Samp_Fields = {
  __typename?: 'user_fk_level_var_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_fk_level" */
export type User_Fk_Level_Var_Samp_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Fk_Level_Variance_Fields = {
  __typename?: 'user_fk_level_variance_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_fk_level" */
export type User_Fk_Level_Variance_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  /** The current user level at this processing. This can be retrieved by level_option.level_number, it's here for convenience */
  level_number?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
};

/** All the users that will receive a specific notification. **Don't insert users after the notification was sent */
export type User_Fk_Notification = {
  __typename?: 'user_fk_notification';
  /** An object relationship */
  notification: Notification;
  notification_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_fk_notification" */
export type User_Fk_Notification_Aggregate = {
  __typename?: 'user_fk_notification_aggregate';
  aggregate: Maybe<User_Fk_Notification_Aggregate_Fields>;
  nodes: Array<User_Fk_Notification>;
};

export type User_Fk_Notification_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Fk_Notification_Aggregate_Bool_Exp_Count>;
};

export type User_Fk_Notification_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Notification_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_fk_notification" */
export type User_Fk_Notification_Aggregate_Fields = {
  __typename?: 'user_fk_notification_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<User_Fk_Notification_Max_Fields>;
  min: Maybe<User_Fk_Notification_Min_Fields>;
};


/** aggregate fields of "user_fk_notification" */
export type User_Fk_Notification_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Fk_Notification_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_fk_notification" */
export type User_Fk_Notification_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Fk_Notification_Max_Order_By>;
  min?: InputMaybe<User_Fk_Notification_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_fk_notification" */
export type User_Fk_Notification_Arr_Rel_Insert_Input = {
  data: Array<User_Fk_Notification_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Fk_Notification_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_fk_notification". All fields are combined with a logical 'AND'. */
export type User_Fk_Notification_Bool_Exp = {
  _and?: InputMaybe<Array<User_Fk_Notification_Bool_Exp>>;
  _not?: InputMaybe<User_Fk_Notification_Bool_Exp>;
  _or?: InputMaybe<Array<User_Fk_Notification_Bool_Exp>>;
  notification?: InputMaybe<Notification_Bool_Exp>;
  notification_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_fk_notification" */
export enum User_Fk_Notification_Constraint {
  /** unique or primary key constraint on columns "user_uuid", "notification_uuid" */
  UserFkNotificationPkey = 'user_fk_notification_pkey'
}

/** input type for inserting data into table "user_fk_notification" */
export type User_Fk_Notification_Insert_Input = {
  notification?: InputMaybe<Notification_Obj_Rel_Insert_Input>;
  notification_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Fk_Notification_Max_Fields = {
  __typename?: 'user_fk_notification_max_fields';
  notification_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_fk_notification" */
export type User_Fk_Notification_Max_Order_By = {
  notification_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Fk_Notification_Min_Fields = {
  __typename?: 'user_fk_notification_min_fields';
  notification_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_fk_notification" */
export type User_Fk_Notification_Min_Order_By = {
  notification_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_fk_notification" */
export type User_Fk_Notification_Mutation_Response = {
  __typename?: 'user_fk_notification_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Fk_Notification>;
};

/** on_conflict condition type for table "user_fk_notification" */
export type User_Fk_Notification_On_Conflict = {
  constraint: User_Fk_Notification_Constraint;
  update_columns?: Array<User_Fk_Notification_Update_Column>;
  where?: InputMaybe<User_Fk_Notification_Bool_Exp>;
};

/** Ordering options when selecting data from "user_fk_notification". */
export type User_Fk_Notification_Order_By = {
  notification?: InputMaybe<Notification_Order_By>;
  notification_uuid?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_fk_notification */
export type User_Fk_Notification_Pk_Columns_Input = {
  notification_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_fk_notification" */
export enum User_Fk_Notification_Select_Column {
  /** column name */
  NotificationUuid = 'notification_uuid',
  /** column name */
  UserUuid = 'user_uuid'
}

/** input type for updating data in table "user_fk_notification" */
export type User_Fk_Notification_Set_Input = {
  notification_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_fk_notification" */
export type User_Fk_Notification_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Fk_Notification_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Fk_Notification_Stream_Cursor_Value_Input = {
  notification_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_fk_notification" */
export enum User_Fk_Notification_Update_Column {
  /** column name */
  NotificationUuid = 'notification_uuid',
  /** column name */
  UserUuid = 'user_uuid'
}

export type User_Fk_Notification_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Fk_Notification_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Fk_Notification_Bool_Exp;
};

/** columns and relationships of "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy = {
  __typename?: 'user_fk_privacy_policy';
  accepted_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Aggregate = {
  __typename?: 'user_fk_privacy_policy_aggregate';
  aggregate: Maybe<User_Fk_Privacy_Policy_Aggregate_Fields>;
  nodes: Array<User_Fk_Privacy_Policy>;
};

export type User_Fk_Privacy_Policy_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Fk_Privacy_Policy_Aggregate_Bool_Exp_Count>;
};

export type User_Fk_Privacy_Policy_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Aggregate_Fields = {
  __typename?: 'user_fk_privacy_policy_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<User_Fk_Privacy_Policy_Max_Fields>;
  min: Maybe<User_Fk_Privacy_Policy_Min_Fields>;
};


/** aggregate fields of "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Fk_Privacy_Policy_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Fk_Privacy_Policy_Max_Order_By>;
  min?: InputMaybe<User_Fk_Privacy_Policy_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Arr_Rel_Insert_Input = {
  data: Array<User_Fk_Privacy_Policy_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Fk_Privacy_Policy_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_fk_privacy_policy". All fields are combined with a logical 'AND'. */
export type User_Fk_Privacy_Policy_Bool_Exp = {
  _and?: InputMaybe<Array<User_Fk_Privacy_Policy_Bool_Exp>>;
  _not?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
  _or?: InputMaybe<Array<User_Fk_Privacy_Policy_Bool_Exp>>;
  accepted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_fk_privacy_policy" */
export enum User_Fk_Privacy_Policy_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserFkPrivacyPolicyPkey = 'user_fk_privacy_policy_pkey'
}

/** input type for inserting data into table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Insert_Input = {
  accepted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Fk_Privacy_Policy_Max_Fields = {
  __typename?: 'user_fk_privacy_policy_max_fields';
  accepted_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Max_Order_By = {
  accepted_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Fk_Privacy_Policy_Min_Fields = {
  __typename?: 'user_fk_privacy_policy_min_fields';
  accepted_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Min_Order_By = {
  accepted_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Mutation_Response = {
  __typename?: 'user_fk_privacy_policy_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Fk_Privacy_Policy>;
};

/** on_conflict condition type for table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_On_Conflict = {
  constraint: User_Fk_Privacy_Policy_Constraint;
  update_columns?: Array<User_Fk_Privacy_Policy_Update_Column>;
  where?: InputMaybe<User_Fk_Privacy_Policy_Bool_Exp>;
};

/** Ordering options when selecting data from "user_fk_privacy_policy". */
export type User_Fk_Privacy_Policy_Order_By = {
  accepted_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_fk_privacy_policy */
export type User_Fk_Privacy_Policy_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_fk_privacy_policy" */
export enum User_Fk_Privacy_Policy_Select_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Set_Input = {
  accepted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_fk_privacy_policy" */
export type User_Fk_Privacy_Policy_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Fk_Privacy_Policy_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Fk_Privacy_Policy_Stream_Cursor_Value_Input = {
  accepted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_fk_privacy_policy" */
export enum User_Fk_Privacy_Policy_Update_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type User_Fk_Privacy_Policy_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Fk_Privacy_Policy_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Fk_Privacy_Policy_Bool_Exp;
};

/** input type for inserting data into table "user" */
export type User_Insert_Input = {
  admitted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['date']['input']>;
  cpf?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_warnings?: InputMaybe<Driver_Warning_Arr_Rel_Insert_Input>;
  /** If the user is enabled or not. This is overwritten in case it's not a driver with the driver replication cron event */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  instructor_supervisions?: InputMaybe<Instructor_Supervision_Arr_Rel_Insert_Input>;
  license_plate?: InputMaybe<Scalars['String']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  product_requests?: InputMaybe<Product_Request_Arr_Rel_Insert_Input>;
  refresh_tokens?: InputMaybe<Refresh_Token_Arr_Rel_Insert_Input>;
  training_document_views?: InputMaybe<Training_Document_View_Arr_Rel_Insert_Input>;
  user_fk_achievements?: InputMaybe<User_Fk_Achievement_Arr_Rel_Insert_Input>;
  user_fk_levels?: InputMaybe<User_Fk_Level_Arr_Rel_Insert_Input>;
  user_fk_notifications?: InputMaybe<User_Fk_Notification_Arr_Rel_Insert_Input>;
  user_fk_privacy_policies?: InputMaybe<User_Fk_Privacy_Policy_Arr_Rel_Insert_Input>;
  user_km_points_approvals?: InputMaybe<User_Km_Points_Approval_Arr_Rel_Insert_Input>;
  user_kmps?: InputMaybe<User_Kmps_Arr_Rel_Insert_Input>;
  user_score_rankings?: InputMaybe<User_Score_Ranking_Arr_Rel_Insert_Input>;
  user_scores?: InputMaybe<User_Score_Arr_Rel_Insert_Input>;
  user_trainings?: InputMaybe<User_Training_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** columns and relationships of "user_km_points_approval" */
export type User_Km_Points_Approval = {
  __typename?: 'user_km_points_approval';
  /** An object relationship */
  admin: Maybe<Admin>;
  /** The admin whom approved/declined the user points */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** When the admin approved this points to this user */
  approved_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** When the admin declined this points to this user */
  declined_at: Maybe<Scalars['timestamptz']['output']>;
  /** A brief description of this approval details */
  description: Scalars['String']['output'];
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Int']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['float8']['output']>;
  /** The total points that will be given to the user if approved */
  points: Scalars['Int']['output'];
  /** An object relationship */
  score_processed: Maybe<Score_Processed>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: User;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  user_kmps: Array<User_Kmps>;
  /** An aggregate relationship */
  user_kmps_aggregate: User_Kmps_Aggregate;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "user_km_points_approval" */
export type User_Km_Points_ApprovalUser_KmpsArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};


/** columns and relationships of "user_km_points_approval" */
export type User_Km_Points_ApprovalUser_Kmps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Kmps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Kmps_Order_By>>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};

/** aggregated selection of "user_km_points_approval" */
export type User_Km_Points_Approval_Aggregate = {
  __typename?: 'user_km_points_approval_aggregate';
  aggregate: Maybe<User_Km_Points_Approval_Aggregate_Fields>;
  nodes: Array<User_Km_Points_Approval>;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp = {
  avg?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<User_Km_Points_Approval_Aggregate_Bool_Exp_Var_Samp>;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Avg = {
  arguments: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Corr = {
  arguments: User_Km_Points_Approval_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Corr_Arguments = {
  X: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: User_Km_Points_Approval_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Max = {
  arguments: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Min = {
  arguments: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Sum = {
  arguments: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Km_Points_Approval_Aggregate_Bool_Exp_Var_Samp = {
  arguments: User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "user_km_points_approval" */
export type User_Km_Points_Approval_Aggregate_Fields = {
  __typename?: 'user_km_points_approval_aggregate_fields';
  avg: Maybe<User_Km_Points_Approval_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<User_Km_Points_Approval_Max_Fields>;
  min: Maybe<User_Km_Points_Approval_Min_Fields>;
  stddev: Maybe<User_Km_Points_Approval_Stddev_Fields>;
  stddev_pop: Maybe<User_Km_Points_Approval_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Km_Points_Approval_Stddev_Samp_Fields>;
  sum: Maybe<User_Km_Points_Approval_Sum_Fields>;
  var_pop: Maybe<User_Km_Points_Approval_Var_Pop_Fields>;
  var_samp: Maybe<User_Km_Points_Approval_Var_Samp_Fields>;
  variance: Maybe<User_Km_Points_Approval_Variance_Fields>;
};


/** aggregate fields of "user_km_points_approval" */
export type User_Km_Points_Approval_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Km_Points_Approval_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_km_points_approval" */
export type User_Km_Points_Approval_Aggregate_Order_By = {
  avg?: InputMaybe<User_Km_Points_Approval_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Km_Points_Approval_Max_Order_By>;
  min?: InputMaybe<User_Km_Points_Approval_Min_Order_By>;
  stddev?: InputMaybe<User_Km_Points_Approval_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Km_Points_Approval_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Km_Points_Approval_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Km_Points_Approval_Sum_Order_By>;
  var_pop?: InputMaybe<User_Km_Points_Approval_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Km_Points_Approval_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Km_Points_Approval_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_km_points_approval" */
export type User_Km_Points_Approval_Arr_Rel_Insert_Input = {
  data: Array<User_Km_Points_Approval_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Km_Points_Approval_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Km_Points_Approval_Avg_Fields = {
  __typename?: 'user_km_points_approval_avg_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Float']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['Float']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Float']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Avg_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_km_points_approval". All fields are combined with a logical 'AND'. */
export type User_Km_Points_Approval_Bool_Exp = {
  _and?: InputMaybe<Array<User_Km_Points_Approval_Bool_Exp>>;
  _not?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  _or?: InputMaybe<Array<User_Km_Points_Approval_Bool_Exp>>;
  admin?: InputMaybe<Admin_Bool_Exp>;
  admin_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  approved_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  declined_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  fidelity_range_points_id?: InputMaybe<Int_Comparison_Exp>;
  km_multiplier?: InputMaybe<Float8_Comparison_Exp>;
  points?: InputMaybe<Int_Comparison_Exp>;
  score_processed?: InputMaybe<Score_Processed_Bool_Exp>;
  score_processed_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  total_km?: InputMaybe<Float8_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_admitted_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_kmps?: InputMaybe<User_Kmps_Bool_Exp>;
  user_kmps_aggregate?: InputMaybe<User_Kmps_Aggregate_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_km_points_approval" */
export enum User_Km_Points_Approval_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserKmPointsApprovalPkey = 'user_km_points_approval_pkey'
}

/** input type for incrementing numeric columns in table "user_km_points_approval" */
export type User_Km_Points_Approval_Inc_Input = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Scalars['Int']['input']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Scalars['float8']['input']>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Scalars['Int']['input']>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "user_km_points_approval" */
export type User_Km_Points_Approval_Insert_Input = {
  admin?: InputMaybe<Admin_Obj_Rel_Insert_Input>;
  /** The admin whom approved/declined the user points */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** When the admin approved this points to this user */
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When the admin declined this points to this user */
  declined_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A brief description of this approval details */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Scalars['Int']['input']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Scalars['float8']['input']>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Scalars['Int']['input']>;
  score_processed?: InputMaybe<Score_Processed_Obj_Rel_Insert_Input>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_kmps?: InputMaybe<User_Kmps_Arr_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Km_Points_Approval_Max_Fields = {
  __typename?: 'user_km_points_approval_max_fields';
  /** The admin whom approved/declined the user points */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** When the admin approved this points to this user */
  approved_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** When the admin declined this points to this user */
  declined_at: Maybe<Scalars['timestamptz']['output']>;
  /** A brief description of this approval details */
  description: Maybe<Scalars['String']['output']>;
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Int']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['float8']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Int']['output']>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Max_Order_By = {
  /** The admin whom approved/declined the user points */
  admin_uuid?: InputMaybe<Order_By>;
  /** When the admin approved this points to this user */
  approved_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** When the admin declined this points to this user */
  declined_at?: InputMaybe<Order_By>;
  /** A brief description of this approval details */
  description?: InputMaybe<Order_By>;
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Km_Points_Approval_Min_Fields = {
  __typename?: 'user_km_points_approval_min_fields';
  /** The admin whom approved/declined the user points */
  admin_uuid: Maybe<Scalars['uuid']['output']>;
  /** When the admin approved this points to this user */
  approved_at: Maybe<Scalars['timestamptz']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** When the admin declined this points to this user */
  declined_at: Maybe<Scalars['timestamptz']['output']>;
  /** A brief description of this approval details */
  description: Maybe<Scalars['String']['output']>;
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Int']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['float8']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Int']['output']>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Min_Order_By = {
  /** The admin whom approved/declined the user points */
  admin_uuid?: InputMaybe<Order_By>;
  /** When the admin approved this points to this user */
  approved_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** When the admin declined this points to this user */
  declined_at?: InputMaybe<Order_By>;
  /** A brief description of this approval details */
  description?: InputMaybe<Order_By>;
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_km_points_approval" */
export type User_Km_Points_Approval_Mutation_Response = {
  __typename?: 'user_km_points_approval_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Km_Points_Approval>;
};

/** input type for inserting object relation for remote table "user_km_points_approval" */
export type User_Km_Points_Approval_Obj_Rel_Insert_Input = {
  data: User_Km_Points_Approval_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Km_Points_Approval_On_Conflict>;
};

/** on_conflict condition type for table "user_km_points_approval" */
export type User_Km_Points_Approval_On_Conflict = {
  constraint: User_Km_Points_Approval_Constraint;
  update_columns?: Array<User_Km_Points_Approval_Update_Column>;
  where?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
};

/** Ordering options when selecting data from "user_km_points_approval". */
export type User_Km_Points_Approval_Order_By = {
  admin?: InputMaybe<Admin_Order_By>;
  admin_uuid?: InputMaybe<Order_By>;
  approved_at?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  declined_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  fidelity_range_points_id?: InputMaybe<Order_By>;
  km_multiplier?: InputMaybe<Order_By>;
  points?: InputMaybe<Order_By>;
  score_processed?: InputMaybe<Score_Processed_Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_admitted_at?: InputMaybe<Order_By>;
  user_kmps_aggregate?: InputMaybe<User_Kmps_Aggregate_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_km_points_approval */
export type User_Km_Points_Approval_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  ApprovedAt = 'approved_at',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Description = 'description',
  /** column name */
  FidelityRangePointsId = 'fidelity_range_points_id',
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  Points = 'points',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAdmittedAt = 'user_admitted_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** select "user_km_points_approval_aggregate_bool_exp_avg_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_km_points_approval_aggregate_bool_exp_corr_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_km_points_approval_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_km_points_approval_aggregate_bool_exp_max_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_km_points_approval_aggregate_bool_exp_min_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_km_points_approval_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_km_points_approval_aggregate_bool_exp_sum_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_km_points_approval_aggregate_bool_exp_var_samp_arguments_columns" columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Select_Column_User_Km_Points_Approval_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  TotalKm = 'total_km'
}

/** input type for updating data in table "user_km_points_approval" */
export type User_Km_Points_Approval_Set_Input = {
  /** The admin whom approved/declined the user points */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** When the admin approved this points to this user */
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When the admin declined this points to this user */
  declined_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A brief description of this approval details */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Scalars['Int']['input']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Scalars['float8']['input']>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Scalars['Int']['input']>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type User_Km_Points_Approval_Stddev_Fields = {
  __typename?: 'user_km_points_approval_stddev_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Float']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['Float']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Float']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Stddev_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Km_Points_Approval_Stddev_Pop_Fields = {
  __typename?: 'user_km_points_approval_stddev_pop_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Float']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['Float']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Float']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Stddev_Pop_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Km_Points_Approval_Stddev_Samp_Fields = {
  __typename?: 'user_km_points_approval_stddev_samp_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Float']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['Float']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Float']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Stddev_Samp_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_km_points_approval" */
export type User_Km_Points_Approval_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Km_Points_Approval_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Km_Points_Approval_Stream_Cursor_Value_Input = {
  /** The admin whom approved/declined the user points */
  admin_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** When the admin approved this points to this user */
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** When the admin declined this points to this user */
  declined_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A brief description of this approval details */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Scalars['Int']['input']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Scalars['float8']['input']>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Scalars['Int']['input']>;
  /** The score processed related to this approval. This field will be used for tracking issues between calculating ranking */
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The admission date that was used to compute fidelity points */
  user_admitted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type User_Km_Points_Approval_Sum_Fields = {
  __typename?: 'user_km_points_approval_sum_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Int']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['float8']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Int']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Sum_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** update columns of table "user_km_points_approval" */
export enum User_Km_Points_Approval_Update_Column {
  /** column name */
  AdminUuid = 'admin_uuid',
  /** column name */
  ApprovedAt = 'approved_at',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Description = 'description',
  /** column name */
  FidelityRangePointsId = 'fidelity_range_points_id',
  /** column name */
  KmMultiplier = 'km_multiplier',
  /** column name */
  Points = 'points',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAdmittedAt = 'user_admitted_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type User_Km_Points_Approval_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<User_Km_Points_Approval_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Km_Points_Approval_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Km_Points_Approval_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Km_Points_Approval_Var_Pop_Fields = {
  __typename?: 'user_km_points_approval_var_pop_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Float']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['Float']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Float']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Var_Pop_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Km_Points_Approval_Var_Samp_Fields = {
  __typename?: 'user_km_points_approval_var_samp_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Float']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['Float']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Float']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Var_Samp_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Km_Points_Approval_Variance_Fields = {
  __typename?: 'user_km_points_approval_variance_fields';
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id: Maybe<Scalars['Float']['output']>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier: Maybe<Scalars['Float']['output']>;
  /** The total points that will be given to the user if approved */
  points: Maybe<Scalars['Float']['output']>;
  /** The total kilometers used to calculate this amount of points */
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_km_points_approval" */
export type User_Km_Points_Approval_Variance_Order_By = {
  /** The fidelity_range_points row that was used based on the user admission date */
  fidelity_range_points_id?: InputMaybe<Order_By>;
  /** The multiplier that was used to calculate this amount of points to this user */
  km_multiplier?: InputMaybe<Order_By>;
  /** The total points that will be given to the user if approved */
  points?: InputMaybe<Order_By>;
  /** The total kilometers used to calculate this amount of points */
  total_km?: InputMaybe<Order_By>;
};

/** columns and relationships of "user_kmps" */
export type User_Kmps = {
  __typename?: 'user_kmps';
  /** The challenge that gived these points */
  challenge_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** The delivery uuid that refers to this points */
  delivery_uuid: Maybe<Scalars['uuid']['output']>;
  /** The description of the balance change */
  description: Scalars['String']['output'];
  /** An object relationship */
  new_product_request: Maybe<Product_Request>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid: Maybe<Scalars['uuid']['output']>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid: Maybe<Scalars['uuid']['output']>;
  /** The product that was bought with these points */
  product_price_uuid: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  reversal_product_request: Maybe<Product_Request>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  user: User;
  /** An object relationship */
  user_km_points_approval: Maybe<User_Km_Points_Approval>;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
  /** The value added/subtracted from the user balance */
  value: Scalars['Int']['output'];
};

/** aggregated selection of "user_kmps" */
export type User_Kmps_Aggregate = {
  __typename?: 'user_kmps_aggregate';
  aggregate: Maybe<User_Kmps_Aggregate_Fields>;
  nodes: Array<User_Kmps>;
};

export type User_Kmps_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Kmps_Aggregate_Bool_Exp_Count>;
};

export type User_Kmps_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Kmps_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Kmps_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_kmps" */
export type User_Kmps_Aggregate_Fields = {
  __typename?: 'user_kmps_aggregate_fields';
  avg: Maybe<User_Kmps_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<User_Kmps_Max_Fields>;
  min: Maybe<User_Kmps_Min_Fields>;
  stddev: Maybe<User_Kmps_Stddev_Fields>;
  stddev_pop: Maybe<User_Kmps_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Kmps_Stddev_Samp_Fields>;
  sum: Maybe<User_Kmps_Sum_Fields>;
  var_pop: Maybe<User_Kmps_Var_Pop_Fields>;
  var_samp: Maybe<User_Kmps_Var_Samp_Fields>;
  variance: Maybe<User_Kmps_Variance_Fields>;
};


/** aggregate fields of "user_kmps" */
export type User_Kmps_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Kmps_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_kmps" */
export type User_Kmps_Aggregate_Order_By = {
  avg?: InputMaybe<User_Kmps_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Kmps_Max_Order_By>;
  min?: InputMaybe<User_Kmps_Min_Order_By>;
  stddev?: InputMaybe<User_Kmps_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Kmps_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Kmps_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Kmps_Sum_Order_By>;
  var_pop?: InputMaybe<User_Kmps_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Kmps_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Kmps_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_kmps" */
export type User_Kmps_Arr_Rel_Insert_Input = {
  data: Array<User_Kmps_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Kmps_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Kmps_Avg_Fields = {
  __typename?: 'user_kmps_avg_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_kmps" */
export type User_Kmps_Avg_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_kmps". All fields are combined with a logical 'AND'. */
export type User_Kmps_Bool_Exp = {
  _and?: InputMaybe<Array<User_Kmps_Bool_Exp>>;
  _not?: InputMaybe<User_Kmps_Bool_Exp>;
  _or?: InputMaybe<Array<User_Kmps_Bool_Exp>>;
  challenge_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  new_product_request?: InputMaybe<Product_Request_Bool_Exp>;
  new_product_request_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  points_approval_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  product_price_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  reversal_product_request?: InputMaybe<Product_Request_Bool_Exp>;
  reversal_product_request_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_km_points_approval?: InputMaybe<User_Km_Points_Approval_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  value?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_kmps" */
export enum User_Kmps_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserKmpsPkey = 'user_kmps_pkey'
}

/** input type for incrementing numeric columns in table "user_kmps" */
export type User_Kmps_Inc_Input = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_kmps" */
export type User_Kmps_Insert_Input = {
  /** The challenge that gived these points */
  challenge_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The delivery uuid that refers to this points */
  delivery_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The description of the balance change */
  description?: InputMaybe<Scalars['String']['input']>;
  new_product_request?: InputMaybe<Product_Request_Obj_Rel_Insert_Input>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The product that was bought with these points */
  product_price_uuid?: InputMaybe<Scalars['uuid']['input']>;
  reversal_product_request?: InputMaybe<Product_Request_Obj_Rel_Insert_Input>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_km_points_approval?: InputMaybe<User_Km_Points_Approval_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type User_Kmps_Max_Fields = {
  __typename?: 'user_kmps_max_fields';
  /** The challenge that gived these points */
  challenge_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The delivery uuid that refers to this points */
  delivery_uuid: Maybe<Scalars['uuid']['output']>;
  /** The description of the balance change */
  description: Maybe<Scalars['String']['output']>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid: Maybe<Scalars['uuid']['output']>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid: Maybe<Scalars['uuid']['output']>;
  /** The product that was bought with these points */
  product_price_uuid: Maybe<Scalars['uuid']['output']>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "user_kmps" */
export type User_Kmps_Max_Order_By = {
  /** The challenge that gived these points */
  challenge_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** The delivery uuid that refers to this points */
  delivery_uuid?: InputMaybe<Order_By>;
  /** The description of the balance change */
  description?: InputMaybe<Order_By>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid?: InputMaybe<Order_By>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid?: InputMaybe<Order_By>;
  /** The product that was bought with these points */
  product_price_uuid?: InputMaybe<Order_By>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Kmps_Min_Fields = {
  __typename?: 'user_kmps_min_fields';
  /** The challenge that gived these points */
  challenge_uuid: Maybe<Scalars['uuid']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The delivery uuid that refers to this points */
  delivery_uuid: Maybe<Scalars['uuid']['output']>;
  /** The description of the balance change */
  description: Maybe<Scalars['String']['output']>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid: Maybe<Scalars['uuid']['output']>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid: Maybe<Scalars['uuid']['output']>;
  /** The product that was bought with these points */
  product_price_uuid: Maybe<Scalars['uuid']['output']>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid: Maybe<Scalars['uuid']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "user_kmps" */
export type User_Kmps_Min_Order_By = {
  /** The challenge that gived these points */
  challenge_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** The delivery uuid that refers to this points */
  delivery_uuid?: InputMaybe<Order_By>;
  /** The description of the balance change */
  description?: InputMaybe<Order_By>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid?: InputMaybe<Order_By>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid?: InputMaybe<Order_By>;
  /** The product that was bought with these points */
  product_price_uuid?: InputMaybe<Order_By>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_kmps" */
export type User_Kmps_Mutation_Response = {
  __typename?: 'user_kmps_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Kmps>;
};

/** on_conflict condition type for table "user_kmps" */
export type User_Kmps_On_Conflict = {
  constraint: User_Kmps_Constraint;
  update_columns?: Array<User_Kmps_Update_Column>;
  where?: InputMaybe<User_Kmps_Bool_Exp>;
};

/** Ordering options when selecting data from "user_kmps". */
export type User_Kmps_Order_By = {
  challenge_uuid?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  delivery_uuid?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  new_product_request?: InputMaybe<Product_Request_Order_By>;
  new_product_request_uuid?: InputMaybe<Order_By>;
  points_approval_uuid?: InputMaybe<Order_By>;
  product_price_uuid?: InputMaybe<Order_By>;
  reversal_product_request?: InputMaybe<Product_Request_Order_By>;
  reversal_product_request_uuid?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_km_points_approval?: InputMaybe<User_Km_Points_Approval_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_kmps */
export type User_Kmps_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_kmps" */
export enum User_Kmps_Select_Column {
  /** column name */
  ChallengeUuid = 'challenge_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeliveryUuid = 'delivery_uuid',
  /** column name */
  Description = 'description',
  /** column name */
  NewProductRequestUuid = 'new_product_request_uuid',
  /** column name */
  PointsApprovalUuid = 'points_approval_uuid',
  /** column name */
  ProductPriceUuid = 'product_price_uuid',
  /** column name */
  ReversalProductRequestUuid = 'reversal_product_request_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "user_kmps" */
export type User_Kmps_Set_Input = {
  /** The challenge that gived these points */
  challenge_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The delivery uuid that refers to this points */
  delivery_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The description of the balance change */
  description?: InputMaybe<Scalars['String']['input']>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The product that was bought with these points */
  product_price_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type User_Kmps_Stddev_Fields = {
  __typename?: 'user_kmps_stddev_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_kmps" */
export type User_Kmps_Stddev_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Kmps_Stddev_Pop_Fields = {
  __typename?: 'user_kmps_stddev_pop_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_kmps" */
export type User_Kmps_Stddev_Pop_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Kmps_Stddev_Samp_Fields = {
  __typename?: 'user_kmps_stddev_samp_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_kmps" */
export type User_Kmps_Stddev_Samp_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_kmps" */
export type User_Kmps_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Kmps_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Kmps_Stream_Cursor_Value_Input = {
  /** The challenge that gived these points */
  challenge_uuid?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The delivery uuid that refers to this points */
  delivery_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The description of the balance change */
  description?: InputMaybe<Scalars['String']['input']>;
  /** When the user buy some product this is the newly created product request */
  new_product_request_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** It's the relation used when the user receive points approved by some admin based on the distance travelled and the level multiplier */
  points_approval_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The product that was bought with these points */
  product_price_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** In case of a cancelled product request, a reversal occurs with this relationship */
  reversal_product_request_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type User_Kmps_Sum_Fields = {
  __typename?: 'user_kmps_sum_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "user_kmps" */
export type User_Kmps_Sum_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** update columns of table "user_kmps" */
export enum User_Kmps_Update_Column {
  /** column name */
  ChallengeUuid = 'challenge_uuid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeliveryUuid = 'delivery_uuid',
  /** column name */
  Description = 'description',
  /** column name */
  NewProductRequestUuid = 'new_product_request_uuid',
  /** column name */
  PointsApprovalUuid = 'points_approval_uuid',
  /** column name */
  ProductPriceUuid = 'product_price_uuid',
  /** column name */
  ReversalProductRequestUuid = 'reversal_product_request_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  Value = 'value'
}

export type User_Kmps_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<User_Kmps_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Kmps_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Kmps_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Kmps_Var_Pop_Fields = {
  __typename?: 'user_kmps_var_pop_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_kmps" */
export type User_Kmps_Var_Pop_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Kmps_Var_Samp_Fields = {
  __typename?: 'user_kmps_var_samp_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_kmps" */
export type User_Kmps_Var_Samp_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Kmps_Variance_Fields = {
  __typename?: 'user_kmps_variance_fields';
  /** The value added/subtracted from the user balance */
  value: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_kmps" */
export type User_Kmps_Variance_Order_By = {
  /** The value added/subtracted from the user balance */
  value?: InputMaybe<Order_By>;
};

/** aggregate max on columns */
export type User_Max_Fields = {
  __typename?: 'user_max_fields';
  admitted_at: Maybe<Scalars['timestamptz']['output']>;
  avatar_url: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  birthdate: Maybe<Scalars['date']['output']>;
  cpf: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  license_plate: Maybe<Scalars['String']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  password: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type User_Min_Fields = {
  __typename?: 'user_min_fields';
  admitted_at: Maybe<Scalars['timestamptz']['output']>;
  avatar_url: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  birthdate: Maybe<Scalars['date']['output']>;
  cpf: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  license_plate: Maybe<Scalars['String']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  password: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "user" */
export type User_Mutation_Response = {
  __typename?: 'user_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User>;
};

/** input type for inserting object relation for remote table "user" */
export type User_Obj_Rel_Insert_Input = {
  data: User_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<User_On_Conflict>;
};

/** on_conflict condition type for table "user" */
export type User_On_Conflict = {
  constraint: User_Constraint;
  update_columns?: Array<User_Update_Column>;
  where?: InputMaybe<User_Bool_Exp>;
};

/** Ordering options when selecting data from "user". */
export type User_Order_By = {
  accepted_privacy_policy?: InputMaybe<Order_By>;
  admitted_at?: InputMaybe<Order_By>;
  avatar_url?: InputMaybe<Order_By>;
  balance?: InputMaybe<Order_By>;
  birthdate?: InputMaybe<Order_By>;
  cpf?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  current_level_number?: InputMaybe<Order_By>;
  current_level_option_aggregate?: InputMaybe<Level_Option_Aggregate_Order_By>;
  driver_warnings_aggregate?: InputMaybe<Driver_Warning_Aggregate_Order_By>;
  enabled?: InputMaybe<Order_By>;
  instructor_supervisions_aggregate?: InputMaybe<Instructor_Supervision_Aggregate_Order_By>;
  license_plate?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  password?: InputMaybe<Order_By>;
  product_requests_aggregate?: InputMaybe<Product_Request_Aggregate_Order_By>;
  refresh_tokens_aggregate?: InputMaybe<Refresh_Token_Aggregate_Order_By>;
  score_average?: InputMaybe<Order_By>;
  training_document_views_aggregate?: InputMaybe<Training_Document_View_Aggregate_Order_By>;
  user_fk_achievements_aggregate?: InputMaybe<User_Fk_Achievement_Aggregate_Order_By>;
  user_fk_levels_aggregate?: InputMaybe<User_Fk_Level_Aggregate_Order_By>;
  user_fk_notifications_aggregate?: InputMaybe<User_Fk_Notification_Aggregate_Order_By>;
  user_fk_privacy_policies_aggregate?: InputMaybe<User_Fk_Privacy_Policy_Aggregate_Order_By>;
  user_km_points_approvals_aggregate?: InputMaybe<User_Km_Points_Approval_Aggregate_Order_By>;
  user_kmps_aggregate?: InputMaybe<User_Kmps_Aggregate_Order_By>;
  user_score_rankings_aggregate?: InputMaybe<User_Score_Ranking_Aggregate_Order_By>;
  user_scores_aggregate?: InputMaybe<User_Score_Aggregate_Order_By>;
  user_trainings_aggregate?: InputMaybe<User_Training_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user */
export type User_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "user_score" */
export type User_Score = {
  __typename?: 'user_score';
  brake_use: Scalars['float8']['output'];
  consumed_fuel: Scalars['float8']['output'];
  created_at: Scalars['timestamptz']['output'];
  economic_range: Scalars['float8']['output'];
  engine_load: Scalars['float8']['output'];
  inertia: Scalars['float8']['output'];
  motorista_code: Scalars['String']['output'];
  note: Scalars['float8']['output'];
  /** An object relationship */
  score_processed: Score_Processed;
  score_processed_uuid: Scalars['uuid']['output'];
  slow_running: Scalars['float8']['output'];
  speed_control: Scalars['float8']['output'];
  total_km: Maybe<Scalars['float8']['output']>;
  total_time: Maybe<Scalars['float8']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: User;
  uuid: Scalars['uuid']['output'];
};

export type User_Score_ActionType = {
  __typename?: 'user_score_ActionType';
  brake_use: Scalars['float8']['output'];
  consumed_fuel: Scalars['float8']['output'];
  created_at: Scalars['timestamptz']['output'];
  economic_range: Scalars['float8']['output'];
  engine_load: Scalars['float8']['output'];
  inertia: Scalars['float8']['output'];
  motorista_code: Scalars['String']['output'];
  note: Scalars['float8']['output'];
  score_processed_uuid: Scalars['uuid']['output'];
  slow_running: Scalars['float8']['output'];
  speed_control: Scalars['float8']['output'];
  total_km: Maybe<Scalars['float8']['output']>;
  total_time: Maybe<Scalars['float8']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_score" */
export type User_Score_Aggregate = {
  __typename?: 'user_score_aggregate';
  aggregate: Maybe<User_Score_Aggregate_Fields>;
  nodes: Array<User_Score>;
};

export type User_Score_Aggregate_Bool_Exp = {
  avg?: InputMaybe<User_Score_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<User_Score_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<User_Score_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<User_Score_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<User_Score_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<User_Score_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<User_Score_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<User_Score_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<User_Score_Aggregate_Bool_Exp_Var_Samp>;
};

export type User_Score_Aggregate_Bool_Exp_Avg = {
  arguments: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Corr = {
  arguments: User_Score_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Corr_Arguments = {
  X: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type User_Score_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Score_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: User_Score_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type User_Score_Aggregate_Bool_Exp_Max = {
  arguments: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Min = {
  arguments: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Sum = {
  arguments: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Aggregate_Bool_Exp_Var_Samp = {
  arguments: User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "user_score" */
export type User_Score_Aggregate_Fields = {
  __typename?: 'user_score_aggregate_fields';
  avg: Maybe<User_Score_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<User_Score_Max_Fields>;
  min: Maybe<User_Score_Min_Fields>;
  stddev: Maybe<User_Score_Stddev_Fields>;
  stddev_pop: Maybe<User_Score_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Score_Stddev_Samp_Fields>;
  sum: Maybe<User_Score_Sum_Fields>;
  var_pop: Maybe<User_Score_Var_Pop_Fields>;
  var_samp: Maybe<User_Score_Var_Samp_Fields>;
  variance: Maybe<User_Score_Variance_Fields>;
};


/** aggregate fields of "user_score" */
export type User_Score_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Score_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_score" */
export type User_Score_Aggregate_Order_By = {
  avg?: InputMaybe<User_Score_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Score_Max_Order_By>;
  min?: InputMaybe<User_Score_Min_Order_By>;
  stddev?: InputMaybe<User_Score_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Score_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Score_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Score_Sum_Order_By>;
  var_pop?: InputMaybe<User_Score_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Score_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Score_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_score" */
export type User_Score_Arr_Rel_Insert_Input = {
  data: Array<User_Score_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Score_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Score_Avg_Fields = {
  __typename?: 'user_score_avg_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_time: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_score" */
export type User_Score_Avg_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_score". All fields are combined with a logical 'AND'. */
export type User_Score_Bool_Exp = {
  _and?: InputMaybe<Array<User_Score_Bool_Exp>>;
  _not?: InputMaybe<User_Score_Bool_Exp>;
  _or?: InputMaybe<Array<User_Score_Bool_Exp>>;
  brake_use?: InputMaybe<Float8_Comparison_Exp>;
  consumed_fuel?: InputMaybe<Float8_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  economic_range?: InputMaybe<Float8_Comparison_Exp>;
  engine_load?: InputMaybe<Float8_Comparison_Exp>;
  inertia?: InputMaybe<Float8_Comparison_Exp>;
  motorista_code?: InputMaybe<String_Comparison_Exp>;
  note?: InputMaybe<Float8_Comparison_Exp>;
  score_processed?: InputMaybe<Score_Processed_Bool_Exp>;
  score_processed_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  slow_running?: InputMaybe<Float8_Comparison_Exp>;
  speed_control?: InputMaybe<Float8_Comparison_Exp>;
  total_km?: InputMaybe<Float8_Comparison_Exp>;
  total_time?: InputMaybe<Float8_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_score" */
export enum User_Score_Constraint {
  /** unique or primary key constraint on columns "motorista_code", "score_processed_uuid" */
  UserScoreMotoristaCodeScoreProcessedUuidKey = 'user_score_motorista_code_score_processed_uuid_key',
  /** unique or primary key constraint on columns "uuid" */
  UserScorePkey = 'user_score_pkey'
}

/** input type for incrementing numeric columns in table "user_score" */
export type User_Score_Inc_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_time?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "user_score" */
export type User_Score_Insert_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  score_processed?: InputMaybe<Score_Processed_Obj_Rel_Insert_Input>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_time?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Score_Max_Fields = {
  __typename?: 'user_score_max_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  consumed_fuel: Maybe<Scalars['float8']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_time: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_score" */
export type User_Score_Max_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Score_Min_Fields = {
  __typename?: 'user_score_min_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  consumed_fuel: Maybe<Scalars['float8']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_time: Maybe<Scalars['float8']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_score" */
export type User_Score_Min_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_score" */
export type User_Score_Mutation_Response = {
  __typename?: 'user_score_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Score>;
};

/** on_conflict condition type for table "user_score" */
export type User_Score_On_Conflict = {
  constraint: User_Score_Constraint;
  update_columns?: Array<User_Score_Update_Column>;
  where?: InputMaybe<User_Score_Bool_Exp>;
};

/** Ordering options when selecting data from "user_score". */
export type User_Score_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  score_processed?: InputMaybe<Score_Processed_Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_score */
export type User_Score_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "user_score_ranking" */
export type User_Score_Ranking = {
  __typename?: 'user_score_ranking';
  /** An object relationship */
  achievement: Maybe<Achievement>;
  achievement_uuid: Maybe<Scalars['uuid']['output']>;
  avatar_url: Maybe<Scalars['String']['output']>;
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  /** An object relationship */
  level_option: Maybe<Level_Option>;
  level_option_uuid: Maybe<Scalars['uuid']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  position: Maybe<Scalars['bigint']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  score_processed: Maybe<Score_Processed>;
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  /** An object relationship */
  user: Maybe<User>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "user_score_ranking" */
export type User_Score_Ranking_Aggregate = {
  __typename?: 'user_score_ranking_aggregate';
  aggregate: Maybe<User_Score_Ranking_Aggregate_Fields>;
  nodes: Array<User_Score_Ranking>;
};

export type User_Score_Ranking_Aggregate_Bool_Exp = {
  avg?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Avg>;
  corr?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Corr>;
  count?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Count>;
  covar_samp?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Covar_Samp>;
  max?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Max>;
  min?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Min>;
  stddev_samp?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Sum>;
  var_samp?: InputMaybe<User_Score_Ranking_Aggregate_Bool_Exp_Var_Samp>;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Avg = {
  arguments: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Corr = {
  arguments: User_Score_Ranking_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Corr_Arguments = {
  X: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: User_Score_Ranking_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Max = {
  arguments: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Min = {
  arguments: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Sum = {
  arguments: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type User_Score_Ranking_Aggregate_Bool_Exp_Var_Samp = {
  arguments: User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "user_score_ranking" */
export type User_Score_Ranking_Aggregate_Fields = {
  __typename?: 'user_score_ranking_aggregate_fields';
  avg: Maybe<User_Score_Ranking_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<User_Score_Ranking_Max_Fields>;
  min: Maybe<User_Score_Ranking_Min_Fields>;
  stddev: Maybe<User_Score_Ranking_Stddev_Fields>;
  stddev_pop: Maybe<User_Score_Ranking_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Score_Ranking_Stddev_Samp_Fields>;
  sum: Maybe<User_Score_Ranking_Sum_Fields>;
  var_pop: Maybe<User_Score_Ranking_Var_Pop_Fields>;
  var_samp: Maybe<User_Score_Ranking_Var_Samp_Fields>;
  variance: Maybe<User_Score_Ranking_Variance_Fields>;
};


/** aggregate fields of "user_score_ranking" */
export type User_Score_Ranking_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Score_Ranking_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_score_ranking" */
export type User_Score_Ranking_Aggregate_Order_By = {
  avg?: InputMaybe<User_Score_Ranking_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Score_Ranking_Max_Order_By>;
  min?: InputMaybe<User_Score_Ranking_Min_Order_By>;
  stddev?: InputMaybe<User_Score_Ranking_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Score_Ranking_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Score_Ranking_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Score_Ranking_Sum_Order_By>;
  var_pop?: InputMaybe<User_Score_Ranking_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Score_Ranking_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Score_Ranking_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_score_ranking" */
export type User_Score_Ranking_Arr_Rel_Insert_Input = {
  data: Array<User_Score_Ranking_Insert_Input>;
};

/** aggregate avg on columns */
export type User_Score_Ranking_Avg_Fields = {
  __typename?: 'user_score_ranking_avg_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  position: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Avg_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_score_ranking". All fields are combined with a logical 'AND'. */
export type User_Score_Ranking_Bool_Exp = {
  _and?: InputMaybe<Array<User_Score_Ranking_Bool_Exp>>;
  _not?: InputMaybe<User_Score_Ranking_Bool_Exp>;
  _or?: InputMaybe<Array<User_Score_Ranking_Bool_Exp>>;
  achievement?: InputMaybe<Achievement_Bool_Exp>;
  achievement_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  avatar_url?: InputMaybe<String_Comparison_Exp>;
  brake_use?: InputMaybe<Float8_Comparison_Exp>;
  economic_range?: InputMaybe<Float8_Comparison_Exp>;
  engine_load?: InputMaybe<Float8_Comparison_Exp>;
  inertia?: InputMaybe<Float8_Comparison_Exp>;
  level_option?: InputMaybe<Level_Option_Bool_Exp>;
  level_option_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  motorista_code?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  note?: InputMaybe<Float8_Comparison_Exp>;
  position?: InputMaybe<Bigint_Comparison_Exp>;
  processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  score_processed?: InputMaybe<Score_Processed_Bool_Exp>;
  score_processed_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  slow_running?: InputMaybe<Float8_Comparison_Exp>;
  speed_control?: InputMaybe<Float8_Comparison_Exp>;
  total_km?: InputMaybe<Float8_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** input type for inserting data into table "user_score_ranking" */
export type User_Score_Ranking_Insert_Input = {
  achievement?: InputMaybe<Achievement_Obj_Rel_Insert_Input>;
  achievement_uuid?: InputMaybe<Scalars['uuid']['input']>;
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  level_option?: InputMaybe<Level_Option_Obj_Rel_Insert_Input>;
  level_option_uuid?: InputMaybe<Scalars['uuid']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  position?: InputMaybe<Scalars['bigint']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  score_processed?: InputMaybe<Score_Processed_Obj_Rel_Insert_Input>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Score_Ranking_Max_Fields = {
  __typename?: 'user_score_ranking_max_fields';
  achievement_uuid: Maybe<Scalars['uuid']['output']>;
  avatar_url: Maybe<Scalars['String']['output']>;
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  level_option_uuid: Maybe<Scalars['uuid']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  position: Maybe<Scalars['bigint']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Max_Order_By = {
  achievement_uuid?: InputMaybe<Order_By>;
  avatar_url?: InputMaybe<Order_By>;
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  level_option_uuid?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Score_Ranking_Min_Fields = {
  __typename?: 'user_score_ranking_min_fields';
  achievement_uuid: Maybe<Scalars['uuid']['output']>;
  avatar_url: Maybe<Scalars['String']['output']>;
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  level_option_uuid: Maybe<Scalars['uuid']['output']>;
  motorista_code: Maybe<Scalars['String']['output']>;
  name: Maybe<Scalars['String']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  position: Maybe<Scalars['bigint']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  score_processed_uuid: Maybe<Scalars['uuid']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Min_Order_By = {
  achievement_uuid?: InputMaybe<Order_By>;
  avatar_url?: InputMaybe<Order_By>;
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  level_option_uuid?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "user_score_ranking". */
export type User_Score_Ranking_Order_By = {
  achievement?: InputMaybe<Achievement_Order_By>;
  achievement_uuid?: InputMaybe<Order_By>;
  avatar_url?: InputMaybe<Order_By>;
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  level_option?: InputMaybe<Level_Option_Order_By>;
  level_option_uuid?: InputMaybe<Order_By>;
  motorista_code?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  score_processed?: InputMaybe<Score_Processed_Order_By>;
  score_processed_uuid?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** select columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column {
  /** column name */
  AchievementUuid = 'achievement_uuid',
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  LevelOptionUuid = 'level_option_uuid',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  Name = 'name',
  /** column name */
  Note = 'note',
  /** column name */
  Position = 'position',
  /** column name */
  ProcessedAt = 'processed_at',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  UserUuid = 'user_uuid'
}

/** select "user_score_ranking_aggregate_bool_exp_avg_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_score_ranking_aggregate_bool_exp_corr_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_score_ranking_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_score_ranking_aggregate_bool_exp_max_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_score_ranking_aggregate_bool_exp_min_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_score_ranking_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_score_ranking_aggregate_bool_exp_sum_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** select "user_score_ranking_aggregate_bool_exp_var_samp_arguments_columns" columns of table "user_score_ranking" */
export enum User_Score_Ranking_Select_Column_User_Score_Ranking_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km'
}

/** aggregate stddev on columns */
export type User_Score_Ranking_Stddev_Fields = {
  __typename?: 'user_score_ranking_stddev_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  position: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Stddev_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Score_Ranking_Stddev_Pop_Fields = {
  __typename?: 'user_score_ranking_stddev_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  position: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Stddev_Pop_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Score_Ranking_Stddev_Samp_Fields = {
  __typename?: 'user_score_ranking_stddev_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  position: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Stddev_Samp_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_score_ranking" */
export type User_Score_Ranking_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Score_Ranking_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Score_Ranking_Stream_Cursor_Value_Input = {
  achievement_uuid?: InputMaybe<Scalars['uuid']['input']>;
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  level_option_uuid?: InputMaybe<Scalars['uuid']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  position?: InputMaybe<Scalars['bigint']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type User_Score_Ranking_Sum_Fields = {
  __typename?: 'user_score_ranking_sum_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  position: Maybe<Scalars['bigint']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Sum_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** aggregate var_pop on columns */
export type User_Score_Ranking_Var_Pop_Fields = {
  __typename?: 'user_score_ranking_var_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  position: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Var_Pop_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Score_Ranking_Var_Samp_Fields = {
  __typename?: 'user_score_ranking_var_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  position: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Var_Samp_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Score_Ranking_Variance_Fields = {
  __typename?: 'user_score_ranking_variance_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  position: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_score_ranking" */
export type User_Score_Ranking_Variance_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
};

/** select columns of table "user_score" */
export enum User_Score_Select_Column {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  Note = 'note',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** select "user_score_aggregate_bool_exp_avg_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** select "user_score_aggregate_bool_exp_corr_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** select "user_score_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** select "user_score_aggregate_bool_exp_max_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** select "user_score_aggregate_bool_exp_min_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** select "user_score_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** select "user_score_aggregate_bool_exp_sum_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** select "user_score_aggregate_bool_exp_var_samp_arguments_columns" columns of table "user_score" */
export enum User_Score_Select_Column_User_Score_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  Note = 'note',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time'
}

/** input type for updating data in table "user_score" */
export type User_Score_Set_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_time?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type User_Score_Stddev_Fields = {
  __typename?: 'user_score_stddev_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_time: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_score" */
export type User_Score_Stddev_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Score_Stddev_Pop_Fields = {
  __typename?: 'user_score_stddev_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_time: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_score" */
export type User_Score_Stddev_Pop_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Score_Stddev_Samp_Fields = {
  __typename?: 'user_score_stddev_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_time: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_score" */
export type User_Score_Stddev_Samp_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_score" */
export type User_Score_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Score_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Score_Stream_Cursor_Value_Input = {
  brake_use?: InputMaybe<Scalars['float8']['input']>;
  consumed_fuel?: InputMaybe<Scalars['float8']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  economic_range?: InputMaybe<Scalars['float8']['input']>;
  engine_load?: InputMaybe<Scalars['float8']['input']>;
  inertia?: InputMaybe<Scalars['float8']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['float8']['input']>;
  score_processed_uuid?: InputMaybe<Scalars['uuid']['input']>;
  slow_running?: InputMaybe<Scalars['float8']['input']>;
  speed_control?: InputMaybe<Scalars['float8']['input']>;
  total_km?: InputMaybe<Scalars['float8']['input']>;
  total_time?: InputMaybe<Scalars['float8']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type User_Score_Sum_Fields = {
  __typename?: 'user_score_sum_fields';
  brake_use: Maybe<Scalars['float8']['output']>;
  consumed_fuel: Maybe<Scalars['float8']['output']>;
  economic_range: Maybe<Scalars['float8']['output']>;
  engine_load: Maybe<Scalars['float8']['output']>;
  inertia: Maybe<Scalars['float8']['output']>;
  note: Maybe<Scalars['float8']['output']>;
  slow_running: Maybe<Scalars['float8']['output']>;
  speed_control: Maybe<Scalars['float8']['output']>;
  total_km: Maybe<Scalars['float8']['output']>;
  total_time: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "user_score" */
export type User_Score_Sum_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** update columns of table "user_score" */
export enum User_Score_Update_Column {
  /** column name */
  BrakeUse = 'brake_use',
  /** column name */
  ConsumedFuel = 'consumed_fuel',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EconomicRange = 'economic_range',
  /** column name */
  EngineLoad = 'engine_load',
  /** column name */
  Inertia = 'inertia',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  Note = 'note',
  /** column name */
  ScoreProcessedUuid = 'score_processed_uuid',
  /** column name */
  SlowRunning = 'slow_running',
  /** column name */
  SpeedControl = 'speed_control',
  /** column name */
  TotalKm = 'total_km',
  /** column name */
  TotalTime = 'total_time',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

export type User_Score_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<User_Score_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Score_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Score_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Score_Var_Pop_Fields = {
  __typename?: 'user_score_var_pop_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_time: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_score" */
export type User_Score_Var_Pop_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Score_Var_Samp_Fields = {
  __typename?: 'user_score_var_samp_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_time: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_score" */
export type User_Score_Var_Samp_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Score_Variance_Fields = {
  __typename?: 'user_score_variance_fields';
  brake_use: Maybe<Scalars['Float']['output']>;
  consumed_fuel: Maybe<Scalars['Float']['output']>;
  economic_range: Maybe<Scalars['Float']['output']>;
  engine_load: Maybe<Scalars['Float']['output']>;
  inertia: Maybe<Scalars['Float']['output']>;
  note: Maybe<Scalars['Float']['output']>;
  slow_running: Maybe<Scalars['Float']['output']>;
  speed_control: Maybe<Scalars['Float']['output']>;
  total_km: Maybe<Scalars['Float']['output']>;
  total_time: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_score" */
export type User_Score_Variance_Order_By = {
  brake_use?: InputMaybe<Order_By>;
  consumed_fuel?: InputMaybe<Order_By>;
  economic_range?: InputMaybe<Order_By>;
  engine_load?: InputMaybe<Order_By>;
  inertia?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  slow_running?: InputMaybe<Order_By>;
  speed_control?: InputMaybe<Order_By>;
  total_km?: InputMaybe<Order_By>;
  total_time?: InputMaybe<Order_By>;
};

/** select columns of table "user" */
export enum User_Select_Column {
  /** column name */
  AdmittedAt = 'admitted_at',
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  Birthdate = 'birthdate',
  /** column name */
  Cpf = 'cpf',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  LicensePlate = 'license_plate',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  Name = 'name',
  /** column name */
  Password = 'password',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "user" */
export type User_Set_Input = {
  admitted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['date']['input']>;
  cpf?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the user is enabled or not. This is overwritten in case it's not a driver with the driver replication cron event */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  license_plate?: InputMaybe<Scalars['String']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type User_Stddev_Fields = {
  __typename?: 'user_stddev_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** aggregate stddev_pop on columns */
export type User_Stddev_Pop_Fields = {
  __typename?: 'user_stddev_pop_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** aggregate stddev_samp on columns */
export type User_Stddev_Samp_Fields = {
  __typename?: 'user_stddev_samp_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** Streaming cursor of the table "user" */
export type User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Stream_Cursor_Value_Input = {
  admitted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['date']['input']>;
  cpf?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the user is enabled or not. This is overwritten in case it's not a driver with the driver replication cron event */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  license_plate?: InputMaybe<Scalars['String']['input']>;
  motorista_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type User_Sum_Fields = {
  __typename?: 'user_sum_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** columns and relationships of "user_training" */
export type User_Training = {
  __typename?: 'user_training';
  created_at: Scalars['timestamptz']['output'];
  /** If the user liked the training */
  liked: Scalars['Boolean']['output'];
  /** An object relationship */
  training: Training;
  training_uuid: Scalars['uuid']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
  /** If the user watched the training */
  watched: Scalars['Boolean']['output'];
};

/** aggregated selection of "user_training" */
export type User_Training_Aggregate = {
  __typename?: 'user_training_aggregate';
  aggregate: Maybe<User_Training_Aggregate_Fields>;
  nodes: Array<User_Training>;
};

export type User_Training_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<User_Training_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<User_Training_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<User_Training_Aggregate_Bool_Exp_Count>;
};

export type User_Training_Aggregate_Bool_Exp_Bool_And = {
  arguments: User_Training_Select_Column_User_Training_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Training_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Training_Aggregate_Bool_Exp_Bool_Or = {
  arguments: User_Training_Select_Column_User_Training_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Training_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Training_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Training_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Training_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_training" */
export type User_Training_Aggregate_Fields = {
  __typename?: 'user_training_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<User_Training_Max_Fields>;
  min: Maybe<User_Training_Min_Fields>;
};


/** aggregate fields of "user_training" */
export type User_Training_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Training_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_training" */
export type User_Training_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Training_Max_Order_By>;
  min?: InputMaybe<User_Training_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_training" */
export type User_Training_Arr_Rel_Insert_Input = {
  data: Array<User_Training_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Training_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_training". All fields are combined with a logical 'AND'. */
export type User_Training_Bool_Exp = {
  _and?: InputMaybe<Array<User_Training_Bool_Exp>>;
  _not?: InputMaybe<User_Training_Bool_Exp>;
  _or?: InputMaybe<Array<User_Training_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  liked?: InputMaybe<Boolean_Comparison_Exp>;
  training?: InputMaybe<Training_Bool_Exp>;
  training_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  watched?: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_training" */
export enum User_Training_Constraint {
  /** unique or primary key constraint on columns "training_uuid", "user_uuid" */
  UserTrainingPkey = 'user_training_pkey'
}

/** input type for inserting data into table "user_training" */
export type User_Training_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the user liked the training */
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  training?: InputMaybe<Training_Obj_Rel_Insert_Input>;
  training_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** If the user watched the training */
  watched?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type User_Training_Max_Fields = {
  __typename?: 'user_training_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  training_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_training" */
export type User_Training_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  training_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Training_Min_Fields = {
  __typename?: 'user_training_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  training_uuid: Maybe<Scalars['uuid']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  user_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_training" */
export type User_Training_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  training_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_training" */
export type User_Training_Mutation_Response = {
  __typename?: 'user_training_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Training>;
};

/** on_conflict condition type for table "user_training" */
export type User_Training_On_Conflict = {
  constraint: User_Training_Constraint;
  update_columns?: Array<User_Training_Update_Column>;
  where?: InputMaybe<User_Training_Bool_Exp>;
};

/** Ordering options when selecting data from "user_training". */
export type User_Training_Order_By = {
  created_at?: InputMaybe<Order_By>;
  liked?: InputMaybe<Order_By>;
  training?: InputMaybe<Training_Order_By>;
  training_uuid?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  watched?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_training */
export type User_Training_Pk_Columns_Input = {
  training_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_training" */
export enum User_Training_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Liked = 'liked',
  /** column name */
  TrainingUuid = 'training_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Watched = 'watched'
}

/** select "user_training_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user_training" */
export enum User_Training_Select_Column_User_Training_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Liked = 'liked',
  /** column name */
  Watched = 'watched'
}

/** select "user_training_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user_training" */
export enum User_Training_Select_Column_User_Training_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Liked = 'liked',
  /** column name */
  Watched = 'watched'
}

/** input type for updating data in table "user_training" */
export type User_Training_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the user liked the training */
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  training_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** If the user watched the training */
  watched?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Streaming cursor of the table "user_training" */
export type User_Training_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Training_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Training_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If the user liked the training */
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  training_uuid?: InputMaybe<Scalars['uuid']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** If the user watched the training */
  watched?: InputMaybe<Scalars['Boolean']['input']>;
};

/** update columns of table "user_training" */
export enum User_Training_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Liked = 'liked',
  /** column name */
  TrainingUuid = 'training_uuid',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Watched = 'watched'
}

export type User_Training_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Training_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Training_Bool_Exp;
};

/** update columns of table "user" */
export enum User_Update_Column {
  /** column name */
  AdmittedAt = 'admitted_at',
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  Birthdate = 'birthdate',
  /** column name */
  Cpf = 'cpf',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  LicensePlate = 'license_plate',
  /** column name */
  MotoristaCode = 'motorista_code',
  /** column name */
  Name = 'name',
  /** column name */
  Password = 'password',
  /** column name */
  Uuid = 'uuid'
}

export type User_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Var_Pop_Fields = {
  __typename?: 'user_var_pop_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** aggregate var_samp on columns */
export type User_Var_Samp_Fields = {
  __typename?: 'user_var_samp_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** aggregate variance on columns */
export type User_Variance_Fields = {
  __typename?: 'user_variance_fields';
  /** A computed field, executes function "user_current_balance" */
  balance: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_current_level_number" */
  current_level_number: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "user_average_score" */
  score_average: Maybe<Scalars['float8']['output']>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

/** columns and relationships of "vehicle" */
export type Vehicle = {
  __typename?: 'vehicle';
  axis_configuration: Scalars['String']['output'];
  axis_type_name: Scalars['String']['output'];
  brand_name: Scalars['String']['output'];
  class: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  ibor_tires: Array<CurrentTiresByVehicle>;
  ibor_tires_aggregate: CurrentTiresByVehicle_Aggregate;
  /** An array relationship */
  inspections: Array<Inspection>;
  /** An aggregate relationship */
  inspections_aggregate: Inspection_Aggregate;
  plate: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "vehicle" */
export type VehicleIbor_TiresArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CurrentTiresByVehicle_Order_By>>;
  where?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
};


/** columns and relationships of "vehicle" */
export type VehicleIbor_Tires_AggregateArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CurrentTiresByVehicle_Order_By>>;
  where?: InputMaybe<CurrentTiresByVehicle_Bool_Exp>;
};


/** columns and relationships of "vehicle" */
export type VehicleInspectionsArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Order_By>>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};


/** columns and relationships of "vehicle" */
export type VehicleInspections_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Inspection_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Inspection_Order_By>>;
  where?: InputMaybe<Inspection_Bool_Exp>;
};

/** aggregated selection of "vehicle" */
export type Vehicle_Aggregate = {
  __typename?: 'vehicle_aggregate';
  aggregate: Maybe<Vehicle_Aggregate_Fields>;
  nodes: Array<Vehicle>;
};

/** aggregate fields of "vehicle" */
export type Vehicle_Aggregate_Fields = {
  __typename?: 'vehicle_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Vehicle_Max_Fields>;
  min: Maybe<Vehicle_Min_Fields>;
};


/** aggregate fields of "vehicle" */
export type Vehicle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Vehicle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "vehicle". All fields are combined with a logical 'AND'. */
export type Vehicle_Bool_Exp = {
  _and?: InputMaybe<Array<Vehicle_Bool_Exp>>;
  _not?: InputMaybe<Vehicle_Bool_Exp>;
  _or?: InputMaybe<Array<Vehicle_Bool_Exp>>;
  axis_configuration?: InputMaybe<String_Comparison_Exp>;
  axis_type_name?: InputMaybe<String_Comparison_Exp>;
  brand_name?: InputMaybe<String_Comparison_Exp>;
  class?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  inspections?: InputMaybe<Inspection_Bool_Exp>;
  inspections_aggregate?: InputMaybe<Inspection_Aggregate_Bool_Exp>;
  plate?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "vehicle" */
export enum Vehicle_Constraint {
  /** unique or primary key constraint on columns "plate" */
  VehiclePkey = 'vehicle_pkey'
}

/** input type for inserting data into table "vehicle" */
export type Vehicle_Insert_Input = {
  axis_configuration?: InputMaybe<Scalars['String']['input']>;
  axis_type_name?: InputMaybe<Scalars['String']['input']>;
  brand_name?: InputMaybe<Scalars['String']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  inspections?: InputMaybe<Inspection_Arr_Rel_Insert_Input>;
  plate?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Vehicle_Max_Fields = {
  __typename?: 'vehicle_max_fields';
  axis_configuration: Maybe<Scalars['String']['output']>;
  axis_type_name: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  class: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  plate: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Vehicle_Min_Fields = {
  __typename?: 'vehicle_min_fields';
  axis_configuration: Maybe<Scalars['String']['output']>;
  axis_type_name: Maybe<Scalars['String']['output']>;
  brand_name: Maybe<Scalars['String']['output']>;
  class: Maybe<Scalars['String']['output']>;
  created_at: Maybe<Scalars['timestamptz']['output']>;
  plate: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "vehicle" */
export type Vehicle_Mutation_Response = {
  __typename?: 'vehicle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Vehicle>;
};

/** input type for inserting object relation for remote table "vehicle" */
export type Vehicle_Obj_Rel_Insert_Input = {
  data: Vehicle_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Vehicle_On_Conflict>;
};

/** on_conflict condition type for table "vehicle" */
export type Vehicle_On_Conflict = {
  constraint: Vehicle_Constraint;
  update_columns?: Array<Vehicle_Update_Column>;
  where?: InputMaybe<Vehicle_Bool_Exp>;
};

/** Ordering options when selecting data from "vehicle". */
export type Vehicle_Order_By = {
  axis_configuration?: InputMaybe<Order_By>;
  axis_type_name?: InputMaybe<Order_By>;
  brand_name?: InputMaybe<Order_By>;
  class?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  inspections_aggregate?: InputMaybe<Inspection_Aggregate_Order_By>;
  plate?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: vehicle */
export type Vehicle_Pk_Columns_Input = {
  plate: Scalars['String']['input'];
};

/** select columns of table "vehicle" */
export enum Vehicle_Select_Column {
  /** column name */
  AxisConfiguration = 'axis_configuration',
  /** column name */
  AxisTypeName = 'axis_type_name',
  /** column name */
  BrandName = 'brand_name',
  /** column name */
  Class = 'class',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Plate = 'plate',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "vehicle" */
export type Vehicle_Set_Input = {
  axis_configuration?: InputMaybe<Scalars['String']['input']>;
  axis_type_name?: InputMaybe<Scalars['String']['input']>;
  brand_name?: InputMaybe<Scalars['String']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  plate?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "vehicle" */
export type Vehicle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vehicle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vehicle_Stream_Cursor_Value_Input = {
  axis_configuration?: InputMaybe<Scalars['String']['input']>;
  axis_type_name?: InputMaybe<Scalars['String']['input']>;
  brand_name?: InputMaybe<Scalars['String']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  plate?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "vehicle" */
export enum Vehicle_Update_Column {
  /** column name */
  AxisConfiguration = 'axis_configuration',
  /** column name */
  AxisTypeName = 'axis_type_name',
  /** column name */
  BrandName = 'brand_name',
  /** column name */
  Class = 'class',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Plate = 'plate',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Vehicle_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Vehicle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vehicle_Bool_Exp;
};

/** columns and relationships of "whatsapp_event" */
export type Whatsapp_Event = {
  __typename?: 'whatsapp_event';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  initial_reply_whatsapp_message: Maybe<Whatsapp_Message>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid: Maybe<Scalars['uuid']['output']>;
  last_consumed_at: Maybe<Scalars['timestamptz']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Scalars['Int']['output'];
  uuid: Scalars['uuid']['output'];
  whatsapp_message_body: Scalars['String']['output'];
  whatsapp_message_data: Scalars['jsonb']['output'];
  /** An object relationship */
  whatsapp_trigger: Whatsapp_Trigger;
  whatsapp_trigger_uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "whatsapp_event" */
export type Whatsapp_EventWhatsapp_Message_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "whatsapp_event" */
export type Whatsapp_Event_Aggregate = {
  __typename?: 'whatsapp_event_aggregate';
  aggregate: Maybe<Whatsapp_Event_Aggregate_Fields>;
  nodes: Array<Whatsapp_Event>;
};

export type Whatsapp_Event_Aggregate_Bool_Exp = {
  count?: InputMaybe<Whatsapp_Event_Aggregate_Bool_Exp_Count>;
};

export type Whatsapp_Event_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Whatsapp_Event_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "whatsapp_event" */
export type Whatsapp_Event_Aggregate_Fields = {
  __typename?: 'whatsapp_event_aggregate_fields';
  avg: Maybe<Whatsapp_Event_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Whatsapp_Event_Max_Fields>;
  min: Maybe<Whatsapp_Event_Min_Fields>;
  stddev: Maybe<Whatsapp_Event_Stddev_Fields>;
  stddev_pop: Maybe<Whatsapp_Event_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Whatsapp_Event_Stddev_Samp_Fields>;
  sum: Maybe<Whatsapp_Event_Sum_Fields>;
  var_pop: Maybe<Whatsapp_Event_Var_Pop_Fields>;
  var_samp: Maybe<Whatsapp_Event_Var_Samp_Fields>;
  variance: Maybe<Whatsapp_Event_Variance_Fields>;
};


/** aggregate fields of "whatsapp_event" */
export type Whatsapp_Event_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "whatsapp_event" */
export type Whatsapp_Event_Aggregate_Order_By = {
  avg?: InputMaybe<Whatsapp_Event_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Whatsapp_Event_Max_Order_By>;
  min?: InputMaybe<Whatsapp_Event_Min_Order_By>;
  stddev?: InputMaybe<Whatsapp_Event_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Whatsapp_Event_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Whatsapp_Event_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Whatsapp_Event_Sum_Order_By>;
  var_pop?: InputMaybe<Whatsapp_Event_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Whatsapp_Event_Var_Samp_Order_By>;
  variance?: InputMaybe<Whatsapp_Event_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Whatsapp_Event_Append_Input = {
  whatsapp_message_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "whatsapp_event" */
export type Whatsapp_Event_Arr_Rel_Insert_Input = {
  data: Array<Whatsapp_Event_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Whatsapp_Event_On_Conflict>;
};

/** aggregate avg on columns */
export type Whatsapp_Event_Avg_Fields = {
  __typename?: 'whatsapp_event_avg_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Avg_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "whatsapp_event". All fields are combined with a logical 'AND'. */
export type Whatsapp_Event_Bool_Exp = {
  _and?: InputMaybe<Array<Whatsapp_Event_Bool_Exp>>;
  _not?: InputMaybe<Whatsapp_Event_Bool_Exp>;
  _or?: InputMaybe<Array<Whatsapp_Event_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  initial_reply_whatsapp_message?: InputMaybe<Whatsapp_Message_Bool_Exp>;
  initial_reply_whatsapp_message_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  last_consumed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  processed_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  remaining_retry_count?: InputMaybe<Int_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  whatsapp_message_body?: InputMaybe<String_Comparison_Exp>;
  whatsapp_message_data?: InputMaybe<Jsonb_Comparison_Exp>;
  whatsapp_trigger?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
  whatsapp_trigger_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "whatsapp_event" */
export enum Whatsapp_Event_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  WhatsappEventPkey = 'whatsapp_event_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Whatsapp_Event_Delete_At_Path_Input = {
  whatsapp_message_data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Whatsapp_Event_Delete_Elem_Input = {
  whatsapp_message_data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Whatsapp_Event_Delete_Key_Input = {
  whatsapp_message_data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "whatsapp_event" */
export type Whatsapp_Event_Inc_Input = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "whatsapp_event" */
export type Whatsapp_Event_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  initial_reply_whatsapp_message?: InputMaybe<Whatsapp_Message_Obj_Rel_Insert_Input>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
  last_consumed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_message_body?: InputMaybe<Scalars['String']['input']>;
  whatsapp_message_data?: InputMaybe<Scalars['jsonb']['input']>;
  whatsapp_trigger?: InputMaybe<Whatsapp_Trigger_Obj_Rel_Insert_Input>;
  whatsapp_trigger_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Whatsapp_Event_Max_Fields = {
  __typename?: 'whatsapp_event_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid: Maybe<Scalars['uuid']['output']>;
  last_consumed_at: Maybe<Scalars['timestamptz']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Int']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_message_body: Maybe<Scalars['String']['output']>;
  whatsapp_trigger_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid?: InputMaybe<Order_By>;
  last_consumed_at?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  whatsapp_message_body?: InputMaybe<Order_By>;
  whatsapp_trigger_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Whatsapp_Event_Min_Fields = {
  __typename?: 'whatsapp_event_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid: Maybe<Scalars['uuid']['output']>;
  last_consumed_at: Maybe<Scalars['timestamptz']['output']>;
  processed_at: Maybe<Scalars['timestamptz']['output']>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Int']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_message_body: Maybe<Scalars['String']['output']>;
  whatsapp_trigger_uuid: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid?: InputMaybe<Order_By>;
  last_consumed_at?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  whatsapp_message_body?: InputMaybe<Order_By>;
  whatsapp_trigger_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "whatsapp_event" */
export type Whatsapp_Event_Mutation_Response = {
  __typename?: 'whatsapp_event_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Whatsapp_Event>;
};

/** on_conflict condition type for table "whatsapp_event" */
export type Whatsapp_Event_On_Conflict = {
  constraint: Whatsapp_Event_Constraint;
  update_columns?: Array<Whatsapp_Event_Update_Column>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};

/** Ordering options when selecting data from "whatsapp_event". */
export type Whatsapp_Event_Order_By = {
  created_at?: InputMaybe<Order_By>;
  initial_reply_whatsapp_message?: InputMaybe<Whatsapp_Message_Order_By>;
  initial_reply_whatsapp_message_uuid?: InputMaybe<Order_By>;
  last_consumed_at?: InputMaybe<Order_By>;
  processed_at?: InputMaybe<Order_By>;
  remaining_retry_count?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  whatsapp_message_body?: InputMaybe<Order_By>;
  whatsapp_message_data?: InputMaybe<Order_By>;
  whatsapp_trigger?: InputMaybe<Whatsapp_Trigger_Order_By>;
  whatsapp_trigger_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: whatsapp_event */
export type Whatsapp_Event_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Whatsapp_Event_Prepend_Input = {
  whatsapp_message_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "whatsapp_event" */
export enum Whatsapp_Event_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InitialReplyWhatsappMessageUuid = 'initial_reply_whatsapp_message_uuid',
  /** column name */
  LastConsumedAt = 'last_consumed_at',
  /** column name */
  ProcessedAt = 'processed_at',
  /** column name */
  RemainingRetryCount = 'remaining_retry_count',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WhatsappMessageBody = 'whatsapp_message_body',
  /** column name */
  WhatsappMessageData = 'whatsapp_message_data',
  /** column name */
  WhatsappTriggerUuid = 'whatsapp_trigger_uuid'
}

/** input type for updating data in table "whatsapp_event" */
export type Whatsapp_Event_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
  last_consumed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_message_body?: InputMaybe<Scalars['String']['input']>;
  whatsapp_message_data?: InputMaybe<Scalars['jsonb']['input']>;
  whatsapp_trigger_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type Whatsapp_Event_Stddev_Fields = {
  __typename?: 'whatsapp_event_stddev_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Stddev_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Whatsapp_Event_Stddev_Pop_Fields = {
  __typename?: 'whatsapp_event_stddev_pop_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Stddev_Pop_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Whatsapp_Event_Stddev_Samp_Fields = {
  __typename?: 'whatsapp_event_stddev_samp_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Stddev_Samp_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "whatsapp_event" */
export type Whatsapp_Event_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Whatsapp_Event_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Whatsapp_Event_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The trigger can have an initial reply message, that is sent as soon as the message is read. This is the uuid of that message. Can be null */
  initial_reply_whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
  last_consumed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  processed_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Scalars['Int']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_message_body?: InputMaybe<Scalars['String']['input']>;
  whatsapp_message_data?: InputMaybe<Scalars['jsonb']['input']>;
  whatsapp_trigger_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type Whatsapp_Event_Sum_Fields = {
  __typename?: 'whatsapp_event_sum_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Sum_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** update columns of table "whatsapp_event" */
export enum Whatsapp_Event_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InitialReplyWhatsappMessageUuid = 'initial_reply_whatsapp_message_uuid',
  /** column name */
  LastConsumedAt = 'last_consumed_at',
  /** column name */
  ProcessedAt = 'processed_at',
  /** column name */
  RemainingRetryCount = 'remaining_retry_count',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WhatsappMessageBody = 'whatsapp_message_body',
  /** column name */
  WhatsappMessageData = 'whatsapp_message_data',
  /** column name */
  WhatsappTriggerUuid = 'whatsapp_trigger_uuid'
}

export type Whatsapp_Event_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Whatsapp_Event_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Whatsapp_Event_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Whatsapp_Event_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Whatsapp_Event_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Whatsapp_Event_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Whatsapp_Event_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Whatsapp_Event_Set_Input>;
  /** filter the rows which have to be updated */
  where: Whatsapp_Event_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Whatsapp_Event_Var_Pop_Fields = {
  __typename?: 'whatsapp_event_var_pop_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Var_Pop_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Whatsapp_Event_Var_Samp_Fields = {
  __typename?: 'whatsapp_event_var_samp_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Var_Samp_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Whatsapp_Event_Variance_Fields = {
  __typename?: 'whatsapp_event_variance_fields';
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "whatsapp_event" */
export type Whatsapp_Event_Variance_Order_By = {
  /** The remaining quantity of retries to process this event. If equal or less than 0 it will not process it */
  remaining_retry_count?: InputMaybe<Order_By>;
};

/** columns and relationships of "whatsapp_message" */
export type Whatsapp_Message = {
  __typename?: 'whatsapp_message';
  created_at: Scalars['timestamptz']['output'];
  /** A data em que foi enviada a primeira mensagem, sem edio */
  first_sent_at: Maybe<Scalars['timestamptz']['output']>;
  /** Corpo da mensagem */
  message: Maybe<Scalars['String']['output']>;
  message_data_base64: Maybe<Scalars['String']['output']>;
  message_data_filename: Maybe<Scalars['String']['output']>;
  message_data_mime_type: Maybe<Scalars['String']['output']>;
  message_data_url: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
  was_edited: Scalars['Boolean']['output'];
  /** Se foi enviado por completo. Isto , tanto a primeira mensagem quanto as edies */
  was_sent: Scalars['Boolean']['output'];
  whatsapp_chat_id: Scalars['String']['output'];
  /** An array relationship */
  whatsapp_events: Array<Whatsapp_Event>;
  /** An aggregate relationship */
  whatsapp_events_aggregate: Whatsapp_Event_Aggregate;
  /** An array relationship */
  whatsapp_message_histories: Array<Whatsapp_Message_History>;
  /** An aggregate relationship */
  whatsapp_message_histories_aggregate: Whatsapp_Message_History_Aggregate;
  whatsapp_message_id: Maybe<Scalars['String']['output']>;
  whatsapp_quoted_message_id: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "whatsapp_message" */
export type Whatsapp_MessageWhatsapp_EventsArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


/** columns and relationships of "whatsapp_message" */
export type Whatsapp_MessageWhatsapp_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


/** columns and relationships of "whatsapp_message" */
export type Whatsapp_MessageWhatsapp_Message_HistoriesArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_History_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};


/** columns and relationships of "whatsapp_message" */
export type Whatsapp_MessageWhatsapp_Message_Histories_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Message_History_Order_By>>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};

/** aggregated selection of "whatsapp_message" */
export type Whatsapp_Message_Aggregate = {
  __typename?: 'whatsapp_message_aggregate';
  aggregate: Maybe<Whatsapp_Message_Aggregate_Fields>;
  nodes: Array<Whatsapp_Message>;
};

/** aggregate fields of "whatsapp_message" */
export type Whatsapp_Message_Aggregate_Fields = {
  __typename?: 'whatsapp_message_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Whatsapp_Message_Max_Fields>;
  min: Maybe<Whatsapp_Message_Min_Fields>;
};


/** aggregate fields of "whatsapp_message" */
export type Whatsapp_Message_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Whatsapp_Message_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "whatsapp_message". All fields are combined with a logical 'AND'. */
export type Whatsapp_Message_Bool_Exp = {
  _and?: InputMaybe<Array<Whatsapp_Message_Bool_Exp>>;
  _not?: InputMaybe<Whatsapp_Message_Bool_Exp>;
  _or?: InputMaybe<Array<Whatsapp_Message_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  first_sent_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  message?: InputMaybe<String_Comparison_Exp>;
  message_data_base64?: InputMaybe<String_Comparison_Exp>;
  message_data_filename?: InputMaybe<String_Comparison_Exp>;
  message_data_mime_type?: InputMaybe<String_Comparison_Exp>;
  message_data_url?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  was_edited?: InputMaybe<Boolean_Comparison_Exp>;
  was_sent?: InputMaybe<Boolean_Comparison_Exp>;
  whatsapp_chat_id?: InputMaybe<String_Comparison_Exp>;
  whatsapp_events?: InputMaybe<Whatsapp_Event_Bool_Exp>;
  whatsapp_events_aggregate?: InputMaybe<Whatsapp_Event_Aggregate_Bool_Exp>;
  whatsapp_message_histories?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
  whatsapp_message_histories_aggregate?: InputMaybe<Whatsapp_Message_History_Aggregate_Bool_Exp>;
  whatsapp_message_id?: InputMaybe<String_Comparison_Exp>;
  whatsapp_quoted_message_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "whatsapp_message" */
export enum Whatsapp_Message_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  WhatsappMessagePkey = 'whatsapp_message_pkey'
}

/** columns and relationships of "whatsapp_message_history" */
export type Whatsapp_Message_History = {
  __typename?: 'whatsapp_message_history';
  created_at: Scalars['timestamptz']['output'];
  message: Maybe<Scalars['String']['output']>;
  message_data_base64: Maybe<Scalars['String']['output']>;
  message_data_filename: Maybe<Scalars['String']['output']>;
  message_data_mime_type: Maybe<Scalars['String']['output']>;
  message_data_url: Maybe<Scalars['String']['output']>;
  sent_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Scalars['uuid']['output'];
  /** An object relationship */
  whatsapp_message: Whatsapp_Message;
  whatsapp_message_uuid: Scalars['uuid']['output'];
  whatsapp_quoted_message_id: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "whatsapp_message_history" */
export type Whatsapp_Message_History_Aggregate = {
  __typename?: 'whatsapp_message_history_aggregate';
  aggregate: Maybe<Whatsapp_Message_History_Aggregate_Fields>;
  nodes: Array<Whatsapp_Message_History>;
};

export type Whatsapp_Message_History_Aggregate_Bool_Exp = {
  count?: InputMaybe<Whatsapp_Message_History_Aggregate_Bool_Exp_Count>;
};

export type Whatsapp_Message_History_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "whatsapp_message_history" */
export type Whatsapp_Message_History_Aggregate_Fields = {
  __typename?: 'whatsapp_message_history_aggregate_fields';
  count: Scalars['Int']['output'];
  max: Maybe<Whatsapp_Message_History_Max_Fields>;
  min: Maybe<Whatsapp_Message_History_Min_Fields>;
};


/** aggregate fields of "whatsapp_message_history" */
export type Whatsapp_Message_History_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Whatsapp_Message_History_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "whatsapp_message_history" */
export type Whatsapp_Message_History_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Whatsapp_Message_History_Max_Order_By>;
  min?: InputMaybe<Whatsapp_Message_History_Min_Order_By>;
};

/** input type for inserting array relation for remote table "whatsapp_message_history" */
export type Whatsapp_Message_History_Arr_Rel_Insert_Input = {
  data: Array<Whatsapp_Message_History_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Whatsapp_Message_History_On_Conflict>;
};

/** Boolean expression to filter rows from the table "whatsapp_message_history". All fields are combined with a logical 'AND'. */
export type Whatsapp_Message_History_Bool_Exp = {
  _and?: InputMaybe<Array<Whatsapp_Message_History_Bool_Exp>>;
  _not?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
  _or?: InputMaybe<Array<Whatsapp_Message_History_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  message?: InputMaybe<String_Comparison_Exp>;
  message_data_base64?: InputMaybe<String_Comparison_Exp>;
  message_data_filename?: InputMaybe<String_Comparison_Exp>;
  message_data_mime_type?: InputMaybe<String_Comparison_Exp>;
  message_data_url?: InputMaybe<String_Comparison_Exp>;
  sent_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  whatsapp_message?: InputMaybe<Whatsapp_Message_Bool_Exp>;
  whatsapp_message_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  whatsapp_quoted_message_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "whatsapp_message_history" */
export enum Whatsapp_Message_History_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  WhatsappMessageHistoryPkey = 'whatsapp_message_history_pkey'
}

/** input type for inserting data into table "whatsapp_message_history" */
export type Whatsapp_Message_History_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  message_data_base64?: InputMaybe<Scalars['String']['input']>;
  message_data_filename?: InputMaybe<Scalars['String']['input']>;
  message_data_mime_type?: InputMaybe<Scalars['String']['input']>;
  message_data_url?: InputMaybe<Scalars['String']['input']>;
  sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_message?: InputMaybe<Whatsapp_Message_Obj_Rel_Insert_Input>;
  whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_quoted_message_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Whatsapp_Message_History_Max_Fields = {
  __typename?: 'whatsapp_message_history_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  message: Maybe<Scalars['String']['output']>;
  message_data_base64: Maybe<Scalars['String']['output']>;
  message_data_filename: Maybe<Scalars['String']['output']>;
  message_data_mime_type: Maybe<Scalars['String']['output']>;
  message_data_url: Maybe<Scalars['String']['output']>;
  sent_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_message_uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_quoted_message_id: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "whatsapp_message_history" */
export type Whatsapp_Message_History_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  message_data_base64?: InputMaybe<Order_By>;
  message_data_filename?: InputMaybe<Order_By>;
  message_data_mime_type?: InputMaybe<Order_By>;
  message_data_url?: InputMaybe<Order_By>;
  sent_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  whatsapp_message_uuid?: InputMaybe<Order_By>;
  whatsapp_quoted_message_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Whatsapp_Message_History_Min_Fields = {
  __typename?: 'whatsapp_message_history_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  message: Maybe<Scalars['String']['output']>;
  message_data_base64: Maybe<Scalars['String']['output']>;
  message_data_filename: Maybe<Scalars['String']['output']>;
  message_data_mime_type: Maybe<Scalars['String']['output']>;
  message_data_url: Maybe<Scalars['String']['output']>;
  sent_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_message_uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_quoted_message_id: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "whatsapp_message_history" */
export type Whatsapp_Message_History_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  message_data_base64?: InputMaybe<Order_By>;
  message_data_filename?: InputMaybe<Order_By>;
  message_data_mime_type?: InputMaybe<Order_By>;
  message_data_url?: InputMaybe<Order_By>;
  sent_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  whatsapp_message_uuid?: InputMaybe<Order_By>;
  whatsapp_quoted_message_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "whatsapp_message_history" */
export type Whatsapp_Message_History_Mutation_Response = {
  __typename?: 'whatsapp_message_history_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Whatsapp_Message_History>;
};

/** on_conflict condition type for table "whatsapp_message_history" */
export type Whatsapp_Message_History_On_Conflict = {
  constraint: Whatsapp_Message_History_Constraint;
  update_columns?: Array<Whatsapp_Message_History_Update_Column>;
  where?: InputMaybe<Whatsapp_Message_History_Bool_Exp>;
};

/** Ordering options when selecting data from "whatsapp_message_history". */
export type Whatsapp_Message_History_Order_By = {
  created_at?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  message_data_base64?: InputMaybe<Order_By>;
  message_data_filename?: InputMaybe<Order_By>;
  message_data_mime_type?: InputMaybe<Order_By>;
  message_data_url?: InputMaybe<Order_By>;
  sent_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  whatsapp_message?: InputMaybe<Whatsapp_Message_Order_By>;
  whatsapp_message_uuid?: InputMaybe<Order_By>;
  whatsapp_quoted_message_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: whatsapp_message_history */
export type Whatsapp_Message_History_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "whatsapp_message_history" */
export enum Whatsapp_Message_History_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Message = 'message',
  /** column name */
  MessageDataBase64 = 'message_data_base64',
  /** column name */
  MessageDataFilename = 'message_data_filename',
  /** column name */
  MessageDataMimeType = 'message_data_mime_type',
  /** column name */
  MessageDataUrl = 'message_data_url',
  /** column name */
  SentAt = 'sent_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WhatsappMessageUuid = 'whatsapp_message_uuid',
  /** column name */
  WhatsappQuotedMessageId = 'whatsapp_quoted_message_id'
}

/** input type for updating data in table "whatsapp_message_history" */
export type Whatsapp_Message_History_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  message_data_base64?: InputMaybe<Scalars['String']['input']>;
  message_data_filename?: InputMaybe<Scalars['String']['input']>;
  message_data_mime_type?: InputMaybe<Scalars['String']['input']>;
  message_data_url?: InputMaybe<Scalars['String']['input']>;
  sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_quoted_message_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "whatsapp_message_history" */
export type Whatsapp_Message_History_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Whatsapp_Message_History_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Whatsapp_Message_History_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  message_data_base64?: InputMaybe<Scalars['String']['input']>;
  message_data_filename?: InputMaybe<Scalars['String']['input']>;
  message_data_mime_type?: InputMaybe<Scalars['String']['input']>;
  message_data_url?: InputMaybe<Scalars['String']['input']>;
  sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_message_uuid?: InputMaybe<Scalars['uuid']['input']>;
  whatsapp_quoted_message_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "whatsapp_message_history" */
export enum Whatsapp_Message_History_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Message = 'message',
  /** column name */
  MessageDataBase64 = 'message_data_base64',
  /** column name */
  MessageDataFilename = 'message_data_filename',
  /** column name */
  MessageDataMimeType = 'message_data_mime_type',
  /** column name */
  MessageDataUrl = 'message_data_url',
  /** column name */
  SentAt = 'sent_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WhatsappMessageUuid = 'whatsapp_message_uuid',
  /** column name */
  WhatsappQuotedMessageId = 'whatsapp_quoted_message_id'
}

export type Whatsapp_Message_History_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Whatsapp_Message_History_Set_Input>;
  /** filter the rows which have to be updated */
  where: Whatsapp_Message_History_Bool_Exp;
};

/** input type for inserting data into table "whatsapp_message" */
export type Whatsapp_Message_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A data em que foi enviada a primeira mensagem, sem edio */
  first_sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Corpo da mensagem */
  message?: InputMaybe<Scalars['String']['input']>;
  message_data_base64?: InputMaybe<Scalars['String']['input']>;
  message_data_filename?: InputMaybe<Scalars['String']['input']>;
  message_data_mime_type?: InputMaybe<Scalars['String']['input']>;
  message_data_url?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  was_edited?: InputMaybe<Scalars['Boolean']['input']>;
  /** Se foi enviado por completo. Isto , tanto a primeira mensagem quanto as edies */
  was_sent?: InputMaybe<Scalars['Boolean']['input']>;
  whatsapp_chat_id?: InputMaybe<Scalars['String']['input']>;
  whatsapp_events?: InputMaybe<Whatsapp_Event_Arr_Rel_Insert_Input>;
  whatsapp_message_histories?: InputMaybe<Whatsapp_Message_History_Arr_Rel_Insert_Input>;
  whatsapp_message_id?: InputMaybe<Scalars['String']['input']>;
  whatsapp_quoted_message_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Whatsapp_Message_Max_Fields = {
  __typename?: 'whatsapp_message_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A data em que foi enviada a primeira mensagem, sem edio */
  first_sent_at: Maybe<Scalars['timestamptz']['output']>;
  /** Corpo da mensagem */
  message: Maybe<Scalars['String']['output']>;
  message_data_base64: Maybe<Scalars['String']['output']>;
  message_data_filename: Maybe<Scalars['String']['output']>;
  message_data_mime_type: Maybe<Scalars['String']['output']>;
  message_data_url: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_chat_id: Maybe<Scalars['String']['output']>;
  whatsapp_message_id: Maybe<Scalars['String']['output']>;
  whatsapp_quoted_message_id: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Whatsapp_Message_Min_Fields = {
  __typename?: 'whatsapp_message_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  /** A data em que foi enviada a primeira mensagem, sem edio */
  first_sent_at: Maybe<Scalars['timestamptz']['output']>;
  /** Corpo da mensagem */
  message: Maybe<Scalars['String']['output']>;
  message_data_base64: Maybe<Scalars['String']['output']>;
  message_data_filename: Maybe<Scalars['String']['output']>;
  message_data_mime_type: Maybe<Scalars['String']['output']>;
  message_data_url: Maybe<Scalars['String']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  whatsapp_chat_id: Maybe<Scalars['String']['output']>;
  whatsapp_message_id: Maybe<Scalars['String']['output']>;
  whatsapp_quoted_message_id: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "whatsapp_message" */
export type Whatsapp_Message_Mutation_Response = {
  __typename?: 'whatsapp_message_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Whatsapp_Message>;
};

/** input type for inserting object relation for remote table "whatsapp_message" */
export type Whatsapp_Message_Obj_Rel_Insert_Input = {
  data: Whatsapp_Message_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Whatsapp_Message_On_Conflict>;
};

/** on_conflict condition type for table "whatsapp_message" */
export type Whatsapp_Message_On_Conflict = {
  constraint: Whatsapp_Message_Constraint;
  update_columns?: Array<Whatsapp_Message_Update_Column>;
  where?: InputMaybe<Whatsapp_Message_Bool_Exp>;
};

/** Ordering options when selecting data from "whatsapp_message". */
export type Whatsapp_Message_Order_By = {
  created_at?: InputMaybe<Order_By>;
  first_sent_at?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  message_data_base64?: InputMaybe<Order_By>;
  message_data_filename?: InputMaybe<Order_By>;
  message_data_mime_type?: InputMaybe<Order_By>;
  message_data_url?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  was_edited?: InputMaybe<Order_By>;
  was_sent?: InputMaybe<Order_By>;
  whatsapp_chat_id?: InputMaybe<Order_By>;
  whatsapp_events_aggregate?: InputMaybe<Whatsapp_Event_Aggregate_Order_By>;
  whatsapp_message_histories_aggregate?: InputMaybe<Whatsapp_Message_History_Aggregate_Order_By>;
  whatsapp_message_id?: InputMaybe<Order_By>;
  whatsapp_quoted_message_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: whatsapp_message */
export type Whatsapp_Message_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "whatsapp_message" */
export enum Whatsapp_Message_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FirstSentAt = 'first_sent_at',
  /** column name */
  Message = 'message',
  /** column name */
  MessageDataBase64 = 'message_data_base64',
  /** column name */
  MessageDataFilename = 'message_data_filename',
  /** column name */
  MessageDataMimeType = 'message_data_mime_type',
  /** column name */
  MessageDataUrl = 'message_data_url',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WasEdited = 'was_edited',
  /** column name */
  WasSent = 'was_sent',
  /** column name */
  WhatsappChatId = 'whatsapp_chat_id',
  /** column name */
  WhatsappMessageId = 'whatsapp_message_id',
  /** column name */
  WhatsappQuotedMessageId = 'whatsapp_quoted_message_id'
}

/** input type for updating data in table "whatsapp_message" */
export type Whatsapp_Message_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A data em que foi enviada a primeira mensagem, sem edio */
  first_sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Corpo da mensagem */
  message?: InputMaybe<Scalars['String']['input']>;
  message_data_base64?: InputMaybe<Scalars['String']['input']>;
  message_data_filename?: InputMaybe<Scalars['String']['input']>;
  message_data_mime_type?: InputMaybe<Scalars['String']['input']>;
  message_data_url?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  was_edited?: InputMaybe<Scalars['Boolean']['input']>;
  /** Se foi enviado por completo. Isto , tanto a primeira mensagem quanto as edies */
  was_sent?: InputMaybe<Scalars['Boolean']['input']>;
  whatsapp_chat_id?: InputMaybe<Scalars['String']['input']>;
  whatsapp_message_id?: InputMaybe<Scalars['String']['input']>;
  whatsapp_quoted_message_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "whatsapp_message" */
export type Whatsapp_Message_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Whatsapp_Message_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Whatsapp_Message_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** A data em que foi enviada a primeira mensagem, sem edio */
  first_sent_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Corpo da mensagem */
  message?: InputMaybe<Scalars['String']['input']>;
  message_data_base64?: InputMaybe<Scalars['String']['input']>;
  message_data_filename?: InputMaybe<Scalars['String']['input']>;
  message_data_mime_type?: InputMaybe<Scalars['String']['input']>;
  message_data_url?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  was_edited?: InputMaybe<Scalars['Boolean']['input']>;
  /** Se foi enviado por completo. Isto , tanto a primeira mensagem quanto as edies */
  was_sent?: InputMaybe<Scalars['Boolean']['input']>;
  whatsapp_chat_id?: InputMaybe<Scalars['String']['input']>;
  whatsapp_message_id?: InputMaybe<Scalars['String']['input']>;
  whatsapp_quoted_message_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "whatsapp_message" */
export enum Whatsapp_Message_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FirstSentAt = 'first_sent_at',
  /** column name */
  Message = 'message',
  /** column name */
  MessageDataBase64 = 'message_data_base64',
  /** column name */
  MessageDataFilename = 'message_data_filename',
  /** column name */
  MessageDataMimeType = 'message_data_mime_type',
  /** column name */
  MessageDataUrl = 'message_data_url',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WasEdited = 'was_edited',
  /** column name */
  WasSent = 'was_sent',
  /** column name */
  WhatsappChatId = 'whatsapp_chat_id',
  /** column name */
  WhatsappMessageId = 'whatsapp_message_id',
  /** column name */
  WhatsappQuotedMessageId = 'whatsapp_quoted_message_id'
}

export type Whatsapp_Message_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Whatsapp_Message_Set_Input>;
  /** filter the rows which have to be updated */
  where: Whatsapp_Message_Bool_Exp;
};

/** columns and relationships of "whatsapp_trigger" */
export type Whatsapp_Trigger = {
  __typename?: 'whatsapp_trigger';
  created_at: Scalars['timestamptz']['output'];
  initial_reply_text: Maybe<Scalars['String']['output']>;
  /** A name/identifier of the trigger so it can be used to listen for triggers */
  name: Scalars['String']['output'];
  pattern: Scalars['String']['output'];
  /** Higher the value higher the priority */
  priority: Scalars['Int']['output'];
  queue_consume_timeout: Scalars['interval']['output'];
  total_retry_count: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['uuid']['output'];
  /** The corresponding chat that will trigger the event, can be a group */
  whatsapp_chat_id: Scalars['String']['output'];
  /** An array relationship */
  whatsapp_events: Array<Whatsapp_Event>;
  /** An aggregate relationship */
  whatsapp_events_aggregate: Whatsapp_Event_Aggregate;
};


/** columns and relationships of "whatsapp_trigger" */
export type Whatsapp_TriggerWhatsapp_EventsArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};


/** columns and relationships of "whatsapp_trigger" */
export type Whatsapp_TriggerWhatsapp_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Whatsapp_Event_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Whatsapp_Event_Order_By>>;
  where?: InputMaybe<Whatsapp_Event_Bool_Exp>;
};

/** aggregated selection of "whatsapp_trigger" */
export type Whatsapp_Trigger_Aggregate = {
  __typename?: 'whatsapp_trigger_aggregate';
  aggregate: Maybe<Whatsapp_Trigger_Aggregate_Fields>;
  nodes: Array<Whatsapp_Trigger>;
};

/** aggregate fields of "whatsapp_trigger" */
export type Whatsapp_Trigger_Aggregate_Fields = {
  __typename?: 'whatsapp_trigger_aggregate_fields';
  avg: Maybe<Whatsapp_Trigger_Avg_Fields>;
  count: Scalars['Int']['output'];
  max: Maybe<Whatsapp_Trigger_Max_Fields>;
  min: Maybe<Whatsapp_Trigger_Min_Fields>;
  stddev: Maybe<Whatsapp_Trigger_Stddev_Fields>;
  stddev_pop: Maybe<Whatsapp_Trigger_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Whatsapp_Trigger_Stddev_Samp_Fields>;
  sum: Maybe<Whatsapp_Trigger_Sum_Fields>;
  var_pop: Maybe<Whatsapp_Trigger_Var_Pop_Fields>;
  var_samp: Maybe<Whatsapp_Trigger_Var_Samp_Fields>;
  variance: Maybe<Whatsapp_Trigger_Variance_Fields>;
};


/** aggregate fields of "whatsapp_trigger" */
export type Whatsapp_Trigger_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Whatsapp_Trigger_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Whatsapp_Trigger_Avg_Fields = {
  __typename?: 'whatsapp_trigger_avg_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Float']['output']>;
  total_retry_count: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "whatsapp_trigger". All fields are combined with a logical 'AND'. */
export type Whatsapp_Trigger_Bool_Exp = {
  _and?: InputMaybe<Array<Whatsapp_Trigger_Bool_Exp>>;
  _not?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
  _or?: InputMaybe<Array<Whatsapp_Trigger_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  initial_reply_text?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pattern?: InputMaybe<String_Comparison_Exp>;
  priority?: InputMaybe<Int_Comparison_Exp>;
  queue_consume_timeout?: InputMaybe<Interval_Comparison_Exp>;
  total_retry_count?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
  whatsapp_chat_id?: InputMaybe<String_Comparison_Exp>;
  whatsapp_events?: InputMaybe<Whatsapp_Event_Bool_Exp>;
  whatsapp_events_aggregate?: InputMaybe<Whatsapp_Event_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "whatsapp_trigger" */
export enum Whatsapp_Trigger_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  WhatsappTriggerPkey = 'whatsapp_trigger_pkey'
}

/** input type for incrementing numeric columns in table "whatsapp_trigger" */
export type Whatsapp_Trigger_Inc_Input = {
  /** Higher the value higher the priority */
  priority?: InputMaybe<Scalars['Int']['input']>;
  total_retry_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "whatsapp_trigger" */
export type Whatsapp_Trigger_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  initial_reply_text?: InputMaybe<Scalars['String']['input']>;
  /** A name/identifier of the trigger so it can be used to listen for triggers */
  name?: InputMaybe<Scalars['String']['input']>;
  pattern?: InputMaybe<Scalars['String']['input']>;
  /** Higher the value higher the priority */
  priority?: InputMaybe<Scalars['Int']['input']>;
  queue_consume_timeout?: InputMaybe<Scalars['interval']['input']>;
  total_retry_count?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The corresponding chat that will trigger the event, can be a group */
  whatsapp_chat_id?: InputMaybe<Scalars['String']['input']>;
  whatsapp_events?: InputMaybe<Whatsapp_Event_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Whatsapp_Trigger_Max_Fields = {
  __typename?: 'whatsapp_trigger_max_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  initial_reply_text: Maybe<Scalars['String']['output']>;
  /** A name/identifier of the trigger so it can be used to listen for triggers */
  name: Maybe<Scalars['String']['output']>;
  pattern: Maybe<Scalars['String']['output']>;
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Int']['output']>;
  total_retry_count: Maybe<Scalars['Int']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  /** The corresponding chat that will trigger the event, can be a group */
  whatsapp_chat_id: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Whatsapp_Trigger_Min_Fields = {
  __typename?: 'whatsapp_trigger_min_fields';
  created_at: Maybe<Scalars['timestamptz']['output']>;
  initial_reply_text: Maybe<Scalars['String']['output']>;
  /** A name/identifier of the trigger so it can be used to listen for triggers */
  name: Maybe<Scalars['String']['output']>;
  pattern: Maybe<Scalars['String']['output']>;
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Int']['output']>;
  total_retry_count: Maybe<Scalars['Int']['output']>;
  updated_at: Maybe<Scalars['timestamptz']['output']>;
  uuid: Maybe<Scalars['uuid']['output']>;
  /** The corresponding chat that will trigger the event, can be a group */
  whatsapp_chat_id: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "whatsapp_trigger" */
export type Whatsapp_Trigger_Mutation_Response = {
  __typename?: 'whatsapp_trigger_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Whatsapp_Trigger>;
};

/** input type for inserting object relation for remote table "whatsapp_trigger" */
export type Whatsapp_Trigger_Obj_Rel_Insert_Input = {
  data: Whatsapp_Trigger_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Whatsapp_Trigger_On_Conflict>;
};

/** on_conflict condition type for table "whatsapp_trigger" */
export type Whatsapp_Trigger_On_Conflict = {
  constraint: Whatsapp_Trigger_Constraint;
  update_columns?: Array<Whatsapp_Trigger_Update_Column>;
  where?: InputMaybe<Whatsapp_Trigger_Bool_Exp>;
};

/** Ordering options when selecting data from "whatsapp_trigger". */
export type Whatsapp_Trigger_Order_By = {
  created_at?: InputMaybe<Order_By>;
  initial_reply_text?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pattern?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  queue_consume_timeout?: InputMaybe<Order_By>;
  total_retry_count?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  whatsapp_chat_id?: InputMaybe<Order_By>;
  whatsapp_events_aggregate?: InputMaybe<Whatsapp_Event_Aggregate_Order_By>;
};

/** primary key columns input for table: whatsapp_trigger */
export type Whatsapp_Trigger_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "whatsapp_trigger" */
export enum Whatsapp_Trigger_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InitialReplyText = 'initial_reply_text',
  /** column name */
  Name = 'name',
  /** column name */
  Pattern = 'pattern',
  /** column name */
  Priority = 'priority',
  /** column name */
  QueueConsumeTimeout = 'queue_consume_timeout',
  /** column name */
  TotalRetryCount = 'total_retry_count',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WhatsappChatId = 'whatsapp_chat_id'
}

/** input type for updating data in table "whatsapp_trigger" */
export type Whatsapp_Trigger_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  initial_reply_text?: InputMaybe<Scalars['String']['input']>;
  /** A name/identifier of the trigger so it can be used to listen for triggers */
  name?: InputMaybe<Scalars['String']['input']>;
  pattern?: InputMaybe<Scalars['String']['input']>;
  /** Higher the value higher the priority */
  priority?: InputMaybe<Scalars['Int']['input']>;
  queue_consume_timeout?: InputMaybe<Scalars['interval']['input']>;
  total_retry_count?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The corresponding chat that will trigger the event, can be a group */
  whatsapp_chat_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Whatsapp_Trigger_Stddev_Fields = {
  __typename?: 'whatsapp_trigger_stddev_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Float']['output']>;
  total_retry_count: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Whatsapp_Trigger_Stddev_Pop_Fields = {
  __typename?: 'whatsapp_trigger_stddev_pop_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Float']['output']>;
  total_retry_count: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Whatsapp_Trigger_Stddev_Samp_Fields = {
  __typename?: 'whatsapp_trigger_stddev_samp_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Float']['output']>;
  total_retry_count: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "whatsapp_trigger" */
export type Whatsapp_Trigger_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Whatsapp_Trigger_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Whatsapp_Trigger_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  initial_reply_text?: InputMaybe<Scalars['String']['input']>;
  /** A name/identifier of the trigger so it can be used to listen for triggers */
  name?: InputMaybe<Scalars['String']['input']>;
  pattern?: InputMaybe<Scalars['String']['input']>;
  /** Higher the value higher the priority */
  priority?: InputMaybe<Scalars['Int']['input']>;
  queue_consume_timeout?: InputMaybe<Scalars['interval']['input']>;
  total_retry_count?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
  /** The corresponding chat that will trigger the event, can be a group */
  whatsapp_chat_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Whatsapp_Trigger_Sum_Fields = {
  __typename?: 'whatsapp_trigger_sum_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Int']['output']>;
  total_retry_count: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "whatsapp_trigger" */
export enum Whatsapp_Trigger_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InitialReplyText = 'initial_reply_text',
  /** column name */
  Name = 'name',
  /** column name */
  Pattern = 'pattern',
  /** column name */
  Priority = 'priority',
  /** column name */
  QueueConsumeTimeout = 'queue_consume_timeout',
  /** column name */
  TotalRetryCount = 'total_retry_count',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WhatsappChatId = 'whatsapp_chat_id'
}

export type Whatsapp_Trigger_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Whatsapp_Trigger_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Whatsapp_Trigger_Set_Input>;
  /** filter the rows which have to be updated */
  where: Whatsapp_Trigger_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Whatsapp_Trigger_Var_Pop_Fields = {
  __typename?: 'whatsapp_trigger_var_pop_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Float']['output']>;
  total_retry_count: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Whatsapp_Trigger_Var_Samp_Fields = {
  __typename?: 'whatsapp_trigger_var_samp_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Float']['output']>;
  total_retry_count: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Whatsapp_Trigger_Variance_Fields = {
  __typename?: 'whatsapp_trigger_variance_fields';
  /** Higher the value higher the priority */
  priority: Maybe<Scalars['Float']['output']>;
  total_retry_count: Maybe<Scalars['Float']['output']>;
};

export type UserFragment = { __typename?: 'admin', uuid: string, name: string, email: string, avatar_url: string };

export type ProfilePermissionFragment = { __typename?: 'profile_permission', uuid: string, profile_uuid: string, action: string, deleted_at: string | null };

export type SignInQueryVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type SignInQuery = { __typename?: 'query_root', admin_signin: { __typename?: 'AdminSignInOutput', admin_uuid: string, token: string, refresh_token: string } | null };

export type GetAdminDataQueryVariables = Exact<{
  uuid: Scalars['uuid']['input'];
}>;


export type GetAdminDataQuery = { __typename?: 'query_root', admin_by_pk: { __typename?: 'admin', uuid: string, name: string, email: string, avatar_url: string } | null, admin_fk_profile: Array<{ __typename?: 'admin_fk_profile', profile: { __typename?: 'profile', profile_permissions: Array<{ __typename?: 'profile_permission', uuid: string, profile_uuid: string, action: string, deleted_at: string | null }> } }> };

export type RefreshTokenQueryVariables = Exact<{
  refresh_token: Scalars['String']['input'];
}>;


export type RefreshTokenQuery = { __typename?: 'query_root', get_refresh_token: { __typename?: 'RefreshTokenOutput', token: string } | null };

export type GetNfsPendingCteQueryVariables = Exact<{ [key: string]: never; }>;


export type GetNfsPendingCteQuery = { __typename?: 'query_root', getNfsPendingCte: Array<{ __typename?: 'NfPendingCte', chave_nf: string, cnpj_destinatario: string, cnpj_remetente: string, data_nf: string, endereco_destino: string, observacao: string | null, numero_nf: number, peso: number, serie_nf: number, valor_nf: number } | null> | null };

export type InsertNfLockMutationVariables = Exact<{
  data: Cte_Nf_Lock_Insert_Input;
}>;


export type InsertNfLockMutation = { __typename?: 'mutation_root', insert_cte_nf_lock_one: { __typename?: 'cte_nf_lock', nf: number } | null };

export type DeleteNfLockMutationVariables = Exact<{
  nf: Scalars['Int']['input'];
}>;


export type DeleteNfLockMutation = { __typename?: 'mutation_root', delete_cte_nf_lock_by_pk: { __typename?: 'cte_nf_lock', nf: number } | null };

export type SubGetLockedNfsSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type SubGetLockedNfsSubscription = { __typename?: 'subscription_root', cte_nf_lock: Array<{ __typename?: 'cte_nf_lock', nf: number, user_uuid: string, admin: { __typename?: 'admin', name: string } }> };

export const UserFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"User"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"admin"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"uuid"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"avatar_url"}}]}}]} as unknown as DocumentNode<UserFragment, unknown>;
export const ProfilePermissionFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ProfilePermission"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"profile_permission"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"uuid"}},{"kind":"Field","name":{"kind":"Name","value":"profile_uuid"}},{"kind":"Field","name":{"kind":"Name","value":"action"}},{"kind":"Field","name":{"kind":"Name","value":"deleted_at"}}]}}]} as unknown as DocumentNode<ProfilePermissionFragment, unknown>;
export const SignInDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"SignIn"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"email"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"password"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"admin_signin"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"email"},"value":{"kind":"Variable","name":{"kind":"Name","value":"email"}}},{"kind":"Argument","name":{"kind":"Name","value":"password"},"value":{"kind":"Variable","name":{"kind":"Name","value":"password"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"admin_uuid"}},{"kind":"Field","name":{"kind":"Name","value":"token"}},{"kind":"Field","name":{"kind":"Name","value":"refresh_token"}}]}}]}}]} as unknown as DocumentNode<SignInQuery, SignInQueryVariables>;
export const GetAdminDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetAdminData"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"uuid"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"uuid"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"admin_by_pk"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"uuid"},"value":{"kind":"Variable","name":{"kind":"Name","value":"uuid"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"User"}}]}},{"kind":"Field","name":{"kind":"Name","value":"admin_fk_profile"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"admin_uuid"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"Variable","name":{"kind":"Name","value":"uuid"}}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"deleted_at"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_is_null"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"profile"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"profile_permissions"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"deleted_at"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_is_null"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"module_permission"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"module_name"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"StringValue","value":"inspection","block":false}}]}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ProfilePermission"}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"User"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"admin"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"uuid"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"avatar_url"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ProfilePermission"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"profile_permission"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"uuid"}},{"kind":"Field","name":{"kind":"Name","value":"profile_uuid"}},{"kind":"Field","name":{"kind":"Name","value":"action"}},{"kind":"Field","name":{"kind":"Name","value":"deleted_at"}}]}}]} as unknown as DocumentNode<GetAdminDataQuery, GetAdminDataQueryVariables>;
export const RefreshTokenDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"RefreshToken"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"refresh_token"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"get_refresh_token"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"refresh_token"},"value":{"kind":"Variable","name":{"kind":"Name","value":"refresh_token"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}}]}}]}}]} as unknown as DocumentNode<RefreshTokenQuery, RefreshTokenQueryVariables>;
export const GetNfsPendingCteDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetNfsPendingCte"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"getNfsPendingCte"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"chave_nf"}},{"kind":"Field","name":{"kind":"Name","value":"cnpj_destinatario"}},{"kind":"Field","name":{"kind":"Name","value":"cnpj_remetente"}},{"kind":"Field","name":{"kind":"Name","value":"data_nf"}},{"kind":"Field","name":{"kind":"Name","value":"endereco_destino"}},{"kind":"Field","name":{"kind":"Name","value":"observacao"}},{"kind":"Field","name":{"kind":"Name","value":"numero_nf"}},{"kind":"Field","name":{"kind":"Name","value":"peso"}},{"kind":"Field","name":{"kind":"Name","value":"serie_nf"}},{"kind":"Field","name":{"kind":"Name","value":"valor_nf"}}]}}]}}]} as unknown as DocumentNode<GetNfsPendingCteQuery, GetNfsPendingCteQueryVariables>;
export const InsertNfLockDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"InsertNfLock"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"data"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"cte_nf_lock_insert_input"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"insert_cte_nf_lock_one"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"object"},"value":{"kind":"Variable","name":{"kind":"Name","value":"data"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"nf"}}]}}]}}]} as unknown as DocumentNode<InsertNfLockMutation, InsertNfLockMutationVariables>;
export const DeleteNfLockDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"DeleteNfLock"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"nf"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"delete_cte_nf_lock_by_pk"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"nf"},"value":{"kind":"Variable","name":{"kind":"Name","value":"nf"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"nf"}}]}}]}}]} as unknown as DocumentNode<DeleteNfLockMutation, DeleteNfLockMutationVariables>;
export const SubGetLockedNfsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"SubGetLockedNfs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"cte_nf_lock"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"nf"}},{"kind":"Field","name":{"kind":"Name","value":"user_uuid"}},{"kind":"Field","name":{"kind":"Name","value":"admin"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]} as unknown as DocumentNode<SubGetLockedNfsSubscription, SubGetLockedNfsSubscriptionVariables>;